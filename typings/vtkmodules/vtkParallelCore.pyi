"""
This type stub file was generated by pyright.
"""

import vtkmodules.vtkCommonCore as __vtkmodules_vtkCommonCore

class vtkCommunicator(__vtkmodules_vtkCommonCore.vtkObject):
    """
    vtkCommunicator - Used to send/receive messages in a multiprocess
    environment.
    
    Superclass: vtkObject
    
    This is an abstract class which contains functionality for sending
    and receiving inter-process messages. It contains methods for
    marshaling an object into a string (currently used by the MPI
    communicator but not the shared memory communicator).
    
    @warning
    Communication between systems with different vtkIdTypes is not
    supported. All machines have to have the same vtkIdType.
    
    @sa
    vtkMPICommunicator
    """
    def AllGather(self, int_tuple, *int, **kwargs):
        """
        V.AllGather((int, ...), [int, ...], int) -> int
        C++: int AllGather(const int *sendBuffer, int *recvBuffer,
            vtkIdType length)
        V.AllGather((int, ...), [int, ...], int) -> int
        C++: int AllGather(const long *sendBuffer, long *recvBuffer,
            vtkIdType length)
        V.AllGather(string, string, int) -> int
        C++: int AllGather(const char *sendBuffer, char *recvBuffer,
            vtkIdType length)
        V.AllGather((float, ...), [float, ...], int) -> int
        C++: int AllGather(const double *sendBuffer, double *recvBuffer,
            vtkIdType length)
        V.AllGather((int, ...), [int, ...], int) -> int
        C++: int AllGather(const long long *sendBuffer,
            long long *recvBuffer, vtkIdType length)
        V.AllGather(vtkDataArray, vtkDataArray) -> int
        C++: int AllGather(vtkDataArray *sendBuffer,
            vtkDataArray *recvBuffer)
        
        Same as gather except that the result ends up on all processes.
        """
        ...
    
    def AllGatherV(self, int_tuple, *int, **kwargs):
        """
        V.AllGatherV((int, ...), [int, ...], int, [int, ...], [int, ...])
            -> int
        C++: int AllGatherV(const int *sendBuffer, int *recvBuffer,
            vtkIdType sendLength, vtkIdType *recvLengths,
            vtkIdType *offsets)
        V.AllGatherV((int, ...), [int, ...], int, [int, ...], [int, ...])
            -> int
        C++: int AllGatherV(const long *sendBuffer, long *recvBuffer,
            vtkIdType sendLength, vtkIdType *recvLengths,
            vtkIdType *offsets)
        V.AllGatherV(string, string, int, [int, ...], [int, ...]) -> int
        C++: int AllGatherV(const char *sendBuffer, char *recvBuffer,
            vtkIdType sendLength, vtkIdType *recvLengths,
            vtkIdType *offsets)
        V.AllGatherV((float, ...), [float, ...], int, [int, ...], [int,
            ...]) -> int
        C++: int AllGatherV(const double *sendBuffer, double *recvBuffer,
            vtkIdType sendLength, vtkIdType *recvLengths,
            vtkIdType *offsets)
        V.AllGatherV((int, ...), [int, ...], int, [int, ...], [int, ...])
            -> int
        C++: int AllGatherV(const long long *sendBuffer,
            long long *recvBuffer, vtkIdType sendLength,
            vtkIdType *recvLengths, vtkIdType *offsets)
        V.AllGatherV(vtkDataArray, vtkDataArray, [int, ...], [int, ...])
            -> int
        C++: int AllGatherV(vtkDataArray *sendBuffer,
            vtkDataArray *recvBuffer, vtkIdType *recvLengths,
            vtkIdType *offsets)
        V.AllGatherV(vtkDataArray, vtkDataArray) -> int
        C++: int AllGatherV(vtkDataArray *sendBuffer,
            vtkDataArray *recvBuffer)
        
        Same as GatherV except that the result is placed in all
        processes.
        """
        ...
    
    def AllGatherVoidArray(self, void, void_1, p_int, p_int_1):
        """
        V.AllGatherVoidArray(void, void, int, int) -> int
        C++: virtual int AllGatherVoidArray(const void *sendBuffer,
            void *recvBuffer, vtkIdType length, int type)
        
        Subclasses should reimplement these if they have a more efficient
        implementation.
        """
        ...
    
    def AllGatherVVoidArray(self, void, void_1, p_int, *int, **kwargs):
        """
        V.AllGatherVVoidArray(void, void, int, [int, ...], [int, ...],
            int) -> int
        C++: virtual int AllGatherVVoidArray(const void *sendBuffer,
            void *recvBuffer, vtkIdType sendLength,
            vtkIdType *recvLengths, vtkIdType *offsets, int type)
        
        Subclasses should reimplement these if they have a more efficient
        implementation.
        """
        ...
    
    def AllReduce(self, int_tuple, *int, **kwargs):
        """
        V.AllReduce((int, ...), [int, ...], int, int) -> int
        C++: int AllReduce(const int *sendBuffer, int *recvBuffer,
            vtkIdType length, int operation)
        V.AllReduce((int, ...), [int, ...], int, int) -> int
        C++: int AllReduce(const long *sendBuffer, long *recvBuffer,
            vtkIdType length, int operation)
        V.AllReduce(string, string, int, int) -> int
        C++: int AllReduce(const char *sendBuffer, char *recvBuffer,
            vtkIdType length, int operation)
        V.AllReduce((float, ...), [float, ...], int, int) -> int
        C++: int AllReduce(const double *sendBuffer, double *recvBuffer,
            vtkIdType length, int operation)
        V.AllReduce((int, ...), [int, ...], int, int) -> int
        C++: int AllReduce(const long long *sendBuffer,
            long long *recvBuffer, vtkIdType length, int operation)
        V.AllReduce(vtkDataArray, vtkDataArray, int) -> int
        C++: int AllReduce(vtkDataArray *sendBuffer,
            vtkDataArray *recvBuffer, int operation)
        
        Same as Reduce except that the result is placed in all of the
        processes.
        """
        ...
    
    def AllReduceVoidArray(self, void, void_1, p_int, p_int_1, p_int_2):
        """
        V.AllReduceVoidArray(void, void, int, int, int) -> int
        C++: virtual int AllReduceVoidArray(const void *sendBuffer,
            void *recvBuffer, vtkIdType length, int type, int operation)
        
        Subclasses should reimplement these if they have a more efficient
        implementation.
        """
        ...
    
    def Barrier(self):
        """
        V.Barrier()
        C++: virtual void Barrier()
        
        Will block the processes until all other processes reach the
        Barrier function.
        """
        ...
    
    def Broadcast(self, *int, **kwargs):
        """
        V.Broadcast([int, ...], int, int) -> int
        C++: int Broadcast(int *data, vtkIdType length, int srcProcessId)
        V.Broadcast([int, ...], int, int) -> int
        C++: int Broadcast(long *data, vtkIdType length, int srcProcessId)
        V.Broadcast(string, int, int) -> int
        C++: int Broadcast(char *data, vtkIdType length, int srcProcessId)
        V.Broadcast([float, ...], int, int) -> int
        C++: int Broadcast(double *data, vtkIdType length,
            int srcProcessId)
        V.Broadcast([int, ...], int, int) -> int
        C++: int Broadcast(long long *data, vtkIdType length,
            int srcProcessId)
        V.Broadcast(vtkDataObject, int) -> int
        C++: int Broadcast(vtkDataObject *data, int srcProcessId)
        V.Broadcast(vtkDataArray, int) -> int
        C++: int Broadcast(vtkDataArray *data, int srcProcessId)
        V.Broadcast(vtkMultiProcessStream, int) -> int
        C++: int Broadcast(vtkMultiProcessStream &stream,
            int srcProcessId)
        
        Broadcast sends the array in the process with id srcProcessId to
        all of the other processes.  All processes must call these method
        with the same arguments in order for it to complete.
        """
        ...
    
    def BroadcastVoidArray(self, void, p_int, p_int_1, p_int_2):
        """
        V.BroadcastVoidArray(void, int, int, int) -> int
        C++: virtual int BroadcastVoidArray(void *data, vtkIdType length,
            int type, int srcProcessId)
        
        Subclasses should reimplement these if they have a more efficient
        implementation.
        """
        ...
    
    def Gather(self, int_tuple, *int, **kwargs):
        """
        V.Gather((int, ...), [int, ...], int, int) -> int
        C++: int Gather(const int *sendBuffer, int *recvBuffer,
            vtkIdType length, int destProcessId)
        V.Gather((int, ...), [int, ...], int, int) -> int
        C++: int Gather(const long *sendBuffer, long *recvBuffer,
            vtkIdType length, int destProcessId)
        V.Gather(string, string, int, int) -> int
        C++: int Gather(const char *sendBuffer, char *recvBuffer,
            vtkIdType length, int destProcessId)
        V.Gather((float, ...), [float, ...], int, int) -> int
        C++: int Gather(const double *sendBuffer, double *recvBuffer,
            vtkIdType length, int destProcessId)
        V.Gather((int, ...), [int, ...], int, int) -> int
        C++: int Gather(const long long *sendBuffer,
            long long *recvBuffer, vtkIdType length, int destProcessId)
        V.Gather(vtkDataArray, vtkDataArray, int) -> int
        C++: int Gather(vtkDataArray *sendBuffer,
            vtkDataArray *recvBuffer, int destProcessId)
        
        Gather collects arrays in the process with id destProcessId. 
        Each process (including the destination) sends the contents of
        its send buffer to the destination process.  The destination
        process receives the messages and stores them in rank order.  The
        length argument (which must be the same on all processes) is the
        length of the sendBuffers.  The recvBuffer (on the destination
        process) must be of length length*numProcesses.  Gather is the
        inverse operation of Scatter.
        """
        ...
    
    def GatherV(self, int_tuple, *int, **kwargs):
        """
        V.GatherV((int, ...), [int, ...], int, [int, ...], [int, ...],
            int) -> int
        C++: int GatherV(const int *sendBuffer, int *recvBuffer,
            vtkIdType sendLength, vtkIdType *recvLengths,
            vtkIdType *offsets, int destProcessId)
        V.GatherV((int, ...), [int, ...], int, [int, ...], [int, ...],
            int) -> int
        C++: int GatherV(const long *sendBuffer, long *recvBuffer,
            vtkIdType sendLength, vtkIdType *recvLengths,
            vtkIdType *offsets, int destProcessId)
        V.GatherV(string, string, int, [int, ...], [int, ...], int) -> int
        C++: int GatherV(const char *sendBuffer, char *recvBuffer,
            vtkIdType sendLength, vtkIdType *recvLengths,
            vtkIdType *offsets, int destProcessId)
        V.GatherV((float, ...), [float, ...], int, [int, ...], [int, ...],
             int) -> int
        C++: int GatherV(const double *sendBuffer, double *recvBuffer,
            vtkIdType sendLength, vtkIdType *recvLengths,
            vtkIdType *offsets, int destProcessId)
        V.GatherV((int, ...), [int, ...], int, [int, ...], [int, ...],
            int) -> int
        C++: int GatherV(const long long *sendBuffer,
            long long *recvBuffer, vtkIdType sendLength,
            vtkIdType *recvLengths, vtkIdType *offsets, int destProcessId)
        V.GatherV(vtkDataArray, vtkDataArray, [int, ...], [int, ...], int)
             -> int
        C++: int GatherV(vtkDataArray *sendBuffer,
            vtkDataArray *recvBuffer, vtkIdType *recvLengths,
            vtkIdType *offsets, int destProcessId)
        V.GatherV(vtkDataArray, vtkDataArray, vtkIdTypeArray,
            vtkIdTypeArray, int) -> int
        C++: int GatherV(vtkDataArray *sendBuffer,
            vtkDataArray *recvBuffer, vtkIdTypeArray *recvLengths,
            vtkIdTypeArray *offsets, int destProcessId)
        V.GatherV(vtkDataArray, vtkDataArray, int) -> int
        C++: int GatherV(vtkDataArray *sendBuffer,
            vtkDataArray *recvBuffer, int destProcessId)
        
        GatherV is the vector variant of Gather.  It extends the
        functionality of Gather by allowing a varying count of data from
        each process. GatherV collects arrays in the process with id
        destProcessId.  Each process (including t ...
         [Truncated]
        """
        ...
    
    def GatherVoidArray(self, void, void_1, p_int, p_int_1, p_int_2):
        """
        V.GatherVoidArray(void, void, int, int, int) -> int
        C++: virtual int GatherVoidArray(const void *sendBuffer,
            void *recvBuffer, vtkIdType length, int type,
            int destProcessId)
        
        Subclasses should reimplement these if they have a more efficient
        implementation.
        """
        ...
    
    def GatherVVoidArray(self, void, void_1, p_int, *int, **kwargs):
        """
        V.GatherVVoidArray(void, void, int, [int, ...], [int, ...], int,
            int) -> int
        C++: virtual int GatherVVoidArray(const void *sendBuffer,
            void *recvBuffer, vtkIdType sendLength,
            vtkIdType *recvLengths, vtkIdType *offsets, int type,
            int destProcessId)
        
        Subclasses should reimplement these if they have a more efficient
        implementation.
        """
        ...
    
    def GetCount(self):
        """
        V.GetCount() -> int
        C++: virtual vtkIdType GetCount()
        
        Returns the number of words received by the most recent
        Receive(). Note that this is not the number of bytes received,
        but the number of items of the data-type received by the most
        recent Receive() eg. if Receive(int*,..) was used, then this
        returns the number of ints received; if Receive(double*,..) was
        used, then this returns the number of doubles received etc. The
        return value is valid only after a successful Receive().
        """
        ...
    
    def GetLeftChildProcessor(self, p_int):
        """
        V.GetLeftChildProcessor(int) -> int
        C++: static int GetLeftChildProcessor(int pid)
        
        Some helper functions when dealing with heap tree - based
        algorithms - we don't need a function for getting the right
        processor since it is 1 + theLeftProcessor
        """
        ...
    
    def GetLocalProcessId(self):
        """
        V.GetLocalProcessId() -> int
        C++: virtual int GetLocalProcessId()
        
        Tells you which process [0, NumProcess) you are in.
        """
        ...
    
    def GetNumberOfGenerationsFromBase(self, string):
        """
        V.GetNumberOfGenerationsFromBase(string) -> int
        C++: vtkIdType GetNumberOfGenerationsFromBase(const char *type)
            override;
        
        Given a the name of a base class of this class type, return the
        distance of inheritance between this class type and the named
        class (how many generations of inheritance are there between this
        class and the named class). If the named class is not in this
        class's inheritance tree, return a negative value. Valid
        responses will always be nonnegative. This method works in
        combination with vtkTypeMacro found in vtkSetGet.h.
        """
        ...
    
    def GetNumberOfGenerationsFromBaseType(self, string):
        """
        V.GetNumberOfGenerationsFromBaseType(string) -> int
        C++: static vtkIdType GetNumberOfGenerationsFromBaseType(
            const char *type)
        
        Given a the name of a base class of this class type, return the
        distance of inheritance between this class type and the named
        class (how many generations of inheritance are there between this
        class and the named class). If the named class is not in this
        class's inheritance tree, return a negative value. Valid
        responses will always be nonnegative. This method works in
        combination with vtkTypeMacro found in vtkSetGet.h.
        """
        ...
    
    def GetNumberOfProcesses(self):
        """
        V.GetNumberOfProcesses() -> int
        C++: virtual int GetNumberOfProcesses()
        
        Set the number of processes you will be using.  This defaults to
        the maximum number available.  If you set this to a value higher
        than the default, you will get an error.
        """
        ...
    
    def GetParentProcessor(self, p_int):
        """
        V.GetParentProcessor(int) -> int
        C++: static int GetParentProcessor(int pid)
        
        Some helper functions when dealing with heap tree - based
        algorithms - we don't need a function for getting the right
        processor since it is 1 + theLeftProcessor
        """
        ...
    
    def IsA(self, string):
        """
        V.IsA(string) -> int
        C++: vtkTypeBool IsA(const char *type) override;
        
        Return 1 if this class is the same type of (or a subclass of) the
        named class. Returns 0 otherwise. This method works in
        combination with vtkTypeMacro found in vtkSetGet.h.
        """
        ...
    
    def IsTypeOf(self, string):
        """
        V.IsTypeOf(string) -> int
        C++: static vtkTypeBool IsTypeOf(const char *type)
        
        Return 1 if this class type is the same type of (or a subclass
        of) the named class. Returns 0 otherwise. This method works in
        combination with vtkTypeMacro found in vtkSetGet.h.
        """
        ...
    
    def MarshalDataObject(self, vtkDataObject, vtkCharArray):
        """
        V.MarshalDataObject(vtkDataObject, vtkCharArray) -> int
        C++: static int MarshalDataObject(vtkDataObject *object,
            vtkCharArray *buffer)
        
        Convert a data object into a string that can be transmitted and
        vice versa. Returns 1 for success and 0 for failure. WARNING:
        This will only work for types that have a vtkDataWriter class.
        """
        ...
    
    def NewInstance(self):
        """
        V.NewInstance() -> vtkCommunicator
        C++: vtkCommunicator *NewInstance()
        """
        ...
    
    def Receive(self, vtkDataObject, p_int, p_int_1):
        """
        V.Receive(vtkDataObject, int, int) -> int
        C++: int Receive(vtkDataObject *data, int remoteHandle, int tag)
        V.Receive(vtkDataArray, int, int) -> int
        C++: int Receive(vtkDataArray *data, int remoteHandle, int tag)
        V.Receive([int, ...], int, int, int) -> int
        C++: int Receive(int *data, vtkIdType maxlength, int remoteHandle,
             int tag)
        V.Receive([int, ...], int, int, int) -> int
        C++: int Receive(long *data, vtkIdType maxlength,
            int remoteHandle, int tag)
        V.Receive(string, int, int, int) -> int
        C++: int Receive(char *data, vtkIdType maxlength,
            int remoteHandle, int tag)
        V.Receive([float, ...], int, int, int) -> int
        C++: int Receive(double *data, vtkIdType maxlength,
            int remoteHandle, int tag)
        V.Receive([int, ...], int, int, int) -> int
        C++: int Receive(long long *data, vtkIdType maxlength,
            int remoteHandle, int tag)
        V.Receive(vtkMultiProcessStream, int, int) -> int
        C++: int Receive(vtkMultiProcessStream &stream, int remoteId,
            int tag)
        
        This method receives a data object from a corresponding send. It
        blocks until the receive is finished.
        """
        ...
    
    def ReceiveDataObject(self, p_int, p_int_1):
        """
        V.ReceiveDataObject(int, int) -> vtkDataObject
        C++: vtkDataObject *ReceiveDataObject(int remoteHandle, int tag)
        
        The caller does not have to know the data type before this call
        is made. It returns the newly created object.
        """
        ...
    
    def ReceiveVoidArray(self, void, p_int, p_int_1, p_int_2, p_int_3):
        """
        V.ReceiveVoidArray(void, int, int, int, int) -> int
        C++: virtual int ReceiveVoidArray(void *data, vtkIdType maxlength,
             int type, int remoteHandle, int tag)
        
        Subclasses have to supply this method to receive various arrays
        of data. The type arg is one of the VTK type constants recognized
        by the vtkTemplateMacro (VTK_FLOAT, VTK_INT, etc.).  maxlength is
        measured in number of values (as opposed to number of bytes) and
        is the maxmum length of the data to receive.  If the maxlength is
        less than the length of the message sent by the sender, an error
        will be flagged. Once a message is received, use the GetCount()
        method to determine the actual size of the data received.
        """
        ...
    
    def Reduce(self, int_tuple, *int, **kwargs):
        """
        V.Reduce((int, ...), [int, ...], int, int, int) -> int
        C++: int Reduce(const int *sendBuffer, int *recvBuffer,
            vtkIdType length, int operation, int destProcessId)
        V.Reduce((int, ...), [int, ...], int, int, int) -> int
        C++: int Reduce(const long *sendBuffer, long *recvBuffer,
            vtkIdType length, int operation, int destProcessId)
        V.Reduce(string, string, int, int, int) -> int
        C++: int Reduce(const char *sendBuffer, char *recvBuffer,
            vtkIdType length, int operation, int destProcessId)
        V.Reduce((float, ...), [float, ...], int, int, int) -> int
        C++: int Reduce(const double *sendBuffer, double *recvBuffer,
            vtkIdType length, int operation, int destProcessId)
        V.Reduce((int, ...), [int, ...], int, int, int) -> int
        C++: int Reduce(const long long *sendBuffer,
            long long *recvBuffer, vtkIdType length, int operation,
            int destProcessId)
        V.Reduce(vtkDataArray, vtkDataArray, int, int) -> int
        C++: int Reduce(vtkDataArray *sendBuffer,
            vtkDataArray *recvBuffer, int operation, int destProcessId)
        
        Reduce an array to the given destination process.  This version
        of Reduce takes an identifier defined in the
        vtkCommunicator::StandardOperations enum to define the operation.
        """
        ...
    
    def ReduceVoidArray(self, void, void_1, p_int, p_int_1, p_int_2, p_int_3):
        """
        V.ReduceVoidArray(void, void, int, int, int, int) -> int
        C++: virtual int ReduceVoidArray(const void *sendBuffer,
            void *recvBuffer, vtkIdType length, int type, int operation,
            int destProcessId)
        
        Subclasses should reimplement these if they have a more efficient
        implementation.
        """
        ...
    
    def SafeDownCast(self, vtkObjectBase):
        """
        V.SafeDownCast(vtkObjectBase) -> vtkCommunicator
        C++: static vtkCommunicator *SafeDownCast(vtkObjectBase *o)
        """
        ...
    
    def Scatter(self, int_tuple, *int, **kwargs):
        """
        V.Scatter((int, ...), [int, ...], int, int) -> int
        C++: int Scatter(const int *sendBuffer, int *recvBuffer,
            vtkIdType length, int srcProcessId)
        V.Scatter((int, ...), [int, ...], int, int) -> int
        C++: int Scatter(const long *sendBuffer, long *recvBuffer,
            vtkIdType length, int srcProcessId)
        V.Scatter(string, string, int, int) -> int
        C++: int Scatter(const char *sendBuffer, char *recvBuffer,
            vtkIdType length, int srcProcessId)
        V.Scatter((float, ...), [float, ...], int, int) -> int
        C++: int Scatter(const double *sendBuffer, double *recvBuffer,
            vtkIdType length, int srcProcessId)
        V.Scatter((int, ...), [int, ...], int, int) -> int
        C++: int Scatter(const long long *sendBuffer,
            long long *recvBuffer, vtkIdType length, int srcProcessId)
        V.Scatter(vtkDataArray, vtkDataArray, int) -> int
        C++: int Scatter(vtkDataArray *sendBuffer,
            vtkDataArray *recvBuffer, int srcProcessId)
        
        Scatter takes an array in the process with id srcProcessId and
        distributes it.  Each process (including the source) receives a
        portion of the send buffer.  Process 0 receives the first length
        values, process 1 receives the second length values, and so on. 
        Scatter is the inverse operation of Gather.
        """
        ...
    
    def ScatterV(self, int_tuple, *int, **kwargs):
        """
        V.ScatterV((int, ...), [int, ...], [int, ...], [int, ...], int,
            int) -> int
        C++: int ScatterV(const int *sendBuffer, int *recvBuffer,
            vtkIdType *sendLengths, vtkIdType *offsets,
            vtkIdType recvLength, int srcProcessId)
        V.ScatterV((int, ...), [int, ...], [int, ...], [int, ...], int,
            int) -> int
        C++: int ScatterV(const long *sendBuffer, long *recvBuffer,
            vtkIdType *sendLengths, vtkIdType *offsets,
            vtkIdType recvLength, int srcProcessId)
        V.ScatterV(string, string, [int, ...], [int, ...], int, int)
            -> int
        C++: int ScatterV(const char *sendBuffer, char *recvBuffer,
            vtkIdType *sendLengths, vtkIdType *offsets,
            vtkIdType recvLength, int srcProcessId)
        V.ScatterV((float, ...), [float, ...], [int, ...], [int, ...],
            int, int) -> int
        C++: int ScatterV(const double *sendBuffer, double *recvBuffer,
            vtkIdType *sendLengths, vtkIdType *offsets,
            vtkIdType recvLength, int srcProcessId)
        V.ScatterV((int, ...), [int, ...], [int, ...], [int, ...], int,
            int) -> int
        C++: int ScatterV(const long long *sendBuffer,
            long long *recvBuffer, vtkIdType *sendLengths,
            vtkIdType *offsets, vtkIdType recvLength, int srcProcessId)
        
        ScatterV is the vector variant of Scatter.  It extends the
        functionality of Scatter by allowing a varying count of data to
        each process. ScatterV takes an array in the process with id
        srcProcessId and distributes it.  Each process (including the
        source) receives a portion of the send buffer defined by the
        sendLengths and offsets arrays.
        """
        ...
    
    def ScatterVoidArray(self, void, void_1, p_int, p_int_1, p_int_2):
        """
        V.ScatterVoidArray(void, void, int, int, int) -> int
        C++: virtual int ScatterVoidArray(const void *sendBuffer,
            void *recvBuffer, vtkIdType length, int type,
            int srcProcessId)
        
        Subclasses should reimplement these if they have a more efficient
        implementation.
        """
        ...
    
    def ScatterVVoidArray(self, void, void_1, *int, **kwargs):
        """
        V.ScatterVVoidArray(void, void, [int, ...], [int, ...], int, int,
            int) -> int
        C++: virtual int ScatterVVoidArray(const void *sendBuffer,
            void *recvBuffer, vtkIdType *sendLengths, vtkIdType *offsets,
            vtkIdType recvLength, int type, int srcProcessId)
        
        Subclasses should reimplement these if they have a more efficient
        implementation.
        """
        ...
    
    def Send(self, vtkDataObject, p_int, p_int_1):
        """
        V.Send(vtkDataObject, int, int) -> int
        C++: int Send(vtkDataObject *data, int remoteHandle, int tag)
        V.Send(vtkDataArray, int, int) -> int
        C++: int Send(vtkDataArray *data, int remoteHandle, int tag)
        V.Send((int, ...), int, int, int) -> int
        C++: int Send(const int *data, vtkIdType length, int remoteHandle,
             int tag)
        V.Send((int, ...), int, int, int) -> int
        C++: int Send(const long *data, vtkIdType length,
            int remoteHandle, int tag)
        V.Send(string, int, int, int) -> int
        C++: int Send(const char *data, vtkIdType length,
            int remoteHandle, int tag)
        V.Send((float, ...), int, int, int) -> int
        C++: int Send(const double *data, vtkIdType length,
            int remoteHandle, int tag)
        V.Send((int, ...), int, int, int) -> int
        C++: int Send(const long long *data, vtkIdType length,
            int remoteHandle, int tag)
        V.Send(vtkMultiProcessStream, int, int) -> int
        C++: int Send(const vtkMultiProcessStream &stream, int remoteId,
            int tag)
        
        This method sends a data object to a destination. Tag eliminates
        ambiguity and is used to match sends to receives.
        """
        ...
    
    def SendVoidArray(self, void, p_int, p_int_1, p_int_2, p_int_3):
        """
        V.SendVoidArray(void, int, int, int, int) -> int
        C++: virtual int SendVoidArray(const void *data, vtkIdType length,
             int type, int remoteHandle, int tag)
        
        Subclasses have to supply this method to send various arrays of
        data. The type arg is one of the VTK type constants recognized by
        the vtkTemplateMacro (VTK_FLOAT, VTK_INT, etc.).  length is
        measured in number of values (as opposed to number of bytes).
        """
        ...
    
    def SetNumberOfProcesses(self, p_int):
        """
        V.SetNumberOfProcesses(int)
        C++: virtual void SetNumberOfProcesses(int num)
        
        Set the number of processes you will be using.  This defaults to
        the maximum number available.  If you set this to a value higher
        than the default, you will get an error.
        """
        ...
    
    def SetUseCopy(self, p_int):
        """
        V.SetUseCopy(int)
        C++: static void SetUseCopy(int useCopy)
        """
        ...
    
    def UnMarshalDataObject(self, vtkCharArray, vtkDataObject):
        """
        V.UnMarshalDataObject(vtkCharArray, vtkDataObject) -> int
        C++: static int UnMarshalDataObject(vtkCharArray *buffer,
            vtkDataObject *object)
        V.UnMarshalDataObject(vtkCharArray)
            -> vtkSmartPointer_I13vtkDataObjectE
        C++: static vtkSmartPointer<vtkDataObject> UnMarshalDataObject(
            vtkCharArray *buffer)
        
        Convert a data object into a string that can be transmitted and
        vice versa. Returns 1 for success and 0 for failure. WARNING:
        This will only work for types that have a vtkDataWriter class.
        """
        ...
    
    def __delattr__(self, *args, **kwargs):
        """ Implement delattr(self, name). """
        ...
    
    def __getattribute__(self, *args, **kwargs):
        """ Return getattr(self, name). """
        ...
    
    def __init__(self, *args, **kwargs) -> None:
        ...
    
    @staticmethod
    def __new__(*args, **kwargs):
        """ Create and return a new object.  See help(type) for accurate signature. """
        ...
    
    def __repr__(self, *args, **kwargs):
        """ Return repr(self). """
        ...
    
    def __setattr__(self, *args, **kwargs):
        """ Implement setattr(self, name, value). """
        ...
    
    def __str__(self, *args, **kwargs) -> str:
        """ Return str(self). """
        ...
    
    __this__ = ...
    BARRIER_TAG = ...
    BITWISE_AND_OP = ...
    BITWISE_OR_OP = ...
    BITWISE_XOR_OP = ...
    BROADCAST_TAG = ...
    GATHERV_TAG = ...
    GATHER_TAG = ...
    LOGICAL_AND_OP = ...
    LOGICAL_OR_OP = ...
    LOGICAL_XOR_OP = ...
    MAX_OP = ...
    MIN_OP = ...
    PRODUCT_OP = ...
    REDUCE_TAG = ...
    SCATTERV_TAG = ...
    SCATTER_TAG = ...
    StandardOperations = ...
    SUM_OP = ...
    Tags = ...
    __dict__ = ...
    __vtkname__ = ...


class vtkDummyCommunicator(vtkCommunicator):
    """
    vtkDummyCommunicator - Dummy controller for single process
    applications.
    
    Superclass: vtkCommunicator
    
    This is a dummy communicator, which can be used by applications that
    always require a controller but are also compiled on systems without
    threads or MPI. Because there is always only one process, no real
    communication takes place.
    """
    def GetNumberOfGenerationsFromBase(self, string):
        """
        V.GetNumberOfGenerationsFromBase(string) -> int
        C++: vtkIdType GetNumberOfGenerationsFromBase(const char *type)
            override;
        
        Given a the name of a base class of this class type, return the
        distance of inheritance between this class type and the named
        class (how many generations of inheritance are there between this
        class and the named class). If the named class is not in this
        class's inheritance tree, return a negative value. Valid
        responses will always be nonnegative. This method works in
        combination with vtkTypeMacro found in vtkSetGet.h.
        """
        ...
    
    def GetNumberOfGenerationsFromBaseType(self, string):
        """
        V.GetNumberOfGenerationsFromBaseType(string) -> int
        C++: static vtkIdType GetNumberOfGenerationsFromBaseType(
            const char *type)
        
        Given a the name of a base class of this class type, return the
        distance of inheritance between this class type and the named
        class (how many generations of inheritance are there between this
        class and the named class). If the named class is not in this
        class's inheritance tree, return a negative value. Valid
        responses will always be nonnegative. This method works in
        combination with vtkTypeMacro found in vtkSetGet.h.
        """
        ...
    
    def IsA(self, string):
        """
        V.IsA(string) -> int
        C++: vtkTypeBool IsA(const char *type) override;
        
        Return 1 if this class is the same type of (or a subclass of) the
        named class. Returns 0 otherwise. This method works in
        combination with vtkTypeMacro found in vtkSetGet.h.
        """
        ...
    
    def IsTypeOf(self, string):
        """
        V.IsTypeOf(string) -> int
        C++: static vtkTypeBool IsTypeOf(const char *type)
        
        Return 1 if this class type is the same type of (or a subclass
        of) the named class. Returns 0 otherwise. This method works in
        combination with vtkTypeMacro found in vtkSetGet.h.
        """
        ...
    
    def NewInstance(self):
        """
        V.NewInstance() -> vtkDummyCommunicator
        C++: vtkDummyCommunicator *NewInstance()
        """
        ...
    
    def ReceiveVoidArray(self, void, p_int, p_int_1, p_int_2, p_int_3):
        """
        V.ReceiveVoidArray(void, int, int, int, int) -> int
        C++: int ReceiveVoidArray(void *, vtkIdType, int, int, int)
            override;
        
        Since there is no one to communicate with, these methods just
        report an error.
        """
        ...
    
    def SafeDownCast(self, vtkObjectBase):
        """
        V.SafeDownCast(vtkObjectBase) -> vtkDummyCommunicator
        C++: static vtkDummyCommunicator *SafeDownCast(vtkObjectBase *o)
        """
        ...
    
    def SendVoidArray(self, void, p_int, p_int_1, p_int_2, p_int_3):
        """
        V.SendVoidArray(void, int, int, int, int) -> int
        C++: int SendVoidArray(const void *, vtkIdType, int, int, int)
            override;
        
        Since there is no one to communicate with, these methods just
        report an error.
        """
        ...
    
    def __delattr__(self, *args, **kwargs):
        """ Implement delattr(self, name). """
        ...
    
    def __getattribute__(self, *args, **kwargs):
        """ Return getattr(self, name). """
        ...
    
    def __init__(self, *args, **kwargs) -> None:
        ...
    
    @staticmethod
    def __new__(*args, **kwargs):
        """ Create and return a new object.  See help(type) for accurate signature. """
        ...
    
    def __repr__(self, *args, **kwargs):
        """ Return repr(self). """
        ...
    
    def __setattr__(self, *args, **kwargs):
        """ Implement setattr(self, name, value). """
        ...
    
    def __str__(self, *args, **kwargs) -> str:
        """ Return str(self). """
        ...
    
    __this__ = ...
    __dict__ = ...
    __vtkname__ = ...


class vtkMultiProcessController(__vtkmodules_vtkCommonCore.vtkObject):
    """
    vtkMultiProcessController - Multiprocessing communication superclass
    
    Superclass: vtkObject
    
    vtkMultiProcessController is used to control multiple processes in a
    distributed computing environment. It has methods for executing
    single/multiple method(s) on multiple processors, triggering
    registered callbacks (Remote Methods) (AddRMI(), TriggerRMI()) and
    communication. Please note that the communication is done using the
    communicator which is accessible to the user. Therefore it is
    possible to get the communicator with GetCommunicator() and use it to
    send and receive data. This is the encouraged communication method.
    The internal (RMI) communications are done using a second internal
    communicator (called RMICommunicator).
    
    There are two modes for RMI communication: (1) Send/Receive mode and
    (2) Broadcast (collective) mode. The Send/Receive mode arranges
    processes in a binary tree using post-order traversal and propagates
    the RMI trigger starting from the root (rank 0) to the children. It
    is commonly employed to communicate between client/server over TCP.
    Although, the Send/Receive mode can be employed transparently over
    TCP or MPI, it is not optimal for triggering the RMIs on the
    satellite ranks. The Broadcast mode provides a more desirable
    alternative, namely, it uses MPI_Broadcast for communication, which
    is the nominal way of achieving this in an MPI context. The
    underlying communication mode used for triggering RMIs is controlled
    by the "BroadcastTriggerRMI" variable. Note, that mixing between the
    two modes for RMI communication is not correct behavior. All
    processes within the vtkMultiProcessController must use the same mode
    for triggering RMI.
    
    @sa
    vtkMPIController vtkCommunicator vtkMPICommunicator
    """
    def AllGather(self, int_tuple, *int, **kwargs):
        """
        V.AllGather((int, ...), [int, ...], int) -> int
        C++: int AllGather(const int *sendBuffer, int *recvBuffer,
            vtkIdType length)
        V.AllGather((int, ...), [int, ...], int) -> int
        C++: int AllGather(const long *sendBuffer, long *recvBuffer,
            vtkIdType length)
        V.AllGather(string, string, int) -> int
        C++: int AllGather(const char *sendBuffer, char *recvBuffer,
            vtkIdType length)
        V.AllGather((float, ...), [float, ...], int) -> int
        C++: int AllGather(const double *sendBuffer, double *recvBuffer,
            vtkIdType length)
        V.AllGather((int, ...), [int, ...], int) -> int
        C++: int AllGather(const long long *sendBuffer,
            long long *recvBuffer, vtkIdType length)
        V.AllGather(vtkDataArray, vtkDataArray) -> int
        C++: int AllGather(vtkDataArray *sendBuffer,
            vtkDataArray *recvBuffer)
        
        Same as gather except that the result ends up on all processes.
        """
        ...
    
    def AllGatherV(self, int_tuple, *int, **kwargs):
        """
        V.AllGatherV((int, ...), [int, ...], int, [int, ...], [int, ...])
            -> int
        C++: int AllGatherV(const int *sendBuffer, int *recvBuffer,
            vtkIdType sendLength, vtkIdType *recvLengths,
            vtkIdType *offsets)
        V.AllGatherV((int, ...), [int, ...], int, [int, ...], [int, ...])
            -> int
        C++: int AllGatherV(const long *sendBuffer, long *recvBuffer,
            vtkIdType sendLength, vtkIdType *recvLengths,
            vtkIdType *offsets)
        V.AllGatherV(string, string, int, [int, ...], [int, ...]) -> int
        C++: int AllGatherV(const char *sendBuffer, char *recvBuffer,
            vtkIdType sendLength, vtkIdType *recvLengths,
            vtkIdType *offsets)
        V.AllGatherV((float, ...), [float, ...], int, [int, ...], [int,
            ...]) -> int
        C++: int AllGatherV(const double *sendBuffer, double *recvBuffer,
            vtkIdType sendLength, vtkIdType *recvLengths,
            vtkIdType *offsets)
        V.AllGatherV((int, ...), [int, ...], int, [int, ...], [int, ...])
            -> int
        C++: int AllGatherV(const long long *sendBuffer,
            long long *recvBuffer, vtkIdType sendLength,
            vtkIdType *recvLengths, vtkIdType *offsets)
        V.AllGatherV(vtkDataArray, vtkDataArray, [int, ...], [int, ...])
            -> int
        C++: int AllGatherV(vtkDataArray *sendBuffer,
            vtkDataArray *recvBuffer, vtkIdType *recvLengths,
            vtkIdType *offsets)
        V.AllGatherV(vtkDataArray, vtkDataArray) -> int
        C++: int AllGatherV(vtkDataArray *sendBuffer,
            vtkDataArray *recvBuffer)
        
        Same as GatherV except that the result is placed in all
        processes.
        """
        ...
    
    def AllReduce(self, int_tuple, *int, **kwargs):
        """
        V.AllReduce((int, ...), [int, ...], int, int) -> int
        C++: int AllReduce(const int *sendBuffer, int *recvBuffer,
            vtkIdType length, int operation)
        V.AllReduce((int, ...), [int, ...], int, int) -> int
        C++: int AllReduce(const long *sendBuffer, long *recvBuffer,
            vtkIdType length, int operation)
        V.AllReduce(string, string, int, int) -> int
        C++: int AllReduce(const char *sendBuffer, char *recvBuffer,
            vtkIdType length, int operation)
        V.AllReduce((float, ...), [float, ...], int, int) -> int
        C++: int AllReduce(const double *sendBuffer, double *recvBuffer,
            vtkIdType length, int operation)
        V.AllReduce((int, ...), [int, ...], int, int) -> int
        C++: int AllReduce(const long long *sendBuffer,
            long long *recvBuffer, vtkIdType length, int operation)
        V.AllReduce(vtkDataArray, vtkDataArray, int) -> int
        C++: int AllReduce(vtkDataArray *sendBuffer,
            vtkDataArray *recvBuffer, int operation)
        V.AllReduce(vtkBoundingBox, vtkBoundingBox) -> int
        C++: int AllReduce(const vtkBoundingBox &sendBuffer,
            vtkBoundingBox &recvBuffer)
        
        Same as Reduce except that the result is placed in all of the
        processes.
        """
        ...
    
    def Barrier(self):
        """
        V.Barrier()
        C++: void Barrier()
        
        This method can be used to synchronize processes.
        """
        ...
    
    def Broadcast(self, *int, **kwargs):
        """
        V.Broadcast([int, ...], int, int) -> int
        C++: int Broadcast(int *data, vtkIdType length, int srcProcessId)
        V.Broadcast([int, ...], int, int) -> int
        C++: int Broadcast(long *data, vtkIdType length, int srcProcessId)
        V.Broadcast(string, int, int) -> int
        C++: int Broadcast(char *data, vtkIdType length, int srcProcessId)
        V.Broadcast([float, ...], int, int) -> int
        C++: int Broadcast(double *data, vtkIdType length,
            int srcProcessId)
        V.Broadcast([int, ...], int, int) -> int
        C++: int Broadcast(long long *data, vtkIdType length,
            int srcProcessId)
        V.Broadcast(vtkDataObject, int) -> int
        C++: int Broadcast(vtkDataObject *data, int srcProcessId)
        V.Broadcast(vtkDataArray, int) -> int
        C++: int Broadcast(vtkDataArray *data, int srcProcessId)
        V.Broadcast(vtkMultiProcessStream, int) -> int
        C++: int Broadcast(vtkMultiProcessStream &stream,
            int srcProcessId)
        
        Broadcast sends the array in the process with id srcProcessId to
        all of the other processes.  All processes must call these method
        with the same arguments in order for it to complete.
        """
        ...
    
    def BroadcastProcessRMIs(self, p_int, p_int_1):
        """
        V.BroadcastProcessRMIs(int, int) -> int
        C++: int BroadcastProcessRMIs(int reportErrors, int dont_loop=0)
        
        Calling this method gives control to the controller to start
        processing RMIs. Possible return values are: RMI_NO_ERROR,
        RMI_TAG_ERROR : rmi tag could not be received, RMI_ARG_ERROR :
        rmi arg could not be received. If reportErrors is false, no
        vtkErrorMacro is called. ProcessRMIs() calls ProcessRMIs(int)
        with reportErrors = 0. If dont_loop is 1, this call just process
        one RMI message and exits.
        """
        ...
    
    def BroadcastTriggerRMIOff(self):
        """
        V.BroadcastTriggerRMIOff()
        C++: virtual void BroadcastTriggerRMIOff()
        
        Setting this flag to 1 will cause the TriggerRMIOnAllChildren to
        use a collective broadcast operation to communicate the RMI tag
        to the satellites.
        """
        ...
    
    def BroadcastTriggerRMIOn(self):
        """
        V.BroadcastTriggerRMIOn()
        C++: virtual void BroadcastTriggerRMIOn()
        
        Setting this flag to 1 will cause the TriggerRMIOnAllChildren to
        use a collective broadcast operation to communicate the RMI tag
        to the satellites.
        """
        ...
    
    def BroadcastTriggerRMIOnAllChildren(self, void, p_int, p_int_1):
        """
        V.BroadcastTriggerRMIOnAllChildren(void, int, int)
        C++: void BroadcastTriggerRMIOnAllChildren(void *arg,
            int argLength, int tag)
        
        This is a convenicence method to trigger an RMI call on all the
        "children" of the current node. The children of the current node
        can be determined by drawing a binary tree starting at node 0 and
        then assigned nodes ids incrementally in a breadth-first fashion
        from left to right. This is designed to be used when trigger an
        RMI call on all satellites from the root node.
        """
        ...
    
    def CreateOutputWindow(self):
        """
        V.CreateOutputWindow()
        C++: virtual void CreateOutputWindow()
        
        This method can be used to tell the controller to create a
        special output window in which all messages are preceded by the
        process id.
        """
        ...
    
    def CreateSubController(self, vtkProcessGroup):
        """
        V.CreateSubController(vtkProcessGroup)
            -> vtkMultiProcessController
        C++: virtual vtkMultiProcessController *CreateSubController(
            vtkProcessGroup *group)
        
        Creates a new controller with the processes specified by the
        given group. The new controller will already be initialized for
        you.  You are responsible for deleting the controller once you
        are done.  It is invalid to pass this method a group with a
        different communicator than is used by this controller.  This
        operation is collective across all processes defined in the
        group.  It is undefined what will happen if the group is not the
        same on all processes.  This method must be called by all
        processes in the controller regardless of whether they are in the
        group.  nullptr is returned on all process not in the group.
        """
        ...
    
    def Finalize(self):
        """
        V.Finalize()
        C++: virtual void Finalize()
        V.Finalize(int)
        C++: virtual void Finalize(int finalizedExternally)
        
        This method is for cleaning up. If a subclass needs to clean up
        process communication (i.e. MPI) it would over ride this method.
        """
        ...
    
    def Gather(self, int_tuple, *int, **kwargs):
        """
        V.Gather((int, ...), [int, ...], int, int) -> int
        C++: int Gather(const int *sendBuffer, int *recvBuffer,
            vtkIdType length, int destProcessId)
        V.Gather((int, ...), [int, ...], int, int) -> int
        C++: int Gather(const long *sendBuffer, long *recvBuffer,
            vtkIdType length, int destProcessId)
        V.Gather(string, string, int, int) -> int
        C++: int Gather(const char *sendBuffer, char *recvBuffer,
            vtkIdType length, int destProcessId)
        V.Gather((float, ...), [float, ...], int, int) -> int
        C++: int Gather(const double *sendBuffer, double *recvBuffer,
            vtkIdType length, int destProcessId)
        V.Gather((int, ...), [int, ...], int, int) -> int
        C++: int Gather(const long long *sendBuffer,
            long long *recvBuffer, vtkIdType length, int destProcessId)
        V.Gather(vtkDataArray, vtkDataArray, int) -> int
        C++: int Gather(vtkDataArray *sendBuffer,
            vtkDataArray *recvBuffer, int destProcessId)
        
        Gather collects arrays in the process with id destProcessId. 
        Each process (including the destination) sends the contents of
        its send buffer to the destination process.  The destination
        process receives the messages and stores them in rank order.  The
        length argument (which must be the same on all processes) is the
        length of the sendBuffers.  The recvBuffer (on the destination
        process) must be of length length*numProcesses.  Gather is the
        inverse operation of Scatter.
        """
        ...
    
    def GatherV(self, int_tuple, *int, **kwargs):
        """
        V.GatherV((int, ...), [int, ...], int, [int, ...], [int, ...],
            int) -> int
        C++: int GatherV(const int *sendBuffer, int *recvBuffer,
            vtkIdType sendLength, vtkIdType *recvLengths,
            vtkIdType *offsets, int destProcessId)
        V.GatherV((int, ...), [int, ...], int, [int, ...], [int, ...],
            int) -> int
        C++: int GatherV(const long *sendBuffer, long *recvBuffer,
            vtkIdType sendLength, vtkIdType *recvLengths,
            vtkIdType *offsets, int destProcessId)
        V.GatherV(string, string, int, [int, ...], [int, ...], int) -> int
        C++: int GatherV(const char *sendBuffer, char *recvBuffer,
            vtkIdType sendLength, vtkIdType *recvLengths,
            vtkIdType *offsets, int destProcessId)
        V.GatherV((float, ...), [float, ...], int, [int, ...], [int, ...],
             int) -> int
        C++: int GatherV(const double *sendBuffer, double *recvBuffer,
            vtkIdType sendLength, vtkIdType *recvLengths,
            vtkIdType *offsets, int destProcessId)
        V.GatherV((int, ...), [int, ...], int, [int, ...], [int, ...],
            int) -> int
        C++: int GatherV(const long long *sendBuffer,
            long long *recvBuffer, vtkIdType sendLength,
            vtkIdType *recvLengths, vtkIdType *offsets, int destProcessId)
        V.GatherV(vtkDataArray, vtkDataArray, [int, ...], [int, ...], int)
             -> int
        C++: int GatherV(vtkDataArray *sendBuffer,
            vtkDataArray *recvBuffer, vtkIdType *recvLengths,
            vtkIdType *offsets, int destProcessId)
        V.GatherV(vtkDataArray, vtkDataArray, vtkIdTypeArray,
            vtkIdTypeArray, int) -> int
        C++: int GatherV(vtkDataArray *sendBuffer,
            vtkDataArray *recvBuffer, vtkIdTypeArray *recvLengths,
            vtkIdTypeArray *offsets, int destProcessId)
        V.GatherV(vtkDataArray, vtkDataArray, int) -> int
        C++: int GatherV(vtkDataArray *sendBuffer,
            vtkDataArray *recvBuffer, int destProcessId)
        
        GatherV is the vector variant of Gather.  It extends the
        functionality of Gather by allowing a varying count of data from
        each process. GatherV collects arrays in the process with id
        destProcessId.  Each process (including t ...
         [Truncated]
        """
        ...
    
    def GetBreakFlag(self):
        """
        V.GetBreakFlag() -> int
        C++: virtual int GetBreakFlag()
        
        Setting this flag to 1 will cause the ProcessRMIs loop to return.
        This also causes vtkUpStreamPorts to return from their
        WaitForUpdate loops.
        """
        ...
    
    def GetBreakRMITag(self):
        """
        V.GetBreakRMITag() -> int
        C++: static int GetBreakRMITag()
        
        Accessor to some default tags.
        """
        ...
    
    def GetBroadcastTriggerRMI(self):
        """
        V.GetBroadcastTriggerRMI() -> bool
        C++: virtual bool GetBroadcastTriggerRMI()
        
        Setting this flag to 1 will cause the TriggerRMIOnAllChildren to
        use a collective broadcast operation to communicate the RMI tag
        to the satellites.
        """
        ...
    
    def GetCommunicator(self):
        """
        V.GetCommunicator() -> vtkCommunicator
        C++: virtual vtkCommunicator *GetCommunicator()
        
        Returns the communicator associated with this controller. A
        default communicator is created in constructor.
        """
        ...
    
    def GetCount(self):
        """
        V.GetCount() -> int
        C++: vtkIdType GetCount()
        
        Returns the number of words received by the most recent
        Receive(). Note that this is not the number of bytes received,
        but the number of items of the data-type received by the most
        recent Receive() eg. if Receive(int*,..) was used, then this
        returns the number of ints received; if Receive(double*,..) was
        used, then this returns the number of doubles received etc. The
        return value is valid only after a successful Receive().
        """
        ...
    
    def GetGlobalController(self):
        """
        V.GetGlobalController() -> vtkMultiProcessController
        C++: static vtkMultiProcessController *GetGlobalController()
        
        This convenience method returns the controller associated with
        the local process.  It returns nullptr until the processes are
        spawned. It is better if you hang on to the controller passed as
        an argument to the SingleMethod or MultipleMethod functions.
        """
        ...
    
    def GetLocalProcessId(self):
        """
        V.GetLocalProcessId() -> int
        C++: int GetLocalProcessId()
        
        Tells you which process [0, NumProcess) you are in.
        """
        ...
    
    def GetNumberOfGenerationsFromBase(self, string):
        """
        V.GetNumberOfGenerationsFromBase(string) -> int
        C++: vtkIdType GetNumberOfGenerationsFromBase(const char *type)
            override;
        
        Given a the name of a base class of this class type, return the
        distance of inheritance between this class type and the named
        class (how many generations of inheritance are there between this
        class and the named class). If the named class is not in this
        class's inheritance tree, return a negative value. Valid
        responses will always be nonnegative. This method works in
        combination with vtkTypeMacro found in vtkSetGet.h.
        """
        ...
    
    def GetNumberOfGenerationsFromBaseType(self, string):
        """
        V.GetNumberOfGenerationsFromBaseType(string) -> int
        C++: static vtkIdType GetNumberOfGenerationsFromBaseType(
            const char *type)
        
        Given a the name of a base class of this class type, return the
        distance of inheritance between this class type and the named
        class (how many generations of inheritance are there between this
        class and the named class). If the named class is not in this
        class's inheritance tree, return a negative value. Valid
        responses will always be nonnegative. This method works in
        combination with vtkTypeMacro found in vtkSetGet.h.
        """
        ...
    
    def GetNumberOfProcesses(self):
        """
        V.GetNumberOfProcesses() -> int
        C++: int GetNumberOfProcesses()
        
        Set the number of processes you will be using.  This defaults to
        the maximum number available.  If you set this to a value higher
        than the default, you will get an error.
        """
        ...
    
    def GetRMIArgTag(self):
        """
        V.GetRMIArgTag() -> int
        C++: static int GetRMIArgTag()
        """
        ...
    
    def GetRMITag(self):
        """
        V.GetRMITag() -> int
        C++: static int GetRMITag()
        """
        ...
    
    def IsA(self, string):
        """
        V.IsA(string) -> int
        C++: vtkTypeBool IsA(const char *type) override;
        
        Return 1 if this class is the same type of (or a subclass of) the
        named class. Returns 0 otherwise. This method works in
        combination with vtkTypeMacro found in vtkSetGet.h.
        """
        ...
    
    def IsTypeOf(self, string):
        """
        V.IsTypeOf(string) -> int
        C++: static vtkTypeBool IsTypeOf(const char *type)
        
        Return 1 if this class type is the same type of (or a subclass
        of) the named class. Returns 0 otherwise. This method works in
        combination with vtkTypeMacro found in vtkSetGet.h.
        """
        ...
    
    def MultipleMethodExecute(self):
        """
        V.MultipleMethodExecute()
        C++: virtual void MultipleMethodExecute()
        
        Execute the MultipleMethods (as define by calling
        SetMultipleMethod for each of the required
        this->NumberOfProcesses methods) using this->NumberOfProcesses
        processes.
        """
        ...
    
    def NewInstance(self):
        """
        V.NewInstance() -> vtkMultiProcessController
        C++: vtkMultiProcessController *NewInstance()
        """
        ...
    
    def PartitionController(self, p_int, p_int_1):
        """
        V.PartitionController(int, int) -> vtkMultiProcessController
        C++: virtual vtkMultiProcessController *PartitionController(
            int localColor, int localKey)
        
        Partitions this controller based on a coloring.  That is, each
        process passes in a color.  All processes with the same color are
        grouped into the same partition.  The processes are ordered by
        their self-assigned key. Lower keys have lower process ids.  Ties
        are broken by the current process ids.  (For example, if all the
        keys are 0, then the resulting processes will be ordered in the
        same way.)  This method returns a new controller to each process
        that represents the local partition.  This is basically the same
        operation as MPI_Comm_split.
        """
        ...
    
    def ProcessRMIs(self, p_int, p_int_1):
        """
        V.ProcessRMIs(int, int) -> int
        C++: int ProcessRMIs(int reportErrors, int dont_loop=0)
        V.ProcessRMIs() -> int
        C++: int ProcessRMIs()
        
        Calling this method gives control to the controller to start
        processing RMIs. Possible return values are: RMI_NO_ERROR,
        RMI_TAG_ERROR : rmi tag could not be received, RMI_ARG_ERROR :
        rmi arg could not be received. If reportErrors is false, no
        vtkErrorMacro is called. ProcessRMIs() calls ProcessRMIs(int)
        with reportErrors = 0. If dont_loop is 1, this call just process
        one RMI message and exits.
        """
        ...
    
    def Receive(self, *int, **kwargs):
        """
        V.Receive([int, ...], int, int, int) -> int
        C++: int Receive(int *data, vtkIdType maxlength,
            int remoteProcessId, int tag)
        V.Receive([int, ...], int, int, int) -> int
        C++: int Receive(long *data, vtkIdType maxlength,
            int remoteProcessId, int tag)
        V.Receive(string, int, int, int) -> int
        C++: int Receive(char *data, vtkIdType maxlength,
            int remoteProcessId, int tag)
        V.Receive([float, ...], int, int, int) -> int
        C++: int Receive(double *data, vtkIdType maxlength,
            int remoteProcessId, int tag)
        V.Receive([int, ...], int, int, int) -> int
        C++: int Receive(long long *data, vtkIdType maxLength,
            int remoteProcessId, int tag)
        V.Receive(vtkDataObject, int, int) -> int
        C++: int Receive(vtkDataObject *data, int remoteId, int tag)
        V.Receive(vtkDataArray, int, int) -> int
        C++: int Receive(vtkDataArray *data, int remoteId, int tag)
        V.Receive(vtkMultiProcessStream, int, int) -> int
        C++: int Receive(vtkMultiProcessStream &stream, int remoteId,
            int tag)
        
        This method receives data from a corresponding send. It blocks
        until the receive is finished.  It calls methods in "data" to
        communicate the sending data. In the overrloads that take in a \c
        maxlength argument, this length is the maximum length of the
        message to receive. If the maxlength is less than the length of
        the message sent by the sender, an error will be flagged. Once a
        message is received, use the GetCount() method to determine the
        actual size of the data received.
        """
        ...
    
    def ReceiveDataObject(self, p_int, p_int_1):
        """
        V.ReceiveDataObject(int, int) -> vtkDataObject
        C++: vtkDataObject *ReceiveDataObject(int remoteId, int tag)
        """
        ...
    
    def Reduce(self, int_tuple, *int, **kwargs):
        """
        V.Reduce((int, ...), [int, ...], int, int, int) -> int
        C++: int Reduce(const int *sendBuffer, int *recvBuffer,
            vtkIdType length, int operation, int destProcessId)
        V.Reduce((int, ...), [int, ...], int, int, int) -> int
        C++: int Reduce(const long *sendBuffer, long *recvBuffer,
            vtkIdType length, int operation, int destProcessId)
        V.Reduce(string, string, int, int, int) -> int
        C++: int Reduce(const char *sendBuffer, char *recvBuffer,
            vtkIdType length, int operation, int destProcessId)
        V.Reduce((float, ...), [float, ...], int, int, int) -> int
        C++: int Reduce(const double *sendBuffer, double *recvBuffer,
            vtkIdType length, int operation, int destProcessId)
        V.Reduce((int, ...), [int, ...], int, int, int) -> int
        C++: int Reduce(const long long *sendBuffer,
            long long *recvBuffer, vtkIdType length, int operation,
            int destProcessId)
        V.Reduce(vtkDataArray, vtkDataArray, int, int) -> int
        C++: int Reduce(vtkDataArray *sendBuffer,
            vtkDataArray *recvBuffer, int operation, int destProcessId)
        V.Reduce(vtkBoundingBox, vtkBoundingBox, int) -> int
        C++: int Reduce(const vtkBoundingBox &sendBuffer,
            vtkBoundingBox &recvBuffer, int destProcessId)
        
        Reduce an array to the given destination process.  This version
        of Reduce takes an identifier defined in the
        vtkCommunicator::StandardOperations enum to define the operation.
        """
        ...
    
    def RemoveAllRMICallbacks(self, p_int):
        """
        V.RemoveAllRMICallbacks(int)
        C++: virtual void RemoveAllRMICallbacks(int tag)
        
        These methods are a part of the newer API to add multiple rmi
        callbacks. When the RMI is triggered, all the callbacks are
        called Removes all callbacks for the tag.
        """
        ...
    
    def RemoveFirstRMI(self, p_int):
        """
        V.RemoveFirstRMI(int) -> int
        C++: virtual int RemoveFirstRMI(int tag)
        
        Remove the first RMI matching the tag.
        """
        ...
    
    def RemoveRMI(self, p_int):
        """
        V.RemoveRMI(int) -> int
        C++: virtual int RemoveRMI(unsigned long id)
        
        Remove the RMI matching the id. The id is the same id returned by
        AddRMI().
        """
        ...
    
    def RemoveRMICallback(self, p_int):
        """
        V.RemoveRMICallback(int) -> bool
        C++: virtual bool RemoveRMICallback(unsigned long id)
        
        Remove a callback. Returns true is the remove was successful.
        """
        ...
    
    def SafeDownCast(self, vtkObjectBase):
        """
        V.SafeDownCast(vtkObjectBase) -> vtkMultiProcessController
        C++: static vtkMultiProcessController *SafeDownCast(
            vtkObjectBase *o)
        """
        ...
    
    def Scatter(self, int_tuple, *int, **kwargs):
        """
        V.Scatter((int, ...), [int, ...], int, int) -> int
        C++: int Scatter(const int *sendBuffer, int *recvBuffer,
            vtkIdType length, int srcProcessId)
        V.Scatter((int, ...), [int, ...], int, int) -> int
        C++: int Scatter(const long *sendBuffer, long *recvBuffer,
            vtkIdType length, int srcProcessId)
        V.Scatter(string, string, int, int) -> int
        C++: int Scatter(const char *sendBuffer, char *recvBuffer,
            vtkIdType length, int srcProcessId)
        V.Scatter((float, ...), [float, ...], int, int) -> int
        C++: int Scatter(const double *sendBuffer, double *recvBuffer,
            vtkIdType length, int srcProcessId)
        V.Scatter((int, ...), [int, ...], int, int) -> int
        C++: int Scatter(const long long *sendBuffer,
            long long *recvBuffer, vtkIdType length, int srcProcessId)
        V.Scatter(vtkDataArray, vtkDataArray, int) -> int
        C++: int Scatter(vtkDataArray *sendBuffer,
            vtkDataArray *recvBuffer, int srcProcessId)
        
        Scatter takes an array in the process with id srcProcessId and
        distributes it.  Each process (including the source) receives a
        portion of the send buffer.  Process 0 receives the first length
        values, process 1 receives the second length values, and so on. 
        Scatter is the inverse operation of Gather.
        """
        ...
    
    def ScatterV(self, int_tuple, *int, **kwargs):
        """
        V.ScatterV((int, ...), [int, ...], [int, ...], [int, ...], int,
            int) -> int
        C++: int ScatterV(const int *sendBuffer, int *recvBuffer,
            vtkIdType *sendLengths, vtkIdType *offsets,
            vtkIdType recvLength, int srcProcessId)
        V.ScatterV((int, ...), [int, ...], [int, ...], [int, ...], int,
            int) -> int
        C++: int ScatterV(const long *sendBuffer, long *recvBuffer,
            vtkIdType *sendLengths, vtkIdType *offsets,
            vtkIdType recvLength, int srcProcessId)
        V.ScatterV(string, string, [int, ...], [int, ...], int, int)
            -> int
        C++: int ScatterV(const char *sendBuffer, char *recvBuffer,
            vtkIdType *sendLengths, vtkIdType *offsets,
            vtkIdType recvLength, int srcProcessId)
        V.ScatterV((float, ...), [float, ...], [int, ...], [int, ...],
            int, int) -> int
        C++: int ScatterV(const double *sendBuffer, double *recvBuffer,
            vtkIdType *sendLengths, vtkIdType *offsets,
            vtkIdType recvLength, int srcProcessId)
        V.ScatterV((int, ...), [int, ...], [int, ...], [int, ...], int,
            int) -> int
        C++: int ScatterV(const long long *sendBuffer,
            long long *recvBuffer, vtkIdType *sendLengths,
            vtkIdType *offsets, vtkIdType recvLength, int srcProcessId)
        
        ScatterV is the vector variant of Scatter.  It extends the
        functionality of Scatter by allowing a varying count of data to
        each process. ScatterV takes an array in the process with id
        srcProcessId and distributes it.  Each process (including the
        source) receives a portion of the send buffer defined by the
        sendLengths and offsets arrays.
        """
        ...
    
    def Send(self, int_tuple, p_int, p_int_1, p_int_2):
        """
        V.Send((int, ...), int, int, int) -> int
        C++: int Send(const int *data, vtkIdType length,
            int remoteProcessId, int tag)
        V.Send((int, ...), int, int, int) -> int
        C++: int Send(const long *data, vtkIdType length,
            int remoteProcessId, int tag)
        V.Send(string, int, int, int) -> int
        C++: int Send(const char *data, vtkIdType length,
            int remoteProcessId, int tag)
        V.Send((float, ...), int, int, int) -> int
        C++: int Send(const double *data, vtkIdType length,
            int remoteProcessId, int tag)
        V.Send((int, ...), int, int, int) -> int
        C++: int Send(const long long *data, vtkIdType length,
            int remoteProcessId, int tag)
        V.Send(vtkDataObject, int, int) -> int
        C++: int Send(vtkDataObject *data, int remoteId, int tag)
        V.Send(vtkDataArray, int, int) -> int
        C++: int Send(vtkDataArray *data, int remoteId, int tag)
        V.Send(vtkMultiProcessStream, int, int) -> int
        C++: int Send(const vtkMultiProcessStream &stream, int remoteId,
            int tag)
        
        This method sends data to another process.  Tag eliminates
        ambiguity when multiple sends or receives exist in the same
        process. It is recommended to use custom tag number over 100.
        vtkMultiProcessController has reserved tags between 1 and 4.
        vtkCommunicator has reserved tags between 10 and 16.
        """
        ...
    
    def SetBreakFlag(self, p_int):
        """
        V.SetBreakFlag(int)
        C++: virtual void SetBreakFlag(int _arg)
        
        Setting this flag to 1 will cause the ProcessRMIs loop to return.
        This also causes vtkUpStreamPorts to return from their
        WaitForUpdate loops.
        """
        ...
    
    def SetBroadcastTriggerRMI(self, bool):
        """
        V.SetBroadcastTriggerRMI(bool)
        C++: virtual void SetBroadcastTriggerRMI(bool _arg)
        
        Setting this flag to 1 will cause the TriggerRMIOnAllChildren to
        use a collective broadcast operation to communicate the RMI tag
        to the satellites.
        """
        ...
    
    def SetGlobalController(self, vtkMultiProcessController):
        """
        V.SetGlobalController(vtkMultiProcessController)
        C++: static void SetGlobalController(
            vtkMultiProcessController *controller)
        """
        ...
    
    def SetNumberOfProcesses(self, p_int):
        """
        V.SetNumberOfProcesses(int)
        C++: void SetNumberOfProcesses(int num)
        
        Set the number of processes you will be using.  This defaults to
        the maximum number available.  If you set this to a value higher
        than the default, you will get an error.
        """
        ...
    
    def SetSingleProcessObject(self, vtkProcess):
        """
        V.SetSingleProcessObject(vtkProcess)
        C++: void SetSingleProcessObject(vtkProcess *p)
        
        Object-oriented flavor of SetSingleMethod(). Instead of passing
        some function pointer and user data, a vtkProcess object is
        passed where the method to execute is Execute() and the data the
        object itself.
        """
        ...
    
    def SingleMethodExecute(self):
        """
        V.SingleMethodExecute()
        C++: virtual void SingleMethodExecute()
        
        Execute the SingleMethod (as define by SetSingleMethod) using
        this->NumberOfProcesses processes.  This will only return when
        all the processes finish executing their methods.
        """
        ...
    
    def TriggerBreakRMIs(self):
        """
        V.TriggerBreakRMIs()
        C++: void TriggerBreakRMIs()
        
        A convenience method.  Called on process 0 to break "ProcessRMIs"
        loop on all other processes.
        """
        ...
    
    def TriggerRMI(self, p_int, void, p_int_1, p_int_2):
        """
        V.TriggerRMI(int, void, int, int)
        C++: void TriggerRMI(int remoteProcessId, void *arg,
            int argLength, int tag)
        V.TriggerRMI(int, string, int)
        C++: void TriggerRMI(int remoteProcessId, const char *arg,
            int tag)
        V.TriggerRMI(int, int)
        C++: void TriggerRMI(int remoteProcessId, int tag)
        
        A method to trigger a method invocation in another process.
        """
        ...
    
    def TriggerRMIOnAllChildren(self, void, p_int, p_int_1):
        """
        V.TriggerRMIOnAllChildren(void, int, int)
        C++: void TriggerRMIOnAllChildren(void *arg, int argLength,
            int tag)
        V.TriggerRMIOnAllChildren(string, int)
        C++: void TriggerRMIOnAllChildren(const char *arg, int tag)
        V.TriggerRMIOnAllChildren(int)
        C++: void TriggerRMIOnAllChildren(int tag)
        
        This is a convenicence method to trigger an RMI call on all the
        "children" of the current node. The children of the current node
        can be determined by drawing a binary tree starting at node 0 and
        then assigned nodes ids incrementally in a breadth-first fashion
        from left to right. This is designed to be used when trigger an
        RMI call on all satellites from the root node.
        """
        ...
    
    def __delattr__(self, *args, **kwargs):
        """ Implement delattr(self, name). """
        ...
    
    def __getattribute__(self, *args, **kwargs):
        """ Return getattr(self, name). """
        ...
    
    def __init__(self, *args, **kwargs) -> None:
        ...
    
    @staticmethod
    def __new__(*args, **kwargs):
        """ Create and return a new object.  See help(type) for accurate signature. """
        ...
    
    def __repr__(self, *args, **kwargs):
        """ Return repr(self). """
        ...
    
    def __setattr__(self, *args, **kwargs):
        """ Implement setattr(self, name, value). """
        ...
    
    def __str__(self, *args, **kwargs) -> str:
        """ Return str(self). """
        ...
    
    __this__ = ...
    ANY_SOURCE = ...
    BREAK_RMI_TAG = ...
    Consts = ...
    Errors = ...
    INVALID_SOURCE = ...
    RMI_ARG_ERROR = ...
    RMI_ARG_TAG = ...
    RMI_NO_ERROR = ...
    RMI_TAG = ...
    RMI_TAG_ERROR = ...
    Tags = ...
    XML_WRITER_DATA_INFO = ...
    __dict__ = ...
    __vtkname__ = ...


class vtkDummyController(vtkMultiProcessController):
    """
    vtkDummyController - Dummy controller for single process applications
    
    Superclass: vtkMultiProcessController
    
    This is a dummy controller which can be used by applications which
    always require a controller but are also compile on systems without
    threads or mpi.
    @sa
    vtkMultiProcessController
    """
    def CreateOutputWindow(self):
        """
        V.CreateOutputWindow()
        C++: void CreateOutputWindow() override;
        
        Does nothing.
        """
        ...
    
    def Finalize(self):
        """
        V.Finalize()
        C++: void Finalize() override;
        V.Finalize(int)
        C++: void Finalize(int) override;
        
        This method is for cleaning up. If a subclass needs to clean up
        process communication (i.e. MPI) it would over ride this method.
        """
        ...
    
    def GetLocalProcessId(self):
        """
        V.GetLocalProcessId() -> int
        C++: int GetLocalProcessId()
        
        This method always returns 0.
        """
        ...
    
    def GetNumberOfGenerationsFromBase(self, string):
        """
        V.GetNumberOfGenerationsFromBase(string) -> int
        C++: vtkIdType GetNumberOfGenerationsFromBase(const char *type)
            override;
        
        Given a the name of a base class of this class type, return the
        distance of inheritance between this class type and the named
        class (how many generations of inheritance are there between this
        class and the named class). If the named class is not in this
        class's inheritance tree, return a negative value. Valid
        responses will always be nonnegative. This method works in
        combination with vtkTypeMacro found in vtkSetGet.h.
        """
        ...
    
    def GetNumberOfGenerationsFromBaseType(self, string):
        """
        V.GetNumberOfGenerationsFromBaseType(string) -> int
        C++: static vtkIdType GetNumberOfGenerationsFromBaseType(
            const char *type)
        
        Given a the name of a base class of this class type, return the
        distance of inheritance between this class type and the named
        class (how many generations of inheritance are there between this
        class and the named class). If the named class is not in this
        class's inheritance tree, return a negative value. Valid
        responses will always be nonnegative. This method works in
        combination with vtkTypeMacro found in vtkSetGet.h.
        """
        ...
    
    def GetRMICommunicator(self):
        """
        V.GetRMICommunicator() -> vtkCommunicator
        C++: virtual vtkCommunicator *GetRMICommunicator()
        
        If you don't need any special functionality from the controller,
        you can swap out the dummy communicator for another one.
        """
        ...
    
    def IsA(self, string):
        """
        V.IsA(string) -> int
        C++: vtkTypeBool IsA(const char *type) override;
        
        Return 1 if this class is the same type of (or a subclass of) the
        named class. Returns 0 otherwise. This method works in
        combination with vtkTypeMacro found in vtkSetGet.h.
        """
        ...
    
    def IsTypeOf(self, string):
        """
        V.IsTypeOf(string) -> int
        C++: static vtkTypeBool IsTypeOf(const char *type)
        
        Return 1 if this class type is the same type of (or a subclass
        of) the named class. Returns 0 otherwise. This method works in
        combination with vtkTypeMacro found in vtkSetGet.h.
        """
        ...
    
    def MultipleMethodExecute(self):
        """
        V.MultipleMethodExecute()
        C++: void MultipleMethodExecute() override;
        
        Directly calls multiple method 0.
        """
        ...
    
    def NewInstance(self):
        """
        V.NewInstance() -> vtkDummyController
        C++: vtkDummyController *NewInstance()
        """
        ...
    
    def SafeDownCast(self, vtkObjectBase):
        """
        V.SafeDownCast(vtkObjectBase) -> vtkDummyController
        C++: static vtkDummyController *SafeDownCast(vtkObjectBase *o)
        """
        ...
    
    def SetCommunicator(self, vtkCommunicator):
        """
        V.SetCommunicator(vtkCommunicator)
        C++: virtual void SetCommunicator(vtkCommunicator *)
        
        If you don't need any special functionality from the controller,
        you can swap out the dummy communicator for another one.
        """
        ...
    
    def SetRMICommunicator(self, vtkCommunicator):
        """
        V.SetRMICommunicator(vtkCommunicator)
        C++: virtual void SetRMICommunicator(vtkCommunicator *)
        
        If you don't need any special functionality from the controller,
        you can swap out the dummy communicator for another one.
        """
        ...
    
    def SingleMethodExecute(self):
        """
        V.SingleMethodExecute()
        C++: void SingleMethodExecute() override;
        
        Directly calls the single method.
        """
        ...
    
    def __delattr__(self, *args, **kwargs):
        """ Implement delattr(self, name). """
        ...
    
    def __getattribute__(self, *args, **kwargs):
        """ Return getattr(self, name). """
        ...
    
    def __init__(self, *args, **kwargs) -> None:
        ...
    
    @staticmethod
    def __new__(*args, **kwargs):
        """ Create and return a new object.  See help(type) for accurate signature. """
        ...
    
    def __repr__(self, *args, **kwargs):
        """ Return repr(self). """
        ...
    
    def __setattr__(self, *args, **kwargs):
        """ Implement setattr(self, name, value). """
        ...
    
    def __str__(self, *args, **kwargs) -> str:
        """ Return str(self). """
        ...
    
    __this__ = ...
    __dict__ = ...
    __vtkname__ = ...


class vtkFieldDataSerializer(__vtkmodules_vtkCommonCore.vtkObject):
    """
    vtkFieldDataSerializer -  A concrete instance of vtkObject which
    provides functionality for
     serializing and de-serializing field data, primarily used for the
    purpose
     of preparing the data for transfer over MPI or other communication
     mechanism.
    
    Superclass: vtkObject
    
    @sa
    vtkFieldData vtkPointData vtkCellData vtkMultiProcessStream
    """
    def Deserialize(self, vtkMultiProcessStream, vtkFieldData):
        """
        V.Deserialize(vtkMultiProcessStream, vtkFieldData)
        C++: static void Deserialize(vtkMultiProcessStream &bytestream,
            vtkFieldData *fieldData)
        
        Deserializes the field data from a bytestream.
        """
        ...
    
    def DeserializeMetaData(self, vtkMultiProcessStream, vtkStringArray, vtkIntArray, vtkIntArray_1):
        """
        V.DeserializeMetaData(vtkMultiProcessStream, vtkStringArray,
            vtkIntArray, vtkIntArray)
        C++: static void DeserializeMetaData(
            vtkMultiProcessStream &bytestream, vtkStringArray *names,
            vtkIntArray *datatypes, vtkIntArray *dimensions)
        
        Given the serialized field metadata in a bytestream, this method
        extracts the name, datatype and dimensions of each array. The
        metadata is deserialized on user-supplied, pre-allocated data
        structures. (1) names -- an array of strings wherein, each
        element, names[i], corresponds to the name of array i. (2)
        datatypes -- an array of ints where each element corresponds to
        the actual primitive type of each array, e.g.,VTK_DOUBLE,VTK_INT,
        etc. (3) dimensions -- a 2-component array of integers where the
        first component corresponds to the number of tuples of and the
        second component corresponds to the number components of array i.
        """
        ...
    
    def DeSerializeToSubExtent(self, p_int=..., p_int=..., p_int=..., p_int=..., p_int=..., p_int=..., *args, **kwargs):
        """
        V.DeSerializeToSubExtent([int, int, int, int, int, int], [int,
            int, int, int, int, int], vtkFieldData, vtkMultiProcessStream)
        C++: static void DeSerializeToSubExtent(int subext[6],
            int gridExtent[6], vtkFieldData *fieldData,
            vtkMultiProcessStream &bytestream)
        
        Deserializes the field data from a bytestream to a the given
        sub-extent. The field data can be either cell-centered or
        node-centered depending on what subext and gridExtent actually
        represent.
        """
        ...
    
    def GetNumberOfGenerationsFromBase(self, string):
        """
        V.GetNumberOfGenerationsFromBase(string) -> int
        C++: vtkIdType GetNumberOfGenerationsFromBase(const char *type)
            override;
        
        Given a the name of a base class of this class type, return the
        distance of inheritance between this class type and the named
        class (how many generations of inheritance are there between this
        class and the named class). If the named class is not in this
        class's inheritance tree, return a negative value. Valid
        responses will always be nonnegative. This method works in
        combination with vtkTypeMacro found in vtkSetGet.h.
        """
        ...
    
    def GetNumberOfGenerationsFromBaseType(self, string):
        """
        V.GetNumberOfGenerationsFromBaseType(string) -> int
        C++: static vtkIdType GetNumberOfGenerationsFromBaseType(
            const char *type)
        
        Given a the name of a base class of this class type, return the
        distance of inheritance between this class type and the named
        class (how many generations of inheritance are there between this
        class and the named class). If the named class is not in this
        class's inheritance tree, return a negative value. Valid
        responses will always be nonnegative. This method works in
        combination with vtkTypeMacro found in vtkSetGet.h.
        """
        ...
    
    def IsA(self, string):
        """
        V.IsA(string) -> int
        C++: vtkTypeBool IsA(const char *type) override;
        
        Return 1 if this class is the same type of (or a subclass of) the
        named class. Returns 0 otherwise. This method works in
        combination with vtkTypeMacro found in vtkSetGet.h.
        """
        ...
    
    def IsTypeOf(self, string):
        """
        V.IsTypeOf(string) -> int
        C++: static vtkTypeBool IsTypeOf(const char *type)
        
        Return 1 if this class type is the same type of (or a subclass
        of) the named class. Returns 0 otherwise. This method works in
        combination with vtkTypeMacro found in vtkSetGet.h.
        """
        ...
    
    def NewInstance(self):
        """
        V.NewInstance() -> vtkFieldDataSerializer
        C++: vtkFieldDataSerializer *NewInstance()
        """
        ...
    
    def SafeDownCast(self, vtkObjectBase):
        """
        V.SafeDownCast(vtkObjectBase) -> vtkFieldDataSerializer
        C++: static vtkFieldDataSerializer *SafeDownCast(vtkObjectBase *o)
        """
        ...
    
    def Serialize(self, vtkFieldData, vtkMultiProcessStream):
        """
        V.Serialize(vtkFieldData, vtkMultiProcessStream)
        C++: static void Serialize(vtkFieldData *fieldData,
            vtkMultiProcessStream &bytestream)
        
        Serializes the given field data (all the field data) into a
        bytestream.
        """
        ...
    
    def SerializeMetaData(self, vtkFieldData, vtkMultiProcessStream):
        """
        V.SerializeMetaData(vtkFieldData, vtkMultiProcessStream)
        C++: static void SerializeMetaData(vtkFieldData *fieldData,
            vtkMultiProcessStream &bytestream)
        
        Serializes the metadata of the given field data instance, i.e.,
        the number of arrays, the name of each array and their
        dimensions.
        """
        ...
    
    def SerializeSubExtent(self, p_int=..., p_int=..., p_int=..., p_int=..., p_int=..., p_int=..., *args, **kwargs):
        """
        V.SerializeSubExtent([int, int, int, int, int, int], [int, int,
            int, int, int, int], vtkFieldData, vtkMultiProcessStream)
        C++: static void SerializeSubExtent(int subext[6],
            int gridExtent[6], vtkFieldData *fieldData,
            vtkMultiProcessStream &bytestream)
        
        Serializes the given sub-extent of field data of a structured
        grid in a byte-stream. The field data can be either cell-centered
        or node-centered depending on what subext and gridExtent actually
        represents.
        """
        ...
    
    def SerializeTuples(self, vtkIdList, vtkFieldData, vtkMultiProcessStream):
        """
        V.SerializeTuples(vtkIdList, vtkFieldData, vtkMultiProcessStream)
        C++: static void SerializeTuples(vtkIdList *tupleIds,
            vtkFieldData *fieldData, vtkMultiProcessStream &bytestream)
        
        Serializes the selected tuples from the field data in a
        byte-stream.
        """
        ...
    
    def __delattr__(self, *args, **kwargs):
        """ Implement delattr(self, name). """
        ...
    
    def __getattribute__(self, *args, **kwargs):
        """ Return getattr(self, name). """
        ...
    
    def __init__(self, *args, **kwargs) -> None:
        ...
    
    @staticmethod
    def __new__(*args, **kwargs):
        """ Create and return a new object.  See help(type) for accurate signature. """
        ...
    
    def __repr__(self, *args, **kwargs):
        """ Return repr(self). """
        ...
    
    def __setattr__(self, *args, **kwargs):
        """ Implement setattr(self, name, value). """
        ...
    
    def __str__(self, *args, **kwargs) -> str:
        """ Return str(self). """
        ...
    
    __this__ = ...
    __dict__ = ...
    __vtkname__ = ...


class vtkMultiProcessStream(object):
    """
    vtkMultiProcessStream - stream used to pass data across processes
    using vtkMultiProcessController.
    
    vtkMultiProcessStream is used to pass data across processes. Using
    vtkMultiProcessStream it is possible to send data whose length is not
    known at the receiving end.
    
    @warning
    Note, stream operators cannot be combined with the Push/Pop array
    operators. For example, if you push an array to the stream,
    
    vtkMultiProcessStream()
    vtkMultiProcessStream(const vtkMultiProcessStream &)
    """
    def Empty(self):
        """
        V.Empty() -> bool
        C++: bool Empty()
        
        Returns true iff the stream is empty.
        """
        ...
    
    def GetRawData(self, Stvector_IhE):
        """
        V.GetRawData(Stvector_IhE)
        C++: void GetRawData(std::vector<unsigned char> &data)
        V.GetRawData([int, ...], int)
        C++: void GetRawData(unsigned char *&data, unsigned int &size)
        V.GetRawData() -> Stvector_IhE
        C++: std::vector<unsigned char> GetRawData()
        
        Serialization methods used to save/restore the stream to/from raw
        data. Note: The 1st byte of the raw data buffer consists of the
        endian type.
        """
        ...
    
    def Pop(self, *float, **kwargs):
        """
        V.Pop([float, ...], int)
        C++: void Pop(double *&array, unsigned int &size)
        V.Pop([int, ...], int)
        C++: void Pop(int *&array, unsigned int &size)
        V.Pop([int, ...], int)
        C++: void Pop(vtkTypeInt64 *&array, unsigned int &size)
        
        Remove-array-to-stream methods. Removes from the head of the
        stream. Note: If the input array is nullptr, the array will be
        allocated internally and the calling application is responsible
        for properly de-allocating it. If the input array is not nullptr,
        it is expected to match the size of the data internally, and this
        method would just fill in the data.
        """
        ...
    
    def Push(self, *float, **kwargs):
        """
        V.Push([float, ...], int)
        C++: void Push(double array[], unsigned int size)
        V.Push([int, ...], int)
        C++: void Push(int array[], unsigned int size)
        V.Push(string, int)
        C++: void Push(char array[], unsigned int size)
        V.Push([int, ...], int)
        C++: void Push(vtkTypeInt64 array[], unsigned int size)
        
        Add-array-to-stream methods. Adds to the end of the stream
        """
        ...
    
    def RawSize(self):
        """
        V.RawSize() -> int
        C++: int RawSize()
        
        Returns the size of the raw data returned by GetRawData. This
        includes 1 byte to store the endian type.
        """
        ...
    
    def Reset(self):
        """
        V.Reset()
        C++: void Reset()
        
        Clears everything in the stream.
        """
        ...
    
    def SetRawData(self, Stvector_IhE):
        """
        V.SetRawData(Stvector_IhE)
        C++: void SetRawData(const std::vector<unsigned char> &data)
        V.SetRawData((int, ...), int)
        C++: void SetRawData(const unsigned char *, unsigned int size)
        
        Serialization methods used to save/restore the stream to/from raw
        data. Note: The 1st byte of the raw data buffer consists of the
        endian type.
        """
        ...
    
    def Size(self):
        """
        V.Size() -> int
        C++: int Size()
        
        Returns the size of the stream.
        """
        ...
    
    def __getattribute__(self, *args, **kwargs):
        """ Return getattr(self, name). """
        ...
    
    def __hash__(self, *args, **kwargs) -> int:
        """ Return hash(self). """
        ...
    
    def __init__(self) -> None:
        ...
    
    @staticmethod
    def __new__(*args, **kwargs):
        """ Create and return a new object.  See help(type) for accurate signature. """
        ...
    
    def __repr__(self, *args, **kwargs):
        """ Return repr(self). """
        ...
    


class vtkPDirectory(__vtkmodules_vtkCommonCore.vtkObject):
    """
    vtkPDirectory - vtkPDirectory provides a portable way of finding the
    names of the files in a system directory where process 0 finds the
    information and broadcasts it to other processes.
    
    Superclass: vtkObject
    
    It tries to replicate the API for both Directory and vtkDirectory
    though there are slight mismatches between the two. This is a
    blocking collective operation.
    """
    def Clear(self):
        """
        V.Clear()
        C++: void Clear()
        
        Clear the internal structure. Used internally at beginning of
        Load(...) to clear the cache.
        """
        ...
    
    def FileIsDirectory(self, string):
        """
        V.FileIsDirectory(string) -> int
        C++: int FileIsDirectory(const char *name)
        
        Return true if the file is a directory.  If the file is not an
        absolute path, it is assumed to be relative to the opened
        directory. If no directory has been opened, it is assumed to be
        relative to the current working directory.
        """
        ...
    
    def GetFile(self, p_int):
        """
        V.GetFile(int) -> string
        C++: const char *GetFile(vtkIdType index)
        
        Return the file at the given index, the indexing is 0 based
        """
        ...
    
    def GetFiles(self):
        """
        V.GetFiles() -> vtkStringArray
        C++: virtual vtkStringArray *GetFiles()
        
        Get an array that contains all the file names.
        """
        ...
    
    def GetNumberOfFiles(self):
        """
        V.GetNumberOfFiles() -> int
        C++: vtkIdType GetNumberOfFiles()
        
        Return the number of files in the current directory.
        """
        ...
    
    def GetNumberOfGenerationsFromBase(self, string):
        """
        V.GetNumberOfGenerationsFromBase(string) -> int
        C++: vtkIdType GetNumberOfGenerationsFromBase(const char *type)
            override;
        
        Given a the name of a base class of this class type, return the
        distance of inheritance between this class type and the named
        class (how many generations of inheritance are there between this
        class and the named class). If the named class is not in this
        class's inheritance tree, return a negative value. Valid
        responses will always be nonnegative. This method works in
        combination with vtkTypeMacro found in vtkSetGet.h.
        """
        ...
    
    def GetNumberOfGenerationsFromBaseType(self, string):
        """
        V.GetNumberOfGenerationsFromBaseType(string) -> int
        C++: static vtkIdType GetNumberOfGenerationsFromBaseType(
            const char *type)
        
        Given a the name of a base class of this class type, return the
        distance of inheritance between this class type and the named
        class (how many generations of inheritance are there between this
        class and the named class). If the named class is not in this
        class's inheritance tree, return a negative value. Valid
        responses will always be nonnegative. This method works in
        combination with vtkTypeMacro found in vtkSetGet.h.
        """
        ...
    
    def GetPath(self):
        """
        V.GetPath() -> string
        C++: const char *GetPath()
        
        Return the path to Open'ed directory
        """
        ...
    
    def IsA(self, string):
        """
        V.IsA(string) -> int
        C++: vtkTypeBool IsA(const char *type) override;
        
        Return 1 if this class is the same type of (or a subclass of) the
        named class. Returns 0 otherwise. This method works in
        combination with vtkTypeMacro found in vtkSetGet.h.
        """
        ...
    
    def IsTypeOf(self, string):
        """
        V.IsTypeOf(string) -> int
        C++: static vtkTypeBool IsTypeOf(const char *type)
        
        Return 1 if this class type is the same type of (or a subclass
        of) the named class. Returns 0 otherwise. This method works in
        combination with vtkTypeMacro found in vtkSetGet.h.
        """
        ...
    
    def Load(self, string):
        """
        V.Load(string) -> bool
        C++: bool Load(const std::string &)
        
        Open/Load the specified directory and load the names of the files
        in that directory. false/0 is returned if the directory can not
        be opened, true/1 if it is opened. The reason that there are two
        versions of this is that Directory uses Load() and vtkDirectory
        uses Open() for this functionality.
        """
        ...
    
    def NewInstance(self):
        """
        V.NewInstance() -> vtkPDirectory
        C++: vtkPDirectory *NewInstance()
        """
        ...
    
    def Open(self, string):
        """
        V.Open(string) -> int
        C++: int Open(const char *dir)
        
        Open/Load the specified directory and load the names of the files
        in that directory. false/0 is returned if the directory can not
        be opened, true/1 if it is opened. The reason that there are two
        versions of this is that Directory uses Load() and vtkDirectory
        uses Open() for this functionality.
        """
        ...
    
    def SafeDownCast(self, vtkObjectBase):
        """
        V.SafeDownCast(vtkObjectBase) -> vtkPDirectory
        C++: static vtkPDirectory *SafeDownCast(vtkObjectBase *o)
        """
        ...
    
    def __delattr__(self, *args, **kwargs):
        """ Implement delattr(self, name). """
        ...
    
    def __getattribute__(self, *args, **kwargs):
        """ Return getattr(self, name). """
        ...
    
    def __init__(self, *args, **kwargs) -> None:
        ...
    
    @staticmethod
    def __new__(*args, **kwargs):
        """ Create and return a new object.  See help(type) for accurate signature. """
        ...
    
    def __repr__(self, *args, **kwargs):
        """ Return repr(self). """
        ...
    
    def __setattr__(self, *args, **kwargs):
        """ Implement setattr(self, name, value). """
        ...
    
    def __str__(self, *args, **kwargs) -> str:
        """ Return str(self). """
        ...
    
    __this__ = ...
    __dict__ = ...
    __vtkname__ = ...


class vtkProcess(__vtkmodules_vtkCommonCore.vtkObject):
    """
    vtkProcess - a process that can be launched by a
    vtkMultiProcessController
    
    Superclass: vtkObject
    
    vtkProcess is an abstract class representing a process that can be
    launched by a vtkMultiProcessController. Concrete classes just have
    to implement Execute() method and make sure it set the proper value
    in ReturnValue.
    
    @par Example:
     class MyProcess: public vtkProcess
     ...
     vtkMultiProcessController *c;
     MyProcess *p=new MyProcess::New();
     p->SetArgs(argc,argv); // some parameters specific to the process
     p->SetX(10.0); // ...
     c->SetSingleProcess(p);
     c->SingleMethodExecute();
     int returnValue=p->GetReturnValue();
    
    @sa
    vtkMultiProcessController
    """
    def Execute(self):
        """
        V.Execute()
        C++: virtual void Execute()
        
        Entry point of the process. This method is expected to update
        ReturnValue.
        """
        ...
    
    def GetController(self):
        """
        V.GetController() -> vtkMultiProcessController
        C++: vtkMultiProcessController *GetController()
        
        Give access to the controller that launched the process. Initial
        value is nullptr.
        """
        ...
    
    def GetNumberOfGenerationsFromBase(self, string):
        """
        V.GetNumberOfGenerationsFromBase(string) -> int
        C++: vtkIdType GetNumberOfGenerationsFromBase(const char *type)
            override;
        
        Given a the name of a base class of this class type, return the
        distance of inheritance between this class type and the named
        class (how many generations of inheritance are there between this
        class and the named class). If the named class is not in this
        class's inheritance tree, return a negative value. Valid
        responses will always be nonnegative. This method works in
        combination with vtkTypeMacro found in vtkSetGet.h.
        """
        ...
    
    def GetNumberOfGenerationsFromBaseType(self, string):
        """
        V.GetNumberOfGenerationsFromBaseType(string) -> int
        C++: static vtkIdType GetNumberOfGenerationsFromBaseType(
            const char *type)
        
        Given a the name of a base class of this class type, return the
        distance of inheritance between this class type and the named
        class (how many generations of inheritance are there between this
        class and the named class). If the named class is not in this
        class's inheritance tree, return a negative value. Valid
        responses will always be nonnegative. This method works in
        combination with vtkTypeMacro found in vtkSetGet.h.
        """
        ...
    
    def GetReturnValue(self):
        """
        V.GetReturnValue() -> int
        C++: int GetReturnValue()
        
        Value set at the end of a call to Execute.
        """
        ...
    
    def IsA(self, string):
        """
        V.IsA(string) -> int
        C++: vtkTypeBool IsA(const char *type) override;
        
        Return 1 if this class is the same type of (or a subclass of) the
        named class. Returns 0 otherwise. This method works in
        combination with vtkTypeMacro found in vtkSetGet.h.
        """
        ...
    
    def IsTypeOf(self, string):
        """
        V.IsTypeOf(string) -> int
        C++: static vtkTypeBool IsTypeOf(const char *type)
        
        Return 1 if this class type is the same type of (or a subclass
        of) the named class. Returns 0 otherwise. This method works in
        combination with vtkTypeMacro found in vtkSetGet.h.
        """
        ...
    
    def NewInstance(self):
        """
        V.NewInstance() -> vtkProcess
        C++: vtkProcess *NewInstance()
        """
        ...
    
    def SafeDownCast(self, vtkObjectBase):
        """
        V.SafeDownCast(vtkObjectBase) -> vtkProcess
        C++: static vtkProcess *SafeDownCast(vtkObjectBase *o)
        """
        ...
    
    def SetController(self, vtkMultiProcessController):
        """
        V.SetController(vtkMultiProcessController)
        C++: void SetController(vtkMultiProcessController *aController)
        
        This method should not be called directly but set by the
        controller itself.
        """
        ...
    
    def __delattr__(self, *args, **kwargs):
        """ Implement delattr(self, name). """
        ...
    
    def __getattribute__(self, *args, **kwargs):
        """ Return getattr(self, name). """
        ...
    
    def __init__(self, *args, **kwargs) -> None:
        ...
    
    @staticmethod
    def __new__(*args, **kwargs):
        """ Create and return a new object.  See help(type) for accurate signature. """
        ...
    
    def __repr__(self, *args, **kwargs):
        """ Return repr(self). """
        ...
    
    def __setattr__(self, *args, **kwargs):
        """ Implement setattr(self, name, value). """
        ...
    
    def __str__(self, *args, **kwargs) -> str:
        """ Return str(self). """
        ...
    
    __this__ = ...
    __dict__ = ...
    __vtkname__ = ...


class vtkProcessGroup(__vtkmodules_vtkCommonCore.vtkObject):
    """
    vtkProcessGroup - A subgroup of processes from a communicator.
    
    Superclass: vtkObject
    
    This class is used for creating groups of processes.  A
    vtkProcessGroup is initialized by passing the controller or
    communicator on which the group is based off of.  You can then use
    the group to subset and reorder the processes.  Eventually, you can
    pass the group object to the CreateSubController method of
    vtkMultiProcessController to create a controller for the defined
    group of processes.  You must use the same controller (or attached
    communicator) from which this group was initialized with.
    
    @sa
    vtkMultiProcessController, vtkCommunicator
    
    @par Thanks: This class was originally written by Kenneth Moreland
    (kmorel@sandia.gov) from Sandia National Laboratories.
    """
    def AddProcessId(self, p_int):
        """
        V.AddProcessId(int) -> int
        C++: int AddProcessId(int processId)
        
        Add a process id to the end of the group (if it is not already in
        the group).  Returns the location where the id was stored.
        """
        ...
    
    def Copy(self, vtkProcessGroup):
        """
        V.Copy(vtkProcessGroup)
        C++: void Copy(vtkProcessGroup *group)
        
        Copies the given group's communicator and process ids.
        """
        ...
    
    def FindProcessId(self, p_int):
        """
        V.FindProcessId(int) -> int
        C++: int FindProcessId(int processId)
        
        Given a process id in the communicator, this method returns its
        location in the group or -1 if it is not in the group.  For
        example, if this group contains {6, 2, 8, 1}, then
        FindProcessId(2) will return 1 and FindProcessId(3) will return
        -1.
        """
        ...
    
    def GetCommunicator(self):
        """
        V.GetCommunicator() -> vtkCommunicator
        C++: virtual vtkCommunicator *GetCommunicator()
        
        Get the communicator on which this group is based on.
        """
        ...
    
    def GetLocalProcessId(self):
        """
        V.GetLocalProcessId() -> int
        C++: int GetLocalProcessId()
        
        Get the process id for the local process (as defined by the
        group's communicator).  Returns -1 if the local process is not in
        the group.
        """
        ...
    
    def GetNumberOfGenerationsFromBase(self, string):
        """
        V.GetNumberOfGenerationsFromBase(string) -> int
        C++: vtkIdType GetNumberOfGenerationsFromBase(const char *type)
            override;
        
        Given a the name of a base class of this class type, return the
        distance of inheritance between this class type and the named
        class (how many generations of inheritance are there between this
        class and the named class). If the named class is not in this
        class's inheritance tree, return a negative value. Valid
        responses will always be nonnegative. This method works in
        combination with vtkTypeMacro found in vtkSetGet.h.
        """
        ...
    
    def GetNumberOfGenerationsFromBaseType(self, string):
        """
        V.GetNumberOfGenerationsFromBaseType(string) -> int
        C++: static vtkIdType GetNumberOfGenerationsFromBaseType(
            const char *type)
        
        Given a the name of a base class of this class type, return the
        distance of inheritance between this class type and the named
        class (how many generations of inheritance are there between this
        class and the named class). If the named class is not in this
        class's inheritance tree, return a negative value. Valid
        responses will always be nonnegative. This method works in
        combination with vtkTypeMacro found in vtkSetGet.h.
        """
        ...
    
    def GetNumberOfProcessIds(self):
        """
        V.GetNumberOfProcessIds() -> int
        C++: virtual int GetNumberOfProcessIds()
        
        Returns the size of this group (the number of processes defined
        in it).
        """
        ...
    
    def GetProcessId(self, p_int):
        """
        V.GetProcessId(int) -> int
        C++: int GetProcessId(int pos)
        
        Given a position in the group, returns the id of the process in
        the communicator this group is based on.  For example, if this
        group contains {6, 2, 8, 1}, then GetProcessId(2) will return 8
        and GetProcessId(3) will return 1.
        """
        ...
    
    def Initialize(self, vtkMultiProcessController):
        """
        V.Initialize(vtkMultiProcessController)
        C++: void Initialize(vtkMultiProcessController *controller)
        V.Initialize(vtkCommunicator)
        C++: void Initialize(vtkCommunicator *communicator)
        
        Initialize the group to the given controller or communicator. 
        The group will be set to contain all of the processes in the
        controller/communicator in the same order.
        """
        ...
    
    def IsA(self, string):
        """
        V.IsA(string) -> int
        C++: vtkTypeBool IsA(const char *type) override;
        
        Return 1 if this class is the same type of (or a subclass of) the
        named class. Returns 0 otherwise. This method works in
        combination with vtkTypeMacro found in vtkSetGet.h.
        """
        ...
    
    def IsTypeOf(self, string):
        """
        V.IsTypeOf(string) -> int
        C++: static vtkTypeBool IsTypeOf(const char *type)
        
        Return 1 if this class type is the same type of (or a subclass
        of) the named class. Returns 0 otherwise. This method works in
        combination with vtkTypeMacro found in vtkSetGet.h.
        """
        ...
    
    def NewInstance(self):
        """
        V.NewInstance() -> vtkProcessGroup
        C++: vtkProcessGroup *NewInstance()
        """
        ...
    
    def RemoveAllProcessIds(self):
        """
        V.RemoveAllProcessIds()
        C++: void RemoveAllProcessIds()
        
        Removes all the processes ids from the group, leaving the group
        empty.
        """
        ...
    
    def RemoveProcessId(self, p_int):
        """
        V.RemoveProcessId(int) -> int
        C++: int RemoveProcessId(int processId)
        
        Remove the given process id from the group (assuming it is in the
        group). All ids to the "right" of the removed id are shifted
        over.  Returns 1 if the process id was removed, 0 if the process
        id was not in the group in the first place.
        """
        ...
    
    def SafeDownCast(self, vtkObjectBase):
        """
        V.SafeDownCast(vtkObjectBase) -> vtkProcessGroup
        C++: static vtkProcessGroup *SafeDownCast(vtkObjectBase *o)
        """
        ...
    
    def SetCommunicator(self, vtkCommunicator):
        """
        V.SetCommunicator(vtkCommunicator)
        C++: void SetCommunicator(vtkCommunicator *communicator)
        
        Set the communicator.  This has the same effect as Initialize
        except that the contents of the group will not be modified
        (although they may be truncated if the new communicator is
        smaller than the current group). Note that this can lead to an
        invalid group if there are values in the group that are not valid
        in the new communicator.
        """
        ...
    
    def __delattr__(self, *args, **kwargs):
        """ Implement delattr(self, name). """
        ...
    
    def __getattribute__(self, *args, **kwargs):
        """ Return getattr(self, name). """
        ...
    
    def __init__(self, *args, **kwargs) -> None:
        ...
    
    @staticmethod
    def __new__(*args, **kwargs):
        """ Create and return a new object.  See help(type) for accurate signature. """
        ...
    
    def __repr__(self, *args, **kwargs):
        """ Return repr(self). """
        ...
    
    def __setattr__(self, *args, **kwargs):
        """ Implement setattr(self, name, value). """
        ...
    
    def __str__(self, *args, **kwargs) -> str:
        """ Return str(self). """
        ...
    
    __this__ = ...
    __dict__ = ...
    __vtkname__ = ...


class vtkPSystemTools(__vtkmodules_vtkCommonCore.vtkObject):
    """
    vtkPSystemTools - System tools for file system introspection
    
    Superclass: vtkObject
    
    A class with only static methods for doing parallel file system
    introspection. It limits doing file stats on process 0 and
    broadcasting the results to other processes. It is built on VTK's
    SystemTools class and uses the global controller for communication.
    It uses blocking collective communication operations.
    """
    def BroadcastString(self, string, p_int):
        """
        V.BroadcastString(string, int)
        C++: static void BroadcastString(std::string &, int proc)
        
        Given a string on process proc, broadcast that string to all of
        the other processes. This method does not have a correspondence
        to anything in SystemTools.
        """
        ...
    
    def CollapseFullPath(self, string):
        """
        V.CollapseFullPath(string) -> string
        C++: static std::string CollapseFullPath(
            const std::string &in_relative)
        V.CollapseFullPath(string, string) -> string
        C++: static std::string CollapseFullPath(
            const std::string &in_relative, const char *in_base)
        
        Given a path to a file or directory, convert it to a full path.
        This collapses away relative paths relative to the cwd argument
        (which defaults to the current working directory).  The full path
        is returned.
        """
        ...
    
    def FileExists(self, string, bool):
        """
        V.FileExists(string, bool) -> bool
        C++: static bool FileExists(const std::string &filename,
            bool isFile)
        V.FileExists(string) -> bool
        C++: static bool FileExists(const std::string &filename)
        
        Return true if a file exists in the current directory. If isFile
        = true, then make sure the file is a file and not a directory. 
        If isFile = false, then return true if it is a file or a
        directory.  Note that the file will also be checked for read
        access.  (Currently, this check for read access is only done on
        POSIX systems.)
        """
        ...
    
    def FileIsDirectory(self, string):
        """
        V.FileIsDirectory(string) -> bool
        C++: static bool FileIsDirectory(const std::string &name)
        
        Return true if the file is a directory
        """
        ...
    
    def FindProgramPath(self, string, string_1, string_2, string_3, string_4, string_5):
        """
        V.FindProgramPath(string, string, string, string, string, string)
            -> bool
        C++: static bool FindProgramPath(const char *argv0,
            std::string &pathOut, std::string &errorMsg,
            const char *exeName=nullptr, const char *buildDir=nullptr,
            const char *installPrefix=nullptr)
        
        Given argv[0] for a unix program find the full path to a running
        executable.  argv0 can be null for windows WinMain programs in
        this case GetModuleFileName will be used to find the path to the
        running executable.  If argv0 is not a full path, then this will
        try to find the full path.  If the path is not found false is
        returned, if found true is returned.  An error message of the
        attempted paths is stored in errorMsg. exeName is the name of the
        executable. buildDir is a possibly null path to the build
        directory. installPrefix is a possibly null pointer to the
        install directory.
        """
        ...
    
    def GetCurrentWorkingDirectory(self, bool):
        """
        V.GetCurrentWorkingDirectory(bool) -> string
        C++: static std::string GetCurrentWorkingDirectory(
            bool collapse=true)
        
        Get current working directory CWD
        """
        ...
    
    def GetNumberOfGenerationsFromBase(self, string):
        """
        V.GetNumberOfGenerationsFromBase(string) -> int
        C++: vtkIdType GetNumberOfGenerationsFromBase(const char *type)
            override;
        
        Given a the name of a base class of this class type, return the
        distance of inheritance between this class type and the named
        class (how many generations of inheritance are there between this
        class and the named class). If the named class is not in this
        class's inheritance tree, return a negative value. Valid
        responses will always be nonnegative. This method works in
        combination with vtkTypeMacro found in vtkSetGet.h.
        """
        ...
    
    def GetNumberOfGenerationsFromBaseType(self, string):
        """
        V.GetNumberOfGenerationsFromBaseType(string) -> int
        C++: static vtkIdType GetNumberOfGenerationsFromBaseType(
            const char *type)
        
        Given a the name of a base class of this class type, return the
        distance of inheritance between this class type and the named
        class (how many generations of inheritance are there between this
        class and the named class). If the named class is not in this
        class's inheritance tree, return a negative value. Valid
        responses will always be nonnegative. This method works in
        combination with vtkTypeMacro found in vtkSetGet.h.
        """
        ...
    
    def GetProgramPath(self, string):
        """
        V.GetProgramPath(string) -> string
        C++: static std::string GetProgramPath(const std::string &)
        
        Given the path to a program executable, get the directory part of
        the path with the file stripped off.  If there is no directory
        part, the empty string is returned.
        """
        ...
    
    def IsA(self, string):
        """
        V.IsA(string) -> int
        C++: vtkTypeBool IsA(const char *type) override;
        
        Return 1 if this class is the same type of (or a subclass of) the
        named class. Returns 0 otherwise. This method works in
        combination with vtkTypeMacro found in vtkSetGet.h.
        """
        ...
    
    def IsTypeOf(self, string):
        """
        V.IsTypeOf(string) -> int
        C++: static vtkTypeBool IsTypeOf(const char *type)
        
        Return 1 if this class type is the same type of (or a subclass
        of) the named class. Returns 0 otherwise. This method works in
        combination with vtkTypeMacro found in vtkSetGet.h.
        """
        ...
    
    def NewInstance(self):
        """
        V.NewInstance() -> vtkPSystemTools
        C++: vtkPSystemTools *NewInstance()
        """
        ...
    
    def SafeDownCast(self, vtkObjectBase):
        """
        V.SafeDownCast(vtkObjectBase) -> vtkPSystemTools
        C++: static vtkPSystemTools *SafeDownCast(vtkObjectBase *o)
        """
        ...
    
    def __delattr__(self, *args, **kwargs):
        """ Implement delattr(self, name). """
        ...
    
    def __getattribute__(self, *args, **kwargs):
        """ Return getattr(self, name). """
        ...
    
    def __init__(self, *args, **kwargs) -> None:
        ...
    
    @staticmethod
    def __new__(*args, **kwargs):
        """ Create and return a new object.  See help(type) for accurate signature. """
        ...
    
    def __repr__(self, *args, **kwargs):
        """ Return repr(self). """
        ...
    
    def __setattr__(self, *args, **kwargs):
        """ Implement setattr(self, name, value). """
        ...
    
    def __str__(self, *args, **kwargs) -> str:
        """ Return str(self). """
        ...
    
    __this__ = ...
    __dict__ = ...
    __vtkname__ = ...


class vtkSocketCommunicator(vtkCommunicator):
    """
    vtkSocketCommunicator - Process communication using Sockets
    
    Superclass: vtkCommunicator
    
    This is a concrete implementation of vtkCommunicator which supports
    interprocess communication using BSD style sockets. It supports byte
    swapping for the communication of machines with different endianness.
    
    @warning
    Communication between 32 bit and 64 bit systems is not fully
    supported. If a type does not have the same length on both systems,
    this communicator can not be used to transfer data of that type.
    
    @sa
    vtkCommunicator vtkSocketController
    """
    def AllGatherVoidArray(self, void, void_1, p_int, p_int_1):
        """
        V.AllGatherVoidArray(void, void, int, int) -> int
        C++: int AllGatherVoidArray(const void *sendBuffer,
            void *recvBuffer, vtkIdType length, int type) override;
        
        This class foolishly breaks the conventions of the superclass, so
        the default implementations of these methods do not work.  These
        just give errors instead.
        """
        ...
    
    def AllGatherVVoidArray(self, void, void_1, p_int, *int, **kwargs):
        """
        V.AllGatherVVoidArray(void, void, int, [int, ...], [int, ...],
            int) -> int
        C++: int AllGatherVVoidArray(const void *sendBuffer,
            void *recvBuffer, vtkIdType sendLength,
            vtkIdType *recvLengths, vtkIdType *offsets, int type)
            override;
        
        This class foolishly breaks the conventions of the superclass, so
        the default implementations of these methods do not work.  These
        just give errors instead.
        """
        ...
    
    def AllReduceVoidArray(self, void, void_1, p_int, p_int_1, p_int_2):
        """
        V.AllReduceVoidArray(void, void, int, int, int) -> int
        C++: int AllReduceVoidArray(const void *sendBuffer,
            void *recvBuffer, vtkIdType length, int type, int operation)
            override;
        
        This class foolishly breaks the conventions of the superclass, so
        the default implementations of these methods do not work.  These
        just give errors instead.
        """
        ...
    
    def Barrier(self):
        """
        V.Barrier()
        C++: void Barrier() override;
        
        This class foolishly breaks the conventions of the superclass, so
        this overload fixes the method.
        """
        ...
    
    def BroadcastVoidArray(self, void, p_int, p_int_1, p_int_2):
        """
        V.BroadcastVoidArray(void, int, int, int) -> int
        C++: int BroadcastVoidArray(void *data, vtkIdType length,
            int type, int srcProcessId) override;
        
        This class foolishly breaks the conventions of the superclass, so
        the default implementations of these methods do not work.  These
        just give errors instead.
        """
        ...
    
    def BufferCurrentMessage(self):
        """
        V.BufferCurrentMessage()
        C++: void BufferCurrentMessage()
        
        This flag is cleared before vtkCommand::WrongTagEvent is fired
        when ever a message with mismatched tag is received. If the
        handler wants the message to be buffered for later use, it should
        set this flag to true. In which case the vtkSocketCommunicator
        will buffer the message and it will be automatically processed
        the next time one does a ReceiveTagged() with a matching tag.
        """
        ...
    
    def ClientSideHandshake(self):
        """
        V.ClientSideHandshake() -> int
        C++: int ClientSideHandshake()
        
        Performs ClientSide handshake. One should preferably use
        Handshake() which calls ServerSideHandshake or
        ClientSideHandshake as required.
        """
        ...
    
    def CloseConnection(self):
        """
        V.CloseConnection()
        C++: virtual void CloseConnection()
        
        Close a connection.
        """
        ...
    
    def ConnectTo(self, string, p_int):
        """
        V.ConnectTo(string, int) -> int
        C++: virtual int ConnectTo(const char *hostName, int port)
        
        Open a connection to host.
        """
        ...
    
    def GatherVoidArray(self, void, void_1, p_int, p_int_1, p_int_2):
        """
        V.GatherVoidArray(void, void, int, int, int) -> int
        C++: int GatherVoidArray(const void *sendBuffer, void *recvBuffer,
             vtkIdType length, int type, int destProcessId) override;
        
        This class foolishly breaks the conventions of the superclass, so
        the default implementations of these methods do not work.  These
        just give errors instead.
        """
        ...
    
    def GatherVVoidArray(self, void, void_1, p_int, *int, **kwargs):
        """
        V.GatherVVoidArray(void, void, int, [int, ...], [int, ...], int,
            int) -> int
        C++: int GatherVVoidArray(const void *sendBuffer,
            void *recvBuffer, vtkIdType sendLength,
            vtkIdType *recvLengths, vtkIdType *offsets, int type,
            int destProcessId) override;
        
        This class foolishly breaks the conventions of the superclass, so
        the default implementations of these methods do not work.  These
        just give errors instead.
        """
        ...
    
    def GetIsConnected(self):
        """
        V.GetIsConnected() -> int
        C++: int GetIsConnected()
        
        Is the communicator connected?.
        """
        ...
    
    def GetIsServer(self):
        """
        V.GetIsServer() -> int
        C++: virtual int GetIsServer()
        
        Returns true if this side of the socket is the server.  The
        result is invalid if the socket is not connected.
        """
        ...
    
    def GetNumberOfGenerationsFromBase(self, string):
        """
        V.GetNumberOfGenerationsFromBase(string) -> int
        C++: vtkIdType GetNumberOfGenerationsFromBase(const char *type)
            override;
        
        Given a the name of a base class of this class type, return the
        distance of inheritance between this class type and the named
        class (how many generations of inheritance are there between this
        class and the named class). If the named class is not in this
        class's inheritance tree, return a negative value. Valid
        responses will always be nonnegative. This method works in
        combination with vtkTypeMacro found in vtkSetGet.h.
        """
        ...
    
    def GetNumberOfGenerationsFromBaseType(self, string):
        """
        V.GetNumberOfGenerationsFromBaseType(string) -> int
        C++: static vtkIdType GetNumberOfGenerationsFromBaseType(
            const char *type)
        
        Given a the name of a base class of this class type, return the
        distance of inheritance between this class type and the named
        class (how many generations of inheritance are there between this
        class and the named class). If the named class is not in this
        class's inheritance tree, return a negative value. Valid
        responses will always be nonnegative. This method works in
        combination with vtkTypeMacro found in vtkSetGet.h.
        """
        ...
    
    def GetPerformHandshake(self):
        """
        V.GetPerformHandshake() -> int
        C++: virtual vtkTypeBool GetPerformHandshake()
        
        Set or get the PerformHandshake ivar. If it is on, the
        communicator will try to perform a handshake when connected. It
        is on by default.
        """
        ...
    
    def GetPerformHandshakeMaxValue(self):
        """
        V.GetPerformHandshakeMaxValue() -> int
        C++: virtual vtkTypeBool GetPerformHandshakeMaxValue()
        
        Set or get the PerformHandshake ivar. If it is on, the
        communicator will try to perform a handshake when connected. It
        is on by default.
        """
        ...
    
    def GetPerformHandshakeMinValue(self):
        """
        V.GetPerformHandshakeMinValue() -> int
        C++: virtual vtkTypeBool GetPerformHandshakeMinValue()
        
        Set or get the PerformHandshake ivar. If it is on, the
        communicator will try to perform a handshake when connected. It
        is on by default.
        """
        ...
    
    def GetReportErrors(self):
        """
        V.GetReportErrors() -> int
        C++: virtual int GetReportErrors()
        
        If ReportErrors if false, all vtkErrorMacros are suppressed.
        """
        ...
    
    def GetSocket(self):
        """
        V.GetSocket() -> vtkClientSocket
        C++: virtual vtkClientSocket *GetSocket()
        
        Get/Set the actual socket used for communication.
        """
        ...
    
    def GetSwapBytesInReceivedData(self):
        """
        V.GetSwapBytesInReceivedData() -> int
        C++: virtual int GetSwapBytesInReceivedData()
        
        Returns 1 if bytes must be swapped in received ints, floats, etc
        """
        ...
    
    def GetVersion(self):
        """
        V.GetVersion() -> int
        C++: static int GetVersion()
        
        Uniquely identifies the version of this class.  If the versions
        match, then the socket communicators should be compatible.
        """
        ...
    
    def Handshake(self):
        """
        V.Handshake() -> int
        C++: int Handshake()
        
        Performs handshake. This uses vtkClientSocket::ConnectingSide to
        decide whether to perform ServerSideHandshake or
        ClientSideHandshake.
        """
        ...
    
    def HasBufferredMessages(self):
        """
        V.HasBufferredMessages() -> bool
        C++: bool HasBufferredMessages()
        
        Returns true if there are any messages in the receive buffer.
        """
        ...
    
    def IsA(self, string):
        """
        V.IsA(string) -> int
        C++: vtkTypeBool IsA(const char *type) override;
        
        Return 1 if this class is the same type of (or a subclass of) the
        named class. Returns 0 otherwise. This method works in
        combination with vtkTypeMacro found in vtkSetGet.h.
        """
        ...
    
    def IsTypeOf(self, string):
        """
        V.IsTypeOf(string) -> int
        C++: static vtkTypeBool IsTypeOf(const char *type)
        
        Return 1 if this class type is the same type of (or a subclass
        of) the named class. Returns 0 otherwise. This method works in
        combination with vtkTypeMacro found in vtkSetGet.h.
        """
        ...
    
    def LogToFile(self, string):
        """
        V.LogToFile(string) -> int
        C++: virtual int LogToFile(const char *name)
        V.LogToFile(string, int) -> int
        C++: virtual int LogToFile(const char *name, int append)
        
        Log messages to the given file.  The file is truncated unless the
        second argument is non-zero (default is to truncate).  If the
        file name is empty or nullptr, logging is disabled.  Returns 0 if
        the file failed to open, and 1 otherwise.
        """
        ...
    
    def NewInstance(self):
        """
        V.NewInstance() -> vtkSocketCommunicator
        C++: vtkSocketCommunicator *NewInstance()
        """
        ...
    
    def PerformHandshakeOff(self):
        """
        V.PerformHandshakeOff()
        C++: virtual void PerformHandshakeOff()
        
        Set or get the PerformHandshake ivar. If it is on, the
        communicator will try to perform a handshake when connected. It
        is on by default.
        """
        ...
    
    def PerformHandshakeOn(self):
        """
        V.PerformHandshakeOn()
        C++: virtual void PerformHandshakeOn()
        
        Set or get the PerformHandshake ivar. If it is on, the
        communicator will try to perform a handshake when connected. It
        is on by default.
        """
        ...
    
    def ReceiveVoidArray(self, void, p_int, p_int_1, p_int_2, p_int_3):
        """
        V.ReceiveVoidArray(void, int, int, int, int) -> int
        C++: int ReceiveVoidArray(void *data, vtkIdType length, int type,
            int remoteHandle, int tag) override;
        
        Performs the actual communication.  You will usually use the
        convenience Send functions defined in the superclass.
        """
        ...
    
    def ReduceVoidArray(self, void, void_1, p_int, p_int_1, p_int_2, p_int_3):
        """
        V.ReduceVoidArray(void, void, int, int, int, int) -> int
        C++: int ReduceVoidArray(const void *sendBuffer, void *recvBuffer,
             vtkIdType length, int type, int operation, int destProcessId)
             override;
        
        This class foolishly breaks the conventions of the superclass, so
        the default implementations of these methods do not work.  These
        just give errors instead.
        """
        ...
    
    def SafeDownCast(self, vtkObjectBase):
        """
        V.SafeDownCast(vtkObjectBase) -> vtkSocketCommunicator
        C++: static vtkSocketCommunicator *SafeDownCast(vtkObjectBase *o)
        """
        ...
    
    def ScatterVoidArray(self, void, void_1, p_int, p_int_1, p_int_2):
        """
        V.ScatterVoidArray(void, void, int, int, int) -> int
        C++: int ScatterVoidArray(const void *sendBuffer,
            void *recvBuffer, vtkIdType length, int type,
            int srcProcessId) override;
        
        This class foolishly breaks the conventions of the superclass, so
        the default implementations of these methods do not work.  These
        just give errors instead.
        """
        ...
    
    def ScatterVVoidArray(self, void, void_1, *int, **kwargs):
        """
        V.ScatterVVoidArray(void, void, [int, ...], [int, ...], int, int,
            int) -> int
        C++: int ScatterVVoidArray(const void *sendBuffer,
            void *recvBuffer, vtkIdType *sendLengths, vtkIdType *offsets,
            vtkIdType recvLength, int type, int srcProcessId) override;
        
        This class foolishly breaks the conventions of the superclass, so
        the default implementations of these methods do not work.  These
        just give errors instead.
        """
        ...
    
    def SendVoidArray(self, void, p_int, p_int_1, p_int_2, p_int_3):
        """
        V.SendVoidArray(void, int, int, int, int) -> int
        C++: int SendVoidArray(const void *data, vtkIdType length,
            int type, int remoteHandle, int tag) override;
        
        Performs the actual communication.  You will usually use the
        convenience Send functions defined in the superclass.
        """
        ...
    
    def ServerSideHandshake(self):
        """
        V.ServerSideHandshake() -> int
        C++: int ServerSideHandshake()
        
        Performs ServerSide handshake. One should preferably use
        Handshake() which calls ServerSideHandshake or
        ClientSideHandshake as required.
        """
        ...
    
    def SetNumberOfProcesses(self, p_int):
        """
        V.SetNumberOfProcesses(int)
        C++: void SetNumberOfProcesses(int num) override;
        
        Set the number of processes you will be using.
        """
        ...
    
    def SetPerformHandshake(self, p_int):
        """
        V.SetPerformHandshake(int)
        C++: virtual void SetPerformHandshake(vtkTypeBool _arg)
        
        Set or get the PerformHandshake ivar. If it is on, the
        communicator will try to perform a handshake when connected. It
        is on by default.
        """
        ...
    
    def SetReportErrors(self, p_int):
        """
        V.SetReportErrors(int)
        C++: virtual void SetReportErrors(int _arg)
        
        If ReportErrors if false, all vtkErrorMacros are suppressed.
        """
        ...
    
    def SetSocket(self, vtkClientSocket):
        """
        V.SetSocket(vtkClientSocket)
        C++: void SetSocket(vtkClientSocket *)
        
        Get/Set the actual socket used for communication.
        """
        ...
    
    def WaitForConnection(self, p_int):
        """
        V.WaitForConnection(int) -> int
        C++: virtual int WaitForConnection(int port)
        V.WaitForConnection(vtkServerSocket, int) -> int
        C++: virtual int WaitForConnection(vtkServerSocket *socket,
            unsigned long msec=0)
        
        Wait for connection on a given port. These methods return 1 on
        success, 0 on error.
        """
        ...
    
    def __delattr__(self, *args, **kwargs):
        """ Implement delattr(self, name). """
        ...
    
    def __getattribute__(self, *args, **kwargs):
        """ Return getattr(self, name). """
        ...
    
    def __init__(self, *args, **kwargs) -> None:
        ...
    
    @staticmethod
    def __new__(*args, **kwargs):
        """ Create and return a new object.  See help(type) for accurate signature. """
        ...
    
    def __repr__(self, *args, **kwargs):
        """ Return repr(self). """
        ...
    
    def __setattr__(self, *args, **kwargs):
        """ Implement setattr(self, name, value). """
        ...
    
    def __str__(self, *args, **kwargs) -> str:
        """ Return str(self). """
        ...
    
    __this__ = ...
    __dict__ = ...
    __vtkname__ = ...


class vtkSocketController(vtkMultiProcessController):
    """
    vtkSocketController - Process communication using Sockets
    
    Superclass: vtkMultiProcessController
    
    This is a concrete implementation of vtkMultiProcessController. It
    supports one-to-one communication using sockets. Note that process 0
    will always correspond to self and process 1 to the remote process.
    This class is best used with ports.
    
    @bug Note that because process 0 will always correspond to self, this
    class breaks assumptions usually implied when using ad-hoc
    polymorphism.  That is, the vtkSocketController will behave
    differently than other subclasses of vtkMultiProcessController.  If
    you upcast vtkSocketController to vtkMultiProcessController and send
    it to a method that does not know that the object is actually a
    vtkSocketController, the object may not behave as intended.  For
    example, if that oblivious class chose to identify a "root" based on
    the local process id, then both sides of the controller will think
    they are the root (and that will probably lead to deadlock).  If you
    plan to upcast to vtkMultiProcessController, you should probably use
    the CreateCompliantController instead.
    
    @sa
    vtkMultiProcessController vtkSocketCommunicator vtkInputPort
    vtkOutputPort
    """
    def CloseConnection(self):
        """
        V.CloseConnection()
        C++: virtual void CloseConnection()
        
        Close a connection, forwarded to the communicator
        """
        ...
    
    def ConnectTo(self, string, p_int):
        """
        V.ConnectTo(string, int) -> int
        C++: virtual int ConnectTo(const char *hostName, int port)
        
        Open a connection to a give machine, forwarded to the
        communicator
        """
        ...
    
    def CreateCompliantController(self):
        """
        V.CreateCompliantController() -> vtkMultiProcessController
        C++: vtkMultiProcessController *CreateCompliantController()
        
        FOOLISH MORTALS!  Thou hast forsaken the sacred laws of ad-hoc
        polymorphism when thou broke a critical assumption of the
        superclass (namely, each process has thine own id).  The time
        frame to fix thy error has passed. Too much code has come to rely
        on this abhorrent behavior.  Instead, we offer this gift: a
        method for creating an equivalent communicator with correct
        process id semantics.  The calling code is responsible for
        deleting this controller.
        """
        ...
    
    def CreateOutputWindow(self):
        """
        V.CreateOutputWindow()
        C++: void CreateOutputWindow() override;
        
        Does not apply to sockets. Does nothing.
        """
        ...
    
    def Finalize(self):
        """
        V.Finalize()
        C++: void Finalize() override;
        V.Finalize(int)
        C++: void Finalize(int) override;
        
        Does not apply to sockets. Does nothing.
        """
        ...
    
    def GetNumberOfGenerationsFromBase(self, string):
        """
        V.GetNumberOfGenerationsFromBase(string) -> int
        C++: vtkIdType GetNumberOfGenerationsFromBase(const char *type)
            override;
        
        Given a the name of a base class of this class type, return the
        distance of inheritance between this class type and the named
        class (how many generations of inheritance are there between this
        class and the named class). If the named class is not in this
        class's inheritance tree, return a negative value. Valid
        responses will always be nonnegative. This method works in
        combination with vtkTypeMacro found in vtkSetGet.h.
        """
        ...
    
    def GetNumberOfGenerationsFromBaseType(self, string):
        """
        V.GetNumberOfGenerationsFromBaseType(string) -> int
        C++: static vtkIdType GetNumberOfGenerationsFromBaseType(
            const char *type)
        
        Given a the name of a base class of this class type, return the
        distance of inheritance between this class type and the named
        class (how many generations of inheritance are there between this
        class and the named class). If the named class is not in this
        class's inheritance tree, return a negative value. Valid
        responses will always be nonnegative. This method works in
        combination with vtkTypeMacro found in vtkSetGet.h.
        """
        ...
    
    def GetSwapBytesInReceivedData(self):
        """
        V.GetSwapBytesInReceivedData() -> int
        C++: int GetSwapBytesInReceivedData()
        """
        ...
    
    def Initialize(self):
        """
        V.Initialize()
        C++: virtual void Initialize()
        """
        ...
    
    def IsA(self, string):
        """
        V.IsA(string) -> int
        C++: vtkTypeBool IsA(const char *type) override;
        
        Return 1 if this class is the same type of (or a subclass of) the
        named class. Returns 0 otherwise. This method works in
        combination with vtkTypeMacro found in vtkSetGet.h.
        """
        ...
    
    def IsTypeOf(self, string):
        """
        V.IsTypeOf(string) -> int
        C++: static vtkTypeBool IsTypeOf(const char *type)
        
        Return 1 if this class type is the same type of (or a subclass
        of) the named class. Returns 0 otherwise. This method works in
        combination with vtkTypeMacro found in vtkSetGet.h.
        """
        ...
    
    def MultipleMethodExecute(self):
        """
        V.MultipleMethodExecute()
        C++: void MultipleMethodExecute() override;
        
        Does not apply to sockets.  Does nothing.
        """
        ...
    
    def NewInstance(self):
        """
        V.NewInstance() -> vtkSocketController
        C++: vtkSocketController *NewInstance()
        """
        ...
    
    def SafeDownCast(self, vtkObjectBase):
        """
        V.SafeDownCast(vtkObjectBase) -> vtkSocketController
        C++: static vtkSocketController *SafeDownCast(vtkObjectBase *o)
        """
        ...
    
    def SetCommunicator(self, vtkSocketCommunicator):
        """
        V.SetCommunicator(vtkSocketCommunicator)
        C++: void SetCommunicator(vtkSocketCommunicator *comm)
        
        Set the communicator used in normal and rmi communications.
        """
        ...
    
    def SingleMethodExecute(self):
        """
        V.SingleMethodExecute()
        C++: void SingleMethodExecute() override;
        
        Does not apply to sockets. Does nothing.
        """
        ...
    
    def WaitForConnection(self, p_int):
        """
        V.WaitForConnection(int) -> int
        C++: virtual int WaitForConnection(int port)
        
        Wait for connection on a given port, forwarded to the
        communicator
        """
        ...
    
    def __delattr__(self, *args, **kwargs):
        """ Implement delattr(self, name). """
        ...
    
    def __getattribute__(self, *args, **kwargs):
        """ Return getattr(self, name). """
        ...
    
    def __init__(self, *args, **kwargs) -> None:
        ...
    
    @staticmethod
    def __new__(*args, **kwargs):
        """ Create and return a new object.  See help(type) for accurate signature. """
        ...
    
    def __repr__(self, *args, **kwargs):
        """ Return repr(self). """
        ...
    
    def __setattr__(self, *args, **kwargs):
        """ Implement setattr(self, name, value). """
        ...
    
    def __str__(self, *args, **kwargs) -> str:
        """ Return str(self). """
        ...
    
    __this__ = ...
    Consts = ...
    ENDIAN_TAG = ...
    HASH_TAG = ...
    IDTYPESIZE_TAG = ...
    VERSION_TAG = ...
    __dict__ = ...
    __vtkname__ = ...


class vtkSubCommunicator(vtkCommunicator):
    """
    vtkSubCommunicator - Provides communication on a process group.
    
    Superclass: vtkCommunicator
    
    This class provides an implementation for communicating on process
    groups. In general, you should never use this class directly. 
    Instead, use the vtkMultiProcessController::CreateSubController
    method.
    
    @bug Because all communication is delegated to the original
    communicator, any error will report process ids with respect to the
    original communicator, not this communicator that was actually used.
    
    @sa
    vtkCommunicator, vtkMultiProcessController
    
    @par Thanks: This class was originally written by Kenneth Moreland
    (kmorel@sandia.gov) from Sandia National Laboratories.
    """
    def GetGroup(self):
        """
        V.GetGroup() -> vtkProcessGroup
        C++: virtual vtkProcessGroup *GetGroup()
        
        Set/get the group on which communication will happen.
        """
        ...
    
    def GetNumberOfGenerationsFromBase(self, string):
        """
        V.GetNumberOfGenerationsFromBase(string) -> int
        C++: vtkIdType GetNumberOfGenerationsFromBase(const char *type)
            override;
        
        Given a the name of a base class of this class type, return the
        distance of inheritance between this class type and the named
        class (how many generations of inheritance are there between this
        class and the named class). If the named class is not in this
        class's inheritance tree, return a negative value. Valid
        responses will always be nonnegative. This method works in
        combination with vtkTypeMacro found in vtkSetGet.h.
        """
        ...
    
    def GetNumberOfGenerationsFromBaseType(self, string):
        """
        V.GetNumberOfGenerationsFromBaseType(string) -> int
        C++: static vtkIdType GetNumberOfGenerationsFromBaseType(
            const char *type)
        
        Given a the name of a base class of this class type, return the
        distance of inheritance between this class type and the named
        class (how many generations of inheritance are there between this
        class and the named class). If the named class is not in this
        class's inheritance tree, return a negative value. Valid
        responses will always be nonnegative. This method works in
        combination with vtkTypeMacro found in vtkSetGet.h.
        """
        ...
    
    def IsA(self, string):
        """
        V.IsA(string) -> int
        C++: vtkTypeBool IsA(const char *type) override;
        
        Return 1 if this class is the same type of (or a subclass of) the
        named class. Returns 0 otherwise. This method works in
        combination with vtkTypeMacro found in vtkSetGet.h.
        """
        ...
    
    def IsTypeOf(self, string):
        """
        V.IsTypeOf(string) -> int
        C++: static vtkTypeBool IsTypeOf(const char *type)
        
        Return 1 if this class type is the same type of (or a subclass
        of) the named class. Returns 0 otherwise. This method works in
        combination with vtkTypeMacro found in vtkSetGet.h.
        """
        ...
    
    def NewInstance(self):
        """
        V.NewInstance() -> vtkSubCommunicator
        C++: vtkSubCommunicator *NewInstance()
        """
        ...
    
    def ReceiveVoidArray(self, void, p_int, p_int_1, p_int_2, p_int_3):
        """
        V.ReceiveVoidArray(void, int, int, int, int) -> int
        C++: int ReceiveVoidArray(void *data, vtkIdType length, int type,
            int remoteHandle, int tag) override;
        
        Implementation for abstract supercalss.
        """
        ...
    
    def SafeDownCast(self, vtkObjectBase):
        """
        V.SafeDownCast(vtkObjectBase) -> vtkSubCommunicator
        C++: static vtkSubCommunicator *SafeDownCast(vtkObjectBase *o)
        """
        ...
    
    def SendVoidArray(self, void, p_int, p_int_1, p_int_2, p_int_3):
        """
        V.SendVoidArray(void, int, int, int, int) -> int
        C++: int SendVoidArray(const void *data, vtkIdType length,
            int type, int remoteHandle, int tag) override;
        
        Implementation for abstract supercalss.
        """
        ...
    
    def SetGroup(self, vtkProcessGroup):
        """
        V.SetGroup(vtkProcessGroup)
        C++: virtual void SetGroup(vtkProcessGroup *group)
        
        Set/get the group on which communication will happen.
        """
        ...
    
    def __delattr__(self, *args, **kwargs):
        """ Implement delattr(self, name). """
        ...
    
    def __getattribute__(self, *args, **kwargs):
        """ Return getattr(self, name). """
        ...
    
    def __init__(self, *args, **kwargs) -> None:
        ...
    
    @staticmethod
    def __new__(*args, **kwargs):
        """ Create and return a new object.  See help(type) for accurate signature. """
        ...
    
    def __repr__(self, *args, **kwargs):
        """ Return repr(self). """
        ...
    
    def __setattr__(self, *args, **kwargs):
        """ Implement setattr(self, name, value). """
        ...
    
    def __str__(self, *args, **kwargs) -> str:
        """ Return str(self). """
        ...
    
    __this__ = ...
    __dict__ = ...
    __vtkname__ = ...


class vtkSubGroup(__vtkmodules_vtkCommonCore.vtkObject):
    """
    vtkSubGroup - scalable collective communication for a
         subset of members of a parallel VTK application
    
    Superclass: vtkObject
    
    This class provides scalable broadcast, reduce, etc. using
        only a vtkMultiProcessController. It does not require MPI.
        Users are vtkPKdTree and vtkDistributedDataFilter.
    
    @attention This class will be deprecated soon.  Instead of using this
    class, use the collective and subgrouping operations now built into
    vtkMultiProcessController.  The only reason this class is not
    deprecated already is because vtkPKdTree relies heavily on this class
    in ways that are not easy to work around.  Since vtkPKdTree is due
    for a major overhaul anyway, we are leaving things the way they are
    for now.
    
    @sa
         vtkPKdTree vtkDistributedDataFilter
    """
    def Barrier(self):
        """
        V.Barrier() -> int
        C++: int Barrier()
        """
        ...
    
    def Broadcast(self, *float, **kwargs):
        """
        V.Broadcast([float, ...], int, int) -> int
        C++: int Broadcast(double *data, int length, int root)
        V.Broadcast([int, ...], int, int) -> int
        C++: int Broadcast(int *data, int length, int root)
        V.Broadcast(string, int, int) -> int
        C++: int Broadcast(char *data, int length, int root)
        V.Broadcast([int, ...], int, int) -> int
        C++: int Broadcast(vtkIdType *data, int length, int root)
        """
        ...
    
    def Gather(self, *int, **kwargs):
        """
        V.Gather([int, ...], [int, ...], int, int) -> int
        C++: int Gather(int *data, int *to, int length, int root)
        V.Gather(string, string, int, int) -> int
        C++: int Gather(char *data, char *to, int length, int root)
        V.Gather([float, ...], [float, ...], int, int) -> int
        C++: int Gather(float *data, float *to, int length, int root)
        V.Gather([int, ...], [int, ...], int, int) -> int
        C++: int Gather(vtkIdType *data, vtkIdType *to, int length,
            int root)
        """
        ...
    
    def getLocalRank(self, p_int):
        """
        V.getLocalRank(int) -> int
        C++: int getLocalRank(int processID)
        """
        ...
    
    def GetNumberOfGenerationsFromBase(self, string):
        """
        V.GetNumberOfGenerationsFromBase(string) -> int
        C++: vtkIdType GetNumberOfGenerationsFromBase(const char *type)
            override;
        
        Given a the name of a base class of this class type, return the
        distance of inheritance between this class type and the named
        class (how many generations of inheritance are there between this
        class and the named class). If the named class is not in this
        class's inheritance tree, return a negative value. Valid
        responses will always be nonnegative. This method works in
        combination with vtkTypeMacro found in vtkSetGet.h.
        """
        ...
    
    def GetNumberOfGenerationsFromBaseType(self, string):
        """
        V.GetNumberOfGenerationsFromBaseType(string) -> int
        C++: static vtkIdType GetNumberOfGenerationsFromBaseType(
            const char *type)
        
        Given a the name of a base class of this class type, return the
        distance of inheritance between this class type and the named
        class (how many generations of inheritance are there between this
        class and the named class). If the named class is not in this
        class's inheritance tree, return a negative value. Valid
        responses will always be nonnegative. This method works in
        combination with vtkTypeMacro found in vtkSetGet.h.
        """
        ...
    
    def Initialize(self, p_int, p_int_1, p_int_2, p_int_3, vtkCommunicator):
        """
        V.Initialize(int, int, int, int, vtkCommunicator) -> int
        C++: int Initialize(int p0, int p1, int me, int tag,
            vtkCommunicator *c)
        
        Initialize a communication subgroup for the processes with rank
        p0 through p1 of the given communicator.  (So vtkSubGroup is
        limited to working with subgroups that are identified by a
        contiguous set of rank IDs.) The third argument is the callers
        rank, which must in the range from p0 through p1.
        """
        ...
    
    def IsA(self, string):
        """
        V.IsA(string) -> int
        C++: vtkTypeBool IsA(const char *type) override;
        
        Return 1 if this class is the same type of (or a subclass of) the
        named class. Returns 0 otherwise. This method works in
        combination with vtkTypeMacro found in vtkSetGet.h.
        """
        ...
    
    def IsTypeOf(self, string):
        """
        V.IsTypeOf(string) -> int
        C++: static vtkTypeBool IsTypeOf(const char *type)
        
        Return 1 if this class type is the same type of (or a subclass
        of) the named class. Returns 0 otherwise. This method works in
        combination with vtkTypeMacro found in vtkSetGet.h.
        """
        ...
    
    def NewInstance(self):
        """
        V.NewInstance() -> vtkSubGroup
        C++: vtkSubGroup *NewInstance()
        """
        ...
    
    def PrintSubGroup(self):
        """
        V.PrintSubGroup()
        C++: void PrintSubGroup()
        """
        ...
    
    def ReduceMax(self, *float, **kwargs):
        """
        V.ReduceMax([float, ...], [float, ...], int, int) -> int
        C++: int ReduceMax(double *data, double *to, int length, int root)
        V.ReduceMax([int, ...], [int, ...], int, int) -> int
        C++: int ReduceMax(int *data, int *to, int length, int root)
        """
        ...
    
    def ReduceMin(self, *float, **kwargs):
        """
        V.ReduceMin([float, ...], [float, ...], int, int) -> int
        C++: int ReduceMin(double *data, double *to, int length, int root)
        V.ReduceMin([int, ...], [int, ...], int, int) -> int
        C++: int ReduceMin(int *data, int *to, int length, int root)
        """
        ...
    
    def ReduceSum(self, *int, **kwargs):
        """
        V.ReduceSum([int, ...], [int, ...], int, int) -> int
        C++: int ReduceSum(int *data, int *to, int length, int root)
        """
        ...
    
    def SafeDownCast(self, vtkObjectBase):
        """
        V.SafeDownCast(vtkObjectBase) -> vtkSubGroup
        C++: static vtkSubGroup *SafeDownCast(vtkObjectBase *o)
        """
        ...
    
    def setGatherPattern(self, p_int, p_int_1):
        """
        V.setGatherPattern(int, int)
        C++: void setGatherPattern(int root, int length)
        """
        ...
    
    def __delattr__(self, *args, **kwargs):
        """ Implement delattr(self, name). """
        ...
    
    def __getattribute__(self, *args, **kwargs):
        """ Return getattr(self, name). """
        ...
    
    def __init__(self, *args, **kwargs) -> None:
        ...
    
    @staticmethod
    def __new__(*args, **kwargs):
        """ Create and return a new object.  See help(type) for accurate signature. """
        ...
    
    def __repr__(self, *args, **kwargs):
        """ Return repr(self). """
        ...
    
    def __setattr__(self, *args, **kwargs):
        """ Implement setattr(self, name, value). """
        ...
    
    def __str__(self, *args, **kwargs) -> str:
        """ Return str(self). """
        ...
    
    __this__ = ...
    MAXOP = ...
    MINOP = ...
    SUMOP = ...
    __dict__ = ...
    __vtkname__ = ...


__loader__ = ...
__spec__ = ...
