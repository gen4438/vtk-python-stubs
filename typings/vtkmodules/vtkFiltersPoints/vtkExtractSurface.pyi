"""
This type stub file was generated by pyright.
"""

import vtkmodules.vtkCommonExecutionModel as __vtkmodules_vtkCommonExecutionModel

class vtkExtractSurface(__vtkmodules_vtkCommonExecutionModel.vtkPolyDataAlgorithm):
    """
    vtkExtractSurface - generate zero-crossing isosurface from truncated
    signed distance volume
    
    Superclass: vtkPolyDataAlgorithm
    
    This filter extracts the zero-crossing isosurface from a truncated
    signed distance function TSDF. The TSDF is sampled across a volume,
    and is extracted using a modified version of the Flying Edges (FE)
    algorithm for increased speed, and to support multithreading. To use
    the filter, an input volume should be assigned, which may have
    special values indicating empty and/or unseen portions of the volume.
    These values are equal to +/- radius value of the signed distance
    function, and should be consistent with any filters used to generate
    the input volume (e.g., vtkSignedDistance).
    
    The Flying Edges algorithm is modified to deal with the nature of the
    truncated, signed distance function. Being truncated, the distance
    function typically is not computed throughout the volume, rather the
    special data values "unseen" and/or "empty" maybe assigned to distant
    or bordering voxels. The implications of this are that this
    implementation may produce non-closed, non-manifold surfaces, which
    is what is required to extract surfaces.
    
    More specifically, voxels may exist in one of three states: 1) within
    the TSDF, which extends +/-Radius from a generating geometry
    (typically a point cloud); 2) in the empty state, in which it is
    known that the surface does not exist; and 3) the unseen state, where
    a surface may exist but not enough information is known to be
    certain. Such situations arise, for example, when laser scanners
    generate point clouds, and the propagation of the laser beam "carves"
    out regions where no geometry exists (thereby defining empty space).
    Furthermore, areas in which the beam are occluded by geometry are
    known as "unseen" and the boundary between empty and unseen can be
    processed to produced a portion of the output isosurface (this is
    called hole filling).
    
    @warning
    This class has been threaded with vtkSMPTools. Using TBB or other
    non-sequential type (set in the CMake variable
    VTK_SMP_IMPLEMENTATION_TYPE) may improve performance significantly.
    
    @warning
    Empty regions are expected to have a data value
    -(this->Radius+FLT_EPSILON). Unseen regions are expected to have a
        data value (this->Radius+FLT_EPSILON). Near regions have data
        values d such that:
    -(this->Radius+FLT_EPSILON) < d (this->Radius+FLT_EPSILON).
    
    @warning
    
    Notes on the implementation:
    1. This is a lightly modified version of vtkFlyingEdges3D. Some
       design goals included minimizing the impact on the FE algorithm,
       and not adding extra memory requirements.
    2. It presumes an isocontour value=0.0 (the zero crossing of a signed
       distance function).
    3. The major modifications are to the edge cases. In Flying Edges, a
       single byte represents the case of an edge, and within that byte
       only 2 bits are needed (the extra six bytes are not used). Here,
       these unused bytes are repurposed to represent the "state" of the
       edge, whether it is
    1) near to the TSDF; 2) in an empty state; or 3) unseen state.
    4. Since these now-used bits encode extra state information, masking
       and related methods are modified from FE to tease apart the edge
       cases from the edge state.
    5. Voxels with edges marked "empty" are not processed, i.e., no
       output triangle primitives are generated. Depending on whether
       hole filling is enabled, voxels with edges marked "unseen" may not
    be processed either.
    6. As a result of #1 and #5, and the desire to keep the
       implementation simple, it is possible to produce output points
       which are not used by any output triangle. 
    
    @warning
    This algorithm loosely follows the most excellent paper by Curless
    and Levoy: "A Volumetric Method for Building Complex Models from
    Range Images."
    
    @warning
    This algorithm differs from the paper cited above in an important
    way. The Curless & Levoy algorithm is designed to create watertight
    surfaces, while this modified algorithm may not do so as the
    generating surface is not assumed to be closed.
    
    @sa
    vtkSignedDistance vtkFlyingEdges3D
    """
    def ComputeGradientsOff(self):
        """
        V.ComputeGradientsOff()
        C++: virtual void ComputeGradientsOff()
        
        Set/Get the computation of gradients. Gradient computation is
        fairly expensive in both time and storage. Note that if
        ComputeNormals is on, gradients will have to be calculated, but
        will not be stored in the output dataset. If the output data will
        be processed by filters that modify topology or geometry, it may
        be wise to turn Normals and Gradients off.
        """
        ...
    
    def ComputeGradientsOn(self):
        """
        V.ComputeGradientsOn()
        C++: virtual void ComputeGradientsOn()
        
        Set/Get the computation of gradients. Gradient computation is
        fairly expensive in both time and storage. Note that if
        ComputeNormals is on, gradients will have to be calculated, but
        will not be stored in the output dataset. If the output data will
        be processed by filters that modify topology or geometry, it may
        be wise to turn Normals and Gradients off.
        """
        ...
    
    def ComputeNormalsOff(self):
        """
        V.ComputeNormalsOff()
        C++: virtual void ComputeNormalsOff()
        
        Set/Get the computation of normals. Normal computation is fairly
        expensive in both time and storage. If the output data will be
        processed by filters that modify topology or geometry, it may be
        wise to turn Normals and Gradients off.
        """
        ...
    
    def ComputeNormalsOn(self):
        """
        V.ComputeNormalsOn()
        C++: virtual void ComputeNormalsOn()
        
        Set/Get the computation of normals. Normal computation is fairly
        expensive in both time and storage. If the output data will be
        processed by filters that modify topology or geometry, it may be
        wise to turn Normals and Gradients off.
        """
        ...
    
    def GetComputeGradients(self):
        """
        V.GetComputeGradients() -> int
        C++: virtual vtkTypeBool GetComputeGradients()
        
        Set/Get the computation of gradients. Gradient computation is
        fairly expensive in both time and storage. Note that if
        ComputeNormals is on, gradients will have to be calculated, but
        will not be stored in the output dataset. If the output data will
        be processed by filters that modify topology or geometry, it may
        be wise to turn Normals and Gradients off.
        """
        ...
    
    def GetComputeNormals(self):
        """
        V.GetComputeNormals() -> int
        C++: virtual vtkTypeBool GetComputeNormals()
        
        Set/Get the computation of normals. Normal computation is fairly
        expensive in both time and storage. If the output data will be
        processed by filters that modify topology or geometry, it may be
        wise to turn Normals and Gradients off.
        """
        ...
    
    def GetHoleFilling(self):
        """
        V.GetHoleFilling() -> bool
        C++: virtual bool GetHoleFilling()
        
        Enable hole filling. This generates separating surfaces between
        the empty and unseen portions of the volume.
        """
        ...
    
    def GetNumberOfGenerationsFromBase(self, string):
        """
        V.GetNumberOfGenerationsFromBase(string) -> int
        C++: vtkIdType GetNumberOfGenerationsFromBase(const char *type)
            override;
        
        Standard methods for instantiating the class, providing type
        information, and printing.
        """
        ...
    
    def GetNumberOfGenerationsFromBaseType(self, string):
        """
        V.GetNumberOfGenerationsFromBaseType(string) -> int
        C++: static vtkIdType GetNumberOfGenerationsFromBaseType(
            const char *type)
        
        Standard methods for instantiating the class, providing type
        information, and printing.
        """
        ...
    
    def GetRadius(self):
        """
        V.GetRadius() -> float
        C++: virtual double GetRadius()
        
        Specify the radius of influence of the signed distance function.
        Data values (which are distances) that are greater than the
        radius (i.e., d > Radius) are considered empty voxels; those
        voxel data values d < -Radius are considered unseen voxels.
        """
        ...
    
    def GetRadiusMaxValue(self):
        """
        V.GetRadiusMaxValue() -> float
        C++: virtual double GetRadiusMaxValue()
        
        Specify the radius of influence of the signed distance function.
        Data values (which are distances) that are greater than the
        radius (i.e., d > Radius) are considered empty voxels; those
        voxel data values d < -Radius are considered unseen voxels.
        """
        ...
    
    def GetRadiusMinValue(self):
        """
        V.GetRadiusMinValue() -> float
        C++: virtual double GetRadiusMinValue()
        
        Specify the radius of influence of the signed distance function.
        Data values (which are distances) that are greater than the
        radius (i.e., d > Radius) are considered empty voxels; those
        voxel data values d < -Radius are considered unseen voxels.
        """
        ...
    
    def HoleFillingOff(self):
        """
        V.HoleFillingOff()
        C++: virtual void HoleFillingOff()
        
        Enable hole filling. This generates separating surfaces between
        the empty and unseen portions of the volume.
        """
        ...
    
    def HoleFillingOn(self):
        """
        V.HoleFillingOn()
        C++: virtual void HoleFillingOn()
        
        Enable hole filling. This generates separating surfaces between
        the empty and unseen portions of the volume.
        """
        ...
    
    def IsA(self, string):
        """
        V.IsA(string) -> int
        C++: vtkTypeBool IsA(const char *type) override;
        
        Standard methods for instantiating the class, providing type
        information, and printing.
        """
        ...
    
    def IsTypeOf(self, string):
        """
        V.IsTypeOf(string) -> int
        C++: static vtkTypeBool IsTypeOf(const char *type)
        
        Standard methods for instantiating the class, providing type
        information, and printing.
        """
        ...
    
    def NewInstance(self):
        """
        V.NewInstance() -> vtkExtractSurface
        C++: vtkExtractSurface *NewInstance()
        
        Standard methods for instantiating the class, providing type
        information, and printing.
        """
        ...
    
    def SafeDownCast(self, vtkObjectBase):
        """
        V.SafeDownCast(vtkObjectBase) -> vtkExtractSurface
        C++: static vtkExtractSurface *SafeDownCast(vtkObjectBase *o)
        
        Standard methods for instantiating the class, providing type
        information, and printing.
        """
        ...
    
    def SetComputeGradients(self, p_int):
        """
        V.SetComputeGradients(int)
        C++: virtual void SetComputeGradients(vtkTypeBool _arg)
        
        Set/Get the computation of gradients. Gradient computation is
        fairly expensive in both time and storage. Note that if
        ComputeNormals is on, gradients will have to be calculated, but
        will not be stored in the output dataset. If the output data will
        be processed by filters that modify topology or geometry, it may
        be wise to turn Normals and Gradients off.
        """
        ...
    
    def SetComputeNormals(self, p_int):
        """
        V.SetComputeNormals(int)
        C++: virtual void SetComputeNormals(vtkTypeBool _arg)
        
        Set/Get the computation of normals. Normal computation is fairly
        expensive in both time and storage. If the output data will be
        processed by filters that modify topology or geometry, it may be
        wise to turn Normals and Gradients off.
        """
        ...
    
    def SetHoleFilling(self, bool):
        """
        V.SetHoleFilling(bool)
        C++: virtual void SetHoleFilling(bool _arg)
        
        Enable hole filling. This generates separating surfaces between
        the empty and unseen portions of the volume.
        """
        ...
    
    def SetRadius(self, p_float):
        """
        V.SetRadius(float)
        C++: virtual void SetRadius(double _arg)
        
        Specify the radius of influence of the signed distance function.
        Data values (which are distances) that are greater than the
        radius (i.e., d > Radius) are considered empty voxels; those
        voxel data values d < -Radius are considered unseen voxels.
        """
        ...
    
    def __delattr__(self, *args, **kwargs):
        """ Implement delattr(self, name). """
        ...
    
    def __getattribute__(self, *args, **kwargs):
        """ Return getattr(self, name). """
        ...
    
    def __init__(self, *args, **kwargs) -> None:
        ...
    
    @staticmethod
    def __new__(*args, **kwargs):
        """ Create and return a new object.  See help(type) for accurate signature. """
        ...
    
    def __repr__(self, *args, **kwargs):
        """ Return repr(self). """
        ...
    
    def __setattr__(self, *args, **kwargs):
        """ Implement setattr(self, name, value). """
        ...
    
    def __str__(self, *args, **kwargs) -> str:
        """ Return str(self). """
        ...
    
    __this__ = ...
    __dict__ = ...
    __vtkname__ = ...


