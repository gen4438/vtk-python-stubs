"""
This type stub file was generated by pyright.
"""

import vtkmodules.vtkCommonExecutionModel as __vtkmodules_vtkCommonExecutionModel

class vtkUnsignedDistance(__vtkmodules_vtkCommonExecutionModel.vtkImageAlgorithm):
    """
    vtkUnsignedDistance - compute unsigned (i.e., non-negative) distances
    from an input point cloud
    
    Superclass: vtkImageAlgorithm
    
    vtkUnsignedDistance is a filter that computes non-negative (i.e.,
    unsigned) distances over a volume from an input point cloud. This
    filter is distinct from vtkSignedDistance in that it does not require
    point normals. However, isocontouring a zero-valued distance function
    (e.g., trying to fit a surface will produce unsatisfactory results).
    Rather this filter, when combined with an isocontouring filter such
    as vtkFlyingEdges3D, can produce an offset, bounding surface
    surrounding the input point cloud.
    
    To use this filter, specify the input vtkPolyData (which represents
    the point cloud); define the sampling volume; specify a radius (which
    limits the radius of influence of each point); and set an optional
    point locator (to accelerate proximity operations, a
    vtkStaticPointLocator is used by default). Note that large radius
    values may have significant impact on performance. The volume is
    defined by specifying dimensions in the x-y-z directions, as well as
    a domain bounds. By default the model bounds are defined from the
    input points, but the user can also manually specify them. Finally,
    because the radius data member limits the influence of the distance
    calculation, some voxels may receive no contribution. These voxel
    values are set to the CapValue.
    
    This filter has one other unusual capability: it is possible to
    append data in a sequence of operations to generate a single output.
    This is useful when you have multiple point clouds (e.g., possibly
    from multiple acqusition scans) and want to incrementally accumulate
    all the data. However, the user must be careful to either specify the
    Bounds or order the input such that the bounds of the first input
    completely contains all other input data.  This is because the
    geometry and topology of the output sampling volume cannot be changed
    after the initial Append operation.
    
    @warning
    Note that multiple, non-connected surfaces may be produced. For
    example, if the point cloud is from the surface of the sphere, it is
    possible to generate two surfaces (with isocontouring): one inside
    the sphere, one outside the sphere. It is sometimes possible to
    select the surface you want from the output of the contouring filter
    by using vtkPolyDataConnectivityFilter.
    
    @warning
    This class has been threaded with vtkSMPTools. Using TBB or other
    non-sequential type (set in the CMake variable
    VTK_SMP_IMPLEMENTATION_TYPE) may improve performance significantly.
    
    @sa
    vtkSignedDistance vtkExtractSurface vtkImplicitModeller
    """
    def AdjustBoundsOff(self):
        """
        V.AdjustBoundsOff()
        C++: virtual void AdjustBoundsOff()
        
        Control how the model bounds are computed. If the ivar
        AdjustBounds is set, then the bounds specified (or computed
        automatically) is modified by the fraction given by
        AdjustDistance. This means that the model bounds is expanded in
        each of the x-y-z directions.
        """
        ...
    
    def AdjustBoundsOn(self):
        """
        V.AdjustBoundsOn()
        C++: virtual void AdjustBoundsOn()
        
        Control how the model bounds are computed. If the ivar
        AdjustBounds is set, then the bounds specified (or computed
        automatically) is modified by the fraction given by
        AdjustDistance. This means that the model bounds is expanded in
        each of the x-y-z directions.
        """
        ...
    
    def Append(self, vtkPolyData):
        """
        V.Append(vtkPolyData)
        C++: void Append(vtkPolyData *input)
        
        Append a data set to the existing output. To use this function,
        you'll have to invoke the StartAppend() method before doing
        successive appends. It's also a good idea to specify the model
        bounds; otherwise the input model bounds is used. When you've
        finished appending, use the EndAppend() method.
        """
        ...
    
    def CappingOff(self):
        """
        V.CappingOff()
        C++: virtual void CappingOff()
        
        The outer boundary of the volume can be assigned a particular
        value after distances are computed. This can be used to close or
        "cap" all surfaces during isocontouring.
        """
        ...
    
    def CappingOn(self):
        """
        V.CappingOn()
        C++: virtual void CappingOn()
        
        The outer boundary of the volume can be assigned a particular
        value after distances are computed. This can be used to close or
        "cap" all surfaces during isocontouring.
        """
        ...
    
    def EndAppend(self):
        """
        V.EndAppend()
        C++: void EndAppend()
        
        Method completes the append process.
        """
        ...
    
    def GetAdjustBounds(self):
        """
        V.GetAdjustBounds() -> int
        C++: virtual vtkTypeBool GetAdjustBounds()
        
        Control how the model bounds are computed. If the ivar
        AdjustBounds is set, then the bounds specified (or computed
        automatically) is modified by the fraction given by
        AdjustDistance. This means that the model bounds is expanded in
        each of the x-y-z directions.
        """
        ...
    
    def GetAdjustDistance(self):
        """
        V.GetAdjustDistance() -> float
        C++: virtual double GetAdjustDistance()
        
        Specify the amount to grow the model bounds (if the ivar
        AdjustBounds is set). The value is a fraction of the maximum
        length of the sides of the box specified by the model bounds.
        """
        ...
    
    def GetAdjustDistanceMaxValue(self):
        """
        V.GetAdjustDistanceMaxValue() -> float
        C++: virtual double GetAdjustDistanceMaxValue()
        
        Specify the amount to grow the model bounds (if the ivar
        AdjustBounds is set). The value is a fraction of the maximum
        length of the sides of the box specified by the model bounds.
        """
        ...
    
    def GetAdjustDistanceMinValue(self):
        """
        V.GetAdjustDistanceMinValue() -> float
        C++: virtual double GetAdjustDistanceMinValue()
        
        Specify the amount to grow the model bounds (if the ivar
        AdjustBounds is set). The value is a fraction of the maximum
        length of the sides of the box specified by the model bounds.
        """
        ...
    
    def GetBounds(self):
        """
        V.GetBounds() -> (float, float, float, float, float, float)
        C++: virtual double *GetBounds()
        
        Set / get the region in space in which to perform the sampling.
        If not specified, it will be computed automatically.
        """
        ...
    
    def GetCapping(self):
        """
        V.GetCapping() -> int
        C++: virtual vtkTypeBool GetCapping()
        
        The outer boundary of the volume can be assigned a particular
        value after distances are computed. This can be used to close or
        "cap" all surfaces during isocontouring.
        """
        ...
    
    def GetCapValue(self):
        """
        V.GetCapValue() -> float
        C++: virtual double GetCapValue()
        
        Specify the capping value to use. The CapValue is also used as an
        initial distance value at each point in the dataset. By default,
        the CapValue is VTK_FLOAT_MAX;
        """
        ...
    
    def GetDimensions(self):
        """
        V.GetDimensions() -> (int, int, int)
        C++: virtual int *GetDimensions()
        
        Set/Get the i-j-k dimensions on which to computer the distance
        function.
        """
        ...
    
    def GetLocator(self):
        """
        V.GetLocator() -> vtkAbstractPointLocator
        C++: virtual vtkAbstractPointLocator *GetLocator()
        
        Specify a point locator. By default a vtkStaticPointLocator is
        used. The locator performs efficient searches to locate points
        surrounding a voxel (within the specified radius).
        """
        ...
    
    def GetNumberOfGenerationsFromBase(self, string):
        """
        V.GetNumberOfGenerationsFromBase(string) -> int
        C++: vtkIdType GetNumberOfGenerationsFromBase(const char *type)
            override;
        
        Standard methods for instantiating the class, providing type
        information, and printing.
        """
        ...
    
    def GetNumberOfGenerationsFromBaseType(self, string):
        """
        V.GetNumberOfGenerationsFromBaseType(string) -> int
        C++: static vtkIdType GetNumberOfGenerationsFromBaseType(
            const char *type)
        
        Standard methods for instantiating the class, providing type
        information, and printing.
        """
        ...
    
    def GetOutputScalarType(self):
        """
        V.GetOutputScalarType() -> int
        C++: virtual int GetOutputScalarType()
        
        Set the desired output scalar type. Currently only real types are
        supported. By default, VTK_FLOAT scalars are created.
        """
        ...
    
    def GetRadius(self):
        """
        V.GetRadius() -> float
        C++: virtual double GetRadius()
        
        Set / get the radius of influence of each point. Smaller values
        generally improve performance markedly.
        """
        ...
    
    def GetRadiusMaxValue(self):
        """
        V.GetRadiusMaxValue() -> float
        C++: virtual double GetRadiusMaxValue()
        
        Set / get the radius of influence of each point. Smaller values
        generally improve performance markedly.
        """
        ...
    
    def GetRadiusMinValue(self):
        """
        V.GetRadiusMinValue() -> float
        C++: virtual double GetRadiusMinValue()
        
        Set / get the radius of influence of each point. Smaller values
        generally improve performance markedly.
        """
        ...
    
    def IsA(self, string):
        """
        V.IsA(string) -> int
        C++: vtkTypeBool IsA(const char *type) override;
        
        Standard methods for instantiating the class, providing type
        information, and printing.
        """
        ...
    
    def IsTypeOf(self, string):
        """
        V.IsTypeOf(string) -> int
        C++: static vtkTypeBool IsTypeOf(const char *type)
        
        Standard methods for instantiating the class, providing type
        information, and printing.
        """
        ...
    
    def NewInstance(self):
        """
        V.NewInstance() -> vtkUnsignedDistance
        C++: vtkUnsignedDistance *NewInstance()
        
        Standard methods for instantiating the class, providing type
        information, and printing.
        """
        ...
    
    def SafeDownCast(self, vtkObjectBase):
        """
        V.SafeDownCast(vtkObjectBase) -> vtkUnsignedDistance
        C++: static vtkUnsignedDistance *SafeDownCast(vtkObjectBase *o)
        
        Standard methods for instantiating the class, providing type
        information, and printing.
        """
        ...
    
    def SetAdjustBounds(self, p_int):
        """
        V.SetAdjustBounds(int)
        C++: virtual void SetAdjustBounds(vtkTypeBool _arg)
        
        Control how the model bounds are computed. If the ivar
        AdjustBounds is set, then the bounds specified (or computed
        automatically) is modified by the fraction given by
        AdjustDistance. This means that the model bounds is expanded in
        each of the x-y-z directions.
        """
        ...
    
    def SetAdjustDistance(self, p_float):
        """
        V.SetAdjustDistance(float)
        C++: virtual void SetAdjustDistance(double _arg)
        
        Specify the amount to grow the model bounds (if the ivar
        AdjustBounds is set). The value is a fraction of the maximum
        length of the sides of the box specified by the model bounds.
        """
        ...
    
    def SetBounds(self, p_float, p_float_1, p_float_2, p_float_3, p_float_4, p_float_5):
        """
        V.SetBounds(float, float, float, float, float, float)
        C++: virtual void SetBounds(double _arg1, double _arg2,
            double _arg3, double _arg4, double _arg5, double _arg6)
        V.SetBounds((float, float, float, float, float, float))
        C++: virtual void SetBounds(const double _arg[6])
        
        Set / get the region in space in which to perform the sampling.
        If not specified, it will be computed automatically.
        """
        ...
    
    def SetCapping(self, p_int):
        """
        V.SetCapping(int)
        C++: virtual void SetCapping(vtkTypeBool _arg)
        
        The outer boundary of the volume can be assigned a particular
        value after distances are computed. This can be used to close or
        "cap" all surfaces during isocontouring.
        """
        ...
    
    def SetCapValue(self, p_float):
        """
        V.SetCapValue(float)
        C++: virtual void SetCapValue(double _arg)
        
        Specify the capping value to use. The CapValue is also used as an
        initial distance value at each point in the dataset. By default,
        the CapValue is VTK_FLOAT_MAX;
        """
        ...
    
    def SetDimensions(self, p_int, p_int_1, p_int_2):
        """
        V.SetDimensions(int, int, int)
        C++: void SetDimensions(int i, int j, int k)
        V.SetDimensions((int, int, int))
        C++: void SetDimensions(const int dim[3])
        
        Set/Get the i-j-k dimensions on which to computer the distance
        function.
        """
        ...
    
    def SetLocator(self, vtkAbstractPointLocator):
        """
        V.SetLocator(vtkAbstractPointLocator)
        C++: void SetLocator(vtkAbstractPointLocator *locator)
        
        Specify a point locator. By default a vtkStaticPointLocator is
        used. The locator performs efficient searches to locate points
        surrounding a voxel (within the specified radius).
        """
        ...
    
    def SetOutputScalarType(self, p_int):
        """
        V.SetOutputScalarType(int)
        C++: virtual void SetOutputScalarType(int _arg)
        
        Set the desired output scalar type. Currently only real types are
        supported. By default, VTK_FLOAT scalars are created.
        """
        ...
    
    def SetOutputScalarTypeToDouble(self):
        """
        V.SetOutputScalarTypeToDouble()
        C++: void SetOutputScalarTypeToDouble()
        
        Set the desired output scalar type. Currently only real types are
        supported. By default, VTK_FLOAT scalars are created.
        """
        ...
    
    def SetOutputScalarTypeToFloat(self):
        """
        V.SetOutputScalarTypeToFloat()
        C++: void SetOutputScalarTypeToFloat()
        
        Set the desired output scalar type. Currently only real types are
        supported. By default, VTK_FLOAT scalars are created.
        """
        ...
    
    def SetRadius(self, p_float):
        """
        V.SetRadius(float)
        C++: virtual void SetRadius(double _arg)
        
        Set / get the radius of influence of each point. Smaller values
        generally improve performance markedly.
        """
        ...
    
    def StartAppend(self):
        """
        V.StartAppend()
        C++: void StartAppend()
        
        Initialize the filter for appending data. You must invoke the
        StartAppend() method before doing successive Appends(). It's also
        a good idea to manually specify the model bounds; otherwise the
        input bounds for the data will be used.
        """
        ...
    
    def __delattr__(self, *args, **kwargs):
        """ Implement delattr(self, name). """
        ...
    
    def __getattribute__(self, *args, **kwargs):
        """ Return getattr(self, name). """
        ...
    
    def __init__(self, *args, **kwargs) -> None:
        ...
    
    @staticmethod
    def __new__(*args, **kwargs):
        """ Create and return a new object.  See help(type) for accurate signature. """
        ...
    
    def __repr__(self, *args, **kwargs):
        """ Return repr(self). """
        ...
    
    def __setattr__(self, *args, **kwargs):
        """ Implement setattr(self, name, value). """
        ...
    
    def __str__(self, *args, **kwargs) -> str:
        """ Return str(self). """
        ...
    
    __this__ = ...
    __dict__ = ...
    __vtkname__ = ...


