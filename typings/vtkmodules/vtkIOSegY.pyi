"""
This type stub file was generated by pyright.
"""

import vtkmodules.vtkCommonExecutionModel as __vtkmodules_vtkCommonExecutionModel

class vtkSegYReader(__vtkmodules_vtkCommonExecutionModel.vtkDataSetAlgorithm):
    """
    vtkSegYReader - Reads SegY data files.
    
    Superclass: vtkDataSetAlgorithm
    
    vtkSegYReader reads SegY data files. We create a vtkStructuredGrid
    for 2.5D SegY and 3D data. If we set the StructuredGrid option to 0
    we create a vtkImageData for 3D data. This saves memory and may
    speed-up certain algorithms, but the position and the shape of the
    data may not be correct. The axes for the data are: crossline,
    inline, depth. For situations where traces are missing values of zero
    are used to fill in the dataset.
    """
    def Force2DOff(self):
        """
        V.Force2DOff()
        C++: virtual void Force2DOff()
        
        Should we force the data to be interpreted as a 2D dataset? It
        may be a 2D sheet through 3D space. When this is turned on we
        ignore the cross line and line values and instead build a 2D data
        by processing and connecting the traces in order from first to
        last. The output will be a Structrured Grid.
        """
        ...
    
    def Force2DOn(self):
        """
        V.Force2DOn()
        C++: virtual void Force2DOn()
        
        Should we force the data to be interpreted as a 2D dataset? It
        may be a 2D sheet through 3D space. When this is turned on we
        ignore the cross line and line values and instead build a 2D data
        by processing and connecting the traces in order from first to
        last. The output will be a Structrured Grid.
        """
        ...
    
    def GetFileName(self):
        """
        V.GetFileName() -> string
        C++: virtual char *GetFileName()
        """
        ...
    
    def GetForce2D(self):
        """
        V.GetForce2D() -> bool
        C++: virtual bool GetForce2D()
        
        Should we force the data to be interpreted as a 2D dataset? It
        may be a 2D sheet through 3D space. When this is turned on we
        ignore the cross line and line values and instead build a 2D data
        by processing and connecting the traces in order from first to
        last. The output will be a Structrured Grid.
        """
        ...
    
    def GetNumberOfGenerationsFromBase(self, string):
        """
        V.GetNumberOfGenerationsFromBase(string) -> int
        C++: vtkIdType GetNumberOfGenerationsFromBase(const char *type)
            override;
        
        Given a the name of a base class of this class type, return the
        distance of inheritance between this class type and the named
        class (how many generations of inheritance are there between this
        class and the named class). If the named class is not in this
        class's inheritance tree, return a negative value. Valid
        responses will always be nonnegative. This method works in
        combination with vtkTypeMacro found in vtkSetGet.h.
        """
        ...
    
    def GetNumberOfGenerationsFromBaseType(self, string):
        """
        V.GetNumberOfGenerationsFromBaseType(string) -> int
        C++: static vtkIdType GetNumberOfGenerationsFromBaseType(
            const char *type)
        
        Given a the name of a base class of this class type, return the
        distance of inheritance between this class type and the named
        class (how many generations of inheritance are there between this
        class and the named class). If the named class is not in this
        class's inheritance tree, return a negative value. Valid
        responses will always be nonnegative. This method works in
        combination with vtkTypeMacro found in vtkSetGet.h.
        """
        ...
    
    def GetStructuredGrid(self):
        """
        V.GetStructuredGrid() -> int
        C++: virtual int GetStructuredGrid()
        
        Specify if we create a vtkStructuredGrid even when the data is
        3D. Note this consumes more memory but it shows the precise
        location for each point and the correct shape of the data. The
        default value is true.  If we set this option to false we create
        a vtkImageData for the SegY 3D dataset.
        """
        ...
    
    def GetVerticalCRS(self):
        """
        V.GetVerticalCRS() -> int
        C++: virtual int GetVerticalCRS()
        
        Specify whether the vertical coordinates in the SEG-Y file are
        heights (positive up) or depths (positive down). By default, the
        vertical coordinates are treated as heights (i.e. positive up).
        This means that the Z-axis of the dataset goes from 0 (surface)
        to -ve depth (last sample).
        
        ote As per the SEG-Y rev 2.0 specification, this information is
        defined in the Location Data Stanza of the Extended Textual
        Header. However, as of this revision, vtkSegY2DReader does not
        support reading the extended textual header.
        """
        ...
    
    def GetXCoordByte(self):
        """
        V.GetXCoordByte() -> int
        C++: virtual int GetXCoordByte()
        
        Specify X and Y byte positions for custom XYCoordinateMode. By
        default, XCoordByte = 73, YCoordByte = 77 i.e. source xy.
        
        \sa SetXYCoordinatesModeToCustom()
        """
        ...
    
    def GetXYCoordMode(self):
        """
        V.GetXYCoordMode() -> int
        C++: virtual int GetXYCoordMode()
        
        Specify whether to use source x/y coordinates or CDP coordinates
        or custom byte positions for data position in the SEG-Y trace
        header. Defaults to source x/y coordinates.
        
        As per SEG-Y rev 2.0 specification, Source XY coordinate bytes =
        (73, 77) CDP XY coordinate bytes = (181, 185)
        """
        ...
    
    def GetXYCoordModeMaxValue(self):
        """
        V.GetXYCoordModeMaxValue() -> int
        C++: virtual int GetXYCoordModeMaxValue()
        
        Specify whether to use source x/y coordinates or CDP coordinates
        or custom byte positions for data position in the SEG-Y trace
        header. Defaults to source x/y coordinates.
        
        As per SEG-Y rev 2.0 specification, Source XY coordinate bytes =
        (73, 77) CDP XY coordinate bytes = (181, 185)
        """
        ...
    
    def GetXYCoordModeMinValue(self):
        """
        V.GetXYCoordModeMinValue() -> int
        C++: virtual int GetXYCoordModeMinValue()
        
        Specify whether to use source x/y coordinates or CDP coordinates
        or custom byte positions for data position in the SEG-Y trace
        header. Defaults to source x/y coordinates.
        
        As per SEG-Y rev 2.0 specification, Source XY coordinate bytes =
        (73, 77) CDP XY coordinate bytes = (181, 185)
        """
        ...
    
    def GetYCoordByte(self):
        """
        V.GetYCoordByte() -> int
        C++: virtual int GetYCoordByte()
        
        Specify X and Y byte positions for custom XYCoordinateMode. By
        default, XCoordByte = 73, YCoordByte = 77 i.e. source xy.
        
        \sa SetXYCoordinatesModeToCustom()
        """
        ...
    
    def IsA(self, string):
        """
        V.IsA(string) -> int
        C++: vtkTypeBool IsA(const char *type) override;
        
        Return 1 if this class is the same type of (or a subclass of) the
        named class. Returns 0 otherwise. This method works in
        combination with vtkTypeMacro found in vtkSetGet.h.
        """
        ...
    
    def IsTypeOf(self, string):
        """
        V.IsTypeOf(string) -> int
        C++: static vtkTypeBool IsTypeOf(const char *type)
        
        Return 1 if this class type is the same type of (or a subclass
        of) the named class. Returns 0 otherwise. This method works in
        combination with vtkTypeMacro found in vtkSetGet.h.
        """
        ...
    
    def NewInstance(self):
        """
        V.NewInstance() -> vtkSegYReader
        C++: vtkSegYReader *NewInstance()
        """
        ...
    
    def SafeDownCast(self, vtkObjectBase):
        """
        V.SafeDownCast(vtkObjectBase) -> vtkSegYReader
        C++: static vtkSegYReader *SafeDownCast(vtkObjectBase *o)
        """
        ...
    
    def SetFileName(self, string):
        """
        V.SetFileName(string)
        C++: virtual void SetFileName(const char *_arg)
        """
        ...
    
    def SetForce2D(self, bool):
        """
        V.SetForce2D(bool)
        C++: virtual void SetForce2D(bool _arg)
        
        Should we force the data to be interpreted as a 2D dataset? It
        may be a 2D sheet through 3D space. When this is turned on we
        ignore the cross line and line values and instead build a 2D data
        by processing and connecting the traces in order from first to
        last. The output will be a Structrured Grid.
        """
        ...
    
    def SetStructuredGrid(self, p_int):
        """
        V.SetStructuredGrid(int)
        C++: virtual void SetStructuredGrid(int _arg)
        
        Specify if we create a vtkStructuredGrid even when the data is
        3D. Note this consumes more memory but it shows the precise
        location for each point and the correct shape of the data. The
        default value is true.  If we set this option to false we create
        a vtkImageData for the SegY 3D dataset.
        """
        ...
    
    def SetVerticalCRS(self, p_int):
        """
        V.SetVerticalCRS(int)
        C++: virtual void SetVerticalCRS(int _arg)
        
        Specify whether the vertical coordinates in the SEG-Y file are
        heights (positive up) or depths (positive down). By default, the
        vertical coordinates are treated as heights (i.e. positive up).
        This means that the Z-axis of the dataset goes from 0 (surface)
        to -ve depth (last sample).
        
        ote As per the SEG-Y rev 2.0 specification, this information is
        defined in the Location Data Stanza of the Extended Textual
        Header. However, as of this revision, vtkSegY2DReader does not
        support reading the extended textual header.
        """
        ...
    
    def SetXCoordByte(self, p_int):
        """
        V.SetXCoordByte(int)
        C++: virtual void SetXCoordByte(int _arg)
        
        Specify X and Y byte positions for custom XYCoordinateMode. By
        default, XCoordByte = 73, YCoordByte = 77 i.e. source xy.
        
        \sa SetXYCoordinatesModeToCustom()
        """
        ...
    
    def SetXYCoordMode(self, p_int):
        """
        V.SetXYCoordMode(int)
        C++: virtual void SetXYCoordMode(int _arg)
        
        Specify whether to use source x/y coordinates or CDP coordinates
        or custom byte positions for data position in the SEG-Y trace
        header. Defaults to source x/y coordinates.
        
        As per SEG-Y rev 2.0 specification, Source XY coordinate bytes =
        (73, 77) CDP XY coordinate bytes = (181, 185)
        """
        ...
    
    def SetXYCoordModeToCDP(self):
        """
        V.SetXYCoordModeToCDP()
        C++: void SetXYCoordModeToCDP()
        
        Specify whether to use source x/y coordinates or CDP coordinates
        or custom byte positions for data position in the SEG-Y trace
        header. Defaults to source x/y coordinates.
        
        As per SEG-Y rev 2.0 specification, Source XY coordinate bytes =
        (73, 77) CDP XY coordinate bytes = (181, 185)
        """
        ...
    
    def SetXYCoordModeToCustom(self):
        """
        V.SetXYCoordModeToCustom()
        C++: void SetXYCoordModeToCustom()
        
        Specify whether to use source x/y coordinates or CDP coordinates
        or custom byte positions for data position in the SEG-Y trace
        header. Defaults to source x/y coordinates.
        
        As per SEG-Y rev 2.0 specification, Source XY coordinate bytes =
        (73, 77) CDP XY coordinate bytes = (181, 185)
        """
        ...
    
    def SetXYCoordModeToSource(self):
        """
        V.SetXYCoordModeToSource()
        C++: void SetXYCoordModeToSource()
        
        Specify whether to use source x/y coordinates or CDP coordinates
        or custom byte positions for data position in the SEG-Y trace
        header. Defaults to source x/y coordinates.
        
        As per SEG-Y rev 2.0 specification, Source XY coordinate bytes =
        (73, 77) CDP XY coordinate bytes = (181, 185)
        """
        ...
    
    def SetYCoordByte(self, p_int):
        """
        V.SetYCoordByte(int)
        C++: virtual void SetYCoordByte(int _arg)
        
        Specify X and Y byte positions for custom XYCoordinateMode. By
        default, XCoordByte = 73, YCoordByte = 77 i.e. source xy.
        
        \sa SetXYCoordinatesModeToCustom()
        """
        ...
    
    def StructuredGridOff(self):
        """
        V.StructuredGridOff()
        C++: virtual void StructuredGridOff()
        
        Specify if we create a vtkStructuredGrid even when the data is
        3D. Note this consumes more memory but it shows the precise
        location for each point and the correct shape of the data. The
        default value is true.  If we set this option to false we create
        a vtkImageData for the SegY 3D dataset.
        """
        ...
    
    def StructuredGridOn(self):
        """
        V.StructuredGridOn()
        C++: virtual void StructuredGridOn()
        
        Specify if we create a vtkStructuredGrid even when the data is
        3D. Note this consumes more memory but it shows the precise
        location for each point and the correct shape of the data. The
        default value is true.  If we set this option to false we create
        a vtkImageData for the SegY 3D dataset.
        """
        ...
    
    def __delattr__(self, *args, **kwargs):
        """ Implement delattr(self, name). """
        ...
    
    def __getattribute__(self, *args, **kwargs):
        """ Return getattr(self, name). """
        ...
    
    def __init__(self, *args, **kwargs) -> None:
        ...
    
    @staticmethod
    def __new__(*args, **kwargs):
        """ Create and return a new object.  See help(type) for accurate signature. """
        ...
    
    def __repr__(self, *args, **kwargs):
        """ Return repr(self). """
        ...
    
    def __setattr__(self, *args, **kwargs):
        """ Implement setattr(self, name, value). """
        ...
    
    def __str__(self, *args, **kwargs) -> str:
        """ Return str(self). """
        ...
    
    __this__ = ...
    VTKSegYCoordinateModes = ...
    VTKSegYVerticalCRS = ...
    VTK_SEGY_CDP = ...
    VTK_SEGY_CUSTOM = ...
    VTK_SEGY_SOURCE = ...
    VTK_SEGY_VERTICAL_DEPTHS = ...
    VTK_SEGY_VERTICAL_HEIGHTS = ...
    __dict__ = ...
    __vtkname__ = ...


__loader__ = ...
__spec__ = ...
