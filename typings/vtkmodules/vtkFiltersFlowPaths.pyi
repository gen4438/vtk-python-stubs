"""
This type stub file was generated by pyright.
"""

import vtkmodules.vtkCommonDataModel as __vtkmodules_vtkCommonDataModel
import vtkmodules.vtkCommonExecutionModel as __vtkmodules_vtkCommonExecutionModel
import vtkmodules.vtkCommonMath as __vtkmodules_vtkCommonMath

class vtkAbstractInterpolatedVelocityField(__vtkmodules_vtkCommonMath.vtkFunctionSet):
    """
    vtkAbstractInterpolatedVelocityField - An abstract class for
     obtaining the interpolated velocity values at a point
    
    Superclass: vtkFunctionSet
    
    vtkAbstractInterpolatedVelocityField acts as a continuous velocity
    field
     by performing cell interpolation on the underlying vtkDataSet. This
    is an
     abstract sub-class of vtkFunctionSet, NumberOfIndependentVariables =
    4
     (x,y,z,t) and NumberOfFunctions = 3 (u,v,w). With a brute-force
    scheme,
     every time an evaluation is performed, the target cell containing
    point
     (x,y,z) needs to be found by calling FindCell(), via either
    vtkDataSet or
     vtkAbstractCelllocator's sub-classes (vtkCellLocator &
    vtkModifiedBSPTree).
     As it incurs a large cost, one (for
    vtkCellLocatorInterpolatedVelocityField
     via vtkAbstractCellLocator) or two (for vtkInterpolatedVelocityField
    via
     vtkDataSet that involves vtkPointLocator in addressing vtkPointSet)
    levels
     of cell caching may be exploited to increase the performance.
    
    
     For vtkInterpolatedVelocityField, level #0 begins with intra-cell
    caching.
     Specifically if the previous cell is valid and the next point is
    still in
     it ( i.e., vtkCell::EvaluatePosition() returns 1, coupled with newly
    created
     parametric coordinates & weights ), the function values can be
    interpolated
     and only vtkCell::EvaluatePosition() is invoked. If this fails, then
    level #1
     follows by inter-cell search for the target cell that contains the
    next point.
     By an inter-cell search, the previous cell provides an important
    clue or serves
     as an immediate neighbor to aid in locating the target cell via
    vtkPointSet::
     FindCell(). If this still fails, a global cell location / search is
    invoked via
     vtkPointSet::FindCell(). Here regardless of either inter-cell or
    global search,
     vtkPointLocator is in fact employed (for datasets of type
    vtkPointSet only, note
     vtkImageData and vtkRectilinearGrid are able to provide rapid and
    robust cell
     location due to the simple mesh topology) as a crucial tool
    underlying the cell
     locator. However, the use of vtkPointLocator makes
    vtkInterpolatedVelocityField
     non-robust in cell location for vtkPointSet.
    
    
     For vtkCellLocatorInterpolatedVelocityField, the only caching (level
    #0) works
     by intra-cell trial. In case of failure, a global search for the
    target cell is
     invoked via vtkAbstractCellLocator::FindCell() and the actual work
    is done by
     either vtkCellLocator or vtkModifiedBSPTree (for datasets of type
    vtkPointSet
     only, while vtkImageData and vtkRectilinearGrid themselves are able
    to provide
     fast robust cell location). Without the involvement of
    vtkPointLocator, robust
     cell location is achieved for vtkPointSet.
    
    @warning
     vtkAbstractInterpolatedVelocityField is not thread safe. A new
    instance
     should be created by each thread.
    
    @sa
     vtkInterpolatedVelocityField vtkCellLocatorInterpolatedVelocityField
     vtkGenericInterpolatedVelocityField
    vtkCachingInterpolatedVelocityField
     vtkTemporalInterpolatedVelocityField vtkFunctionSet vtkStreamTracer
    """
    def ClearLastCellId(self):
        """
        V.ClearLastCellId()
        C++: void ClearLastCellId()
        
        Set the last cell id to -1 to incur a global cell search for the
        next point.
        """
        ...
    
    def CopyParameters(self, vtkAbstractInterpolatedVelocityField):
        """
        V.CopyParameters(vtkAbstractInterpolatedVelocityField)
        C++: virtual void CopyParameters(
            vtkAbstractInterpolatedVelocityField *from)
        
        Import parameters. Sub-classes can add more after chaining.
        """
        ...
    
    def FunctionValues(self, *float, **kwargs):
        """
        V.FunctionValues([float, ...], [float, ...]) -> int
        C++: int FunctionValues(double *x, double *f) override = 0;
        V.FunctionValues([float, ...], [float, ...], void) -> int
        C++: virtual int FunctionValues(double *x, double *f,
            void *userData)
        
        Evaluate the velocity field f at point (x, y, z).
        """
        ...
    
    def GetCacheHit(self):
        """
        V.GetCacheHit() -> int
        C++: virtual int GetCacheHit()
        
        Get the caching statistics. CacheHit refers to the number of
        level #0 cache hits while CacheMiss is the number of level #0
        cache misses.
        """
        ...
    
    def GetCacheMiss(self):
        """
        V.GetCacheMiss() -> int
        C++: virtual int GetCacheMiss()
        
        Get the caching statistics. CacheHit refers to the number of
        level #0 cache hits while CacheMiss is the number of level #0
        cache misses.
        """
        ...
    
    def GetCaching(self):
        """
        V.GetCaching() -> bool
        C++: virtual bool GetCaching()
        
        Set/Get the caching flag. If this flag is turned ON, there are
        two levels of caching for derived concrete class
        vtkInterpolatedVelocityField and one level of caching for derived
        concrete class vtkCellLocatorInterpolatedVelocityField. Otherwise
        a global cell location is always invoked for evaluating the
        function values at any point.
        """
        ...
    
    def GetFindCellStrategy(self):
        """
        V.GetFindCellStrategy() -> vtkFindCellStrategy
        C++: virtual vtkFindCellStrategy *GetFindCellStrategy()
        
        Set / get the strategy used to perform the FindCell() operation.
        This strategy is used when operating on vtkPointSet subclasses.
        Note if the input is a composite dataset then the strategy will
        be used to clone one strategy per leaf dataset.
        """
        ...
    
    def GetForceSurfaceTangentVector(self):
        """
        V.GetForceSurfaceTangentVector() -> bool
        C++: virtual bool GetForceSurfaceTangentVector()
        
        If set to true, the first three point of the cell will be used to
        compute a normal to the cell, this normal will then be removed
        from the vorticity so the resulting vector in tangent to the
        cell.
        """
        ...
    
    def GetLastCellId(self):
        """
        V.GetLastCellId() -> int
        C++: virtual vtkIdType GetLastCellId()
        
        Get/Set the id of the cell cached from last evaluation.
        """
        ...
    
    def GetLastDataSet(self):
        """
        V.GetLastDataSet() -> vtkDataSet
        C++: virtual vtkDataSet *GetLastDataSet()
        """
        ...
    
    def GetLastLocalCoordinates(self, p_float=..., p_float=..., p_float=...):
        """
        V.GetLastLocalCoordinates([float, float, float]) -> int
        C++: int GetLastLocalCoordinates(double pcoords[3])
        
        Get the interpolation weights cached from last evaluation. Return
        1 if the cached cell is valid and 0 otherwise.
        """
        ...
    
    def GetLastWeights(self, *float):
        """
        V.GetLastWeights([float, ...]) -> int
        C++: int GetLastWeights(double *w)
        
        Get the interpolation weights cached from last evaluation. Return
        1 if the cached cell is valid and 0 otherwise.
        """
        ...
    
    def GetNormalizeVector(self):
        """
        V.GetNormalizeVector() -> bool
        C++: virtual bool GetNormalizeVector()
        
        Set/Get the flag indicating vector post-normalization (following
        vector interpolation). Vector post-normalization is required to
        avoid the 'curve-overshooting' problem (caused by high velocity
        magnitude) that occurs when Cell-Length is used as the step size
        unit (particularly the Minimum step size unit). Furthermore, it
        is required by RK45 to achieve, as expected, high numerical
        accuracy (or high smoothness of flow lines) through adaptive step
        sizing. Note this operation is performed (when NormalizeVector
        TRUE) right after vector interpolation such that the differing
        amount of contribution of each node (of a cell) to the resulting
        direction of the interpolated vector, due to the possibly
        significantly-differing velocity magnitude values at the nodes
        (which is the case with large cells), can be reflected as is.
        Also note that this flag needs to be turned to FALSE after
        vtkInitialValueProblemSolver:: ComputeNextStep() as subsequent
        operations, e.g., vorticity computation, may need non-normalized
        vectors.
        """
        ...
    
    def GetNumberOfGenerationsFromBase(self, string):
        """
        V.GetNumberOfGenerationsFromBase(string) -> int
        C++: vtkIdType GetNumberOfGenerationsFromBase(const char *type)
            override;
        
        Given a the name of a base class of this class type, return the
        distance of inheritance between this class type and the named
        class (how many generations of inheritance are there between this
        class and the named class). If the named class is not in this
        class's inheritance tree, return a negative value. Valid
        responses will always be nonnegative. This method works in
        combination with vtkTypeMacro found in vtkSetGet.h.
        """
        ...
    
    def GetNumberOfGenerationsFromBaseType(self, string):
        """
        V.GetNumberOfGenerationsFromBaseType(string) -> int
        C++: static vtkIdType GetNumberOfGenerationsFromBaseType(
            const char *type)
        
        Given a the name of a base class of this class type, return the
        distance of inheritance between this class type and the named
        class (how many generations of inheritance are there between this
        class and the named class). If the named class is not in this
        class's inheritance tree, return a negative value. Valid
        responses will always be nonnegative. This method works in
        combination with vtkTypeMacro found in vtkSetGet.h.
        """
        ...
    
    def GetSurfaceDataset(self):
        """
        V.GetSurfaceDataset() -> bool
        C++: virtual bool GetSurfaceDataset()
        
        If set to true, cell within tolerance factor will always be
        found, except for edges.
        """
        ...
    
    def GetVectorsSelection(self):
        """
        V.GetVectorsSelection() -> string
        C++: virtual char *GetVectorsSelection()
        
        Get/Set the name of a spcified vector array. By default it is
        nullptr, with the active vector array for use.
        """
        ...
    
    def GetVectorsType(self):
        """
        V.GetVectorsType() -> int
        C++: virtual int GetVectorsType()
        
        Get/Set the name of a spcified vector array. By default it is
        nullptr, with the active vector array for use.
        """
        ...
    
    def IsA(self, string):
        """
        V.IsA(string) -> int
        C++: vtkTypeBool IsA(const char *type) override;
        
        Return 1 if this class is the same type of (or a subclass of) the
        named class. Returns 0 otherwise. This method works in
        combination with vtkTypeMacro found in vtkSetGet.h.
        """
        ...
    
    def IsTypeOf(self, string):
        """
        V.IsTypeOf(string) -> int
        C++: static vtkTypeBool IsTypeOf(const char *type)
        
        Return 1 if this class type is the same type of (or a subclass
        of) the named class. Returns 0 otherwise. This method works in
        combination with vtkTypeMacro found in vtkSetGet.h.
        """
        ...
    
    def NewInstance(self):
        """
        V.NewInstance() -> vtkAbstractInterpolatedVelocityField
        C++: vtkAbstractInterpolatedVelocityField *NewInstance()
        """
        ...
    
    def SafeDownCast(self, vtkObjectBase):
        """
        V.SafeDownCast(vtkObjectBase)
            -> vtkAbstractInterpolatedVelocityField
        C++: static vtkAbstractInterpolatedVelocityField *SafeDownCast(
            vtkObjectBase *o)
        """
        ...
    
    def SelectVectors(self, p_int, string):
        """
        V.SelectVectors(int, string)
        C++: void SelectVectors(int fieldAssociation,
            const char *fieldName)
        
        the association type (see vtkDataObject::FieldAssociations) and
        the name of the velocity data field
        """
        ...
    
    def SetCaching(self, bool):
        """
        V.SetCaching(bool)
        C++: virtual void SetCaching(bool _arg)
        
        Set/Get the caching flag. If this flag is turned ON, there are
        two levels of caching for derived concrete class
        vtkInterpolatedVelocityField and one level of caching for derived
        concrete class vtkCellLocatorInterpolatedVelocityField. Otherwise
        a global cell location is always invoked for evaluating the
        function values at any point.
        """
        ...
    
    def SetFindCellStrategy(self, vtkFindCellStrategy):
        """
        V.SetFindCellStrategy(vtkFindCellStrategy)
        C++: virtual void SetFindCellStrategy(vtkFindCellStrategy *)
        
        Set / get the strategy used to perform the FindCell() operation.
        This strategy is used when operating on vtkPointSet subclasses.
        Note if the input is a composite dataset then the strategy will
        be used to clone one strategy per leaf dataset.
        """
        ...
    
    def SetForceSurfaceTangentVector(self, bool):
        """
        V.SetForceSurfaceTangentVector(bool)
        C++: virtual void SetForceSurfaceTangentVector(bool _arg)
        
        If set to true, the first three point of the cell will be used to
        compute a normal to the cell, this normal will then be removed
        from the vorticity so the resulting vector in tangent to the
        cell.
        """
        ...
    
    def SetLastCellId(self, p_int):
        """
        V.SetLastCellId(int)
        C++: virtual void SetLastCellId(vtkIdType c)
        V.SetLastCellId(int, int)
        C++: virtual void SetLastCellId(vtkIdType c, int dataindex)
        
        Get/Set the id of the cell cached from last evaluation.
        """
        ...
    
    def SetNormalizeVector(self, bool):
        """
        V.SetNormalizeVector(bool)
        C++: virtual void SetNormalizeVector(bool _arg)
        
        Set/Get the flag indicating vector post-normalization (following
        vector interpolation). Vector post-normalization is required to
        avoid the 'curve-overshooting' problem (caused by high velocity
        magnitude) that occurs when Cell-Length is used as the step size
        unit (particularly the Minimum step size unit). Furthermore, it
        is required by RK45 to achieve, as expected, high numerical
        accuracy (or high smoothness of flow lines) through adaptive step
        sizing. Note this operation is performed (when NormalizeVector
        TRUE) right after vector interpolation such that the differing
        amount of contribution of each node (of a cell) to the resulting
        direction of the interpolated vector, due to the possibly
        significantly-differing velocity magnitude values at the nodes
        (which is the case with large cells), can be reflected as is.
        Also note that this flag needs to be turned to FALSE after
        vtkInitialValueProblemSolver:: ComputeNextStep() as subsequent
        operations, e.g., vorticity computation, may need non-normalized
        vectors.
        """
        ...
    
    def SetSurfaceDataset(self, bool):
        """
        V.SetSurfaceDataset(bool)
        C++: virtual void SetSurfaceDataset(bool _arg)
        
        If set to true, cell within tolerance factor will always be
        found, except for edges.
        """
        ...
    
    def __delattr__(self, *args, **kwargs):
        """ Implement delattr(self, name). """
        ...
    
    def __getattribute__(self, *args, **kwargs):
        """ Return getattr(self, name). """
        ...
    
    def __init__(self, *args, **kwargs) -> None:
        ...
    
    @staticmethod
    def __new__(*args, **kwargs):
        """ Create and return a new object.  See help(type) for accurate signature. """
        ...
    
    def __repr__(self, *args, **kwargs):
        """ Return repr(self). """
        ...
    
    def __setattr__(self, *args, **kwargs):
        """ Implement setattr(self, name, value). """
        ...
    
    def __str__(self, *args, **kwargs) -> str:
        """ Return str(self). """
        ...
    
    __this__ = ...
    __dict__ = ...
    __vtkname__ = ...


class vtkAMRInterpolatedVelocityField(vtkAbstractInterpolatedVelocityField):
    """
    vtkAMRInterpolatedVelocityField - A concrete class for obtaining
     the interpolated velocity values at a point in AMR data.
    
    Superclass: vtkAbstractInterpolatedVelocityField
    
    The main functionality supported here is the point location inside
    vtkOverlappingAMR data set.
    """
    def FindGrid(self, p_float=..., p_float=..., p_float=..., *args, **kwargs):
        """
        V.FindGrid([float, float, float], vtkOverlappingAMR, int, int)
            -> bool
        C++: static bool FindGrid(double q[3], vtkOverlappingAMR *amrds,
            unsigned int &level, unsigned int &gridId)
        """
        ...
    
    def FunctionValues(self, *float, **kwargs):
        """
        V.FunctionValues([float, ...], [float, ...]) -> int
        C++: int FunctionValues(double *x, double *f) override;
        V.FunctionValues([float, ...], [float, ...], void) -> int
        C++: virtual int FunctionValues(double *x, double *f,
            void *userData)
        
        Evaluate the velocity field f at point p. If it succeeds, then
        both the last data set (this->LastDataSet) and the last data set
        location (this->LastLevel, this->LastId) will be set according to
        where p is found.  If it fails, either p is out of bound, in
        which case both the last data set and the last location will be
        invalid or, in a multi-process setting, p is inbound but not on
        the processor.  In the last case, the last data set location is
        still valid
        """
        ...
    
    def GetAmrDataSet(self):
        """
        V.GetAmrDataSet() -> vtkOverlappingAMR
        C++: virtual vtkOverlappingAMR *GetAmrDataSet()
        """
        ...
    
    def GetLastDataSetLocation(self, p_int, p_int_1):
        """
        V.GetLastDataSetLocation(int, int) -> bool
        C++: bool GetLastDataSetLocation(unsigned int &level,
            unsigned int &id)
        """
        ...
    
    def GetNumberOfGenerationsFromBase(self, string):
        """
        V.GetNumberOfGenerationsFromBase(string) -> int
        C++: vtkIdType GetNumberOfGenerationsFromBase(const char *type)
            override;
        
        Given a the name of a base class of this class type, return the
        distance of inheritance between this class type and the named
        class (how many generations of inheritance are there between this
        class and the named class). If the named class is not in this
        class's inheritance tree, return a negative value. Valid
        responses will always be nonnegative. This method works in
        combination with vtkTypeMacro found in vtkSetGet.h.
        """
        ...
    
    def GetNumberOfGenerationsFromBaseType(self, string):
        """
        V.GetNumberOfGenerationsFromBaseType(string) -> int
        C++: static vtkIdType GetNumberOfGenerationsFromBaseType(
            const char *type)
        
        Given a the name of a base class of this class type, return the
        distance of inheritance between this class type and the named
        class (how many generations of inheritance are there between this
        class and the named class). If the named class is not in this
        class's inheritance tree, return a negative value. Valid
        responses will always be nonnegative. This method works in
        combination with vtkTypeMacro found in vtkSetGet.h.
        """
        ...
    
    def IsA(self, string):
        """
        V.IsA(string) -> int
        C++: vtkTypeBool IsA(const char *type) override;
        
        Return 1 if this class is the same type of (or a subclass of) the
        named class. Returns 0 otherwise. This method works in
        combination with vtkTypeMacro found in vtkSetGet.h.
        """
        ...
    
    def IsTypeOf(self, string):
        """
        V.IsTypeOf(string) -> int
        C++: static vtkTypeBool IsTypeOf(const char *type)
        
        Return 1 if this class type is the same type of (or a subclass
        of) the named class. Returns 0 otherwise. This method works in
        combination with vtkTypeMacro found in vtkSetGet.h.
        """
        ...
    
    def NewInstance(self):
        """
        V.NewInstance() -> vtkAMRInterpolatedVelocityField
        C++: vtkAMRInterpolatedVelocityField *NewInstance()
        """
        ...
    
    def SafeDownCast(self, vtkObjectBase):
        """
        V.SafeDownCast(vtkObjectBase) -> vtkAMRInterpolatedVelocityField
        C++: static vtkAMRInterpolatedVelocityField *SafeDownCast(
            vtkObjectBase *o)
        """
        ...
    
    def SetAMRData(self, vtkOverlappingAMR):
        """
        V.SetAMRData(vtkOverlappingAMR)
        C++: void SetAMRData(vtkOverlappingAMR *amr)
        """
        ...
    
    def SetLastCellId(self, p_int, p_int_1):
        """
        V.SetLastCellId(int, int)
        C++: void SetLastCellId(vtkIdType c, int dataindex) override;
        V.SetLastCellId(int)
        C++: void SetLastCellId(vtkIdType c) override;
        
        Set the id of the most recently visited cell of a dataset.
        """
        ...
    
    def SetLastDataSet(self, p_int, p_int_1):
        """
        V.SetLastDataSet(int, int) -> bool
        C++: bool SetLastDataSet(int level, int id)
        """
        ...
    
    def __delattr__(self, *args, **kwargs):
        """ Implement delattr(self, name). """
        ...
    
    def __getattribute__(self, *args, **kwargs):
        """ Return getattr(self, name). """
        ...
    
    def __init__(self, *args, **kwargs) -> None:
        ...
    
    @staticmethod
    def __new__(*args, **kwargs):
        """ Create and return a new object.  See help(type) for accurate signature. """
        ...
    
    def __repr__(self, *args, **kwargs):
        """ Return repr(self). """
        ...
    
    def __setattr__(self, *args, **kwargs):
        """ Implement setattr(self, name, value). """
        ...
    
    def __str__(self, *args, **kwargs) -> str:
        """ Return str(self). """
        ...
    
    __this__ = ...
    __dict__ = ...
    __vtkname__ = ...


class vtkCachingInterpolatedVelocityField(__vtkmodules_vtkCommonMath.vtkFunctionSet):
    """
    vtkCachingInterpolatedVelocityField - Interface for obtaining
    interpolated velocity values
    
    Superclass: vtkFunctionSet
    
    vtkCachingInterpolatedVelocityField acts as a continuous velocity
    field by performing cell interpolation on the underlying vtkDataSet.
    This is a concrete sub-class of vtkFunctionSet with
    NumberOfIndependentVariables = 4 (x,y,z,t) and NumberOfFunctions = 3
    (u,v,w). Normally, every time an evaluation is performed, the cell
    which contains the point (x,y,z) has to be found by calling FindCell.
    This is a computationally expensive operation. In certain cases, the
    cell search can be avoided or shortened by providing a guess for the
    cell id. For example, in streamline integration, the next evaluation
    is usually in the same or a neighbour cell. For this reason,
    vtkCachingInterpolatedVelocityField stores the last cell id. If
    caching is turned on, it uses this id as the starting point.
    
    @warning
    vtkCachingInterpolatedVelocityField is not thread safe. A new
    instance should be created by each thread.
    
    @sa
    vtkFunctionSet vtkStreamTracer
    
    @todo Need to clean up style to match vtk/Kitware standards. Please
    help.
    """
    def ClearLastCellInfo(self):
        """
        V.ClearLastCellInfo()
        C++: void ClearLastCellInfo()
        
        Set LastCellId to -1 and Cache to nullptr so that the next search
        does not start from the previous cell.
        """
        ...
    
    def FunctionValues(self, *float, **kwargs):
        """
        V.FunctionValues([float, ...], [float, ...]) -> int
        C++: int FunctionValues(double *x, double *f) override;
        V.FunctionValues([float, ...], [float, ...], void) -> int
        C++: virtual int FunctionValues(double *x, double *f,
            void *userData)
        
        Evaluate the velocity field, f={u,v,w}, at {x, y, z}. returns 1
        if valid, 0 if test failed
        """
        ...
    
    def GetCacheMiss(self):
        """
        V.GetCacheMiss() -> int
        C++: virtual int GetCacheMiss()
        
        Caching statistics.
        """
        ...
    
    def GetCellCacheHit(self):
        """
        V.GetCellCacheHit() -> int
        C++: virtual int GetCellCacheHit()
        
        Caching statistics.
        """
        ...
    
    def GetDataSetCacheHit(self):
        """
        V.GetDataSetCacheHit() -> int
        C++: virtual int GetDataSetCacheHit()
        
        Caching statistics.
        """
        ...
    
    def GetLastLocalCoordinates(self, p_float=..., p_float=..., p_float=...):
        """
        V.GetLastLocalCoordinates([float, float, float]) -> int
        C++: int GetLastLocalCoordinates(double pcoords[3])
        
        Returns the interpolation weights/pcoords cached from last
        evaluation if the cached cell is valid (returns 1). Otherwise, it
        does not change w and returns 0.
        """
        ...
    
    def GetLastWeights(self, *float):
        """
        V.GetLastWeights([float, ...]) -> int
        C++: int GetLastWeights(double *w)
        
        Returns the interpolation weights/pcoords cached from last
        evaluation if the cached cell is valid (returns 1). Otherwise, it
        does not change w and returns 0.
        """
        ...
    
    def GetNumberOfGenerationsFromBase(self, string):
        """
        V.GetNumberOfGenerationsFromBase(string) -> int
        C++: vtkIdType GetNumberOfGenerationsFromBase(const char *type)
            override;
        
        Given a the name of a base class of this class type, return the
        distance of inheritance between this class type and the named
        class (how many generations of inheritance are there between this
        class and the named class). If the named class is not in this
        class's inheritance tree, return a negative value. Valid
        responses will always be nonnegative. This method works in
        combination with vtkTypeMacro found in vtkSetGet.h.
        """
        ...
    
    def GetNumberOfGenerationsFromBaseType(self, string):
        """
        V.GetNumberOfGenerationsFromBaseType(string) -> int
        C++: static vtkIdType GetNumberOfGenerationsFromBaseType(
            const char *type)
        
        Given a the name of a base class of this class type, return the
        distance of inheritance between this class type and the named
        class (how many generations of inheritance are there between this
        class and the named class). If the named class is not in this
        class's inheritance tree, return a negative value. Valid
        responses will always be nonnegative. This method works in
        combination with vtkTypeMacro found in vtkSetGet.h.
        """
        ...
    
    def GetVectorsSelection(self):
        """
        V.GetVectorsSelection() -> string
        C++: virtual char *GetVectorsSelection()
        
        If you want to work with an arbitrary vector array, then set its
        name here. By default this in nullptr and the filter will use the
        active vector array.
        """
        ...
    
    def InsideTest(self, *float):
        """
        V.InsideTest([float, ...]) -> int
        C++: virtual int InsideTest(double *x)
        
        Evaluate the velocity field, f={u,v,w}, at {x, y, z}. returns 1
        if valid, 0 if test failed
        """
        ...
    
    def IsA(self, string):
        """
        V.IsA(string) -> int
        C++: vtkTypeBool IsA(const char *type) override;
        
        Return 1 if this class is the same type of (or a subclass of) the
        named class. Returns 0 otherwise. This method works in
        combination with vtkTypeMacro found in vtkSetGet.h.
        """
        ...
    
    def IsTypeOf(self, string):
        """
        V.IsTypeOf(string) -> int
        C++: static vtkTypeBool IsTypeOf(const char *type)
        
        Return 1 if this class type is the same type of (or a subclass
        of) the named class. Returns 0 otherwise. This method works in
        combination with vtkTypeMacro found in vtkSetGet.h.
        """
        ...
    
    def NewInstance(self):
        """
        V.NewInstance() -> vtkCachingInterpolatedVelocityField
        C++: vtkCachingInterpolatedVelocityField *NewInstance()
        """
        ...
    
    def SafeDownCast(self, vtkObjectBase):
        """
        V.SafeDownCast(vtkObjectBase)
            -> vtkCachingInterpolatedVelocityField
        C++: static vtkCachingInterpolatedVelocityField *SafeDownCast(
            vtkObjectBase *o)
        """
        ...
    
    def SelectVectors(self, string):
        """
        V.SelectVectors(string)
        C++: void SelectVectors(const char *fieldName)
        
        If you want to work with an arbitrary vector array, then set its
        name here. By default this in nullptr and the filter will use the
        active vector array.
        """
        ...
    
    def SetDataSet(self, p_int, vtkDataSet, bool, vtkAbstractCellLocator):
        """
        V.SetDataSet(int, vtkDataSet, bool, vtkAbstractCellLocator)
        C++: virtual void SetDataSet(int I, vtkDataSet *dataset,
            bool staticdataset, vtkAbstractCellLocator *locator)
        
        Add a dataset used by the interpolation function evaluation.
        """
        ...
    
    def SetLastCellInfo(self, p_int, p_int_1):
        """
        V.SetLastCellInfo(int, int)
        C++: void SetLastCellInfo(vtkIdType c, int datasetindex)
        
        Set LastCellId to c and LastCacheIndex datasetindex, cached from
        last evaluation. If c isn't -1 then the corresponding cell is
        stored in Cache->Cell. These values should be valid or an
        assertion will be triggered.
        """
        ...
    
    def __delattr__(self, *args, **kwargs):
        """ Implement delattr(self, name). """
        ...
    
    def __getattribute__(self, *args, **kwargs):
        """ Return getattr(self, name). """
        ...
    
    def __init__(self, *args, **kwargs) -> None:
        ...
    
    @staticmethod
    def __new__(*args, **kwargs):
        """ Create and return a new object.  See help(type) for accurate signature. """
        ...
    
    def __repr__(self, *args, **kwargs):
        """ Return repr(self). """
        ...
    
    def __setattr__(self, *args, **kwargs):
        """ Implement setattr(self, name, value). """
        ...
    
    def __str__(self, *args, **kwargs) -> str:
        """ Return str(self). """
        ...
    
    __this__ = ...
    __dict__ = ...
    __vtkname__ = ...


class vtkCompositeInterpolatedVelocityField(vtkAbstractInterpolatedVelocityField):
    """
    vtkCompositeInterpolatedVelocityField - An abstract class for
     obtaining the interpolated velocity values at a point
    
    Superclass: vtkAbstractInterpolatedVelocityField
    
    vtkCompositeInterpolatedVelocityField acts as a continuous velocity
    field
     by performing cell interpolation on one or more underlying
    vtkDataSets.
    
    @warning
     vtkCompositeInterpolatedVelocityField is not thread safe. A new
    instance
     should be created by each thread.
    
    @sa
     vtkInterpolatedVelocityField vtkCellLocatorInterpolatedVelocityField
     vtkGenericInterpolatedVelocityField
    vtkCachingInterpolatedVelocityField
     vtkTemporalInterpolatedVelocityField vtkFunctionSet vtkStreamTracer
    """
    def AddDataSet(self, vtkDataSet):
        """
        V.AddDataSet(vtkDataSet)
        C++: virtual void AddDataSet(vtkDataSet *dataset)
        
        Add a dataset for implicit velocity function evaluation. If more
        than one dataset is added, the evaluation point is searched in
        all until a match is found. THIS FUNCTION DOES NOT CHANGE THE
        REFERENCE COUNT OF dataset FOR THREAD SAFETY REASONS.
        """
        ...
    
    def GetLastDataSetIndex(self):
        """
        V.GetLastDataSetIndex() -> int
        C++: virtual int GetLastDataSetIndex()
        
        Get the most recently visited dataset and its id. The dataset is
        used for a guess regarding where the next point will be, without
        searching through all datasets. When setting the last dataset,
        care is needed as no reference counting or checks are performed.
        This feature is intended for custom interpolators only that cache
        datasets independently.
        """
        ...
    
    def GetNumberOfGenerationsFromBase(self, string):
        """
        V.GetNumberOfGenerationsFromBase(string) -> int
        C++: vtkIdType GetNumberOfGenerationsFromBase(const char *type)
            override;
        
        Given a the name of a base class of this class type, return the
        distance of inheritance between this class type and the named
        class (how many generations of inheritance are there between this
        class and the named class). If the named class is not in this
        class's inheritance tree, return a negative value. Valid
        responses will always be nonnegative. This method works in
        combination with vtkTypeMacro found in vtkSetGet.h.
        """
        ...
    
    def GetNumberOfGenerationsFromBaseType(self, string):
        """
        V.GetNumberOfGenerationsFromBaseType(string) -> int
        C++: static vtkIdType GetNumberOfGenerationsFromBaseType(
            const char *type)
        
        Given a the name of a base class of this class type, return the
        distance of inheritance between this class type and the named
        class (how many generations of inheritance are there between this
        class and the named class). If the named class is not in this
        class's inheritance tree, return a negative value. Valid
        responses will always be nonnegative. This method works in
        combination with vtkTypeMacro found in vtkSetGet.h.
        """
        ...
    
    def IsA(self, string):
        """
        V.IsA(string) -> int
        C++: vtkTypeBool IsA(const char *type) override;
        
        Return 1 if this class is the same type of (or a subclass of) the
        named class. Returns 0 otherwise. This method works in
        combination with vtkTypeMacro found in vtkSetGet.h.
        """
        ...
    
    def IsTypeOf(self, string):
        """
        V.IsTypeOf(string) -> int
        C++: static vtkTypeBool IsTypeOf(const char *type)
        
        Return 1 if this class type is the same type of (or a subclass
        of) the named class. Returns 0 otherwise. This method works in
        combination with vtkTypeMacro found in vtkSetGet.h.
        """
        ...
    
    def NewInstance(self):
        """
        V.NewInstance() -> vtkCompositeInterpolatedVelocityField
        C++: vtkCompositeInterpolatedVelocityField *NewInstance()
        """
        ...
    
    def SafeDownCast(self, vtkObjectBase):
        """
        V.SafeDownCast(vtkObjectBase)
            -> vtkCompositeInterpolatedVelocityField
        C++: static vtkCompositeInterpolatedVelocityField *SafeDownCast(
            vtkObjectBase *o)
        """
        ...
    
    def __delattr__(self, *args, **kwargs):
        """ Implement delattr(self, name). """
        ...
    
    def __getattribute__(self, *args, **kwargs):
        """ Return getattr(self, name). """
        ...
    
    def __init__(self, *args, **kwargs) -> None:
        ...
    
    @staticmethod
    def __new__(*args, **kwargs):
        """ Create and return a new object.  See help(type) for accurate signature. """
        ...
    
    def __repr__(self, *args, **kwargs):
        """ Return repr(self). """
        ...
    
    def __setattr__(self, *args, **kwargs):
        """ Implement setattr(self, name, value). """
        ...
    
    def __str__(self, *args, **kwargs) -> str:
        """ Return str(self). """
        ...
    
    __this__ = ...
    __dict__ = ...
    __vtkname__ = ...


class vtkCellLocatorInterpolatedVelocityField(vtkCompositeInterpolatedVelocityField):
    """
    vtkCellLocatorInterpolatedVelocityField - A concrete class for
     obtaining the interpolated velocity values at a point.
    
    Superclass: vtkCompositeInterpolatedVelocityField
    
    vtkCellLocatorInterpolatedVelocityField acts as a continuous velocity
     field via cell interpolation on a vtkDataSet,
    NumberOfIndependentVariables
     = 4 (x,y,z,t) and NumberOfFunctions = 3 (u,v,w). As a concrete
    sub-class
     of vtkCompositeInterpolatedVelocityField, it adopts
    vtkAbstractCellLocator's
     sub-classes, e.g., vtkCellLocator and vtkModifiedBSPTree, without
    the use
     of vtkPointLocator ( employed by vtkDataSet/vtkPointSet::FindCell()
    in
     vtkInterpolatedVelocityField ).
    vtkCellLocatorInterpolatedVelocityField
     adopts one level of cell caching. Specifically, if the next point is
    still
     within the previous cell, cell location is then simply skipped and
    vtkCell::
     EvaluatePosition() is called to obtain the new parametric
    coordinates and
     weights that are used to interpolate the velocity function values
    across the
     vertices of this cell. Otherwise a global cell (the target
    containing the next
     point) location is instead directly invoked, without exploiting the
    clue that
     vtkInterpolatedVelocityField makes use of from the previous cell (an
    immediate
     neighbor). Although ignoring the neighbor cell may incur a
    relatively high
     computational cost, vtkCellLocatorInterpolatedVelocityField is more
    robust in
     locating the target cell than its sibling class
    vtkInterpolatedVelocityField.
    
    @warning
     vtkCellLocatorInterpolatedVelocityField is not thread safe. A new
    instance
     should be created by each thread.
    
    @sa
     vtkCompositeInterpolatedVelocityField vtkInterpolatedVelocityField
     vtkGenericInterpolatedVelocityField
    vtkCachingInterpolatedVelocityField
     vtkTemporalInterpolatedVelocityField vtkFunctionSet vtkStreamTracer
    """
    def AddDataSet(self, vtkDataSet):
        """
        V.AddDataSet(vtkDataSet)
        C++: void AddDataSet(vtkDataSet *dataset) override;
        
        Add a dataset coupled with a cell locator (of type
        vtkAbstractCellLocator) for vector function evaluation. Note the
        use of a vtkAbstractCellLocator enables robust cell location. If
        more than one dataset is added, the evaluation point is searched
        in all until a match is found. THIS FUNCTION DOES NOT CHANGE THE
        REFERENCE COUNT OF dataset FOR THREAD SAFETY REASONS.
        """
        ...
    
    def CopyParameters(self, vtkAbstractInterpolatedVelocityField):
        """
        V.CopyParameters(vtkAbstractInterpolatedVelocityField)
        C++: void CopyParameters(
            vtkAbstractInterpolatedVelocityField *from) override;
        
        Import parameters. Sub-classes can add more after chaining.
        """
        ...
    
    def FunctionValues(self, *float, **kwargs):
        """
        V.FunctionValues([float, ...], [float, ...]) -> int
        C++: int FunctionValues(double *x, double *f) override;
        V.FunctionValues([float, ...], [float, ...], void) -> int
        C++: virtual int FunctionValues(double *x, double *f,
            void *userData)
        
        Evaluate the velocity field f at point (x, y, z).
        """
        ...
    
    def GetCellLocatorPrototype(self):
        """
        V.GetCellLocatorPrototype() -> vtkAbstractCellLocator
        C++: virtual vtkAbstractCellLocator *GetCellLocatorPrototype()
        
        Set/Get the prototype of the cell locator that is used for
        interpolating the velocity field during integration. The
        prototype is used to instantiate locators for performing
        interpolation. By default, a vtkModifiedBSPTree is used - other
        classes such as vtkStaticCellLocator can be faster.
        """
        ...
    
    def GetLastCellLocator(self):
        """
        V.GetLastCellLocator() -> vtkAbstractCellLocator
        C++: virtual vtkAbstractCellLocator *GetLastCellLocator()
        
        Get the cell locator attached to the most recently visited
        dataset.
        """
        ...
    
    def GetNumberOfGenerationsFromBase(self, string):
        """
        V.GetNumberOfGenerationsFromBase(string) -> int
        C++: vtkIdType GetNumberOfGenerationsFromBase(const char *type)
            override;
        
        Given a the name of a base class of this class type, return the
        distance of inheritance between this class type and the named
        class (how many generations of inheritance are there between this
        class and the named class). If the named class is not in this
        class's inheritance tree, return a negative value. Valid
        responses will always be nonnegative. This method works in
        combination with vtkTypeMacro found in vtkSetGet.h.
        """
        ...
    
    def GetNumberOfGenerationsFromBaseType(self, string):
        """
        V.GetNumberOfGenerationsFromBaseType(string) -> int
        C++: static vtkIdType GetNumberOfGenerationsFromBaseType(
            const char *type)
        
        Given a the name of a base class of this class type, return the
        distance of inheritance between this class type and the named
        class (how many generations of inheritance are there between this
        class and the named class). If the named class is not in this
        class's inheritance tree, return a negative value. Valid
        responses will always be nonnegative. This method works in
        combination with vtkTypeMacro found in vtkSetGet.h.
        """
        ...
    
    def IsA(self, string):
        """
        V.IsA(string) -> int
        C++: vtkTypeBool IsA(const char *type) override;
        
        Return 1 if this class is the same type of (or a subclass of) the
        named class. Returns 0 otherwise. This method works in
        combination with vtkTypeMacro found in vtkSetGet.h.
        """
        ...
    
    def IsTypeOf(self, string):
        """
        V.IsTypeOf(string) -> int
        C++: static vtkTypeBool IsTypeOf(const char *type)
        
        Return 1 if this class type is the same type of (or a subclass
        of) the named class. Returns 0 otherwise. This method works in
        combination with vtkTypeMacro found in vtkSetGet.h.
        """
        ...
    
    def NewInstance(self):
        """
        V.NewInstance() -> vtkCellLocatorInterpolatedVelocityField
        C++: vtkCellLocatorInterpolatedVelocityField *NewInstance()
        """
        ...
    
    def SafeDownCast(self, vtkObjectBase):
        """
        V.SafeDownCast(vtkObjectBase)
            -> vtkCellLocatorInterpolatedVelocityField
        C++: static vtkCellLocatorInterpolatedVelocityField *SafeDownCast(
            vtkObjectBase *o)
        """
        ...
    
    def SetCellLocatorPrototype(self, vtkAbstractCellLocator):
        """
        V.SetCellLocatorPrototype(vtkAbstractCellLocator)
        C++: void SetCellLocatorPrototype(
            vtkAbstractCellLocator *prototype)
        
        Set/Get the prototype of the cell locator that is used for
        interpolating the velocity field during integration. The
        prototype is used to instantiate locators for performing
        interpolation. By default, a vtkModifiedBSPTree is used - other
        classes such as vtkStaticCellLocator can be faster.
        """
        ...
    
    def SetLastCellId(self, p_int, p_int_1):
        """
        V.SetLastCellId(int, int)
        C++: void SetLastCellId(vtkIdType c, int dataindex) override;
        V.SetLastCellId(int)
        C++: void SetLastCellId(vtkIdType c) override;
        
        Set the cell id cached by the last evaluation within a specified
        dataset.
        """
        ...
    
    def __delattr__(self, *args, **kwargs):
        """ Implement delattr(self, name). """
        ...
    
    def __getattribute__(self, *args, **kwargs):
        """ Return getattr(self, name). """
        ...
    
    def __init__(self, *args, **kwargs) -> None:
        ...
    
    @staticmethod
    def __new__(*args, **kwargs):
        """ Create and return a new object.  See help(type) for accurate signature. """
        ...
    
    def __repr__(self, *args, **kwargs):
        """ Return repr(self). """
        ...
    
    def __setattr__(self, *args, **kwargs):
        """ Implement setattr(self, name, value). """
        ...
    
    def __str__(self, *args, **kwargs) -> str:
        """ Return str(self). """
        ...
    
    __this__ = ...
    __dict__ = ...
    __vtkname__ = ...


class vtkCompositeInterpolatedVelocityFieldDataSetsType(object):
    """
    vtkCompositeInterpolatedVelocityFieldDataSetsType - no description provided.
    
    vtkCompositeInterpolatedVelocityFieldDataSetsType()
    vtkCompositeInterpolatedVelocityFieldDataSetsType(
        const &vtkCompositeInterpolatedVelocityFieldDataSetsType)
    """
    def __getattribute__(self, *args, **kwargs):
        """ Return getattr(self, name). """
        ...
    
    def __hash__(self, *args, **kwargs) -> int:
        """ Return hash(self). """
        ...
    
    def __init__(self) -> None:
        ...
    
    @staticmethod
    def __new__(*args, **kwargs):
        """ Create and return a new object.  See help(type) for accurate signature. """
        ...
    
    def __repr__(self, *args, **kwargs):
        """ Return repr(self). """
        ...
    


class vtkEvenlySpacedStreamlines2D(__vtkmodules_vtkCommonExecutionModel.vtkPolyDataAlgorithm):
    """
    vtkEvenlySpacedStreamlines2D - Evenly spaced streamline generator for
    2D.
    
    Superclass: vtkPolyDataAlgorithm
    
    vtkEvenlySpacedStreamlines2D is a filter that integrates a 2D vector
    field to generate evenly-spaced streamlines.
    
    We implement the algorithm described in: Jobard, Bruno, and Wilfrid
    Lefer. "Creating evenly-spaced streamlines of arbitrary density."
    Visualization in Scientific Computing '97. Springer Vienna, 1997.
    43-55. The loop detection is described in: Liu, Zhanping, Robert
    Moorhead, and Joe Groner. "An advanced evenly-spaced streamline placement
    algorithm." IEEE Transactions on Visualization and Computer Graphics
    12.5 (2006): 965-972.
    
    The integration is performed using a specified integrator, by default
    Runge-Kutta2.
    
    vtkEvenlySpacedStreamlines2D produces polylines as the output, with
    each cell (i.e., polyline) representing a streamline. The attribute
    values associated with each streamline are stored in the cell data,
    whereas those associated with streamline-points are stored in the
    point data.
    
    vtkEvenlySpacedStreamlines2D integrates streamlines both forward and
    backward. The integration for a streamline terminates upon exiting
    the flow field domain, or if the particle speed is reduced to a value
    less than a specified terminal speed, if the current streamline gets
    too close to other streamlines
    (vtkStreamTracer::FIXED_REASONS_FOR_TERMINATION_COUNT + 1) or if the
    streamline forms a loop
    (vtkStreamTracer::FIXED_REASONS_FOR_TERMINATION_COUNT). The specific
    reason for the termination is stored in a cell array named
    ReasonForTermination.
    
    Note that normalized vectors are adopted in streamline integration,
    which achieves high numerical accuracy/smoothness of flow lines that
    is particularly guaranteed for Runge-Kutta45 with adaptive step size
    and error control). In support of this feature, the underlying step
    size is ALWAYS in arc length unit (LENGTH_UNIT) while the 'real' time
    interval (virtual for steady flows) that a particle actually takes to
    trave in a single step is obtained by dividing the arc length by the
    LOCAL speed. The overall elapsed time (i.e., the life span) of the
    particle is the sum of those individual step-wise time intervals.
    
    The quality of streamline integration can be controlled by setting
    the initial integration step (InitialIntegrationStep), particularly
    for Runge-Kutta2 and Runge-Kutta4 (with a fixed step size). We do not
    support Runge-Kutta45 (with an adaptive step size and error control)
    because a requirement of the algorithm is that sample points along a
    streamline be evenly spaced. These steps are in either LENGTH_UNIT or
    CELL_LENGTH_UNIT.
    
    The integration time, vorticity, rotation and angular velocity are
    stored in point data arrays named "IntegrationTime", "Vorticity",
    "Rotation" and "AngularVelocity", respectively (vorticity, rotation
    and angular velocity are computed only when ComputeVorticity is on).
    All point data attributes in the source dataset are interpolated on
    the new streamline points.
    
    vtkEvenlySpacedStreamlines2D supports integration through any type of
    2D dataset.
    
    The starting point, or the so-called 'seed', of the first streamline
    is set by setting StartPosition
    
    @sa
    vtkStreamTracer vtkRibbonFilter vtkRuledSurfaceFilter
    vtkInitialValueProblemSolver vtkRungeKutta2 vtkRungeKutta4
    vtkRungeKutta45 vtkParticleTracerBase vtkParticleTracer
    vtkParticlePathFilter vtkStreaklineFilter
    vtkAbstractInterpolatedVelocityField vtkInterpolatedVelocityField
    vtkCellLocatorInterpolatedVelocityField
    """
    def GetClosedLoopMaximumDistance(self):
        """
        V.GetClosedLoopMaximumDistance() -> float
        C++: virtual double GetClosedLoopMaximumDistance()
        
        Loops are considered closed if the have two points at distance
        less than this. This is expressed in IntegrationStepUnit.
        """
        ...
    
    def GetComputeVorticity(self):
        """
        V.GetComputeVorticity() -> bool
        C++: virtual bool GetComputeVorticity()
        
        Turn on/off vorticity computation at streamline points (necessary
        for generating proper stream-ribbons using the vtkRibbonFilter.
        """
        ...
    
    def GetInitialIntegrationStep(self):
        """
        V.GetInitialIntegrationStep() -> float
        C++: virtual double GetInitialIntegrationStep()
        
        Specify the Initial step size used for line integration,
        expressed in IntegrationStepUnit
        
        This is the constant / fixed size for non-adaptive integration
        methods, i.e., RK2 and RK4
        """
        ...
    
    def GetIntegrationStepUnit(self):
        """
        V.GetIntegrationStepUnit() -> int
        C++: int GetIntegrationStepUnit()
        """
        ...
    
    def GetIntegrator(self):
        """
        V.GetIntegrator() -> vtkInitialValueProblemSolver
        C++: virtual vtkInitialValueProblemSolver *GetIntegrator()
        
        Set/get the integrator type to be used for streamline generation.
        The object passed is not actually used but is cloned with
        NewInstance in the process of integration  (prototype pattern).
        The default is Runge-Kutta2. The integrator can also be changed
        using SetIntegratorType. The recognized solvers are: RUNGE_KUTTA2
         = 0 RUNGE_KUTTA4  = 1
        """
        ...
    
    def GetIntegratorType(self):
        """
        V.GetIntegratorType() -> int
        C++: int GetIntegratorType()
        
        Set/get the integrator type to be used for streamline generation.
        The object passed is not actually used but is cloned with
        NewInstance in the process of integration  (prototype pattern).
        The default is Runge-Kutta2. The integrator can also be changed
        using SetIntegratorType. The recognized solvers are: RUNGE_KUTTA2
         = 0 RUNGE_KUTTA4  = 1
        """
        ...
    
    def GetLoopAngle(self):
        """
        V.GetLoopAngle() -> float
        C++: virtual double GetLoopAngle()
        
        The angle (in radians) between the vector created by p0p1 and the
        velocity in the point closing the loop. p0 is the current point
        and p1 is the point before that.  Default value is 20 degrees in
        radians.
        """
        ...
    
    def GetMaximumNumberOfSteps(self):
        """
        V.GetMaximumNumberOfSteps() -> int
        C++: virtual vtkIdType GetMaximumNumberOfSteps()
        
        Specify the maximum number of steps for integrating a streamline.
        """
        ...
    
    def GetMinimumNumberOfLoopPoints(self):
        """
        V.GetMinimumNumberOfLoopPoints() -> int
        C++: virtual vtkIdType GetMinimumNumberOfLoopPoints()
        
        We don't try to eliminate loops with fewer points than this.
        Default value is 4.
        """
        ...
    
    def GetNumberOfGenerationsFromBase(self, string):
        """
        V.GetNumberOfGenerationsFromBase(string) -> int
        C++: vtkIdType GetNumberOfGenerationsFromBase(const char *type)
            override;
        
        Given a the name of a base class of this class type, return the
        distance of inheritance between this class type and the named
        class (how many generations of inheritance are there between this
        class and the named class). If the named class is not in this
        class's inheritance tree, return a negative value. Valid
        responses will always be nonnegative. This method works in
        combination with vtkTypeMacro found in vtkSetGet.h.
        """
        ...
    
    def GetNumberOfGenerationsFromBaseType(self, string):
        """
        V.GetNumberOfGenerationsFromBaseType(string) -> int
        C++: static vtkIdType GetNumberOfGenerationsFromBaseType(
            const char *type)
        
        Given a the name of a base class of this class type, return the
        distance of inheritance between this class type and the named
        class (how many generations of inheritance are there between this
        class and the named class). If the named class is not in this
        class's inheritance tree, return a negative value. Valid
        responses will always be nonnegative. This method works in
        combination with vtkTypeMacro found in vtkSetGet.h.
        """
        ...
    
    def GetSeparatingDistance(self):
        """
        V.GetSeparatingDistance() -> float
        C++: virtual double GetSeparatingDistance()
        
        Specify the separation distance between streamlines expressed in
        IntegrationStepUnit.
        """
        ...
    
    def GetSeparatingDistanceRatio(self):
        """
        V.GetSeparatingDistanceRatio() -> float
        C++: virtual double GetSeparatingDistanceRatio()
        
        Streamline integration is stopped if streamlines are closer than
        SeparatingDistance*SeparatingDistanceRatio to other streamlines.
        """
        ...
    
    def GetStartPosition(self):
        """
        V.GetStartPosition() -> (float, float, float)
        C++: virtual double *GetStartPosition()
        
        Specify the starting point (seed) of the first streamline in the
        global coordinate system. Search must be performed to find the
        initial cell from which to start integration. If the seed is not
        specified a random position in the input data is chosen.
        """
        ...
    
    def GetTerminalSpeed(self):
        """
        V.GetTerminalSpeed() -> float
        C++: virtual double GetTerminalSpeed()
        
        Specify the terminal speed value, below which integration is
        terminated.
        """
        ...
    
    def IsA(self, string):
        """
        V.IsA(string) -> int
        C++: vtkTypeBool IsA(const char *type) override;
        
        Return 1 if this class is the same type of (or a subclass of) the
        named class. Returns 0 otherwise. This method works in
        combination with vtkTypeMacro found in vtkSetGet.h.
        """
        ...
    
    def IsTypeOf(self, string):
        """
        V.IsTypeOf(string) -> int
        C++: static vtkTypeBool IsTypeOf(const char *type)
        
        Return 1 if this class type is the same type of (or a subclass
        of) the named class. Returns 0 otherwise. This method works in
        combination with vtkTypeMacro found in vtkSetGet.h.
        """
        ...
    
    def NewInstance(self):
        """
        V.NewInstance() -> vtkEvenlySpacedStreamlines2D
        C++: vtkEvenlySpacedStreamlines2D *NewInstance()
        """
        ...
    
    def SafeDownCast(self, vtkObjectBase):
        """
        V.SafeDownCast(vtkObjectBase) -> vtkEvenlySpacedStreamlines2D
        C++: static vtkEvenlySpacedStreamlines2D *SafeDownCast(
            vtkObjectBase *o)
        """
        ...
    
    def SetClosedLoopMaximumDistance(self, p_float):
        """
        V.SetClosedLoopMaximumDistance(float)
        C++: virtual void SetClosedLoopMaximumDistance(double _arg)
        
        Loops are considered closed if the have two points at distance
        less than this. This is expressed in IntegrationStepUnit.
        """
        ...
    
    def SetComputeVorticity(self, bool):
        """
        V.SetComputeVorticity(bool)
        C++: virtual void SetComputeVorticity(bool _arg)
        
        Turn on/off vorticity computation at streamline points (necessary
        for generating proper stream-ribbons using the vtkRibbonFilter.
        """
        ...
    
    def SetInitialIntegrationStep(self, p_float):
        """
        V.SetInitialIntegrationStep(float)
        C++: virtual void SetInitialIntegrationStep(double _arg)
        
        Specify the Initial step size used for line integration,
        expressed in IntegrationStepUnit
        
        This is the constant / fixed size for non-adaptive integration
        methods, i.e., RK2 and RK4
        """
        ...
    
    def SetIntegrationStepUnit(self, p_int):
        """
        V.SetIntegrationStepUnit(int)
        C++: void SetIntegrationStepUnit(int unit)
        
        Specify a uniform integration step unit for
        InitialIntegrationStep, and SeparatingDistance. Valid units are
        LENGTH_UNIT (1) (value is in global coordinates) and
        CELL_LENGTH_UNIT (2) (the value is in number of cell lengths)
        """
        ...
    
    def SetIntegrator(self, vtkInitialValueProblemSolver):
        """
        V.SetIntegrator(vtkInitialValueProblemSolver)
        C++: void SetIntegrator(vtkInitialValueProblemSolver *)
        
        Set/get the integrator type to be used for streamline generation.
        The object passed is not actually used but is cloned with
        NewInstance in the process of integration  (prototype pattern).
        The default is Runge-Kutta2. The integrator can also be changed
        using SetIntegratorType. The recognized solvers are: RUNGE_KUTTA2
         = 0 RUNGE_KUTTA4  = 1
        """
        ...
    
    def SetIntegratorType(self, p_int):
        """
        V.SetIntegratorType(int)
        C++: void SetIntegratorType(int type)
        
        Set/get the integrator type to be used for streamline generation.
        The object passed is not actually used but is cloned with
        NewInstance in the process of integration  (prototype pattern).
        The default is Runge-Kutta2. The integrator can also be changed
        using SetIntegratorType. The recognized solvers are: RUNGE_KUTTA2
         = 0 RUNGE_KUTTA4  = 1
        """
        ...
    
    def SetIntegratorTypeToRungeKutta2(self):
        """
        V.SetIntegratorTypeToRungeKutta2()
        C++: void SetIntegratorTypeToRungeKutta2()
        
        Set/get the integrator type to be used for streamline generation.
        The object passed is not actually used but is cloned with
        NewInstance in the process of integration  (prototype pattern).
        The default is Runge-Kutta2. The integrator can also be changed
        using SetIntegratorType. The recognized solvers are: RUNGE_KUTTA2
         = 0 RUNGE_KUTTA4  = 1
        """
        ...
    
    def SetIntegratorTypeToRungeKutta4(self):
        """
        V.SetIntegratorTypeToRungeKutta4()
        C++: void SetIntegratorTypeToRungeKutta4()
        
        Set/get the integrator type to be used for streamline generation.
        The object passed is not actually used but is cloned with
        NewInstance in the process of integration  (prototype pattern).
        The default is Runge-Kutta2. The integrator can also be changed
        using SetIntegratorType. The recognized solvers are: RUNGE_KUTTA2
         = 0 RUNGE_KUTTA4  = 1
        """
        ...
    
    def SetInterpolatorPrototype(self, vtkAbstractInterpolatedVelocityField):
        """
        V.SetInterpolatorPrototype(vtkAbstractInterpolatedVelocityField)
        C++: void SetInterpolatorPrototype(
            vtkAbstractInterpolatedVelocityField *ivf)
        
        The object used to interpolate the velocity field during
        integration is of the same class as this prototype.
        """
        ...
    
    def SetInterpolatorType(self, p_int):
        """
        V.SetInterpolatorType(int)
        C++: void SetInterpolatorType(int interpType)
        
        Set the type of the velocity field interpolator to determine
        whether vtkInterpolatedVelocityField
        (INTERPOLATOR_WITH_DATASET_POINT_LOCATOR) or
        vtkCellLocatorInterpolatedVelocityField
        (INTERPOLATOR_WITH_CELL_LOCATOR) is employed for locating cells
        during streamline integration. The latter (adopting
        vtkAbstractCellLocator sub-classes such as vtkCellLocator and
        vtkModifiedBSPTree) is more robust then the former (through
        vtkDataSet / vtkPointSet::FindCell() coupled with
        vtkPointLocator).
        """
        ...
    
    def SetInterpolatorTypeToCellLocator(self):
        """
        V.SetInterpolatorTypeToCellLocator()
        C++: void SetInterpolatorTypeToCellLocator()
        
        Set the velocity field interpolator type to the one involving a
        cell locator.
        """
        ...
    
    def SetInterpolatorTypeToDataSetPointLocator(self):
        """
        V.SetInterpolatorTypeToDataSetPointLocator()
        C++: void SetInterpolatorTypeToDataSetPointLocator()
        
        Set the velocity field interpolator type to the one involving a
        dataset point locator.
        """
        ...
    
    def SetLoopAngle(self, p_float):
        """
        V.SetLoopAngle(float)
        C++: virtual void SetLoopAngle(double _arg)
        
        The angle (in radians) between the vector created by p0p1 and the
        velocity in the point closing the loop. p0 is the current point
        and p1 is the point before that.  Default value is 20 degrees in
        radians.
        """
        ...
    
    def SetMaximumNumberOfSteps(self, p_int):
        """
        V.SetMaximumNumberOfSteps(int)
        C++: virtual void SetMaximumNumberOfSteps(vtkIdType _arg)
        
        Specify the maximum number of steps for integrating a streamline.
        """
        ...
    
    def SetMinimumNumberOfLoopPoints(self, p_int):
        """
        V.SetMinimumNumberOfLoopPoints(int)
        C++: virtual void SetMinimumNumberOfLoopPoints(vtkIdType _arg)
        
        We don't try to eliminate loops with fewer points than this.
        Default value is 4.
        """
        ...
    
    def SetSeparatingDistance(self, p_float):
        """
        V.SetSeparatingDistance(float)
        C++: virtual void SetSeparatingDistance(double _arg)
        
        Specify the separation distance between streamlines expressed in
        IntegrationStepUnit.
        """
        ...
    
    def SetSeparatingDistanceRatio(self, p_float):
        """
        V.SetSeparatingDistanceRatio(float)
        C++: virtual void SetSeparatingDistanceRatio(double _arg)
        
        Streamline integration is stopped if streamlines are closer than
        SeparatingDistance*SeparatingDistanceRatio to other streamlines.
        """
        ...
    
    def SetStartPosition(self, p_float, p_float_1, p_float_2):
        """
        V.SetStartPosition(float, float, float)
        C++: virtual void SetStartPosition(double _arg1, double _arg2,
            double _arg3)
        V.SetStartPosition((float, float, float))
        C++: virtual void SetStartPosition(const double _arg[3])
        
        Specify the starting point (seed) of the first streamline in the
        global coordinate system. Search must be performed to find the
        initial cell from which to start integration. If the seed is not
        specified a random position in the input data is chosen.
        """
        ...
    
    def SetTerminalSpeed(self, p_float):
        """
        V.SetTerminalSpeed(float)
        C++: virtual void SetTerminalSpeed(double _arg)
        
        Specify the terminal speed value, below which integration is
        terminated.
        """
        ...
    
    def __delattr__(self, *args, **kwargs):
        """ Implement delattr(self, name). """
        ...
    
    def __getattribute__(self, *args, **kwargs):
        """ Return getattr(self, name). """
        ...
    
    def __init__(self, *args, **kwargs) -> None:
        ...
    
    @staticmethod
    def __new__(*args, **kwargs):
        """ Create and return a new object.  See help(type) for accurate signature. """
        ...
    
    def __repr__(self, *args, **kwargs):
        """ Return repr(self). """
        ...
    
    def __setattr__(self, *args, **kwargs):
        """ Implement setattr(self, name, value). """
        ...
    
    def __str__(self, *args, **kwargs) -> str:
        """ Return str(self). """
        ...
    
    __this__ = ...
    __dict__ = ...
    __vtkname__ = ...


class vtkInterpolatedVelocityField(vtkCompositeInterpolatedVelocityField):
    """
    vtkInterpolatedVelocityField - A concrete class for obtaining
     the interpolated velocity values at a point.
    
    Superclass: vtkCompositeInterpolatedVelocityField
    
    vtkInterpolatedVelocityField acts as a continuous velocity field via
    cell interpolation on a vtkDataSet, NumberOfIndependentVariables = 4
    (x,y,z,t) and NumberOfFunctions = 3 (u,v,w). As a concrete sub-class
    of vtkCompositeInterpolatedVelocityField, this class adopts two
    levels of cell caching for faster though less robust cell location
    than its sibling class vtkCellLocatorInterpolatedVelocityField. Level
    #0 begins with intra-cell caching. Specifically, if the previous cell
    is valid and the next point is still within it, (
    vtkCell::EvaluatePosition() returns 1, coupled with the new
    parametric coordinates and weights ), the function values are
    interpolated and vtkCell::EvaluatePosition() is invoked only. If it
    fails, level #1 follows by inter-cell location of the target cell
    (that contains the next point). By inter-cell, the previous cell
    gives an important clue / guess or serves as an immediate neighbor to
    aid in the location of the target cell (as is typically the case with
    integrating a streamline across cells) by means of vtkDataSet::
    FindCell(). If this still fails, a global cell search is invoked via
    vtkDataSet::FindCell().
    
    Regardless of inter-cell or global search, a point locator is
    employed as a crucial tool underlying the interpolation process. The
    use of a point locator, while faster than a cell locator, is not
    optimal and may cause vtkInterpolatedVelocityField to return
    incorrect results (i.e., premature streamline termination) for
    datasets defined on complex grids (especially those this
    discontinuous/incompatible cells). In these cases, try
    vtkCellLocatorInterpolatedVelocityField which produces the best
    results at the cost of speed.
    
    @warning
    vtkInterpolatedVelocityField is not thread safe. A new instance
    should be created by each thread.
    
    @sa
     vtkCompositeInterpolatedVelocityField
    vtkCellLocatorInterpolatedVelocityField
     vtkGenericInterpolatedVelocityField
    vtkCachingInterpolatedVelocityField
     vtkTemporalInterpolatedVelocityField vtkFunctionSet vtkStreamTracer
    """
    def AddDataSet(self, vtkDataSet):
        """
        V.AddDataSet(vtkDataSet)
        C++: void AddDataSet(vtkDataSet *dataset) override;
        
        Add a dataset used for the implicit function evaluation. If more
        than one dataset is added, the evaluation point is searched in
        all until a match is found. THIS FUNCTION DOES NOT CHANGE THE
        REFERENCE COUNT OF DATASET FOR THREAD SAFETY REASONS.
        """
        ...
    
    def FunctionValues(self, *float, **kwargs):
        """
        V.FunctionValues([float, ...], [float, ...]) -> int
        C++: int FunctionValues(double *x, double *f) override;
        V.FunctionValues([float, ...], [float, ...], void) -> int
        C++: virtual int FunctionValues(double *x, double *f,
            void *userData)
        
        Evaluate the velocity field f at point (x, y, z).
        """
        ...
    
    def GetNumberOfGenerationsFromBase(self, string):
        """
        V.GetNumberOfGenerationsFromBase(string) -> int
        C++: vtkIdType GetNumberOfGenerationsFromBase(const char *type)
            override;
        
        Standard methods for type information and printing.
        """
        ...
    
    def GetNumberOfGenerationsFromBaseType(self, string):
        """
        V.GetNumberOfGenerationsFromBaseType(string) -> int
        C++: static vtkIdType GetNumberOfGenerationsFromBaseType(
            const char *type)
        
        Standard methods for type information and printing.
        """
        ...
    
    def IsA(self, string):
        """
        V.IsA(string) -> int
        C++: vtkTypeBool IsA(const char *type) override;
        
        Standard methods for type information and printing.
        """
        ...
    
    def IsTypeOf(self, string):
        """
        V.IsTypeOf(string) -> int
        C++: static vtkTypeBool IsTypeOf(const char *type)
        
        Standard methods for type information and printing.
        """
        ...
    
    def NewInstance(self):
        """
        V.NewInstance() -> vtkInterpolatedVelocityField
        C++: vtkInterpolatedVelocityField *NewInstance()
        
        Standard methods for type information and printing.
        """
        ...
    
    def SafeDownCast(self, vtkObjectBase):
        """
        V.SafeDownCast(vtkObjectBase) -> vtkInterpolatedVelocityField
        C++: static vtkInterpolatedVelocityField *SafeDownCast(
            vtkObjectBase *o)
        
        Standard methods for type information and printing.
        """
        ...
    
    def SetLastCellId(self, p_int, p_int_1):
        """
        V.SetLastCellId(int, int)
        C++: void SetLastCellId(vtkIdType c, int dataindex) override;
        V.SetLastCellId(int)
        C++: void SetLastCellId(vtkIdType c) override;
        
        Set the cell id cached by the last evaluation within a specified
        dataset.
        """
        ...
    
    def SnapPointOnCell(self, *float, **kwargs):
        """
        V.SnapPointOnCell([float, ...], [float, ...]) -> int
        C++: virtual int SnapPointOnCell(double *pOrigin, double *pProj)
        
        Project the provided point on current cell, current dataset.
        """
        ...
    
    def __delattr__(self, *args, **kwargs):
        """ Implement delattr(self, name). """
        ...
    
    def __getattribute__(self, *args, **kwargs):
        """ Return getattr(self, name). """
        ...
    
    def __init__(self, *args, **kwargs) -> None:
        ...
    
    @staticmethod
    def __new__(*args, **kwargs):
        """ Create and return a new object.  See help(type) for accurate signature. """
        ...
    
    def __repr__(self, *args, **kwargs):
        """ Return repr(self). """
        ...
    
    def __setattr__(self, *args, **kwargs):
        """ Implement setattr(self, name, value). """
        ...
    
    def __str__(self, *args, **kwargs) -> str:
        """ Return str(self). """
        ...
    
    __this__ = ...
    __dict__ = ...
    __vtkname__ = ...


class vtkLagrangianBasicIntegrationModel(__vtkmodules_vtkCommonMath.vtkFunctionSet):
    """
    vtkLagrangianBasicIntegrationModel - vtkFunctionSet abstract
    implementation to be used in the vtkLagrangianParticleTracker
    integrator.
    
    Superclass: vtkFunctionSet
    
    This vtkFunctionSet abstract implementation is meant to be used as a
    parameter of vtkLagrangianParticleTracker. It manages multiple
    dataset locators in order to evaluate the
    vtkFunctionSet::FunctionValues method. The actual FunctionValues
    implementation should be found in the class inheriting this class.
    Input Arrays to process are expected as follows: Index 0 :
    "SurfaceType" array of surface input of the particle tracker
    
    Inherited classes MUST implement int FunctionValues(vtkDataSet*
    detaSet, vtkIdType cellId, double* weights,
       double * x, double * f); to define how the integration works.
    
    Inherited classes could reimplement InitializeVariablesParticleData
    and InsertVariablesParticleData to add new UserVariables to integrate
    with.
    
    Inherited classes could reimplement InteractWithSurface or other
    surface interaction methods to change the way particles interact with
    surfaces.
    
    Inherited classes could reimplement IntersectWithLine to use a
    specific algorithm to intersect particles and surface cells.
    
    Inherited classes could reimplement CheckFreeFlightTermination to set
    the way particles terminate in free flight.
    
    Inherited classes could reimplement Initialize*Data and Insert*Data
    in order to customize the output of the tracker
    
    @sa
    vtkLagrangianParticleTracker vtkLagrangianParticle
    vtkLagrangianMatidaIntegrationModel
    """
    def AddDataSet(self, vtkDataSet, bool, p_int):
        """
        V.AddDataSet(vtkDataSet, bool, int)
        C++: virtual void AddDataSet(vtkDataSet *dataset,
            bool surface=false, unsigned int surfaceFlatIndex=0)
        
        Add a dataset to locate cells in This create a specific locator
        for the provided dataset using the Locator member of this class
        The surface flag allow to manage surfaces datasets for surface
        interaction instead of flow datasets surfaceFlatIndex, used only
        with composite surface, in order to identify the flatIndex of the
        surface for particle interaction
        """
        ...
    
    def ClearDataSets(self, bool):
        """
        V.ClearDataSets(bool)
        C++: virtual void ClearDataSets(bool surface=false)
        
        Add a dataset to locate cells in This create a specific locator
        for the provided dataset using the Locator member of this class
        The surface flag allow to manage surfaces datasets for surface
        interaction instead of flow datasets surfaceFlatIndex, used only
        with composite surface, in order to identify the flatIndex of the
        surface for particle interaction
        """
        ...
    
    def FinalizeOutputs(self, vtkPolyData, vtkDataObject):
        """
        V.FinalizeOutputs(vtkPolyData, vtkDataObject) -> bool
        C++: virtual bool FinalizeOutputs(
            vtkPolyData *particlePathsOutput,
            vtkDataObject *interractionOutput)
        
        Enable model post process on output Return true if successful,
        false otherwise Empty and Always return true with basic model
        """
        ...
    
    def FinalizeThreadedData(self, vtkLagrangianThreadedData):
        """
        V.FinalizeThreadedData(vtkLagrangianThreadedData)
        C++: virtual void FinalizeThreadedData(
            vtkLagrangianThreadedData *data)
        
        Let the model finalize and deallocate a user data at thread level
        This method is called serially for each thread and does not
        require to be thread safe.
        """
        ...
    
    def FunctionValues(self, *float, **kwargs):
        """
        V.FunctionValues([float, ...], [float, ...], void) -> int
        C++: int FunctionValues(double *x, double *f, void *userData)
            override;
        V.FunctionValues([float, ...], [float, ...]) -> int
        C++: virtual int FunctionValues(double *x, double *f)
        
        Evaluate integration model velocity f at position x. Look for the
        cell containing the position x in all its added datasets if found
        this will call FunctionValues(vtkDataSet* detaSet, vtkIdType
        cellId, double* x, double* f) This method is thread safe.
        """
        ...
    
    def GetLocator(self):
        """
        V.GetLocator() -> vtkAbstractCellLocator
        C++: virtual vtkAbstractCellLocator *GetLocator()
        
        Set/Get the locator used to locate cells in the datasets. Only
        the locator class matter here, as it is used only to create
        NewInstance of it. Default is a vtkCellLocator.
        """
        ...
    
    def GetLocatorsBuilt(self):
        """
        V.GetLocatorsBuilt() -> bool
        C++: virtual bool GetLocatorsBuilt()
        
        Get the state of the current locators
        """
        ...
    
    def GetNonPlanarQuadSupport(self):
        """
        V.GetNonPlanarQuadSupport() -> bool
        C++: virtual bool GetNonPlanarQuadSupport()
        
        Set/Get Non Planar Quad Support
        """
        ...
    
    def GetNumberOfGenerationsFromBase(self, string):
        """
        V.GetNumberOfGenerationsFromBase(string) -> int
        C++: vtkIdType GetNumberOfGenerationsFromBase(const char *type)
            override;
        
        Given a the name of a base class of this class type, return the
        distance of inheritance between this class type and the named
        class (how many generations of inheritance are there between this
        class and the named class). If the named class is not in this
        class's inheritance tree, return a negative value. Valid
        responses will always be nonnegative. This method works in
        combination with vtkTypeMacro found in vtkSetGet.h.
        """
        ...
    
    def GetNumberOfGenerationsFromBaseType(self, string):
        """
        V.GetNumberOfGenerationsFromBaseType(string) -> int
        C++: static vtkIdType GetNumberOfGenerationsFromBaseType(
            const char *type)
        
        Given a the name of a base class of this class type, return the
        distance of inheritance between this class type and the named
        class (how many generations of inheritance are there between this
        class and the named class). If the named class is not in this
        class's inheritance tree, return a negative value. Valid
        responses will always be nonnegative. This method works in
        combination with vtkTypeMacro found in vtkSetGet.h.
        """
        ...
    
    def GetNumberOfTrackedUserData(self):
        """
        V.GetNumberOfTrackedUserData() -> int
        C++: virtual int GetNumberOfTrackedUserData()
        """
        ...
    
    def GetSeedArray(self, p_int, vtkPointData):
        """
        V.GetSeedArray(int, vtkPointData) -> vtkAbstractArray
        C++: virtual vtkAbstractArray *GetSeedArray(int idx,
            vtkPointData *pointData)
        
        Get a seed array, as set in setInputArrayToProcess from the
        provided seed point data
        """
        ...
    
    def GetSeedArrayComps(self):
        """
        V.GetSeedArrayComps() -> vtkIntArray
        C++: virtual vtkIntArray *GetSeedArrayComps()
        
        Get the seed arrays expected number of components Used Only be
        the vtkLagrangianSeedHelper in ParaView plugins
        """
        ...
    
    def GetSeedArrayNames(self):
        """
        V.GetSeedArrayNames() -> vtkStringArray
        C++: virtual vtkStringArray *GetSeedArrayNames()
        
        Get the seed arrays expected name Used Only be the
        vtkLagrangianSeedHelper in ParaView plugins
        """
        ...
    
    def GetSeedArrayTypes(self):
        """
        V.GetSeedArrayTypes() -> vtkIntArray
        C++: virtual vtkIntArray *GetSeedArrayTypes()
        
        Get the seed arrays expected type Used Only be the
        vtkLagrangianSeedHelper in ParaView plugins
        """
        ...
    
    def GetSurfaceArrayComps(self):
        """
        V.GetSurfaceArrayComps() -> vtkIntArray
        C++: virtual vtkIntArray *GetSurfaceArrayComps()
        
        Get the seed array expected number of components Used Only be the
        vtkLagrangianSurfaceHelper in ParaView plugins
        """
        ...
    
    def GetSurfaceArrayDefaultValues(self):
        """
        V.GetSurfaceArrayDefaultValues() -> vtkDoubleArray
        C++: virtual vtkDoubleArray *GetSurfaceArrayDefaultValues()
        
        Get the surface arrays default values for each leaf Used Only be
        the vtkLagrangianSurfaceHelper in ParaView plugins
        """
        ...
    
    def GetSurfaceArrayEnumValues(self):
        """
        V.GetSurfaceArrayEnumValues() -> vtkStringArray
        C++: virtual vtkStringArray *GetSurfaceArrayEnumValues()
        
        Get the surface arrays expected values and associated enums Used
        Only be the vtkLagrangianSurfaceHelper in ParaView plugins
        """
        ...
    
    def GetSurfaceArrayNames(self):
        """
        V.GetSurfaceArrayNames() -> vtkStringArray
        C++: virtual vtkStringArray *GetSurfaceArrayNames()
        
        Get the surface arrays expected name Used Only be the
        vtkLagrangianSurfaceHelper in ParaView plugins
        """
        ...
    
    def GetSurfaceArrayTypes(self):
        """
        V.GetSurfaceArrayTypes() -> vtkIntArray
        C++: virtual vtkIntArray *GetSurfaceArrayTypes()
        
        Get the surface arrays expected type Used Only be the
        vtkLagrangianSurfaceHelper in ParaView plugins
        """
        ...
    
    def GetTolerance(self):
        """
        V.GetTolerance() -> float
        C++: virtual double GetTolerance()
        
        Get the tolerance to use with this model.
        """
        ...
    
    def GetUseInitialIntegrationTime(self):
        """
        V.GetUseInitialIntegrationTime() -> bool
        C++: virtual bool GetUseInitialIntegrationTime()
        
        Set/Get the Use of initial integration input array to process
        """
        ...
    
    def GetWeightsSize(self):
        """
        V.GetWeightsSize() -> int
        C++: virtual int GetWeightsSize()
        
        Get the maximum weights size necessary for calling FindInLocators
        with weights
        """
        ...
    
    def InitializeInteractionData(self, vtkFieldData):
        """
        V.InitializeInteractionData(vtkFieldData)
        C++: virtual void InitializeInteractionData(vtkFieldData *data)
        
        Method used by the LPT to initialize data insertion in the
        provided vtkFieldData. It initializes Interaction. Reimplement as
        needed in acccordance with InsertInteractionData.
        """
        ...
    
    def InitializeParticleData(self, vtkFieldData, p_int):
        """
        V.InitializeParticleData(vtkFieldData, int)
        C++: virtual void InitializeParticleData(
            vtkFieldData *particleData, int maxTuples=0)
        
        Method used by the LPT to initialize data insertion in the
        provided vtkFieldData. It initializes StepNumber,
        ParticleVelocity, IntegrationTime. Reimplement as needed in
        acccordance with InsertParticleData.
        """
        ...
    
    def InitializePathData(self, vtkFieldData):
        """
        V.InitializePathData(vtkFieldData)
        C++: virtual void InitializePathData(vtkFieldData *data)
        
        Method used by the LPT to initialize data insertion in the
        provided vtkFieldData. It initializes Id, ParentID, SeedID and
        Termination. Reimplement as needed in acccordance with
        InsertPathData.
        """
        ...
    
    def InitializeThreadedData(self, vtkLagrangianThreadedData):
        """
        V.InitializeThreadedData(vtkLagrangianThreadedData)
        C++: virtual void InitializeThreadedData(
            vtkLagrangianThreadedData *data)
        
        Let the model allocate and initialize a threaded data. This
        method is thread-safe, its reimplementation should still be
        thread-safe.
        """
        ...
    
    def IsA(self, string):
        """
        V.IsA(string) -> int
        C++: vtkTypeBool IsA(const char *type) override;
        
        Return 1 if this class is the same type of (or a subclass of) the
        named class. Returns 0 otherwise. This method works in
        combination with vtkTypeMacro found in vtkSetGet.h.
        """
        ...
    
    def IsTypeOf(self, string):
        """
        V.IsTypeOf(string) -> int
        C++: static vtkTypeBool IsTypeOf(const char *type)
        
        Return 1 if this class type is the same type of (or a subclass
        of) the named class. Returns 0 otherwise. This method works in
        combination with vtkTypeMacro found in vtkSetGet.h.
        """
        ...
    
    def NewInstance(self):
        """
        V.NewInstance() -> vtkLagrangianBasicIntegrationModel
        C++: vtkLagrangianBasicIntegrationModel *NewInstance()
        """
        ...
    
    def NonPlanarQuadSupportOff(self):
        """
        V.NonPlanarQuadSupportOff()
        C++: virtual void NonPlanarQuadSupportOff()
        
        Set/Get Non Planar Quad Support
        """
        ...
    
    def NonPlanarQuadSupportOn(self):
        """
        V.NonPlanarQuadSupportOn()
        C++: virtual void NonPlanarQuadSupportOn()
        
        Set/Get Non Planar Quad Support
        """
        ...
    
    def SafeDownCast(self, vtkObjectBase):
        """
        V.SafeDownCast(vtkObjectBase)
            -> vtkLagrangianBasicIntegrationModel
        C++: static vtkLagrangianBasicIntegrationModel *SafeDownCast(
            vtkObjectBase *o)
        """
        ...
    
    def SetInputArrayToProcess(self, p_int, p_int_1, p_int_2, p_int_3, string):
        """
        V.SetInputArrayToProcess(int, int, int, int, string)
        C++: virtual void SetInputArrayToProcess(int idx, int port,
            int connection, int fieldAssociation, const char *name)
        
        Set a input array to process at a specific index, identified by a
        port, connection, fieldAssociation and a name. Each inherited
        class can specify their own input array to process
        """
        ...
    
    def SetLocator(self, vtkAbstractCellLocator):
        """
        V.SetLocator(vtkAbstractCellLocator)
        C++: virtual void SetLocator(vtkAbstractCellLocator *locator)
        
        Set/Get the locator used to locate cells in the datasets. Only
        the locator class matter here, as it is used only to create
        NewInstance of it. Default is a vtkCellLocator.
        """
        ...
    
    def SetLocatorsBuilt(self, bool):
        """
        V.SetLocatorsBuilt(bool)
        C++: virtual void SetLocatorsBuilt(bool _arg)
        
        Get the state of the current locators
        """
        ...
    
    def SetNonPlanarQuadSupport(self, bool):
        """
        V.SetNonPlanarQuadSupport(bool)
        C++: virtual void SetNonPlanarQuadSupport(bool _arg)
        
        Set/Get Non Planar Quad Support
        """
        ...
    
    def SetNumberOfTrackedUserData(self, p_int):
        """
        V.SetNumberOfTrackedUserData(int)
        C++: virtual void SetNumberOfTrackedUserData(int _arg)
        
        Set/Get the number of tracked user data attached to the
        particles. Tracked user data are data that are related to each
        particle position but are not integrated like the user variables.
        They are not saved in the particle path. Default is 0.
        """
        ...
    
    def SetTracker(self, vtkLagrangianParticleTracker):
        """
        V.SetTracker(vtkLagrangianParticleTracker)
        C++: virtual void SetTracker(
            vtkLagrangianParticleTracker *Tracker)
        
        Set the parent tracker.
        """
        ...
    
    def SetUseInitialIntegrationTime(self, bool):
        """
        V.SetUseInitialIntegrationTime(bool)
        C++: virtual void SetUseInitialIntegrationTime(bool _arg)
        
        Set/Get the Use of initial integration input array to process
        """
        ...
    
    def UseInitialIntegrationTimeOff(self):
        """
        V.UseInitialIntegrationTimeOff()
        C++: virtual void UseInitialIntegrationTimeOff()
        
        Set/Get the Use of initial integration input array to process
        """
        ...
    
    def UseInitialIntegrationTimeOn(self):
        """
        V.UseInitialIntegrationTimeOn()
        C++: virtual void UseInitialIntegrationTimeOn()
        
        Set/Get the Use of initial integration input array to process
        """
        ...
    
    def __delattr__(self, *args, **kwargs):
        """ Implement delattr(self, name). """
        ...
    
    def __getattribute__(self, *args, **kwargs):
        """ Return getattr(self, name). """
        ...
    
    def __init__(self, *args, **kwargs) -> None:
        ...
    
    @staticmethod
    def __new__(*args, **kwargs):
        """ Create and return a new object.  See help(type) for accurate signature. """
        ...
    
    def __repr__(self, *args, **kwargs):
        """ Return repr(self). """
        ...
    
    def __setattr__(self, *args, **kwargs):
        """ Implement setattr(self, name, value). """
        ...
    
    def __str__(self, *args, **kwargs) -> str:
        """ Return str(self). """
        ...
    
    __this__ = ...
    SurfaceType = ...
    SURFACE_TYPE_BOUNCE = ...
    SURFACE_TYPE_BREAK = ...
    SURFACE_TYPE_MODEL = ...
    SURFACE_TYPE_PASS = ...
    SURFACE_TYPE_TERM = ...
    VariableStep = ...
    VARIABLE_STEP_CURRENT = ...
    VARIABLE_STEP_NEXT = ...
    VARIABLE_STEP_PREV = ...
    __dict__ = ...
    __vtkname__ = ...


class vtkLagrangianMatidaIntegrationModel(vtkLagrangianBasicIntegrationModel):
    """
    vtkLagrangianMatidaIntegrationModel -
    vtkLagrangianBasicIntegrationModel implementation
    
    Superclass: vtkLagrangianBasicIntegrationModel
    
    vtkLagrangianBasicIntegrationModel implementation using article : "Matida, E. A., et al.
    "Improved numerical simulation of aerosol deposition in an idealized
    mouth-throat." Journal of Aerosol Science 35.1 (2004): 1-19." Input
    Array to process are expected as follow : Index 1 is the
    "FlowVelocity" from flow input in the tracker Index 2 is the
    "FlowDensity" from flow input in the tracker Index 3 is the
    "FlowDynamicViscosity" from flow input in the tracker Index 4 is the
    "ParticleDiameter" from seed (source) input in the tracker Index 5 is
    the "ParticleDensity" from seed (source) input in the tracker
    
    @sa
    vtkLagrangianParticleTracker vtkLagrangianParticle
    vtkLagrangianBasicIntegrationModel
    """
    def FunctionValues(self, *float, **kwargs):
        """
        V.FunctionValues([float, ...], [float, ...], void) -> int
        C++: int FunctionValues(double *x, double *f, void *userData)
            override;
        V.FunctionValues([float, ...], [float, ...]) -> int
        C++: virtual int FunctionValues(double *x, double *f)
        
        Evaluate integration model velocity f at position x. Look for the
        cell containing the position x in all its added datasets if found
        this will call FunctionValues(vtkDataSet* detaSet, vtkIdType
        cellId, double* x, double* f) This method is thread safe.
        """
        ...
    
    def GetNumberOfGenerationsFromBase(self, string):
        """
        V.GetNumberOfGenerationsFromBase(string) -> int
        C++: vtkIdType GetNumberOfGenerationsFromBase(const char *type)
            override;
        
        Given a the name of a base class of this class type, return the
        distance of inheritance between this class type and the named
        class (how many generations of inheritance are there between this
        class and the named class). If the named class is not in this
        class's inheritance tree, return a negative value. Valid
        responses will always be nonnegative. This method works in
        combination with vtkTypeMacro found in vtkSetGet.h.
        """
        ...
    
    def GetNumberOfGenerationsFromBaseType(self, string):
        """
        V.GetNumberOfGenerationsFromBaseType(string) -> int
        C++: static vtkIdType GetNumberOfGenerationsFromBaseType(
            const char *type)
        
        Given a the name of a base class of this class type, return the
        distance of inheritance between this class type and the named
        class (how many generations of inheritance are there between this
        class and the named class). If the named class is not in this
        class's inheritance tree, return a negative value. Valid
        responses will always be nonnegative. This method works in
        combination with vtkTypeMacro found in vtkSetGet.h.
        """
        ...
    
    def IsA(self, string):
        """
        V.IsA(string) -> int
        C++: vtkTypeBool IsA(const char *type) override;
        
        Return 1 if this class is the same type of (or a subclass of) the
        named class. Returns 0 otherwise. This method works in
        combination with vtkTypeMacro found in vtkSetGet.h.
        """
        ...
    
    def IsTypeOf(self, string):
        """
        V.IsTypeOf(string) -> int
        C++: static vtkTypeBool IsTypeOf(const char *type)
        
        Return 1 if this class type is the same type of (or a subclass
        of) the named class. Returns 0 otherwise. This method works in
        combination with vtkTypeMacro found in vtkSetGet.h.
        """
        ...
    
    def NewInstance(self):
        """
        V.NewInstance() -> vtkLagrangianMatidaIntegrationModel
        C++: vtkLagrangianMatidaIntegrationModel *NewInstance()
        """
        ...
    
    def SafeDownCast(self, vtkObjectBase):
        """
        V.SafeDownCast(vtkObjectBase)
            -> vtkLagrangianMatidaIntegrationModel
        C++: static vtkLagrangianMatidaIntegrationModel *SafeDownCast(
            vtkObjectBase *o)
        """
        ...
    
    def __delattr__(self, *args, **kwargs):
        """ Implement delattr(self, name). """
        ...
    
    def __getattribute__(self, *args, **kwargs):
        """ Return getattr(self, name). """
        ...
    
    def __init__(self, *args, **kwargs) -> None:
        ...
    
    @staticmethod
    def __new__(*args, **kwargs):
        """ Create and return a new object.  See help(type) for accurate signature. """
        ...
    
    def __repr__(self, *args, **kwargs):
        """ Return repr(self). """
        ...
    
    def __setattr__(self, *args, **kwargs):
        """ Implement setattr(self, name, value). """
        ...
    
    def __str__(self, *args, **kwargs) -> str:
        """ Return str(self). """
        ...
    
    __this__ = ...
    __dict__ = ...
    __vtkname__ = ...


class vtkLagrangianParticle(object):
    """
    vtkLagrangianParticle - Basis class for Lagrangian particles.
    
    Particle to inject and integrate in the vtkLagrangianParticleTracker.
    This class does NOT inherit from vtkObject in order to increase
    performance and reduce memory usage.
    
    @sa
    vtkLagrangianParticleTracker vtkLagrangianBasicIntegrationModel
    vtkLagrangianMatidaIntegrationModel
    
    vtkLagrangianParticle(int numberOfVariables, vtkIdType seedId,
        vtkIdType particleId, vtkIdType seedArrayTupleIndex,
        double integrationTime, vtkPointData *seedData, int weightsSize,
        int numberOfTrackedUserData)
    """
    def GetEquationVariables(self):
        """
        V.GetEquationVariables() -> (float, ...)
        C++: double *GetEquationVariables()
        
        Get a pointer to the particle variables array. To be used with
        vtkInitialValueProblemSolver::ComputeNextStep. returned pointer
        contains the following: x y z u v w k0 .. kn t x y z is the
        position of the particle u v w is the velocity of the particle k0
        .. kn are user variables t is the time, always the last
        variables. the number of user variables can be recovered by
        GetNumberOfUserVariables, but it is always NumberOfVariables - 7.
        """
        ...
    
    def GetId(self):
        """
        V.GetId() -> int
        C++: virtual vtkIdType GetId()
        
        Get particle id.
        """
        ...
    
    def GetIntegrationTime(self):
        """
        V.GetIntegrationTime() -> float
        C++: virtual double GetIntegrationTime()
        
        Get the integration time
        """
        ...
    
    def GetInteraction(self):
        """
        V.GetInteraction() -> int
        C++: virtual int GetInteraction()
        
        Set/Get particle interaction. Values out of enum range are
        accepted Values < 100 are system reserved and should not be used
        """
        ...
    
    def GetLastCellId(self):
        """
        V.GetLastCellId() -> int
        C++: vtkIdType GetLastCellId()
        
        Get the last traversed cell id
        """
        ...
    
    def GetLastCellPosition(self):
        """
        V.GetLastCellPosition() -> (float, ...)
        C++: double *GetLastCellPosition()
        
        Get the last position evaluated
        """
        ...
    
    def GetLastDataSet(self):
        """
        V.GetLastDataSet() -> vtkDataSet
        C++: vtkDataSet *GetLastDataSet()
        
        Get the dataset containing the last traversed cell
        """
        ...
    
    def GetLastLocator(self):
        """
        V.GetLastLocator() -> vtkAbstractCellLocator
        C++: vtkAbstractCellLocator *GetLastLocator()
        
        Get the locator used to find the last traversed cell
        """
        ...
    
    def GetLastSurfaceCellId(self):
        """
        V.GetLastSurfaceCellId() -> int
        C++: vtkIdType GetLastSurfaceCellId()
        
        Get the last intersected surface cell id.
        """
        ...
    
    def GetLastSurfaceDataSet(self):
        """
        V.GetLastSurfaceDataSet() -> vtkDataSet
        C++: vtkDataSet *GetLastSurfaceDataSet()
        
        Get the dataset containing the last intersected surface cell
        """
        ...
    
    def GetLastWeights(self):
        """
        V.GetLastWeights() -> (float, ...)
        C++: double *GetLastWeights()
        
        Get the last weights computed when locating the particle in the
        last traversed cell
        """
        ...
    
    def GetNextEquationVariables(self):
        """
        V.GetNextEquationVariables() -> (float, ...)
        C++: double *GetNextEquationVariables()
        
        Get a pointer to the particle variables array at its next
        position. To be used with
        vtkInitialValueProblemSolver::ComputeNextStep. See
        GetEquationVariables for content description
        """
        ...
    
    def GetNextPosition(self):
        """
        V.GetNextPosition() -> (float, ...)
        C++: double *GetNextPosition()
        
        Get a pointer to the next particle position. Convenience method,
        giving the same results as GetNextEquationVariables();
        """
        ...
    
    def GetNextTrackedUserData(self):
        """
        V.GetNextTrackedUserData() -> Stvector_IdE
        C++: std::vector<double> &GetNextTrackedUserData()
        
        Get a reference to NextTrackedUserData See GetTrackedUserData for
        an explanation on how to use it.
        """
        ...
    
    def GetNextUserVariables(self):
        """
        V.GetNextUserVariables() -> (float, ...)
        C++: double *GetNextUserVariables()
        
        Get a pointer to the next user variables. Convenience method,
        giving the result: GetNextEquationVariables() + 6;
        """
        ...
    
    def GetNextVelocity(self):
        """
        V.GetNextVelocity() -> (float, ...)
        C++: double *GetNextVelocity()
        
        Get a pointer to the next particle velocity. Convenience method,
        giving the result: GetNextEquationVariables() + 3;
        """
        ...
    
    def GetNumberOfSteps(self):
        """
        V.GetNumberOfSteps() -> int
        C++: virtual vtkIdType GetNumberOfSteps()
        
        Get particle current number of steps.
        """
        ...
    
    def GetNumberOfUserVariables(self):
        """
        V.GetNumberOfUserVariables() -> int
        C++: virtual int GetNumberOfUserVariables()
        
        Get the number of variables specific to the user.
        """
        ...
    
    def GetNumberOfVariables(self):
        """
        V.GetNumberOfVariables() -> int
        C++: virtual int GetNumberOfVariables()
        
        Get the number of variables used to initialize EquationVariables.
        """
        ...
    
    def GetParentId(self):
        """
        V.GetParentId() -> int
        C++: virtual vtkIdType GetParentId()
        
        Set/Get parent particle id. Allow to find the seed particle of
        any particle.
        """
        ...
    
    def GetPInsertPreviousPosition(self):
        """
        V.GetPInsertPreviousPosition() -> bool
        C++: virtual bool GetPInsertPreviousPosition()
        
        Set/Get parallel specific flag, indication to insert or not the
        previous position after streaming. No effect in serial.
        """
        ...
    
    def GetPManualShift(self):
        """
        V.GetPManualShift() -> bool
        C++: virtual bool GetPManualShift()
        
        Set/Get parallel specific flag, indication that the particle may
        be manually shifted after streaming. No effect in serial.
        """
        ...
    
    def GetPosition(self):
        """
        V.GetPosition() -> (float, ...)
        C++: double *GetPosition()
        
        Get a pointer to the particle position. Convenience method,
        giving the same results as GetEquationVariables().
        """
        ...
    
    def GetPositionVectorMagnitude(self):
        """
        V.GetPositionVectorMagnitude() -> float
        C++: double GetPositionVectorMagnitude()
        
        Compute and return the position vector magnitude
        """
        ...
    
    def GetPrevEquationVariables(self):
        """
        V.GetPrevEquationVariables() -> (float, ...)
        C++: double *GetPrevEquationVariables()
        
        Get a pointer to Particle variables at its previous position See
        GetEquationVariables for content description
        """
        ...
    
    def GetPrevIntegrationTime(self):
        """
        V.GetPrevIntegrationTime() -> float
        C++: virtual double GetPrevIntegrationTime()
        
        Get the integration time at previous position
        """
        ...
    
    def GetPrevPosition(self):
        """
        V.GetPrevPosition() -> (float, ...)
        C++: double *GetPrevPosition()
        
        Get a pointer to the previous particle position. Convenience
        method, giving the same results as GetPrevEquationVariables().
        """
        ...
    
    def GetPrevTrackedUserData(self):
        """
        V.GetPrevTrackedUserData() -> Stvector_IdE
        C++: std::vector<double> &GetPrevTrackedUserData()
        
        Get a reference to PrevTrackedUserData See GetTrackedUserData for
        an explanation on how to use it.
        """
        ...
    
    def GetPrevUserVariables(self):
        """
        V.GetPrevUserVariables() -> (float, ...)
        C++: double *GetPrevUserVariables()
        
        Get a pointer to the previous user variables. Convenience method,
        giving the result: GetPrevEquationVariables() + 6;
        """
        ...
    
    def GetPrevVelocity(self):
        """
        V.GetPrevVelocity() -> (float, ...)
        C++: double *GetPrevVelocity()
        
        Get a pointer to the previous particle velocity. Convenience
        method, giving the result: GetPrevEquationVariables() + 3;
        """
        ...
    
    def GetSeedArrayTupleIndex(self):
        """
        V.GetSeedArrayTupleIndex() -> int
        C++: virtual vtkIdType GetSeedArrayTupleIndex()
        
        Get the index of the tuple for this particle in the point data
        returned by GetSeedData method
        """
        ...
    
    def GetSeedData(self):
        """
        V.GetSeedData() -> vtkPointData
        C++: virtual vtkPointData *GetSeedData()
        
        Get the particle seed data, for reading only.
        """
        ...
    
    def GetSeedId(self):
        """
        V.GetSeedId() -> int
        C++: virtual vtkIdType GetSeedId()
        
        Get the particle original seed index in the seed dataset. Allows
        to track a specific seed along the tracks.
        """
        ...
    
    def GetStepTimeRef(self):
        """
        V.GetStepTimeRef() -> float
        C++: virtual double &GetStepTimeRef()
        
        Get reference to step time of this particle
        """
        ...
    
    def GetTermination(self):
        """
        V.GetTermination() -> int
        C++: virtual int GetTermination()
        
        Set/Get particle termination. Values out of enum range are
        accepted Values < 100 are system reserved and should not be used
        """
        ...
    
    def GetThreadedData(self):
        """
        V.GetThreadedData() -> vtkLagrangianThreadedData
        C++: vtkLagrangianThreadedData *GetThreadedData()
        
        Get/Set a pointer to a vtkLagrangianThreadedData that is
        considered to be local to the thread. This structure contains
        multiple objects to be used by the tracker and the model, it also
        contains a user data that can be used to store any kind of data,
        structure, class instance that you may need. This is set by the
        vtkLagrangianParticleTracker and can be initialized/finalized in
        the model
        """
        ...
    
    def GetTrackedUserData(self):
        """
        V.GetTrackedUserData() -> Stvector_IdE
        C++: std::vector<double> &GetTrackedUserData()
        
        Get a reference to TrackedUserData. The tracked user data is a
        vector of double associated with each position of the particle,
        but it is not integrated contrary to the UserVariables and
        EquationVariables. It is, however, automatically tracked from one
        position to the next, copied when creating new particles with
        NewInstance and CloneParticle and transferred from one node to
        the next when particles move from one domain to the another in
        parallel. If you are using these, you are supposed to compute and
        set the next tracked user data your implementation of
        FunctionValues in your model.
        """
        ...
    
    def GetUserFlag(self):
        """
        V.GetUserFlag() -> int
        C++: virtual int GetUserFlag()
        
        Set/Get user flag.
        """
        ...
    
    def GetUserVariables(self):
        """
        V.GetUserVariables() -> (float, ...)
        C++: double *GetUserVariables()
        
        Get a pointer to the user variables. Convenience method, giving
        the result: GetEquationVariables() + 6;
        """
        ...
    
    def GetVelocity(self):
        """
        V.GetVelocity() -> (float, ...)
        C++: double *GetVelocity()
        
        Get a pointer to the particle velocity. Convenience method,
        giving the result: GetEquationVariables() + 3;
        """
        ...
    
    def MoveToNextPosition(self):
        """
        V.MoveToNextPosition()
        C++: virtual void MoveToNextPosition()
        
        Move the particle to its next position by putting next equation
        variable to equation variable and clearing next equation
        variable. Be sure to have set the StepTime first for accurate
        IntegrationTime computation
        """
        ...
    
    def SetIntegrationTime(self, p_float):
        """
        V.SetIntegrationTime(float)
        C++: virtual void SetIntegrationTime(double time)
        
        Convenience setter for integration time, do not use unless manual
        particle shifting One using this method may want to consider
        modifying EquationVariable[numVals] which contain integrationTime
        as well, if it matters in their model.
        """
        ...
    
    def SetInteraction(self, p_int):
        """
        V.SetInteraction(int)
        C++: virtual void SetInteraction(int interaction)
        
        Set/Get particle interaction. Values out of enum range are
        accepted Values < 100 are system reserved and should not be used
        """
        ...
    
    def SetLastCell(self, vtkAbstractCellLocator, vtkDataSet, p_int, p_float=..., p_float=..., p_float=...):
        """
        V.SetLastCell(vtkAbstractCellLocator, vtkDataSet, int, [float,
            float, float])
        C++: void SetLastCell(vtkAbstractCellLocator *locator,
            vtkDataSet *dataset, vtkIdType cellId,
            double lastCellPosition[3])
        
        Set the last dataset and last cell id
        """
        ...
    
    def SetLastSurfaceCell(self, vtkDataSet, p_int):
        """
        V.SetLastSurfaceCell(vtkDataSet, int)
        C++: void SetLastSurfaceCell(vtkDataSet *dataset,
            vtkIdType cellId)
        
        Set the last surface dataset and last surface cell id
        """
        ...
    
    def SetParentId(self, p_int):
        """
        V.SetParentId(int)
        C++: virtual void SetParentId(vtkIdType parentId)
        
        Set/Get parent particle id. Allow to find the seed particle of
        any particle.
        """
        ...
    
    def SetPInsertPreviousPosition(self, bool):
        """
        V.SetPInsertPreviousPosition(bool)
        C++: virtual void SetPInsertPreviousPosition(bool val)
        
        Set/Get parallel specific flag, indication to insert or not the
        previous position after streaming. No effect in serial.
        """
        ...
    
    def SetPManualShift(self, bool):
        """
        V.SetPManualShift(bool)
        C++: virtual void SetPManualShift(bool val)
        
        Set/Get parallel specific flag, indication that the particle may
        be manually shifted after streaming. No effect in serial.
        """
        ...
    
    def SetTermination(self, p_int):
        """
        V.SetTermination(int)
        C++: virtual void SetTermination(int termination)
        
        Set/Get particle termination. Values out of enum range are
        accepted Values < 100 are system reserved and should not be used
        """
        ...
    
    def SetThreadedData(self, vtkLagrangianThreadedData):
        """
        V.SetThreadedData(vtkLagrangianThreadedData)
        C++: void SetThreadedData(vtkLagrangianThreadedData *threadedData)
        
        Get/Set a pointer to a vtkLagrangianThreadedData that is
        considered to be local to the thread. This structure contains
        multiple objects to be used by the tracker and the model, it also
        contains a user data that can be used to store any kind of data,
        structure, class instance that you may need. This is set by the
        vtkLagrangianParticleTracker and can be initialized/finalized in
        the model
        """
        ...
    
    def SetUserFlag(self, p_int):
        """
        V.SetUserFlag(int)
        C++: virtual void SetUserFlag(int flag)
        
        Set/Get user flag.
        """
        ...
    
    def __getattribute__(self, *args, **kwargs):
        """ Return getattr(self, name). """
        ...
    
    def __hash__(self, *args, **kwargs) -> int:
        """ Return hash(self). """
        ...
    
    def __init__(self, int_numberOfVariables, vtkIdType_seedId, vtkIdType_particleId, vtkIdType_seedArrayTupleIndex, double_integrationTime, vtkPointData, *args, **kwargs) -> None:
        ...
    
    @staticmethod
    def __new__(*args, **kwargs):
        """ Create and return a new object.  See help(type) for accurate signature. """
        ...
    
    def __repr__(self, *args, **kwargs):
        """ Return repr(self). """
        ...
    
    ParticleTermination = ...
    PARTICLE_TERMINATION_FLIGHT_TERMINATED = ...
    PARTICLE_TERMINATION_NOT_TERMINATED = ...
    PARTICLE_TERMINATION_OUT_OF_DOMAIN = ...
    PARTICLE_TERMINATION_OUT_OF_STEPS = ...
    PARTICLE_TERMINATION_OUT_OF_TIME = ...
    PARTICLE_TERMINATION_SURF_BREAK = ...
    PARTICLE_TERMINATION_SURF_TERMINATED = ...
    SurfaceInteraction = ...
    SURFACE_INTERACTION_BOUNCE = ...
    SURFACE_INTERACTION_BREAK = ...
    SURFACE_INTERACTION_NO_INTERACTION = ...
    SURFACE_INTERACTION_OTHER = ...
    SURFACE_INTERACTION_PASS = ...
    SURFACE_INTERACTION_TERMINATED = ...


class vtkLagrangianParticleTracker(__vtkmodules_vtkCommonExecutionModel.vtkDataObjectAlgorithm):
    """
    vtkLagrangianParticleTracker - Filter to inject and track particles
    in a flow
    
    Superclass: vtkDataObjectAlgorithm
    
    Introduce LagrangianParticleTracker
    
    This is a very flexible and adaptive filter to inject and track
    particles in a flow. It takes three inputs :
    * port 0 : Flow Input, a volumic dataset containing data to integrate
    with, any kind of data object, support distributed input.
    * port 1 : Seed (source) Input, a dataset containing point to
      generate particles with, any kind of data object, support
      distributed input. Only first leaf of composite dataset is used.
    * port 2 : Optional Surface Input, containing dataset to interact
      with, any kind of data object, support distributed input.
    
    It has two outputs :
    * port 0 : ParticlePaths : a multipiece of polyData (one per thread)
      of polyLines showing the paths of particles in the flow
    * port 1 : ParticleInteractions : empty if no surface input, contains
    a a multiblock with as many children as the number of threads, each
      children containing a multiblock with the same structure as the
      surfaces. The leafs of these structures contain a polydata of
      vertexes corresponding to the interactions. with the same composite
    layout of surface input if any, showing all interactions between
      particles and the surface input.
    
    It has a parallel implementation which streams particle between
    domains.
    
    The most important parameters of this filter is it's
    integrationModel. Only one integration model implementation exist
    currently in ParaView ,vtkLagrangianMatidaIntegrationModel but the
    design enables plugin developers to expand this tracker by creating
    new models. A model can define  :
    * The number of integration variable and new user defined integration
    variable
    * the way the particle are integrated
    * the way particles intersect and interact with the surface
    * the way freeFlight termination is handled
    * PreProcess and PostProcess methods
    * Manual Integration, Manual partichle shifting see
      vtkLagrangianBasicIntegrationModel and
      vtkLagrangianMatidaIntegrationModel for more information
    
    It also let the user choose the Locator to use when integrating in
    the flow, as well as the Integrator to use. Integration steps are
    also highly configurable, step, step min and step max are passed down
    to the integrator (hence min and max does not matter with a non
    adaptive integrator like RK4/5)
    
    
     An IntegrationModel is a very specific vtkFunctionSet with a lot of
    features allowing inherited classes to concentrate on the
    mathematical part of the code.
     a Particle is basically a class wrapper around three table
    containing variables about the particle at previous, current and next
    position.
     The particle is passed to the integrator, which use the integration
    model to integrate the particle in the flow.
    
    It has other features also, including :
    * Adaptative Step Reintegration, to retry the step with different
      time step when the next position is too far
    * Different kind of cell length computation, including a divergence
      theorem based computation
    * Optional lines rendering controlled by a threshold
    * Ghost cell support
    * Non planar quad interaction support
    * Built-in support for surface interaction including, terminate,
      bounce, break-up and pass-through surface The serial and parallel
      filters are fully tested.
    
    @sa
    vtkLagrangianMatidaIntegrationModel vtkLagrangianParticle
    vtkLagrangianBasicIntegrationModel
    """
    def AdaptiveStepReintegrationOff(self):
        """
        V.AdaptiveStepReintegrationOff()
        C++: virtual void AdaptiveStepReintegrationOff()
        
        Set/Get the Adaptive Step Reintegration feature. it checks the
        step size after the integration and if it is too big will retry
        with a smaller step Default is false.
        """
        ...
    
    def AdaptiveStepReintegrationOn(self):
        """
        V.AdaptiveStepReintegrationOn()
        C++: virtual void AdaptiveStepReintegrationOn()
        
        Set/Get the Adaptive Step Reintegration feature. it checks the
        step size after the integration and if it is too big will retry
        with a smaller step Default is false.
        """
        ...
    
    def FillInputPortInformation(self, p_int, vtkInformation):
        """
        V.FillInputPortInformation(int, vtkInformation) -> int
        C++: int FillInputPortInformation(int port, vtkInformation *info)
            override;
        
        Declare input port type
        """
        ...
    
    def FillOutputPortInformation(self, p_int, vtkInformation):
        """
        V.FillOutputPortInformation(int, vtkInformation) -> int
        C++: int FillOutputPortInformation(int port, vtkInformation *info)
             override;
        
        Declare output port type
        """
        ...
    
    def GenerateParticlePathsOutputOff(self):
        """
        V.GenerateParticlePathsOutputOff()
        C++: virtual void GenerateParticlePathsOutputOff()
        
        Set/Get the generation of the particle path output, Default is
        true.
        """
        ...
    
    def GenerateParticlePathsOutputOn(self):
        """
        V.GenerateParticlePathsOutputOn()
        C++: virtual void GenerateParticlePathsOutputOn()
        
        Set/Get the generation of the particle path output, Default is
        true.
        """
        ...
    
    def GetAdaptiveStepReintegration(self):
        """
        V.GetAdaptiveStepReintegration() -> bool
        C++: virtual bool GetAdaptiveStepReintegration()
        
        Set/Get the Adaptive Step Reintegration feature. it checks the
        step size after the integration and if it is too big will retry
        with a smaller step Default is false.
        """
        ...
    
    def GetCellLengthComputationMode(self):
        """
        V.GetCellLengthComputationMode() -> int
        C++: virtual int GetCellLengthComputationMode()
        
        Set/Get the cell length computation mode. Available modes are :
        - STEP_LAST_CELL_LENGTH : Compute cell length using getLength
          method on the last cell the particle was in
        - STEP_CUR_CELL_LENGTH : Compute cell length using getLength
          method on the current cell the particle is in
        - STEP_LAST_CELL_VEL_DIR : Compute cell length using the particle
        velocity and the edges of the last cell the particle was in.
        - STEP_CUR_CELL_VEL_DIR : Compute cell length using the particle
          velocity and the edges of the last cell the particle was in.
        - STEP_LAST_CELL_DIV_THEO : Compute cell length using the
          particle velocity and the divergence theorem.
        - STEP_CUR_CELL_DIV_THEO : Compute cell length using the particle
        velocity and the divergence theorem. Default is
          STEP_LAST_CELL_LENGTH.
        """
        ...
    
    def GetGenerateParticlePathsOutput(self):
        """
        V.GetGenerateParticlePathsOutput() -> bool
        C++: virtual bool GetGenerateParticlePathsOutput()
        
        Set/Get the generation of the particle path output, Default is
        true.
        """
        ...
    
    def GetGeneratePolyVertexInteractionOutput(self):
        """
        V.GetGeneratePolyVertexInteractionOutput() -> bool
        C++: virtual bool GetGeneratePolyVertexInteractionOutput()
        
        Set/Get whether or not to use PolyVertex cell type for the
        interaction output Default is false
        """
        ...
    
    def GetIntegrationModel(self):
        """
        V.GetIntegrationModel() -> vtkLagrangianBasicIntegrationModel
        C++: virtual vtkLagrangianBasicIntegrationModel *GetIntegrationModel(
            )
        
        Set/Get the integration model. Default is
        vtkLagrangianMatidaIntegrationModel
        """
        ...
    
    def GetIntegrator(self):
        """
        V.GetIntegrator() -> vtkInitialValueProblemSolver
        C++: virtual vtkInitialValueProblemSolver *GetIntegrator()
        
        Set/Get the integrator. Default is vtkRungeKutta2
        """
        ...
    
    def GetMaximumIntegrationTime(self):
        """
        V.GetMaximumIntegrationTime() -> float
        C++: virtual double GetMaximumIntegrationTime()
        
        Set/Get the maximum integration time. A negative value means no
        limit. Default is -1.
        """
        ...
    
    def GetMaximumNumberOfSteps(self):
        """
        V.GetMaximumNumberOfSteps() -> int
        C++: virtual int GetMaximumNumberOfSteps()
        
        Set/Get the maximum number of steps. -1 means no limit. Default
        is 100.
        """
        ...
    
    def GetMTime(self):
        """
        V.GetMTime() -> int
        C++: vtkMTimeType GetMTime() override;
        
        Get the tracker modified time taking into account the integration
        model and the integrator.
        """
        ...
    
    def GetNewParticleId(self):
        """
        V.GetNewParticleId() -> int
        C++: virtual vtkIdType GetNewParticleId()
        
        Get an unique id for a particle This method is thread safe
        """
        ...
    
    def GetNumberOfGenerationsFromBase(self, string):
        """
        V.GetNumberOfGenerationsFromBase(string) -> int
        C++: vtkIdType GetNumberOfGenerationsFromBase(const char *type)
            override;
        
        Given a the name of a base class of this class type, return the
        distance of inheritance between this class type and the named
        class (how many generations of inheritance are there between this
        class and the named class). If the named class is not in this
        class's inheritance tree, return a negative value. Valid
        responses will always be nonnegative. This method works in
        combination with vtkTypeMacro found in vtkSetGet.h.
        """
        ...
    
    def GetNumberOfGenerationsFromBaseType(self, string):
        """
        V.GetNumberOfGenerationsFromBaseType(string) -> int
        C++: static vtkIdType GetNumberOfGenerationsFromBaseType(
            const char *type)
        
        Given a the name of a base class of this class type, return the
        distance of inheritance between this class type and the named
        class (how many generations of inheritance are there between this
        class and the named class). If the named class is not in this
        class's inheritance tree, return a negative value. Valid
        responses will always be nonnegative. This method works in
        combination with vtkTypeMacro found in vtkSetGet.h.
        """
        ...
    
    def GetSource(self):
        """
        V.GetSource() -> vtkDataObject
        C++: vtkDataObject *GetSource()
        
        Specify the source object used to generate particle initial
        position (seeds). Note that this method does not connect the
        pipeline. The algorithm will work on the input data as it is
        without updating the producer of the data. See
        SetSourceConnection for connecting the pipeline.
        """
        ...
    
    def GetStepFactor(self):
        """
        V.GetStepFactor() -> float
        C++: virtual double GetStepFactor()
        
        Set/Get the integration step factor. Default is 1.0.
        """
        ...
    
    def GetStepFactorMax(self):
        """
        V.GetStepFactorMax() -> float
        C++: virtual double GetStepFactorMax()
        
        Set/Get the integration step factor max. Default is 1.5.
        """
        ...
    
    def GetStepFactorMin(self):
        """
        V.GetStepFactorMin() -> float
        C++: virtual double GetStepFactorMin()
        
        Set/Get the integration step factor min. Default is 0.5.
        """
        ...
    
    def GetSurface(self):
        """
        V.GetSurface() -> vtkDataObject
        C++: vtkDataObject *GetSurface()
        
        Specify the source object used to compute surface interaction
        with Note that this method does not connect the pipeline. The
        algorithm will work on the input data as it is without updating
        the producer of the data. See SetSurfaceConnection for connecting
        the pipeline.
        """
        ...
    
    def IsA(self, string):
        """
        V.IsA(string) -> int
        C++: vtkTypeBool IsA(const char *type) override;
        
        Return 1 if this class is the same type of (or a subclass of) the
        named class. Returns 0 otherwise. This method works in
        combination with vtkTypeMacro found in vtkSetGet.h.
        """
        ...
    
    def IsTypeOf(self, string):
        """
        V.IsTypeOf(string) -> int
        C++: static vtkTypeBool IsTypeOf(const char *type)
        
        Return 1 if this class type is the same type of (or a subclass
        of) the named class. Returns 0 otherwise. This method works in
        combination with vtkTypeMacro found in vtkSetGet.h.
        """
        ...
    
    def NewInstance(self):
        """
        V.NewInstance() -> vtkLagrangianParticleTracker
        C++: vtkLagrangianParticleTracker *NewInstance()
        """
        ...
    
    def SafeDownCast(self, vtkObjectBase):
        """
        V.SafeDownCast(vtkObjectBase) -> vtkLagrangianParticleTracker
        C++: static vtkLagrangianParticleTracker *SafeDownCast(
            vtkObjectBase *o)
        """
        ...
    
    def SetAdaptiveStepReintegration(self, bool):
        """
        V.SetAdaptiveStepReintegration(bool)
        C++: virtual void SetAdaptiveStepReintegration(bool _arg)
        
        Set/Get the Adaptive Step Reintegration feature. it checks the
        step size after the integration and if it is too big will retry
        with a smaller step Default is false.
        """
        ...
    
    def SetCellLengthComputationMode(self, p_int):
        """
        V.SetCellLengthComputationMode(int)
        C++: virtual void SetCellLengthComputationMode(int _arg)
        
        Set/Get the cell length computation mode. Available modes are :
        - STEP_LAST_CELL_LENGTH : Compute cell length using getLength
          method on the last cell the particle was in
        - STEP_CUR_CELL_LENGTH : Compute cell length using getLength
          method on the current cell the particle is in
        - STEP_LAST_CELL_VEL_DIR : Compute cell length using the particle
        velocity and the edges of the last cell the particle was in.
        - STEP_CUR_CELL_VEL_DIR : Compute cell length using the particle
          velocity and the edges of the last cell the particle was in.
        - STEP_LAST_CELL_DIV_THEO : Compute cell length using the
          particle velocity and the divergence theorem.
        - STEP_CUR_CELL_DIV_THEO : Compute cell length using the particle
        velocity and the divergence theorem. Default is
          STEP_LAST_CELL_LENGTH.
        """
        ...
    
    def SetGenerateParticlePathsOutput(self, bool):
        """
        V.SetGenerateParticlePathsOutput(bool)
        C++: virtual void SetGenerateParticlePathsOutput(bool _arg)
        
        Set/Get the generation of the particle path output, Default is
        true.
        """
        ...
    
    def SetGeneratePolyVertexInteractionOutput(self, bool):
        """
        V.SetGeneratePolyVertexInteractionOutput(bool)
        C++: virtual void SetGeneratePolyVertexInteractionOutput(
            bool _arg)
        
        Set/Get whether or not to use PolyVertex cell type for the
        interaction output Default is false
        """
        ...
    
    def SetIntegrationModel(self, vtkLagrangianBasicIntegrationModel):
        """
        V.SetIntegrationModel(vtkLagrangianBasicIntegrationModel)
        C++: void SetIntegrationModel(
            vtkLagrangianBasicIntegrationModel *integrationModel)
        
        Set/Get the integration model. Default is
        vtkLagrangianMatidaIntegrationModel
        """
        ...
    
    def SetIntegrator(self, vtkInitialValueProblemSolver):
        """
        V.SetIntegrator(vtkInitialValueProblemSolver)
        C++: void SetIntegrator(vtkInitialValueProblemSolver *integrator)
        
        Set/Get the integrator. Default is vtkRungeKutta2
        """
        ...
    
    def SetMaximumIntegrationTime(self, p_float):
        """
        V.SetMaximumIntegrationTime(float)
        C++: virtual void SetMaximumIntegrationTime(double _arg)
        
        Set/Get the maximum integration time. A negative value means no
        limit. Default is -1.
        """
        ...
    
    def SetMaximumNumberOfSteps(self, p_int):
        """
        V.SetMaximumNumberOfSteps(int)
        C++: virtual void SetMaximumNumberOfSteps(int _arg)
        
        Set/Get the maximum number of steps. -1 means no limit. Default
        is 100.
        """
        ...
    
    def SetSourceConnection(self, vtkAlgorithmOutput):
        """
        V.SetSourceConnection(vtkAlgorithmOutput)
        C++: void SetSourceConnection(vtkAlgorithmOutput *algOutput)
        
        Specify the source object used to generate particle initial
        position (seeds).
        """
        ...
    
    def SetSourceData(self, vtkDataObject):
        """
        V.SetSourceData(vtkDataObject)
        C++: void SetSourceData(vtkDataObject *source)
        
        Specify the source object used to generate particle initial
        position (seeds). Note that this method does not connect the
        pipeline. The algorithm will work on the input data as it is
        without updating the producer of the data. See
        SetSourceConnection for connecting the pipeline.
        """
        ...
    
    def SetStepFactor(self, p_float):
        """
        V.SetStepFactor(float)
        C++: virtual void SetStepFactor(double _arg)
        
        Set/Get the integration step factor. Default is 1.0.
        """
        ...
    
    def SetStepFactorMax(self, p_float):
        """
        V.SetStepFactorMax(float)
        C++: virtual void SetStepFactorMax(double _arg)
        
        Set/Get the integration step factor max. Default is 1.5.
        """
        ...
    
    def SetStepFactorMin(self, p_float):
        """
        V.SetStepFactorMin(float)
        C++: virtual void SetStepFactorMin(double _arg)
        
        Set/Get the integration step factor min. Default is 0.5.
        """
        ...
    
    def SetSurfaceConnection(self, vtkAlgorithmOutput):
        """
        V.SetSurfaceConnection(vtkAlgorithmOutput)
        C++: void SetSurfaceConnection(vtkAlgorithmOutput *algOutput)
        
        Specify the object used to compute surface interaction with.
        """
        ...
    
    def SetSurfaceData(self, vtkDataObject):
        """
        V.SetSurfaceData(vtkDataObject)
        C++: void SetSurfaceData(vtkDataObject *source)
        
        Specify the source object used to compute surface interaction
        with Note that this method does not connect the pipeline. The
        algorithm will work on the input data as it is without updating
        the producer of the data. See SetSurfaceConnection for connecting
        the pipeline.
        """
        ...
    
    def __delattr__(self, *args, **kwargs):
        """ Implement delattr(self, name). """
        ...
    
    def __getattribute__(self, *args, **kwargs):
        """ Return getattr(self, name). """
        ...
    
    def __init__(self, *args, **kwargs) -> None:
        ...
    
    @staticmethod
    def __new__(*args, **kwargs):
        """ Create and return a new object.  See help(type) for accurate signature. """
        ...
    
    def __repr__(self, *args, **kwargs):
        """ Return repr(self). """
        ...
    
    def __setattr__(self, *args, **kwargs):
        """ Implement setattr(self, name, value). """
        ...
    
    def __str__(self, *args, **kwargs) -> str:
        """ Return str(self). """
        ...
    
    __this__ = ...
    CellLengthComputation = ...
    STEP_CUR_CELL_DIV_THEO = ...
    STEP_CUR_CELL_LENGTH = ...
    STEP_CUR_CELL_VEL_DIR = ...
    STEP_LAST_CELL_DIV_THEO = ...
    STEP_LAST_CELL_LENGTH = ...
    STEP_LAST_CELL_VEL_DIR = ...
    __dict__ = ...
    __vtkname__ = ...


class vtkModifiedBSPTree(__vtkmodules_vtkCommonDataModel.vtkAbstractCellLocator):
    """
    vtkModifiedBSPTree - Generate axis aligned BBox tree for raycasting
    and other Locator based searches
    
    Superclass: vtkAbstractCellLocator
    
    vtkModifiedBSPTree creates an evenly balanced BSP tree using a top
    down implementation. Axis aligned split planes are found which evenly
    divide cells into two buckets. Generally a split plane will intersect
    some cells and these are usually stored in both child nodes of the
    current parent. (Or split into separate cells which we cannot
    consider in this case). Storing cells in multiple buckets creates
    problems associated with multiple tests against rays and increases
    the required storage as complex meshes will have many cells
    straddling a split plane (and further splits may cause multiple
    copies of these).
    
    During a discussion with Arno Formella in 1998 he suggested using a
    third child node to store objects which straddle split planes. I've
    not seen this published (Yes! - see below), but thought it worth
    trying. This implementation of the BSP tree creates a third child
    node for storing cells laying across split planes, the third cell may
    overlap the other two, but the two 'proper' nodes otherwise conform
    to usual BSP rules.
    
    The advantage of this implementation is cells only ever lie in one
    node and mailbox testing is avoided. All BBoxes are axis aligned and
    a ray cast uses an efficient search strategy based on near/far nodes
    and rejects all BBoxes using simple tests.
    
    For fast raytracing, 6 copies of cell lists are stored in each leaf
    node each list is in axis sorted order +/- x,y,z and cells are always
    tested in the direction of the ray dominant axis. Once an
    intersection is found any cell or BBox with a closest point further
    than the I-point can be instantly rejected and raytracing stops as
    soon as no nodes can be closer than the current best intersection
    point.
    
    The addition of the 'middle' node upsets the optimal balance of the
    tree, but is a minor overhead during the raytrace. Each child node is
    contracted such that it tightly fits all cells inside it, enabling
    further ray/box rejections.
    
    This class is intended for persons requiring many ray tests and is
    optimized for this purpose. As no cell ever lies in more than one
    leaf node, and parent nodes do not maintain cell lists, the memory
    overhead of the sorted cell lists is 6*num_cells*4 for 6 lists of
    ints, each num_cells in length. The memory requirement of the nodes
    themselves is usually of minor significance.
    
    Subdividision is controlled by MaxCellsPerNode - any node with more
    than this number will be subdivided providing a good split plane can
    be found and the max depth is not exceeded.
    
    The average cells per leaf will usually be around half the
    MaxCellsPerNode, though the middle node is usually sparsely populated
    and lowers the average slightly. The middle node will not be created
    when not needed. Subdividing down to very small cells per node is not
    generally suggested as then the 6 stored cell lists are effectively
    redundant.
    
    Values of MaxcellsPerNode of around 16->128 depending on dataset size
    will usually give good results.
    
    Cells are only sorted into 6 lists once - before tree creation, each
    node segments the lists and passes them down to the new child nodes
    whilst maintaining sorted order. This makes for an efficient
    subdivision strategy.
    
    NB. The following reference has been sent to me 
    @Article{formella-1995-ray,
        author =     "Arno Formella and Christian Gill",
        title =      "{Ray Tracing: A Quantitative Analysis and a New
                      Practical Algorithm}",
        journal =    "{The Visual Computer}",
        year =       "{1995}",
        month =       dec,
        pages =      "{465--476}",
        volume =     "{11}",
        number =     "{9}",
        publisher =  "{Springer}",
        keywords =   "{ray tracing, space subdivision, plane traversal,
                       octree, clustering, benchmark scenes}",
        annote =     "{We present a new method to accelerate the process
    of
                       finding nearest ray--object intersections in ray
                       tracing. The algorithm consumes an amount of
    memory
                       more or less linear in the number of objects. The
    basic
                       ideas can be characterized with a modified
    BSP--tree
                       and plane traversal. Plane traversal is a fast
    linear
                       time algorithm to find the closest intersection
    point
                       in a list of bounding volumes hit by a ray. We use
                       plane traversal at every node of the high
    outdegree
                       BSP--tree. Our implementation is competitive to
    fast
                       ray tracing programs. We present a benchmark suite
                       which allows for an extensive comparison of ray
    tracing
                       algorithms.}",
      }
    
    @par Thanks:
     John Biddiscombe for developing and contributing this class
    
    @todo
    ------------- Implement intersection heap for testing rays against
        transparent objects
    
    @par Style:
    -------------- This class is currently maintained by J. Biddiscombe
        who has specially requested that the code style not be modified
        to the kitware standard. Please respect the contribution of this
        class by keeping the style as close as possible to the author's
        original.
    """
    def BuildLocator(self):
        """
        V.BuildLocator()
        C++: void BuildLocator() override;
        
        Build Tree
        """
        ...
    
    def FindCell(self, p_float=..., p_float=..., p_float=..., *args, **kwargs):
        """
        V.FindCell([float, float, float], float, vtkGenericCell, [float,
            float, float], [float, ...]) -> int
        C++: vtkIdType FindCell(double x[3], double tol2,
            vtkGenericCell *GenCell, double pcoords[3], double *weights)
            override;
        V.FindCell([float, float, float]) -> int
        C++: virtual vtkIdType FindCell(double x[3])
        
        Test a point to find if it is inside a cell. Returns the cellId
        if inside or -1 if not.
        """
        ...
    
    def FreeSearchStructure(self):
        """
        V.FreeSearchStructure()
        C++: void FreeSearchStructure() override;
        
        Free tree memory
        """
        ...
    
    def GenerateRepresentation(self, p_int, vtkPolyData):
        """
        V.GenerateRepresentation(int, vtkPolyData)
        C++: void GenerateRepresentation(int level, vtkPolyData *pd)
            override;
        
        Generate BBox representation of Nth level
        """
        ...
    
    def GenerateRepresentationLeafs(self, vtkPolyData):
        """
        V.GenerateRepresentationLeafs(vtkPolyData)
        C++: virtual void GenerateRepresentationLeafs(vtkPolyData *pd)
        
        Generate BBox representation of all leaf nodes
        """
        ...
    
    def GetLeafNodeCellInformation(self):
        """
        V.GetLeafNodeCellInformation() -> vtkIdListCollection
        C++: vtkIdListCollection *GetLeafNodeCellInformation()
        
        After subdivision has completed, one may wish to query the tree
        to find which cells are in which leaf nodes. This function
        returns a list which holds a cell Id list for each leaf node.
        """
        ...
    
    def GetNumberOfGenerationsFromBase(self, string):
        """
        V.GetNumberOfGenerationsFromBase(string) -> int
        C++: vtkIdType GetNumberOfGenerationsFromBase(const char *type)
            override;
        
        Standard Type-Macro
        """
        ...
    
    def GetNumberOfGenerationsFromBaseType(self, string):
        """
        V.GetNumberOfGenerationsFromBaseType(string) -> int
        C++: static vtkIdType GetNumberOfGenerationsFromBaseType(
            const char *type)
        
        Standard Type-Macro
        """
        ...
    
    def InsideCellBounds(self, p_float=..., p_float=..., p_float=..., *args, **kwargs):
        """
        V.InsideCellBounds([float, float, float], int) -> bool
        C++: bool InsideCellBounds(double x[3], vtkIdType cell_ID)
            override;
        
        Quickly test if a point is inside the bounds of a particular
        cell. Some locators cache cell bounds and this function can make
        use of fast access to the data.
        """
        ...
    
    def IntersectWithLine(self, , , p_float_6, p_float_7, p_float=..., p_float=..., p_float=..., *args, **kwargs):
        """
        V.IntersectWithLine((float, float, float), (float, float, float),
            float, float, [float, float, float], [float, float, float],
            int, int) -> int
        C++: int IntersectWithLine(const double p1[3], const double p2[3],
             double tol, double &t, double x[3], double pcoords[3],
            int &subId, vtkIdType &cellId) override;
        V.IntersectWithLine((float, float, float), (float, float, float),
            float, float, [float, float, float], [float, float, float],
            int, int, vtkGenericCell) -> int
        C++: int IntersectWithLine(const double p1[3], const double p2[3],
             double tol, double &t, double x[3], double pcoords[3],
            int &subId, vtkIdType &cellId, vtkGenericCell *cell) override;
        V.IntersectWithLine((float, float, float), (float, float, float),
            float, vtkPoints, vtkIdList) -> int
        C++: virtual int IntersectWithLine(const double p1[3],
            const double p2[3], const double tol, vtkPoints *points,
            vtkIdList *cellIds)
        V.IntersectWithLine((float, float, float), (float, float, float),
            float, float, [float, float, float], [float, float, float],
            int) -> int
        C++: virtual int IntersectWithLine(const double p1[3],
            const double p2[3], double tol, double &t, double x[3],
            double pcoords[3], int &subId)
        V.IntersectWithLine((float, float, float), (float, float, float),
            vtkPoints, vtkIdList) -> int
        C++: virtual int IntersectWithLine(const double p1[3],
            const double p2[3], vtkPoints *points, vtkIdList *cellIds)
        
        Return intersection point (if any) AND the cell which was
        intersected by the finite line. Uses fast tree-search BBox
        rejection tests.
        """
        ...
    
    def IsA(self, string):
        """
        V.IsA(string) -> int
        C++: vtkTypeBool IsA(const char *type) override;
        
        Standard Type-Macro
        """
        ...
    
    def IsTypeOf(self, string):
        """
        V.IsTypeOf(string) -> int
        C++: static vtkTypeBool IsTypeOf(const char *type)
        
        Standard Type-Macro
        """
        ...
    
    def NewInstance(self):
        """
        V.NewInstance() -> vtkModifiedBSPTree
        C++: vtkModifiedBSPTree *NewInstance()
        
        Standard Type-Macro
        """
        ...
    
    def SafeDownCast(self, vtkObjectBase):
        """
        V.SafeDownCast(vtkObjectBase) -> vtkModifiedBSPTree
        C++: static vtkModifiedBSPTree *SafeDownCast(vtkObjectBase *o)
        
        Standard Type-Macro
        """
        ...
    
    def __delattr__(self, *args, **kwargs):
        """ Implement delattr(self, name). """
        ...
    
    def __getattribute__(self, *args, **kwargs):
        """ Return getattr(self, name). """
        ...
    
    def __init__(self, *args, **kwargs) -> None:
        ...
    
    @staticmethod
    def __new__(*args, **kwargs):
        """ Create and return a new object.  See help(type) for accurate signature. """
        ...
    
    def __repr__(self, *args, **kwargs):
        """ Return repr(self). """
        ...
    
    def __setattr__(self, *args, **kwargs):
        """ Implement setattr(self, name, value). """
        ...
    
    def __str__(self, *args, **kwargs) -> str:
        """ Return str(self). """
        ...
    
    __this__ = ...
    __dict__ = ...
    __vtkname__ = ...


class vtkParticleTracerBase(__vtkmodules_vtkCommonExecutionModel.vtkPolyDataAlgorithm):
    """
    vtkParticleTracerBase - A particle tracer for vector fields
    
    Superclass: vtkPolyDataAlgorithm
    
    vtkParticleTracerBase is the base class for filters that advect
    particles in a vector field. Note that the input vtkPointData
    structure must be identical on all datasets.
    
    @sa
    vtkRibbonFilter vtkRuledSurfaceFilter vtkInitialValueProblemSolver
    vtkRungeKutta2 vtkRungeKutta4 vtkRungeKutta45 vtkStreamTracer
    """
    def AddSourceConnection(self, vtkAlgorithmOutput):
        """
        V.AddSourceConnection(vtkAlgorithmOutput)
        C++: void AddSourceConnection(vtkAlgorithmOutput *input)
        
        Provide support for multiple seed sources
        """
        ...
    
    def DisableResetCacheOff(self):
        """
        V.DisableResetCacheOff()
        C++: virtual void DisableResetCacheOff()
        
        Set/Get the flag to disable cache This is off by default and
        turned on in special circumstances such as in a coprocessing
        workflow
        """
        ...
    
    def DisableResetCacheOn(self):
        """
        V.DisableResetCacheOn()
        C++: virtual void DisableResetCacheOn()
        
        Set/Get the flag to disable cache This is off by default and
        turned on in special circumstances such as in a coprocessing
        workflow
        """
        ...
    
    def EnableParticleWritingOff(self):
        """
        V.EnableParticleWritingOff()
        C++: virtual void EnableParticleWritingOff()
        
        Set/Get the filename to be used with the particle writer when
        dumping particles to disk
        """
        ...
    
    def EnableParticleWritingOn(self):
        """
        V.EnableParticleWritingOn()
        C++: virtual void EnableParticleWritingOn()
        
        Set/Get the filename to be used with the particle writer when
        dumping particles to disk
        """
        ...
    
    def GetComputeVorticity(self):
        """
        V.GetComputeVorticity() -> bool
        C++: virtual bool GetComputeVorticity()
        
        Turn on/off vorticity computation at streamline points (necessary
        for generating proper stream-ribbons using the vtkRibbonFilter.
        """
        ...
    
    def GetDisableResetCache(self):
        """
        V.GetDisableResetCache() -> int
        C++: virtual vtkTypeBool GetDisableResetCache()
        
        Set/Get the flag to disable cache This is off by default and
        turned on in special circumstances such as in a coprocessing
        workflow
        """
        ...
    
    def GetEnableParticleWriting(self):
        """
        V.GetEnableParticleWriting() -> int
        C++: virtual vtkTypeBool GetEnableParticleWriting()
        
        Set/Get the filename to be used with the particle writer when
        dumping particles to disk
        """
        ...
    
    def GetForceReinjectionEveryNSteps(self):
        """
        V.GetForceReinjectionEveryNSteps() -> int
        C++: virtual int GetForceReinjectionEveryNSteps()
        
        When animating particles, it is nice to inject new ones every Nth
        step to produce a continuous flow. Setting
        ForceReinjectionEveryNSteps to a non zero value will cause the
        particle source to reinject particles every Nth step even if it
        is otherwise unchanged. Note that if the particle source is also
        animated, this flag will be redundant as the particles will be
        reinjected whenever the source changes anyway
        """
        ...
    
    def GetIgnorePipelineTime(self):
        """
        V.GetIgnorePipelineTime() -> int
        C++: virtual vtkTypeBool GetIgnorePipelineTime()
        
        To get around problems with the Paraview Animation controls we
        can just animate the time step and ignore the TIME_ requests
        """
        ...
    
    def GetIntegrator(self):
        """
        V.GetIntegrator() -> vtkInitialValueProblemSolver
        C++: virtual vtkInitialValueProblemSolver *GetIntegrator()
        """
        ...
    
    def GetIntegratorType(self):
        """
        V.GetIntegratorType() -> int
        C++: int GetIntegratorType()
        """
        ...
    
    def GetNumberOfGenerationsFromBase(self, string):
        """
        V.GetNumberOfGenerationsFromBase(string) -> int
        C++: vtkIdType GetNumberOfGenerationsFromBase(const char *type)
            override;
        
        Given a the name of a base class of this class type, return the
        distance of inheritance between this class type and the named
        class (how many generations of inheritance are there between this
        class and the named class). If the named class is not in this
        class's inheritance tree, return a negative value. Valid
        responses will always be nonnegative. This method works in
        combination with vtkTypeMacro found in vtkSetGet.h.
        """
        ...
    
    def GetNumberOfGenerationsFromBaseType(self, string):
        """
        V.GetNumberOfGenerationsFromBaseType(string) -> int
        C++: static vtkIdType GetNumberOfGenerationsFromBaseType(
            const char *type)
        
        Given a the name of a base class of this class type, return the
        distance of inheritance between this class type and the named
        class (how many generations of inheritance are there between this
        class and the named class). If the named class is not in this
        class's inheritance tree, return a negative value. Valid
        responses will always be nonnegative. This method works in
        combination with vtkTypeMacro found in vtkSetGet.h.
        """
        ...
    
    def GetParticleFileName(self):
        """
        V.GetParticleFileName() -> string
        C++: virtual char *GetParticleFileName()
        
        Set/Get the filename to be used with the particle writer when
        dumping particles to disk
        """
        ...
    
    def GetParticleWriter(self):
        """
        V.GetParticleWriter() -> vtkAbstractParticleWriter
        C++: virtual vtkAbstractParticleWriter *GetParticleWriter()
        
        Set/Get the Writer associated with this Particle Tracer Ideally a
        parallel IO capable vtkH5PartWriter should be used which will
        collect particles from all parallel processes and write them to a
        single HDF5 file.
        """
        ...
    
    def GetRotationScale(self):
        """
        V.GetRotationScale() -> float
        C++: virtual double GetRotationScale()
        
        This can be used to scale the rate with which the streamribbons
        twist. The default is 1.
        """
        ...
    
    def GetStartTime(self):
        """
        V.GetStartTime() -> float
        C++: virtual double GetStartTime()
        
        Set the time value for particle tracing to begin. The units of
        time should be consistent with the primary time variable.
        """
        ...
    
    def GetStaticMesh(self):
        """
        V.GetStaticMesh() -> int
        C++: virtual int GetStaticMesh()
        
        if StaticMesh is set, many optimizations for cell caching can be
        assumed. if StaticMesh is not set, the algorithm will attempt to
        find out if optimizations can be used, but setting it to true
        will force all optimizations. Do not Set StaticMesh to true if a
        dynamic mesh is being used as this will invalidate all results.
        The default is that StaticMesh is 0.
        """
        ...
    
    def GetStaticSeeds(self):
        """
        V.GetStaticSeeds() -> int
        C++: virtual int GetStaticSeeds()
        
        if StaticSeeds is set and the mesh is static, then every time
        particles are injected we can re-use the same injection
        information. We classify particles according to processor just
        once before start. If StaticSeeds is set and a moving seed source
        is specified the motion will be ignored and results will not be
        as expected. The default is that StaticSeeds is 0.
        """
        ...
    
    def GetTerminalSpeed(self):
        """
        V.GetTerminalSpeed() -> float
        C++: virtual double GetTerminalSpeed()
        
        Specify the terminal speed value, below which integration is
        terminated.
        """
        ...
    
    def GetTerminationTime(self):
        """
        V.GetTerminationTime() -> float
        C++: virtual double GetTerminationTime()
        
        Setting TerminationTime to a positive value will cause particles
        to terminate when the time is reached. Use a vlue of zero to
        disable termination. The units of time should be consistent with
        the primary time variable.
        """
        ...
    
    def IgnorePipelineTimeOff(self):
        """
        V.IgnorePipelineTimeOff()
        C++: virtual void IgnorePipelineTimeOff()
        
        To get around problems with the Paraview Animation controls we
        can just animate the time step and ignore the TIME_ requests
        """
        ...
    
    def IgnorePipelineTimeOn(self):
        """
        V.IgnorePipelineTimeOn()
        C++: virtual void IgnorePipelineTimeOn()
        
        To get around problems with the Paraview Animation controls we
        can just animate the time step and ignore the TIME_ requests
        """
        ...
    
    def IsA(self, string):
        """
        V.IsA(string) -> int
        C++: vtkTypeBool IsA(const char *type) override;
        
        Return 1 if this class is the same type of (or a subclass of) the
        named class. Returns 0 otherwise. This method works in
        combination with vtkTypeMacro found in vtkSetGet.h.
        """
        ...
    
    def IsTypeOf(self, string):
        """
        V.IsTypeOf(string) -> int
        C++: static vtkTypeBool IsTypeOf(const char *type)
        
        Return 1 if this class type is the same type of (or a subclass
        of) the named class. Returns 0 otherwise. This method works in
        combination with vtkTypeMacro found in vtkSetGet.h.
        """
        ...
    
    def NewInstance(self):
        """
        V.NewInstance() -> vtkParticleTracerBase
        C++: vtkParticleTracerBase *NewInstance()
        """
        ...
    
    def PrintParticleHistories(self):
        """
        V.PrintParticleHistories()
        C++: void PrintParticleHistories()
        """
        ...
    
    def RemoveAllSources(self):
        """
        V.RemoveAllSources()
        C++: void RemoveAllSources()
        
        Provide support for multiple seed sources
        """
        ...
    
    def SafeDownCast(self, vtkObjectBase):
        """
        V.SafeDownCast(vtkObjectBase) -> vtkParticleTracerBase
        C++: static vtkParticleTracerBase *SafeDownCast(vtkObjectBase *o)
        """
        ...
    
    def SetComputeVorticity(self, bool):
        """
        V.SetComputeVorticity(bool)
        C++: void SetComputeVorticity(bool)
        
        Turn on/off vorticity computation at streamline points (necessary
        for generating proper stream-ribbons using the vtkRibbonFilter.
        """
        ...
    
    def SetDisableResetCache(self, p_int):
        """
        V.SetDisableResetCache(int)
        C++: virtual void SetDisableResetCache(vtkTypeBool _arg)
        
        Set/Get the flag to disable cache This is off by default and
        turned on in special circumstances such as in a coprocessing
        workflow
        """
        ...
    
    def SetEnableParticleWriting(self, p_int):
        """
        V.SetEnableParticleWriting(int)
        C++: virtual void SetEnableParticleWriting(vtkTypeBool _arg)
        
        Set/Get the filename to be used with the particle writer when
        dumping particles to disk
        """
        ...
    
    def SetForceReinjectionEveryNSteps(self, p_int):
        """
        V.SetForceReinjectionEveryNSteps(int)
        C++: void SetForceReinjectionEveryNSteps(int)
        
        When animating particles, it is nice to inject new ones every Nth
        step to produce a continuous flow. Setting
        ForceReinjectionEveryNSteps to a non zero value will cause the
        particle source to reinject particles every Nth step even if it
        is otherwise unchanged. Note that if the particle source is also
        animated, this flag will be redundant as the particles will be
        reinjected whenever the source changes anyway
        """
        ...
    
    def SetIgnorePipelineTime(self, p_int):
        """
        V.SetIgnorePipelineTime(int)
        C++: virtual void SetIgnorePipelineTime(vtkTypeBool _arg)
        
        To get around problems with the Paraview Animation controls we
        can just animate the time step and ignore the TIME_ requests
        """
        ...
    
    def SetIntegrator(self, vtkInitialValueProblemSolver):
        """
        V.SetIntegrator(vtkInitialValueProblemSolver)
        C++: void SetIntegrator(vtkInitialValueProblemSolver *)
        """
        ...
    
    def SetIntegratorType(self, p_int):
        """
        V.SetIntegratorType(int)
        C++: void SetIntegratorType(int type)
        """
        ...
    
    def SetParticleFileName(self, string):
        """
        V.SetParticleFileName(string)
        C++: virtual void SetParticleFileName(const char *_arg)
        
        Set/Get the filename to be used with the particle writer when
        dumping particles to disk
        """
        ...
    
    def SetParticleWriter(self, vtkAbstractParticleWriter):
        """
        V.SetParticleWriter(vtkAbstractParticleWriter)
        C++: virtual void SetParticleWriter(vtkAbstractParticleWriter *pw)
        
        Set/Get the Writer associated with this Particle Tracer Ideally a
        parallel IO capable vtkH5PartWriter should be used which will
        collect particles from all parallel processes and write them to a
        single HDF5 file.
        """
        ...
    
    def SetRotationScale(self, p_float):
        """
        V.SetRotationScale(float)
        C++: void SetRotationScale(double)
        
        This can be used to scale the rate with which the streamribbons
        twist. The default is 1.
        """
        ...
    
    def SetStartTime(self, p_float):
        """
        V.SetStartTime(float)
        C++: void SetStartTime(double t)
        
        Set the time value for particle tracing to begin. The units of
        time should be consistent with the primary time variable.
        """
        ...
    
    def SetStaticMesh(self, p_int):
        """
        V.SetStaticMesh(int)
        C++: virtual void SetStaticMesh(int _arg)
        
        if StaticMesh is set, many optimizations for cell caching can be
        assumed. if StaticMesh is not set, the algorithm will attempt to
        find out if optimizations can be used, but setting it to true
        will force all optimizations. Do not Set StaticMesh to true if a
        dynamic mesh is being used as this will invalidate all results.
        The default is that StaticMesh is 0.
        """
        ...
    
    def SetStaticSeeds(self, p_int):
        """
        V.SetStaticSeeds(int)
        C++: virtual void SetStaticSeeds(int _arg)
        
        if StaticSeeds is set and the mesh is static, then every time
        particles are injected we can re-use the same injection
        information. We classify particles according to processor just
        once before start. If StaticSeeds is set and a moving seed source
        is specified the motion will be ignored and results will not be
        as expected. The default is that StaticSeeds is 0.
        """
        ...
    
    def SetTerminalSpeed(self, p_float):
        """
        V.SetTerminalSpeed(float)
        C++: void SetTerminalSpeed(double)
        
        Specify the terminal speed value, below which integration is
        terminated.
        """
        ...
    
    def SetTerminationTime(self, p_float):
        """
        V.SetTerminationTime(float)
        C++: void SetTerminationTime(double t)
        
        Setting TerminationTime to a positive value will cause particles
        to terminate when the time is reached. Use a vlue of zero to
        disable termination. The units of time should be consistent with
        the primary time variable.
        """
        ...
    
    def __delattr__(self, *args, **kwargs):
        """ Implement delattr(self, name). """
        ...
    
    def __getattribute__(self, *args, **kwargs):
        """ Return getattr(self, name). """
        ...
    
    def __init__(self, *args, **kwargs) -> None:
        ...
    
    @staticmethod
    def __new__(*args, **kwargs):
        """ Create and return a new object.  See help(type) for accurate signature. """
        ...
    
    def __repr__(self, *args, **kwargs):
        """ Return repr(self). """
        ...
    
    def __setattr__(self, *args, **kwargs):
        """ Implement setattr(self, name, value). """
        ...
    
    def __str__(self, *args, **kwargs) -> str:
        """ Return str(self). """
        ...
    
    __this__ = ...
    NONE = ...
    RUNGE_KUTTA2 = ...
    RUNGE_KUTTA4 = ...
    RUNGE_KUTTA45 = ...
    Solvers = ...
    UNKNOWN = ...
    __dict__ = ...
    __vtkname__ = ...


class vtkParticlePathFilter(vtkParticleTracerBase):
    """
    vtkParticlePathFilter - A Parallel Particle tracer for unsteady
    vector fields
    
    Superclass: vtkParticleTracerBase
    
    vtkParticlePathFilter is a filter that integrates a vector field to
    generate particle paths
    
    @sa
    vtkParticlePathFilterBase has the details of the algorithms
    """
    def GetNumberOfGenerationsFromBase(self, string):
        """
        V.GetNumberOfGenerationsFromBase(string) -> int
        C++: vtkIdType GetNumberOfGenerationsFromBase(const char *type)
            override;
        
        Given a the name of a base class of this class type, return the
        distance of inheritance between this class type and the named
        class (how many generations of inheritance are there between this
        class and the named class). If the named class is not in this
        class's inheritance tree, return a negative value. Valid
        responses will always be nonnegative. This method works in
        combination with vtkTypeMacro found in vtkSetGet.h.
        """
        ...
    
    def GetNumberOfGenerationsFromBaseType(self, string):
        """
        V.GetNumberOfGenerationsFromBaseType(string) -> int
        C++: static vtkIdType GetNumberOfGenerationsFromBaseType(
            const char *type)
        
        Given a the name of a base class of this class type, return the
        distance of inheritance between this class type and the named
        class (how many generations of inheritance are there between this
        class and the named class). If the named class is not in this
        class's inheritance tree, return a negative value. Valid
        responses will always be nonnegative. This method works in
        combination with vtkTypeMacro found in vtkSetGet.h.
        """
        ...
    
    def IsA(self, string):
        """
        V.IsA(string) -> int
        C++: vtkTypeBool IsA(const char *type) override;
        
        Return 1 if this class is the same type of (or a subclass of) the
        named class. Returns 0 otherwise. This method works in
        combination with vtkTypeMacro found in vtkSetGet.h.
        """
        ...
    
    def IsTypeOf(self, string):
        """
        V.IsTypeOf(string) -> int
        C++: static vtkTypeBool IsTypeOf(const char *type)
        
        Return 1 if this class type is the same type of (or a subclass
        of) the named class. Returns 0 otherwise. This method works in
        combination with vtkTypeMacro found in vtkSetGet.h.
        """
        ...
    
    def NewInstance(self):
        """
        V.NewInstance() -> vtkParticlePathFilter
        C++: vtkParticlePathFilter *NewInstance()
        """
        ...
    
    def SafeDownCast(self, vtkObjectBase):
        """
        V.SafeDownCast(vtkObjectBase) -> vtkParticlePathFilter
        C++: static vtkParticlePathFilter *SafeDownCast(vtkObjectBase *o)
        """
        ...
    
    def __delattr__(self, *args, **kwargs):
        """ Implement delattr(self, name). """
        ...
    
    def __getattribute__(self, *args, **kwargs):
        """ Return getattr(self, name). """
        ...
    
    def __init__(self, *args, **kwargs) -> None:
        ...
    
    @staticmethod
    def __new__(*args, **kwargs):
        """ Create and return a new object.  See help(type) for accurate signature. """
        ...
    
    def __repr__(self, *args, **kwargs):
        """ Return repr(self). """
        ...
    
    def __setattr__(self, *args, **kwargs):
        """ Implement setattr(self, name, value). """
        ...
    
    def __str__(self, *args, **kwargs) -> str:
        """ Return str(self). """
        ...
    
    __this__ = ...
    __dict__ = ...
    __vtkname__ = ...


class vtkParticleTracer(vtkParticleTracerBase):
    """
    vtkParticleTracer - A Parallel Particle tracer for unsteady vector
    fields
    
    Superclass: vtkParticleTracerBase
    
    vtkParticleTracer is a filter that integrates a vector field to
    advect particles
    
    @sa
    vtkParticleTracerBase has the details of the algorithms
    """
    def GetNumberOfGenerationsFromBase(self, string):
        """
        V.GetNumberOfGenerationsFromBase(string) -> int
        C++: vtkIdType GetNumberOfGenerationsFromBase(const char *type)
            override;
        
        Given a the name of a base class of this class type, return the
        distance of inheritance between this class type and the named
        class (how many generations of inheritance are there between this
        class and the named class). If the named class is not in this
        class's inheritance tree, return a negative value. Valid
        responses will always be nonnegative. This method works in
        combination with vtkTypeMacro found in vtkSetGet.h.
        """
        ...
    
    def GetNumberOfGenerationsFromBaseType(self, string):
        """
        V.GetNumberOfGenerationsFromBaseType(string) -> int
        C++: static vtkIdType GetNumberOfGenerationsFromBaseType(
            const char *type)
        
        Given a the name of a base class of this class type, return the
        distance of inheritance between this class type and the named
        class (how many generations of inheritance are there between this
        class and the named class). If the named class is not in this
        class's inheritance tree, return a negative value. Valid
        responses will always be nonnegative. This method works in
        combination with vtkTypeMacro found in vtkSetGet.h.
        """
        ...
    
    def IsA(self, string):
        """
        V.IsA(string) -> int
        C++: vtkTypeBool IsA(const char *type) override;
        
        Return 1 if this class is the same type of (or a subclass of) the
        named class. Returns 0 otherwise. This method works in
        combination with vtkTypeMacro found in vtkSetGet.h.
        """
        ...
    
    def IsTypeOf(self, string):
        """
        V.IsTypeOf(string) -> int
        C++: static vtkTypeBool IsTypeOf(const char *type)
        
        Return 1 if this class type is the same type of (or a subclass
        of) the named class. Returns 0 otherwise. This method works in
        combination with vtkTypeMacro found in vtkSetGet.h.
        """
        ...
    
    def NewInstance(self):
        """
        V.NewInstance() -> vtkParticleTracer
        C++: vtkParticleTracer *NewInstance()
        """
        ...
    
    def SafeDownCast(self, vtkObjectBase):
        """
        V.SafeDownCast(vtkObjectBase) -> vtkParticleTracer
        C++: static vtkParticleTracer *SafeDownCast(vtkObjectBase *o)
        """
        ...
    
    def __delattr__(self, *args, **kwargs):
        """ Implement delattr(self, name). """
        ...
    
    def __getattribute__(self, *args, **kwargs):
        """ Return getattr(self, name). """
        ...
    
    def __init__(self, *args, **kwargs) -> None:
        ...
    
    @staticmethod
    def __new__(*args, **kwargs):
        """ Create and return a new object.  See help(type) for accurate signature. """
        ...
    
    def __repr__(self, *args, **kwargs):
        """ Return repr(self). """
        ...
    
    def __setattr__(self, *args, **kwargs):
        """ Implement setattr(self, name, value). """
        ...
    
    def __str__(self, *args, **kwargs) -> str:
        """ Return str(self). """
        ...
    
    __this__ = ...
    __dict__ = ...
    __vtkname__ = ...


class vtkStreaklineFilter(vtkParticleTracerBase):
    """
    vtkStreaklineFilter - A Parallel Particle tracer for unsteady vector
    fields
    
    Superclass: vtkParticleTracerBase
    
    vtkStreaklineFilter is a filter that integrates a vector field to
    generate streak lines
    
    @sa
    vtkParticleTracerBase has the details of the algorithms
    """
    def GetNumberOfGenerationsFromBase(self, string):
        """
        V.GetNumberOfGenerationsFromBase(string) -> int
        C++: vtkIdType GetNumberOfGenerationsFromBase(const char *type)
            override;
        
        Given a the name of a base class of this class type, return the
        distance of inheritance between this class type and the named
        class (how many generations of inheritance are there between this
        class and the named class). If the named class is not in this
        class's inheritance tree, return a negative value. Valid
        responses will always be nonnegative. This method works in
        combination with vtkTypeMacro found in vtkSetGet.h.
        """
        ...
    
    def GetNumberOfGenerationsFromBaseType(self, string):
        """
        V.GetNumberOfGenerationsFromBaseType(string) -> int
        C++: static vtkIdType GetNumberOfGenerationsFromBaseType(
            const char *type)
        
        Given a the name of a base class of this class type, return the
        distance of inheritance between this class type and the named
        class (how many generations of inheritance are there between this
        class and the named class). If the named class is not in this
        class's inheritance tree, return a negative value. Valid
        responses will always be nonnegative. This method works in
        combination with vtkTypeMacro found in vtkSetGet.h.
        """
        ...
    
    def IsA(self, string):
        """
        V.IsA(string) -> int
        C++: vtkTypeBool IsA(const char *type) override;
        
        Return 1 if this class is the same type of (or a subclass of) the
        named class. Returns 0 otherwise. This method works in
        combination with vtkTypeMacro found in vtkSetGet.h.
        """
        ...
    
    def IsTypeOf(self, string):
        """
        V.IsTypeOf(string) -> int
        C++: static vtkTypeBool IsTypeOf(const char *type)
        
        Return 1 if this class type is the same type of (or a subclass
        of) the named class. Returns 0 otherwise. This method works in
        combination with vtkTypeMacro found in vtkSetGet.h.
        """
        ...
    
    def NewInstance(self):
        """
        V.NewInstance() -> vtkStreaklineFilter
        C++: vtkStreaklineFilter *NewInstance()
        """
        ...
    
    def SafeDownCast(self, vtkObjectBase):
        """
        V.SafeDownCast(vtkObjectBase) -> vtkStreaklineFilter
        C++: static vtkStreaklineFilter *SafeDownCast(vtkObjectBase *o)
        """
        ...
    
    def __delattr__(self, *args, **kwargs):
        """ Implement delattr(self, name). """
        ...
    
    def __getattribute__(self, *args, **kwargs):
        """ Return getattr(self, name). """
        ...
    
    def __init__(self, *args, **kwargs) -> None:
        ...
    
    @staticmethod
    def __new__(*args, **kwargs):
        """ Create and return a new object.  See help(type) for accurate signature. """
        ...
    
    def __repr__(self, *args, **kwargs):
        """ Return repr(self). """
        ...
    
    def __setattr__(self, *args, **kwargs):
        """ Implement setattr(self, name, value). """
        ...
    
    def __str__(self, *args, **kwargs) -> str:
        """ Return str(self). """
        ...
    
    __this__ = ...
    __dict__ = ...
    __vtkname__ = ...


class vtkStreamTracer(__vtkmodules_vtkCommonExecutionModel.vtkPolyDataAlgorithm):
    """
    vtkStreamTracer - Streamline generator
    
    Superclass: vtkPolyDataAlgorithm
    
    vtkStreamTracer is a filter that integrates a vector field to
    generate streamlines. The integration is performed using a specified
    integrator, by default Runge-Kutta2.
    
    vtkStreamTracer produces polylines as the output, with each cell
    (i.e., polyline) representing a streamline. The attribute values
    associated with each streamline are stored in the cell data, whereas
    those associated with streamline-points are stored in the point data.
    
    vtkStreamTracer supports forward (the default), backward, and
    combined (i.e., BOTH) integration. The length of a streamline is
    governed by specifying a maximum value either in physical arc length
    or in (local) cell length. Otherwise, the integration terminates upon
    exiting the flow field domain, or if the particle speed is reduced to
    a value less than a specified terminal speed, or when a maximum
    number of steps is completed. The specific reason for the termination
    is stored in a cell array named ReasonForTermination.
    
    Note that normalized vectors are adopted in streamline integration,
    which achieves high numerical accuracy/smoothness of flow lines that
    is particularly guaranteed for Runge-Kutta45 with adaptive step size
    and error control). In support of this feature, the underlying step
    size is ALWAYS in arc length unit (LENGTH_UNIT) while the 'real' time
    interval (virtual for steady flows) that a particle actually takes to
    trave in a single step is obtained by dividing the arc length by the
    LOCAL speed. The overall elapsed time (i.e., the life span) of the
    particle is the sum of those individual step-wise time intervals.
    
    The quality of streamline integration can be controlled by setting
    the initial integration step (InitialIntegrationStep), particularly
    for Runge-Kutta2 and Runge-Kutta4 (with a fixed step size), and in
    the case of Runge-Kutta45 (with an adaptive step size and error
    control) the minimum integration step, the maximum integration step,
    and the maximum error. These steps are in either LENGTH_UNIT or
    CELL_LENGTH_UNIT while the error is in physical arc length. For the
    former two integrators, there is a trade-off between integration
    speed and streamline quality.
    
    The integration time, vorticity, rotation and angular velocity are
    stored in point data arrays named "IntegrationTime", "Vorticity",
    "Rotation" and "AngularVelocity", respectively (vorticity, rotation
    and angular velocity are computed only when ComputeVorticity is on).
    All point data attributes in the source dataset are interpolated on
    the new streamline points.
    
    vtkStreamTracer supports integration through any type of dataset.
    Thus if the dataset contains 2D cells like polygons or triangles, the
    integration is constrained to lie on the surface defined by 2D cells.
    
    The starting point, or the so-called 'seed', of a streamline may be
    set in two different ways. Starting from global x-y-z "position"
    allows you to start a single trace at a specified x-y-z coordinate.
    If you specify a source object, traces will be generated from each
    point in the source that is inside the dataset.
    
    @sa
    vtkRibbonFilter vtkRuledSurfaceFilter vtkInitialValueProblemSolver
    vtkRungeKutta2 vtkRungeKutta4 vtkRungeKutta45 vtkParticleTracerBase
    vtkParticleTracer vtkParticlePathFilter vtkStreaklineFilter
    vtkAbstractInterpolatedVelocityField vtkInterpolatedVelocityField
    vtkCellLocatorInterpolatedVelocityField
    """
    def GetComputeVorticity(self):
        """
        V.GetComputeVorticity() -> bool
        C++: virtual bool GetComputeVorticity()
        
        Turn on/off vorticity computation at streamline points (necessary
        for generating proper stream-ribbons using the vtkRibbonFilter.
        """
        ...
    
    def GetInitialIntegrationStep(self):
        """
        V.GetInitialIntegrationStep() -> float
        C++: virtual double GetInitialIntegrationStep()
        
        Specify the Initial step size used for line integration,
        expressed in: LENGTH_UNIT      = 1 CELL_LENGTH_UNIT = 2 (either
        the starting size for an adaptive integrator, e.g., RK45, or the
        constant / fixed size for non-adaptive ones, i.e., RK2 and RK4)
        """
        ...
    
    def GetIntegrationDirection(self):
        """
        V.GetIntegrationDirection() -> int
        C++: virtual int GetIntegrationDirection()
        
        Specify whether the streamline is integrated in the upstream or
        downstream direction.
        """
        ...
    
    def GetIntegrationDirectionMaxValue(self):
        """
        V.GetIntegrationDirectionMaxValue() -> int
        C++: virtual int GetIntegrationDirectionMaxValue()
        
        Specify whether the streamline is integrated in the upstream or
        downstream direction.
        """
        ...
    
    def GetIntegrationDirectionMinValue(self):
        """
        V.GetIntegrationDirectionMinValue() -> int
        C++: virtual int GetIntegrationDirectionMinValue()
        
        Specify whether the streamline is integrated in the upstream or
        downstream direction.
        """
        ...
    
    def GetIntegrationStepUnit(self):
        """
        V.GetIntegrationStepUnit() -> int
        C++: int GetIntegrationStepUnit()
        """
        ...
    
    def GetIntegrator(self):
        """
        V.GetIntegrator() -> vtkInitialValueProblemSolver
        C++: virtual vtkInitialValueProblemSolver *GetIntegrator()
        
        Set/get the integrator type to be used for streamline generation.
        The object passed is not actually used but is cloned with
        NewInstance in the process of integration  (prototype pattern).
        The default is Runge-Kutta2. The integrator can also be changed
        using SetIntegratorType. The recognized solvers are: RUNGE_KUTTA2
         = 0 RUNGE_KUTTA4  = 1 RUNGE_KUTTA45 = 2
        """
        ...
    
    def GetIntegratorType(self):
        """
        V.GetIntegratorType() -> int
        C++: int GetIntegratorType()
        
        Set/get the integrator type to be used for streamline generation.
        The object passed is not actually used but is cloned with
        NewInstance in the process of integration  (prototype pattern).
        The default is Runge-Kutta2. The integrator can also be changed
        using SetIntegratorType. The recognized solvers are: RUNGE_KUTTA2
         = 0 RUNGE_KUTTA4  = 1 RUNGE_KUTTA45 = 2
        """
        ...
    
    def GetMaximumError(self):
        """
        V.GetMaximumError() -> float
        C++: virtual double GetMaximumError()
        
        Specify the maximum error tolerated throughout streamline
        integration.
        """
        ...
    
    def GetMaximumIntegrationStep(self):
        """
        V.GetMaximumIntegrationStep() -> float
        C++: virtual double GetMaximumIntegrationStep()
        
        Specify the Maximum step size used for line integration,
        expressed in: LENGTH_UNIT      = 1 CELL_LENGTH_UNIT = 2 (Only
        valid for an adaptive integrator, e.g., RK45)
        """
        ...
    
    def GetMaximumNumberOfSteps(self):
        """
        V.GetMaximumNumberOfSteps() -> int
        C++: virtual vtkIdType GetMaximumNumberOfSteps()
        
        Specify the maximum number of steps for integrating a streamline.
        """
        ...
    
    def GetMaximumPropagation(self):
        """
        V.GetMaximumPropagation() -> float
        C++: virtual double GetMaximumPropagation()
        
        Specify the maximum length of a streamline expressed in
        LENGTH_UNIT.
        """
        ...
    
    def GetMinimumIntegrationStep(self):
        """
        V.GetMinimumIntegrationStep() -> float
        C++: virtual double GetMinimumIntegrationStep()
        
        Specify the Minimum step size used for line integration,
        expressed in: LENGTH_UNIT      = 1 CELL_LENGTH_UNIT = 2 (Only
        valid for an adaptive integrator, e.g., RK45)
        """
        ...
    
    def GetNumberOfGenerationsFromBase(self, string):
        """
        V.GetNumberOfGenerationsFromBase(string) -> int
        C++: vtkIdType GetNumberOfGenerationsFromBase(const char *type)
            override;
        
        Given a the name of a base class of this class type, return the
        distance of inheritance between this class type and the named
        class (how many generations of inheritance are there between this
        class and the named class). If the named class is not in this
        class's inheritance tree, return a negative value. Valid
        responses will always be nonnegative. This method works in
        combination with vtkTypeMacro found in vtkSetGet.h.
        """
        ...
    
    def GetNumberOfGenerationsFromBaseType(self, string):
        """
        V.GetNumberOfGenerationsFromBaseType(string) -> int
        C++: static vtkIdType GetNumberOfGenerationsFromBaseType(
            const char *type)
        
        Given a the name of a base class of this class type, return the
        distance of inheritance between this class type and the named
        class (how many generations of inheritance are there between this
        class and the named class). If the named class is not in this
        class's inheritance tree, return a negative value. Valid
        responses will always be nonnegative. This method works in
        combination with vtkTypeMacro found in vtkSetGet.h.
        """
        ...
    
    def GetRotationScale(self):
        """
        V.GetRotationScale() -> float
        C++: virtual double GetRotationScale()
        
        This can be used to scale the rate with which the streamribbons
        twist. The default is 1.
        """
        ...
    
    def GetSource(self):
        """
        V.GetSource() -> vtkDataSet
        C++: vtkDataSet *GetSource()
        
        Specify the source object used to generate starting points
        (seeds). Note that this method does not connect the pipeline. The
        algorithm will work on the input data as it is without updating
        the producer of the data. See SetSourceConnection for connecting
        the pipeline.
        """
        ...
    
    def GetStartPosition(self):
        """
        V.GetStartPosition() -> (float, float, float)
        C++: virtual double *GetStartPosition()
        
        Specify the starting point (seed) of a streamline in the global
        coordinate system. Search must be performed to find the initial
        cell from which to start integration.
        """
        ...
    
    def GetSurfaceStreamlines(self):
        """
        V.GetSurfaceStreamlines() -> bool
        C++: virtual bool GetSurfaceStreamlines()
        
        Set/Unset the streamlines to be computed on a surface
        """
        ...
    
    def GetTerminalSpeed(self):
        """
        V.GetTerminalSpeed() -> float
        C++: virtual double GetTerminalSpeed()
        
        Specify the terminal speed value, below which integration is
        terminated.
        """
        ...
    
    def IsA(self, string):
        """
        V.IsA(string) -> int
        C++: vtkTypeBool IsA(const char *type) override;
        
        Return 1 if this class is the same type of (or a subclass of) the
        named class. Returns 0 otherwise. This method works in
        combination with vtkTypeMacro found in vtkSetGet.h.
        """
        ...
    
    def IsTypeOf(self, string):
        """
        V.IsTypeOf(string) -> int
        C++: static vtkTypeBool IsTypeOf(const char *type)
        
        Return 1 if this class type is the same type of (or a subclass
        of) the named class. Returns 0 otherwise. This method works in
        combination with vtkTypeMacro found in vtkSetGet.h.
        """
        ...
    
    def NewInstance(self):
        """
        V.NewInstance() -> vtkStreamTracer
        C++: vtkStreamTracer *NewInstance()
        """
        ...
    
    def SafeDownCast(self, vtkObjectBase):
        """
        V.SafeDownCast(vtkObjectBase) -> vtkStreamTracer
        C++: static vtkStreamTracer *SafeDownCast(vtkObjectBase *o)
        """
        ...
    
    def SetComputeVorticity(self, bool):
        """
        V.SetComputeVorticity(bool)
        C++: virtual void SetComputeVorticity(bool _arg)
        
        Turn on/off vorticity computation at streamline points (necessary
        for generating proper stream-ribbons using the vtkRibbonFilter.
        """
        ...
    
    def SetInitialIntegrationStep(self, p_float):
        """
        V.SetInitialIntegrationStep(float)
        C++: virtual void SetInitialIntegrationStep(double _arg)
        
        Specify the Initial step size used for line integration,
        expressed in: LENGTH_UNIT      = 1 CELL_LENGTH_UNIT = 2 (either
        the starting size for an adaptive integrator, e.g., RK45, or the
        constant / fixed size for non-adaptive ones, i.e., RK2 and RK4)
        """
        ...
    
    def SetIntegrationDirection(self, p_int):
        """
        V.SetIntegrationDirection(int)
        C++: virtual void SetIntegrationDirection(int _arg)
        
        Specify whether the streamline is integrated in the upstream or
        downstream direction.
        """
        ...
    
    def SetIntegrationDirectionToBackward(self):
        """
        V.SetIntegrationDirectionToBackward()
        C++: void SetIntegrationDirectionToBackward()
        
        Specify whether the streamline is integrated in the upstream or
        downstream direction.
        """
        ...
    
    def SetIntegrationDirectionToBoth(self):
        """
        V.SetIntegrationDirectionToBoth()
        C++: void SetIntegrationDirectionToBoth()
        
        Specify whether the streamline is integrated in the upstream or
        downstream direction.
        """
        ...
    
    def SetIntegrationDirectionToForward(self):
        """
        V.SetIntegrationDirectionToForward()
        C++: void SetIntegrationDirectionToForward()
        
        Specify whether the streamline is integrated in the upstream or
        downstream direction.
        """
        ...
    
    def SetIntegrationStepUnit(self, p_int):
        """
        V.SetIntegrationStepUnit(int)
        C++: void SetIntegrationStepUnit(int unit)
        
        Specify a uniform integration step unit for
        MinimumIntegrationStep, InitialIntegrationStep, and
        MaximumIntegrationStep. NOTE: The valid unit is now limited to
        only LENGTH_UNIT (1) and CELL_LENGTH_UNIT (2), EXCLUDING the
        previously-supported TIME_UNIT.
        """
        ...
    
    def SetIntegrator(self, vtkInitialValueProblemSolver):
        """
        V.SetIntegrator(vtkInitialValueProblemSolver)
        C++: void SetIntegrator(vtkInitialValueProblemSolver *)
        
        Set/get the integrator type to be used for streamline generation.
        The object passed is not actually used but is cloned with
        NewInstance in the process of integration  (prototype pattern).
        The default is Runge-Kutta2. The integrator can also be changed
        using SetIntegratorType. The recognized solvers are: RUNGE_KUTTA2
         = 0 RUNGE_KUTTA4  = 1 RUNGE_KUTTA45 = 2
        """
        ...
    
    def SetIntegratorType(self, p_int):
        """
        V.SetIntegratorType(int)
        C++: void SetIntegratorType(int type)
        
        Set/get the integrator type to be used for streamline generation.
        The object passed is not actually used but is cloned with
        NewInstance in the process of integration  (prototype pattern).
        The default is Runge-Kutta2. The integrator can also be changed
        using SetIntegratorType. The recognized solvers are: RUNGE_KUTTA2
         = 0 RUNGE_KUTTA4  = 1 RUNGE_KUTTA45 = 2
        """
        ...
    
    def SetIntegratorTypeToRungeKutta2(self):
        """
        V.SetIntegratorTypeToRungeKutta2()
        C++: void SetIntegratorTypeToRungeKutta2()
        
        Set/get the integrator type to be used for streamline generation.
        The object passed is not actually used but is cloned with
        NewInstance in the process of integration  (prototype pattern).
        The default is Runge-Kutta2. The integrator can also be changed
        using SetIntegratorType. The recognized solvers are: RUNGE_KUTTA2
         = 0 RUNGE_KUTTA4  = 1 RUNGE_KUTTA45 = 2
        """
        ...
    
    def SetIntegratorTypeToRungeKutta4(self):
        """
        V.SetIntegratorTypeToRungeKutta4()
        C++: void SetIntegratorTypeToRungeKutta4()
        
        Set/get the integrator type to be used for streamline generation.
        The object passed is not actually used but is cloned with
        NewInstance in the process of integration  (prototype pattern).
        The default is Runge-Kutta2. The integrator can also be changed
        using SetIntegratorType. The recognized solvers are: RUNGE_KUTTA2
         = 0 RUNGE_KUTTA4  = 1 RUNGE_KUTTA45 = 2
        """
        ...
    
    def SetIntegratorTypeToRungeKutta45(self):
        """
        V.SetIntegratorTypeToRungeKutta45()
        C++: void SetIntegratorTypeToRungeKutta45()
        
        Set/get the integrator type to be used for streamline generation.
        The object passed is not actually used but is cloned with
        NewInstance in the process of integration  (prototype pattern).
        The default is Runge-Kutta2. The integrator can also be changed
        using SetIntegratorType. The recognized solvers are: RUNGE_KUTTA2
         = 0 RUNGE_KUTTA4  = 1 RUNGE_KUTTA45 = 2
        """
        ...
    
    def SetInterpolatorPrototype(self, vtkAbstractInterpolatedVelocityField):
        """
        V.SetInterpolatorPrototype(vtkAbstractInterpolatedVelocityField)
        C++: void SetInterpolatorPrototype(
            vtkAbstractInterpolatedVelocityField *ivf)
        
        The object used to interpolate the velocity field during
        integration is of the same class as this prototype.
        """
        ...
    
    def SetInterpolatorType(self, p_int):
        """
        V.SetInterpolatorType(int)
        C++: void SetInterpolatorType(int interpType)
        
        Set the type of the velocity field interpolator to determine
        whether vtkInterpolatedVelocityField
        (INTERPOLATOR_WITH_DATASET_POINT_LOCATOR) or
        vtkCellLocatorInterpolatedVelocityField
        (INTERPOLATOR_WITH_CELL_LOCATOR) is employed for locating cells
        during streamline integration. The latter (adopting
        vtkAbstractCellLocator sub-classes such as vtkCellLocator and
        vtkModifiedBSPTree) is more robust then the former (through
        vtkDataSet / vtkPointSet::FindCell() coupled with
        vtkPointLocator).
        """
        ...
    
    def SetInterpolatorTypeToCellLocator(self):
        """
        V.SetInterpolatorTypeToCellLocator()
        C++: void SetInterpolatorTypeToCellLocator()
        
        Set the velocity field interpolator type to the one involving a
        cell locator.
        """
        ...
    
    def SetInterpolatorTypeToDataSetPointLocator(self):
        """
        V.SetInterpolatorTypeToDataSetPointLocator()
        C++: void SetInterpolatorTypeToDataSetPointLocator()
        
        Set the velocity field interpolator type to the one involving a
        dataset point locator.
        """
        ...
    
    def SetMaximumError(self, p_float):
        """
        V.SetMaximumError(float)
        C++: virtual void SetMaximumError(double _arg)
        
        Specify the maximum error tolerated throughout streamline
        integration.
        """
        ...
    
    def SetMaximumIntegrationStep(self, p_float):
        """
        V.SetMaximumIntegrationStep(float)
        C++: virtual void SetMaximumIntegrationStep(double _arg)
        
        Specify the Maximum step size used for line integration,
        expressed in: LENGTH_UNIT      = 1 CELL_LENGTH_UNIT = 2 (Only
        valid for an adaptive integrator, e.g., RK45)
        """
        ...
    
    def SetMaximumNumberOfSteps(self, p_int):
        """
        V.SetMaximumNumberOfSteps(int)
        C++: virtual void SetMaximumNumberOfSteps(vtkIdType _arg)
        
        Specify the maximum number of steps for integrating a streamline.
        """
        ...
    
    def SetMaximumPropagation(self, p_float):
        """
        V.SetMaximumPropagation(float)
        C++: virtual void SetMaximumPropagation(double _arg)
        
        Specify the maximum length of a streamline expressed in
        LENGTH_UNIT.
        """
        ...
    
    def SetMinimumIntegrationStep(self, p_float):
        """
        V.SetMinimumIntegrationStep(float)
        C++: virtual void SetMinimumIntegrationStep(double _arg)
        
        Specify the Minimum step size used for line integration,
        expressed in: LENGTH_UNIT      = 1 CELL_LENGTH_UNIT = 2 (Only
        valid for an adaptive integrator, e.g., RK45)
        """
        ...
    
    def SetRotationScale(self, p_float):
        """
        V.SetRotationScale(float)
        C++: virtual void SetRotationScale(double _arg)
        
        This can be used to scale the rate with which the streamribbons
        twist. The default is 1.
        """
        ...
    
    def SetSourceConnection(self, vtkAlgorithmOutput):
        """
        V.SetSourceConnection(vtkAlgorithmOutput)
        C++: void SetSourceConnection(vtkAlgorithmOutput *algOutput)
        
        Specify the source object used to generate starting points
        (seeds). New style.
        """
        ...
    
    def SetSourceData(self, vtkDataSet):
        """
        V.SetSourceData(vtkDataSet)
        C++: void SetSourceData(vtkDataSet *source)
        
        Specify the source object used to generate starting points
        (seeds). Note that this method does not connect the pipeline. The
        algorithm will work on the input data as it is without updating
        the producer of the data. See SetSourceConnection for connecting
        the pipeline.
        """
        ...
    
    def SetStartPosition(self, p_float, p_float_1, p_float_2):
        """
        V.SetStartPosition(float, float, float)
        C++: virtual void SetStartPosition(double _arg1, double _arg2,
            double _arg3)
        V.SetStartPosition((float, float, float))
        C++: virtual void SetStartPosition(const double _arg[3])
        
        Specify the starting point (seed) of a streamline in the global
        coordinate system. Search must be performed to find the initial
        cell from which to start integration.
        """
        ...
    
    def SetSurfaceStreamlines(self, bool):
        """
        V.SetSurfaceStreamlines(bool)
        C++: virtual void SetSurfaceStreamlines(bool _arg)
        
        Set/Unset the streamlines to be computed on a surface
        """
        ...
    
    def SetTerminalSpeed(self, p_float):
        """
        V.SetTerminalSpeed(float)
        C++: virtual void SetTerminalSpeed(double _arg)
        
        Specify the terminal speed value, below which integration is
        terminated.
        """
        ...
    
    def SurfaceStreamlinesOff(self):
        """
        V.SurfaceStreamlinesOff()
        C++: virtual void SurfaceStreamlinesOff()
        
        Set/Unset the streamlines to be computed on a surface
        """
        ...
    
    def SurfaceStreamlinesOn(self):
        """
        V.SurfaceStreamlinesOn()
        C++: virtual void SurfaceStreamlinesOn()
        
        Set/Unset the streamlines to be computed on a surface
        """
        ...
    
    def __delattr__(self, *args, **kwargs):
        """ Implement delattr(self, name). """
        ...
    
    def __getattribute__(self, *args, **kwargs):
        """ Return getattr(self, name). """
        ...
    
    def __init__(self, *args, **kwargs) -> None:
        ...
    
    @staticmethod
    def __new__(*args, **kwargs):
        """ Create and return a new object.  See help(type) for accurate signature. """
        ...
    
    def __repr__(self, *args, **kwargs):
        """ Return repr(self). """
        ...
    
    def __setattr__(self, *args, **kwargs):
        """ Implement setattr(self, name, value). """
        ...
    
    def __str__(self, *args, **kwargs) -> str:
        """ Return str(self). """
        ...
    
    __this__ = ...
    BACKWARD = ...
    BOTH = ...
    CELL_LENGTH_UNIT = ...
    FIXED_REASONS_FOR_TERMINATION_COUNT = ...
    FORWARD = ...
    INTERPOLATOR_WITH_CELL_LOCATOR = ...
    INTERPOLATOR_WITH_DATASET_POINT_LOCATOR = ...
    LENGTH_UNIT = ...
    NONE = ...
    NOT_INITIALIZED = ...
    OUT_OF_DOMAIN = ...
    OUT_OF_LENGTH = ...
    OUT_OF_STEPS = ...
    ReasonForTermination = ...
    RUNGE_KUTTA2 = ...
    RUNGE_KUTTA4 = ...
    RUNGE_KUTTA45 = ...
    Solvers = ...
    STAGNATION = ...
    UNEXPECTED_VALUE = ...
    Units = ...
    UNKNOWN = ...
    __dict__ = ...
    __vtkname__ = ...


class vtkTemporalInterpolatedVelocityField(__vtkmodules_vtkCommonMath.vtkFunctionSet):
    """
    vtkTemporalInterpolatedVelocityField - A helper class for
    interpolating between times during particle tracing
    
    Superclass: vtkFunctionSet
    
    vtkTemporalInterpolatedVelocityField is a general purpose helper for
    the temporal particle tracing code (vtkParticleTracerBase)
    
    It maintains two copies of vtkCachingInterpolatedVelocityField
    internally and uses them to obtain velocity values at time T0 and T1.
    
    In fact the class does quite a bit more than this because when the
    geometry of the datasets is the same at T0 and T1, we can re-use
    cached cell Ids and weights used in the cell interpolation routines.
    Additionally, the same weights can be used when interpolating (point)
    scalar values and computing vorticity etc.
    
    @warning
    vtkTemporalInterpolatedVelocityField is probably not thread safe. A
    new instance should be created by each thread.
    
    @warning
    Datasets are added in lists. The list for T1 must be identical to
    that for T0 in structure/topology and dataset order, and any datasets
    marked as static, must remain so for all T - changing a dataset from
    static to dynamic between time steps will result in undefined
    behaviour (=crash probably)
    
    @sa
    vtkCachingInterpolatedVelocityField vtkParticleTracerBase
    vtkParticleTracer vtkParticlePathFilter vtkStreaklineFilter
    """
    def AdvanceOneTimeStep(self):
        """
        V.AdvanceOneTimeStep()
        C++: void AdvanceOneTimeStep()
        """
        ...
    
    def ClearCache(self):
        """
        V.ClearCache()
        C++: void ClearCache()
        
        Set the last cell id to -1 so that the next search does not start
        from the previous cell
        """
        ...
    
    def FunctionValues(self, *float, **kwargs):
        """
        V.FunctionValues([float, ...], [float, ...]) -> int
        C++: int FunctionValues(double *x, double *u) override;
        V.FunctionValues([float, ...], [float, ...], void) -> int
        C++: virtual int FunctionValues(double *x, double *f,
            void *userData)
        
        Evaluate the velocity field, f, at (x, y, z, t). For now, t is
        ignored.
        """
        ...
    
    def FunctionValuesAtT(self, p_int, *float, **kwargs):
        """
        V.FunctionValuesAtT(int, [float, ...], [float, ...]) -> int
        C++: int FunctionValuesAtT(int T, double *x, double *u)
        
        Evaluate the velocity field, f, at (x, y, z, t). For now, t is
        ignored.
        """
        ...
    
    def GetCachedCellIds(self, p_int=..., p_int=..., *args, **kwargs):
        """
        V.GetCachedCellIds([int, int], [int, int]) -> bool
        C++: bool GetCachedCellIds(vtkIdType id[2], int ds[2])
        
        Between iterations of the Particle Tracer, Id's of the Cell are
        stored and then at the start of the next particle the Ids are set
        to 'pre-fill' the cache.
        """
        ...
    
    def GetCurrentWeight(self):
        """
        V.GetCurrentWeight() -> float
        C++: virtual double GetCurrentWeight()
        
        Get the most recent weight between 0->1 from T1->T2. Initial
        value is 0.
        """
        ...
    
    def GetLastGoodVelocity(self):
        """
        V.GetLastGoodVelocity() -> (float, float, float)
        C++: virtual double *GetLastGoodVelocity()
        
        If an interpolation was successful, we can retrieve the last
        computed value from here. Initial value is (0.0,0.0,0.0)
        """
        ...
    
    def GetNumberOfGenerationsFromBase(self, string):
        """
        V.GetNumberOfGenerationsFromBase(string) -> int
        C++: vtkIdType GetNumberOfGenerationsFromBase(const char *type)
            override;
        
        Given a the name of a base class of this class type, return the
        distance of inheritance between this class type and the named
        class (how many generations of inheritance are there between this
        class and the named class). If the named class is not in this
        class's inheritance tree, return a negative value. Valid
        responses will always be nonnegative. This method works in
        combination with vtkTypeMacro found in vtkSetGet.h.
        """
        ...
    
    def GetNumberOfGenerationsFromBaseType(self, string):
        """
        V.GetNumberOfGenerationsFromBaseType(string) -> int
        C++: static vtkIdType GetNumberOfGenerationsFromBaseType(
            const char *type)
        
        Given a the name of a base class of this class type, return the
        distance of inheritance between this class type and the named
        class (how many generations of inheritance are there between this
        class and the named class). If the named class is not in this
        class's inheritance tree, return a negative value. Valid
        responses will always be nonnegative. This method works in
        combination with vtkTypeMacro found in vtkSetGet.h.
        """
        ...
    
    def InterpolatePoint(self, vtkPointData, vtkPointData_1, p_int):
        """
        V.InterpolatePoint(vtkPointData, vtkPointData, int) -> bool
        C++: bool InterpolatePoint(vtkPointData *outPD1,
            vtkPointData *outPD2, vtkIdType outIndex)
        V.InterpolatePoint(int, vtkPointData, int) -> bool
        C++: bool InterpolatePoint(int T, vtkPointData *outPD1,
            vtkIdType outIndex)
        """
        ...
    
    def IsA(self, string):
        """
        V.IsA(string) -> int
        C++: vtkTypeBool IsA(const char *type) override;
        
        Return 1 if this class is the same type of (or a subclass of) the
        named class. Returns 0 otherwise. This method works in
        combination with vtkTypeMacro found in vtkSetGet.h.
        """
        ...
    
    def IsStatic(self, p_int):
        """
        V.IsStatic(int) -> bool
        C++: bool IsStatic(int datasetIndex)
        """
        ...
    
    def IsTypeOf(self, string):
        """
        V.IsTypeOf(string) -> int
        C++: static vtkTypeBool IsTypeOf(const char *type)
        
        Return 1 if this class type is the same type of (or a subclass
        of) the named class. Returns 0 otherwise. This method works in
        combination with vtkTypeMacro found in vtkSetGet.h.
        """
        ...
    
    def NewInstance(self):
        """
        V.NewInstance() -> vtkTemporalInterpolatedVelocityField
        C++: vtkTemporalInterpolatedVelocityField *NewInstance()
        """
        ...
    
    def QuickTestPoint(self, *float):
        """
        V.QuickTestPoint([float, ...]) -> int
        C++: int QuickTestPoint(double *x)
        
        A utility function which evaluates the point at T1, T2 to see if
        it is inside the data at both times or only one.
        """
        ...
    
    def SafeDownCast(self, vtkObjectBase):
        """
        V.SafeDownCast(vtkObjectBase)
            -> vtkTemporalInterpolatedVelocityField
        C++: static vtkTemporalInterpolatedVelocityField *SafeDownCast(
            vtkObjectBase *o)
        """
        ...
    
    def SelectVectors(self, string):
        """
        V.SelectVectors(string)
        C++: void SelectVectors(const char *fieldName)
        
        If you want to work with an arbitrary vector array, then set its
        name here. By default this is nullptr and the filter will use the
        active vector array.
        """
        ...
    
    def SetCachedCellIds(self, p_int=..., p_int=..., *args, **kwargs):
        """
        V.SetCachedCellIds([int, int], [int, int])
        C++: void SetCachedCellIds(vtkIdType id[2], int ds[2])
        
        Between iterations of the Particle Tracer, Id's of the Cell are
        stored and then at the start of the next particle the Ids are set
        to 'pre-fill' the cache.
        """
        ...
    
    def SetDataSetAtTime(self, p_int, p_int_1, p_float, vtkDataSet, bool):
        """
        V.SetDataSetAtTime(int, int, float, vtkDataSet, bool)
        C++: void SetDataSetAtTime(int I, int N, double T,
            vtkDataSet *dataset, bool staticdataset)
        
        In order to use this class, two sets of data must be supplied,
        corresponding to times T1 and T2. Data is added via this
        function.
        """
        ...
    
    def ShowCacheResults(self):
        """
        V.ShowCacheResults()
        C++: void ShowCacheResults()
        """
        ...
    
    def TestPoint(self, *float):
        """
        V.TestPoint([float, ...]) -> int
        C++: int TestPoint(double *x)
        
        A utility function which evaluates the point at T1, T2 to see if
        it is inside the data at both times or only one.
        """
        ...
    
    def __delattr__(self, *args, **kwargs):
        """ Implement delattr(self, name). """
        ...
    
    def __getattribute__(self, *args, **kwargs):
        """ Return getattr(self, name). """
        ...
    
    def __init__(self, *args, **kwargs) -> None:
        ...
    
    @staticmethod
    def __new__(*args, **kwargs):
        """ Create and return a new object.  See help(type) for accurate signature. """
        ...
    
    def __repr__(self, *args, **kwargs):
        """ Return repr(self). """
        ...
    
    def __setattr__(self, *args, **kwargs):
        """ Implement setattr(self, name, value). """
        ...
    
    def __str__(self, *args, **kwargs) -> str:
        """ Return str(self). """
        ...
    
    __this__ = ...
    __dict__ = ...
    __vtkname__ = ...


class vtkTemporalStreamTracer(vtkStreamTracer):
    """
    vtkTemporalStreamTracer - A Parallel Particle tracer for unsteady
    vector fields
    
    Superclass: vtkStreamTracer
    
    vtkTemporalStreamTracer is a filter that integrates a vector field to
    generate
    
    @sa
    vtkRibbonFilter vtkRuledSurfaceFilter vtkInitialValueProblemSolver
    vtkRungeKutta2 vtkRungeKutta4 vtkRungeKutta45 vtkStreamTracer
    
    This class is deprecated. Use instead one of the following classes:
    vtkParticleTracerBase vtkParticleTracer vtkParticlePathFilter
    vtkStreaklineFilter See
    https://blog.kitware.com/improvements-in-path-tracing-in-vtk/
    """
    def AddSourceConnection(self, vtkAlgorithmOutput):
        """
        V.AddSourceConnection(vtkAlgorithmOutput)
        C++: void AddSourceConnection(vtkAlgorithmOutput *input)
        
        Provide support for multiple see sources
        """
        ...
    
    def EnableParticleWritingOff(self):
        """
        V.EnableParticleWritingOff()
        C++: virtual void EnableParticleWritingOff()
        
        Set/Get the filename to be used with the particle writer when
        dumping particles to disk
        """
        ...
    
    def EnableParticleWritingOn(self):
        """
        V.EnableParticleWritingOn()
        C++: virtual void EnableParticleWritingOn()
        
        Set/Get the filename to be used with the particle writer when
        dumping particles to disk
        """
        ...
    
    def GetEnableParticleWriting(self):
        """
        V.GetEnableParticleWriting() -> int
        C++: virtual vtkTypeBool GetEnableParticleWriting()
        
        Set/Get the filename to be used with the particle writer when
        dumping particles to disk
        """
        ...
    
    def GetForceReinjectionEveryNSteps(self):
        """
        V.GetForceReinjectionEveryNSteps() -> int
        C++: virtual int GetForceReinjectionEveryNSteps()
        
        When animating particles, it is nice to inject new ones every Nth
        step to produce a continuous flow. Setting
        ForceReinjectionEveryNSteps to a non zero value will cause the
        particle source to reinject particles every Nth step even if it
        is otherwise unchanged. Note that if the particle source is also
        animated, this flag will be redundant as the particles will be
        reinjected whenever the source changes anyway
        """
        ...
    
    def GetIgnorePipelineTime(self):
        """
        V.GetIgnorePipelineTime() -> int
        C++: virtual vtkTypeBool GetIgnorePipelineTime()
        
        To get around problems with the Paraview Animation controls we
        can just animate the time step and ignore the TIME_ requests
        """
        ...
    
    def GetNumberOfGenerationsFromBase(self, string):
        """
        V.GetNumberOfGenerationsFromBase(string) -> int
        C++: vtkIdType GetNumberOfGenerationsFromBase(const char *type)
            override;
        
        Given a the name of a base class of this class type, return the
        distance of inheritance between this class type and the named
        class (how many generations of inheritance are there between this
        class and the named class). If the named class is not in this
        class's inheritance tree, return a negative value. Valid
        responses will always be nonnegative. This method works in
        combination with vtkTypeMacro found in vtkSetGet.h.
        """
        ...
    
    def GetNumberOfGenerationsFromBaseType(self, string):
        """
        V.GetNumberOfGenerationsFromBaseType(string) -> int
        C++: static vtkIdType GetNumberOfGenerationsFromBaseType(
            const char *type)
        
        Given a the name of a base class of this class type, return the
        distance of inheritance between this class type and the named
        class (how many generations of inheritance are there between this
        class and the named class). If the named class is not in this
        class's inheritance tree, return a negative value. Valid
        responses will always be nonnegative. This method works in
        combination with vtkTypeMacro found in vtkSetGet.h.
        """
        ...
    
    def GetParticleFileName(self):
        """
        V.GetParticleFileName() -> string
        C++: virtual char *GetParticleFileName()
        
        Set/Get the filename to be used with the particle writer when
        dumping particles to disk
        """
        ...
    
    def GetParticleWriter(self):
        """
        V.GetParticleWriter() -> vtkAbstractParticleWriter
        C++: virtual vtkAbstractParticleWriter *GetParticleWriter()
        
        Set/Get the Writer associated with this Particle Tracer Ideally a
        parallel IO capable vtkH5PartWriter should be used which will
        collect particles from all parallel processes and write them to a
        single HDF5 file.
        """
        ...
    
    def GetStaticMesh(self):
        """
        V.GetStaticMesh() -> int
        C++: virtual vtkTypeBool GetStaticMesh()
        
        if StaticMesh is set, many optimizations for cell caching can be
        assumed. if StaticMesh is not set, the algorithm will attempt to
        find out if optimizations can be used, but setting it to true
        will force all optimizations. Do not Set StaticMesh to true if a
        dynamic mesh is being used as this will invalidate all results.
        """
        ...
    
    def GetStaticSeeds(self):
        """
        V.GetStaticSeeds() -> int
        C++: virtual vtkTypeBool GetStaticSeeds()
        
        if StaticSeeds is set and the mesh is static, then every time
        particles are injected we can re-use the same injection
        information. We classify particles according to processor just
        once before start. If StaticSeeds is set and a moving seed source
        is specified the motion will be ignored and results will not be
        as expected.
        """
        ...
    
    def GetTerminationTime(self):
        """
        V.GetTerminationTime() -> float
        C++: virtual double GetTerminationTime()
        
        Setting TerminationTime to a positive value will cause particles
        to terminate when the time is reached. Use a vlue of zero to
        disable termination. The units of time should be consistent with
        the primary time variable.
        """
        ...
    
    def GetTerminationTimeUnit(self):
        """
        V.GetTerminationTimeUnit() -> int
        C++: virtual int GetTerminationTimeUnit()
        
        The units of TerminationTime may be actual 'Time' units as
        described by the data, or just TimeSteps of iteration.
        """
        ...
    
    def GetTimeStep(self):
        """
        V.GetTimeStep() -> int
        C++: virtual unsigned int GetTimeStep()
        
        Set/Get the TimeStep. This is the primary means of advancing the
        particles. The TimeStep should be animated and this will drive
        the pipeline forcing timesteps to be fetched from upstream.
        """
        ...
    
    def GetTimeStepResolution(self):
        """
        V.GetTimeStepResolution() -> float
        C++: virtual double GetTimeStepResolution()
        
        If the data source does not have the correct time values present
        on each time step - setting this value to non unity can be used
        to adjust the time step size from 1s pre step to
        1x_TimeStepResolution : Not functional in this version. Broke it
        @todo, put back time scaling
        """
        ...
    
    def IgnorePipelineTimeOff(self):
        """
        V.IgnorePipelineTimeOff()
        C++: virtual void IgnorePipelineTimeOff()
        
        To get around problems with the Paraview Animation controls we
        can just animate the time step and ignore the TIME_ requests
        """
        ...
    
    def IgnorePipelineTimeOn(self):
        """
        V.IgnorePipelineTimeOn()
        C++: virtual void IgnorePipelineTimeOn()
        
        To get around problems with the Paraview Animation controls we
        can just animate the time step and ignore the TIME_ requests
        """
        ...
    
    def IsA(self, string):
        """
        V.IsA(string) -> int
        C++: vtkTypeBool IsA(const char *type) override;
        
        Return 1 if this class is the same type of (or a subclass of) the
        named class. Returns 0 otherwise. This method works in
        combination with vtkTypeMacro found in vtkSetGet.h.
        """
        ...
    
    def IsTypeOf(self, string):
        """
        V.IsTypeOf(string) -> int
        C++: static vtkTypeBool IsTypeOf(const char *type)
        
        Return 1 if this class type is the same type of (or a subclass
        of) the named class. Returns 0 otherwise. This method works in
        combination with vtkTypeMacro found in vtkSetGet.h.
        """
        ...
    
    def NewInstance(self):
        """
        V.NewInstance() -> vtkTemporalStreamTracer
        C++: vtkTemporalStreamTracer *NewInstance()
        """
        ...
    
    def RemoveAllSources(self):
        """
        V.RemoveAllSources()
        C++: void RemoveAllSources()
        
        Provide support for multiple see sources
        """
        ...
    
    def SafeDownCast(self, vtkObjectBase):
        """
        V.SafeDownCast(vtkObjectBase) -> vtkTemporalStreamTracer
        C++: static vtkTemporalStreamTracer *SafeDownCast(
            vtkObjectBase *o)
        """
        ...
    
    def SetEnableParticleWriting(self, p_int):
        """
        V.SetEnableParticleWriting(int)
        C++: virtual void SetEnableParticleWriting(vtkTypeBool _arg)
        
        Set/Get the filename to be used with the particle writer when
        dumping particles to disk
        """
        ...
    
    def SetForceReinjectionEveryNSteps(self, p_int):
        """
        V.SetForceReinjectionEveryNSteps(int)
        C++: virtual void SetForceReinjectionEveryNSteps(int _arg)
        
        When animating particles, it is nice to inject new ones every Nth
        step to produce a continuous flow. Setting
        ForceReinjectionEveryNSteps to a non zero value will cause the
        particle source to reinject particles every Nth step even if it
        is otherwise unchanged. Note that if the particle source is also
        animated, this flag will be redundant as the particles will be
        reinjected whenever the source changes anyway
        """
        ...
    
    def SetIgnorePipelineTime(self, p_int):
        """
        V.SetIgnorePipelineTime(int)
        C++: virtual void SetIgnorePipelineTime(vtkTypeBool _arg)
        
        To get around problems with the Paraview Animation controls we
        can just animate the time step and ignore the TIME_ requests
        """
        ...
    
    def SetParticleFileName(self, string):
        """
        V.SetParticleFileName(string)
        C++: virtual void SetParticleFileName(const char *_arg)
        
        Set/Get the filename to be used with the particle writer when
        dumping particles to disk
        """
        ...
    
    def SetParticleWriter(self, vtkAbstractParticleWriter):
        """
        V.SetParticleWriter(vtkAbstractParticleWriter)
        C++: virtual void SetParticleWriter(vtkAbstractParticleWriter *pw)
        
        Set/Get the Writer associated with this Particle Tracer Ideally a
        parallel IO capable vtkH5PartWriter should be used which will
        collect particles from all parallel processes and write them to a
        single HDF5 file.
        """
        ...
    
    def SetStaticMesh(self, p_int):
        """
        V.SetStaticMesh(int)
        C++: virtual void SetStaticMesh(vtkTypeBool _arg)
        
        if StaticMesh is set, many optimizations for cell caching can be
        assumed. if StaticMesh is not set, the algorithm will attempt to
        find out if optimizations can be used, but setting it to true
        will force all optimizations. Do not Set StaticMesh to true if a
        dynamic mesh is being used as this will invalidate all results.
        """
        ...
    
    def SetStaticSeeds(self, p_int):
        """
        V.SetStaticSeeds(int)
        C++: virtual void SetStaticSeeds(vtkTypeBool _arg)
        
        if StaticSeeds is set and the mesh is static, then every time
        particles are injected we can re-use the same injection
        information. We classify particles according to processor just
        once before start. If StaticSeeds is set and a moving seed source
        is specified the motion will be ignored and results will not be
        as expected.
        """
        ...
    
    def SetTerminationTime(self, p_float):
        """
        V.SetTerminationTime(float)
        C++: virtual void SetTerminationTime(double _arg)
        
        Setting TerminationTime to a positive value will cause particles
        to terminate when the time is reached. Use a vlue of zero to
        disable termination. The units of time should be consistent with
        the primary time variable.
        """
        ...
    
    def SetTerminationTimeUnit(self, p_int):
        """
        V.SetTerminationTimeUnit(int)
        C++: virtual void SetTerminationTimeUnit(int _arg)
        
        The units of TerminationTime may be actual 'Time' units as
        described by the data, or just TimeSteps of iteration.
        """
        ...
    
    def SetTerminationTimeUnitToStepUnit(self):
        """
        V.SetTerminationTimeUnitToStepUnit()
        C++: void SetTerminationTimeUnitToStepUnit()
        
        The units of TerminationTime may be actual 'Time' units as
        described by the data, or just TimeSteps of iteration.
        """
        ...
    
    def SetTerminationTimeUnitToTimeUnit(self):
        """
        V.SetTerminationTimeUnitToTimeUnit()
        C++: void SetTerminationTimeUnitToTimeUnit()
        
        The units of TerminationTime may be actual 'Time' units as
        described by the data, or just TimeSteps of iteration.
        """
        ...
    
    def SetTimeStep(self, p_int):
        """
        V.SetTimeStep(int)
        C++: virtual void SetTimeStep(unsigned int _arg)
        
        Set/Get the TimeStep. This is the primary means of advancing the
        particles. The TimeStep should be animated and this will drive
        the pipeline forcing timesteps to be fetched from upstream.
        """
        ...
    
    def SetTimeStepResolution(self, p_float):
        """
        V.SetTimeStepResolution(float)
        C++: virtual void SetTimeStepResolution(double _arg)
        
        If the data source does not have the correct time values present
        on each time step - setting this value to non unity can be used
        to adjust the time step size from 1s pre step to
        1x_TimeStepResolution : Not functional in this version. Broke it
        @todo, put back time scaling
        """
        ...
    
    def StaticMeshOff(self):
        """
        V.StaticMeshOff()
        C++: virtual void StaticMeshOff()
        
        if StaticMesh is set, many optimizations for cell caching can be
        assumed. if StaticMesh is not set, the algorithm will attempt to
        find out if optimizations can be used, but setting it to true
        will force all optimizations. Do not Set StaticMesh to true if a
        dynamic mesh is being used as this will invalidate all results.
        """
        ...
    
    def StaticMeshOn(self):
        """
        V.StaticMeshOn()
        C++: virtual void StaticMeshOn()
        
        if StaticMesh is set, many optimizations for cell caching can be
        assumed. if StaticMesh is not set, the algorithm will attempt to
        find out if optimizations can be used, but setting it to true
        will force all optimizations. Do not Set StaticMesh to true if a
        dynamic mesh is being used as this will invalidate all results.
        """
        ...
    
    def StaticSeedsOff(self):
        """
        V.StaticSeedsOff()
        C++: virtual void StaticSeedsOff()
        
        if StaticSeeds is set and the mesh is static, then every time
        particles are injected we can re-use the same injection
        information. We classify particles according to processor just
        once before start. If StaticSeeds is set and a moving seed source
        is specified the motion will be ignored and results will not be
        as expected.
        """
        ...
    
    def StaticSeedsOn(self):
        """
        V.StaticSeedsOn()
        C++: virtual void StaticSeedsOn()
        
        if StaticSeeds is set and the mesh is static, then every time
        particles are injected we can re-use the same injection
        information. We classify particles according to processor just
        once before start. If StaticSeeds is set and a moving seed source
        is specified the motion will be ignored and results will not be
        as expected.
        """
        ...
    
    def __delattr__(self, *args, **kwargs):
        """ Implement delattr(self, name). """
        ...
    
    def __getattribute__(self, *args, **kwargs):
        """ Return getattr(self, name). """
        ...
    
    def __init__(self, *args, **kwargs) -> None:
        ...
    
    @staticmethod
    def __new__(*args, **kwargs):
        """ Create and return a new object.  See help(type) for accurate signature. """
        ...
    
    def __repr__(self, *args, **kwargs):
        """ Return repr(self). """
        ...
    
    def __setattr__(self, *args, **kwargs):
        """ Implement setattr(self, name, value). """
        ...
    
    def __str__(self, *args, **kwargs) -> str:
        """ Return str(self). """
        ...
    
    __this__ = ...
    TERMINATION_STEP_UNIT = ...
    TERMINATION_TIME_UNIT = ...
    Units = ...
    __dict__ = ...
    __vtkname__ = ...


__loader__ = ...
__spec__ = ...
