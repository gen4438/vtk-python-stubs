"""
This type stub file was generated by pyright.
"""

from .vtkGraphLayoutStrategy import vtkGraphLayoutStrategy

class vtkSpanTreeLayoutStrategy(vtkGraphLayoutStrategy):
    """
    vtkSpanTreeLayoutStrategy - vtkSpanTreeLayout is a strategy for
    drawing directed graphs that works by first extracting a spanning
    tree (more accurately, a spanning forest), and using this both to
    position graph vertices and to plan the placement of non
    
    Superclass: vtkGraphLayoutStrategy
    
    -tree edges.  The latter are drawn with the aid of edge points to
        produce a tidy drawing.
    
    The approach is best suited to "quasi-trees", graphs where the number
    of edges is of the same order as the number of nodes; it is less well
    suited to denser graphs.  The boolean flag DepthFirstSpanningTree
    determines whether a depth-first or breadth-first strategy is used to
    construct the underlying forest, and the choice of strategy affects
    the output layout significantly.  Informal experiments suggest that
    the breadth-first strategy is better for denser graphs.
    
    Different layouts could also be produced by plugging in alternative
    tree layout strategies.  To work with the method of routing non-tree
    edges, any strategy should draw a tree so that levels are equally
    spaced along the z-axis, precluding for example the use of a radial
    or balloon layout.
    
    vtkSpanTreeLayout is based on an approach to 3D graph layout first
    developed as part of the "tulip" tool by Dr. David Auber at LaBRI,
    U.Bordeaux: see www.tulip-software.org
    
    This implementation departs from the original version in that: (a) it
    is reconstructed to use Titan/VTK data structures; (b) it uses a
    faster method for dealing with non-tree edges,
        requiring at most two edge points per edge (c) allows for
    plugging in different tree layout methods (d) allows selection of two
    different strategies for building
        the underlying layout tree, which can yield significantly
        different results depending on the data.
    
    @par Thanks: Thanks to David Duke from the University of Leeds for
    providing this implementation.
    """
    def DepthFirstSpanningTreeOff(self):
        """
        V.DepthFirstSpanningTreeOff()
        C++: virtual void DepthFirstSpanningTreeOff()
        
        If set, base the layout on a depth-first spanning tree, rather
        than the default breadth-first spanning tree. Switching between
        DFT and BFT may significantly change the layout, and choice must
        be made on a per-graph basis. Default value is off.
        """
        ...
    
    def DepthFirstSpanningTreeOn(self):
        """
        V.DepthFirstSpanningTreeOn()
        C++: virtual void DepthFirstSpanningTreeOn()
        
        If set, base the layout on a depth-first spanning tree, rather
        than the default breadth-first spanning tree. Switching between
        DFT and BFT may significantly change the layout, and choice must
        be made on a per-graph basis. Default value is off.
        """
        ...
    
    def GetDepthFirstSpanningTree(self):
        """
        V.GetDepthFirstSpanningTree() -> bool
        C++: virtual bool GetDepthFirstSpanningTree()
        
        If set, base the layout on a depth-first spanning tree, rather
        than the default breadth-first spanning tree. Switching between
        DFT and BFT may significantly change the layout, and choice must
        be made on a per-graph basis. Default value is off.
        """
        ...
    
    def GetNumberOfGenerationsFromBase(self, string):
        """
        V.GetNumberOfGenerationsFromBase(string) -> int
        C++: vtkIdType GetNumberOfGenerationsFromBase(const char *type)
            override;
        
        Given a the name of a base class of this class type, return the
        distance of inheritance between this class type and the named
        class (how many generations of inheritance are there between this
        class and the named class). If the named class is not in this
        class's inheritance tree, return a negative value. Valid
        responses will always be nonnegative. This method works in
        combination with vtkTypeMacro found in vtkSetGet.h.
        """
        ...
    
    def GetNumberOfGenerationsFromBaseType(self, string):
        """
        V.GetNumberOfGenerationsFromBaseType(string) -> int
        C++: static vtkIdType GetNumberOfGenerationsFromBaseType(
            const char *type)
        
        Given a the name of a base class of this class type, return the
        distance of inheritance between this class type and the named
        class (how many generations of inheritance are there between this
        class and the named class). If the named class is not in this
        class's inheritance tree, return a negative value. Valid
        responses will always be nonnegative. This method works in
        combination with vtkTypeMacro found in vtkSetGet.h.
        """
        ...
    
    def IsA(self, string):
        """
        V.IsA(string) -> int
        C++: vtkTypeBool IsA(const char *type) override;
        
        Return 1 if this class is the same type of (or a subclass of) the
        named class. Returns 0 otherwise. This method works in
        combination with vtkTypeMacro found in vtkSetGet.h.
        """
        ...
    
    def IsTypeOf(self, string):
        """
        V.IsTypeOf(string) -> int
        C++: static vtkTypeBool IsTypeOf(const char *type)
        
        Return 1 if this class type is the same type of (or a subclass
        of) the named class. Returns 0 otherwise. This method works in
        combination with vtkTypeMacro found in vtkSetGet.h.
        """
        ...
    
    def Layout(self):
        """
        V.Layout()
        C++: void Layout() override;
        
        Perform the layout.
        """
        ...
    
    def NewInstance(self):
        """
        V.NewInstance() -> vtkSpanTreeLayoutStrategy
        C++: vtkSpanTreeLayoutStrategy *NewInstance()
        """
        ...
    
    def SafeDownCast(self, vtkObjectBase):
        """
        V.SafeDownCast(vtkObjectBase) -> vtkSpanTreeLayoutStrategy
        C++: static vtkSpanTreeLayoutStrategy *SafeDownCast(
            vtkObjectBase *o)
        """
        ...
    
    def SetDepthFirstSpanningTree(self, bool):
        """
        V.SetDepthFirstSpanningTree(bool)
        C++: virtual void SetDepthFirstSpanningTree(bool _arg)
        
        If set, base the layout on a depth-first spanning tree, rather
        than the default breadth-first spanning tree. Switching between
        DFT and BFT may significantly change the layout, and choice must
        be made on a per-graph basis. Default value is off.
        """
        ...
    
    def __delattr__(self, *args, **kwargs):
        """ Implement delattr(self, name). """
        ...
    
    def __getattribute__(self, *args, **kwargs):
        """ Return getattr(self, name). """
        ...
    
    def __init__(self, *args, **kwargs) -> None:
        ...
    
    @staticmethod
    def __new__(*args, **kwargs):
        """ Create and return a new object.  See help(type) for accurate signature. """
        ...
    
    def __repr__(self, *args, **kwargs):
        """ Return repr(self). """
        ...
    
    def __setattr__(self, *args, **kwargs):
        """ Implement setattr(self, name, value). """
        ...
    
    def __str__(self, *args, **kwargs) -> str:
        """ Return str(self). """
        ...
    
    __this__ = ...
    __dict__ = ...
    __vtkname__ = ...


