"""
This type stub file was generated by pyright.
"""

from .vtkGraphLayoutStrategy import vtkGraphLayoutStrategy

class vtkConeLayoutStrategy(vtkGraphLayoutStrategy):
    """
    vtkConeLayoutStrategy - produce a cone-tree layout for a forest
    
    Superclass: vtkGraphLayoutStrategy
    
    vtkConeLayoutStrategy positions the nodes of a tree(forest) in 3D
    space based on the cone-tree approach first described by Robertson,
    Mackinlay and Card in Proc. CHI'91.  This implementation incorporates
    refinements to the layout developed by Carriere and Kazman, and by
    Auber.
    
    The input graph must be a forest (i.e. a set of trees, or a single
    tree); in the case of a forest, the input will be converted to a
    single tree by introducing a new root node, and connecting each root
    in the input forest to the meta-root. The tree is then laid out,
    after which the meta-root is removed.
    
    The cones are positioned so that children lie in planes parallel to
    the X-Y plane, with the axis of cones parallel to Z, and with Z
    coordinate increasing with distance of nodes from the root.
    
    @par Thanks: Thanks to David Duke from the University of Leeds for
    providing this implementation.
    """
    def CompressionOff(self):
        """
        V.CompressionOff()
        C++: virtual void CompressionOff()
        
        Determine if layout should be compressed, i.e. the layout puts
        children closer together, possibly allowing sub-trees to overlap.
         This is useful if the tree is actually the spanning tree of a
        graph.  For "real" trees, non-compressed layout is best, and is
        the default.
        """
        ...
    
    def CompressionOn(self):
        """
        V.CompressionOn()
        C++: virtual void CompressionOn()
        
        Determine if layout should be compressed, i.e. the layout puts
        children closer together, possibly allowing sub-trees to overlap.
         This is useful if the tree is actually the spanning tree of a
        graph.  For "real" trees, non-compressed layout is best, and is
        the default.
        """
        ...
    
    def GetCompactness(self):
        """
        V.GetCompactness() -> float
        C++: virtual float GetCompactness()
        
        Determine the compactness, the ratio between the average width of
        a cone in the tree, and the height of the cone.  The default
        setting is 0.75 which (empirically) seems reasonable, but this
        will need adapting depending on the data.
        """
        ...
    
    def GetCompression(self):
        """
        V.GetCompression() -> int
        C++: virtual vtkTypeBool GetCompression()
        
        Determine if layout should be compressed, i.e. the layout puts
        children closer together, possibly allowing sub-trees to overlap.
         This is useful if the tree is actually the spanning tree of a
        graph.  For "real" trees, non-compressed layout is best, and is
        the default.
        """
        ...
    
    def GetNumberOfGenerationsFromBase(self, string):
        """
        V.GetNumberOfGenerationsFromBase(string) -> int
        C++: vtkIdType GetNumberOfGenerationsFromBase(const char *type)
            override;
        
        Given a the name of a base class of this class type, return the
        distance of inheritance between this class type and the named
        class (how many generations of inheritance are there between this
        class and the named class). If the named class is not in this
        class's inheritance tree, return a negative value. Valid
        responses will always be nonnegative. This method works in
        combination with vtkTypeMacro found in vtkSetGet.h.
        """
        ...
    
    def GetNumberOfGenerationsFromBaseType(self, string):
        """
        V.GetNumberOfGenerationsFromBaseType(string) -> int
        C++: static vtkIdType GetNumberOfGenerationsFromBaseType(
            const char *type)
        
        Given a the name of a base class of this class type, return the
        distance of inheritance between this class type and the named
        class (how many generations of inheritance are there between this
        class and the named class). If the named class is not in this
        class's inheritance tree, return a negative value. Valid
        responses will always be nonnegative. This method works in
        combination with vtkTypeMacro found in vtkSetGet.h.
        """
        ...
    
    def GetSpacing(self):
        """
        V.GetSpacing() -> float
        C++: virtual float GetSpacing()
        
        Set the spacing parameter that affects space between layers of
        the tree.  If compression is on, Spacing is the actual distance
        between layers.  If compression is off, actual distance also
        includes a factor of the compactness and maximum cone radius.
        """
        ...
    
    def IsA(self, string):
        """
        V.IsA(string) -> int
        C++: vtkTypeBool IsA(const char *type) override;
        
        Return 1 if this class is the same type of (or a subclass of) the
        named class. Returns 0 otherwise. This method works in
        combination with vtkTypeMacro found in vtkSetGet.h.
        """
        ...
    
    def IsTypeOf(self, string):
        """
        V.IsTypeOf(string) -> int
        C++: static vtkTypeBool IsTypeOf(const char *type)
        
        Return 1 if this class type is the same type of (or a subclass
        of) the named class. Returns 0 otherwise. This method works in
        combination with vtkTypeMacro found in vtkSetGet.h.
        """
        ...
    
    def Layout(self):
        """
        V.Layout()
        C++: void Layout() override;
        
        Perform the layout.
        """
        ...
    
    def NewInstance(self):
        """
        V.NewInstance() -> vtkConeLayoutStrategy
        C++: vtkConeLayoutStrategy *NewInstance()
        """
        ...
    
    def SafeDownCast(self, vtkObjectBase):
        """
        V.SafeDownCast(vtkObjectBase) -> vtkConeLayoutStrategy
        C++: static vtkConeLayoutStrategy *SafeDownCast(vtkObjectBase *o)
        """
        ...
    
    def SetCompactness(self, p_float):
        """
        V.SetCompactness(float)
        C++: virtual void SetCompactness(float _arg)
        
        Determine the compactness, the ratio between the average width of
        a cone in the tree, and the height of the cone.  The default
        setting is 0.75 which (empirically) seems reasonable, but this
        will need adapting depending on the data.
        """
        ...
    
    def SetCompression(self, p_int):
        """
        V.SetCompression(int)
        C++: virtual void SetCompression(vtkTypeBool _arg)
        
        Determine if layout should be compressed, i.e. the layout puts
        children closer together, possibly allowing sub-trees to overlap.
         This is useful if the tree is actually the spanning tree of a
        graph.  For "real" trees, non-compressed layout is best, and is
        the default.
        """
        ...
    
    def SetSpacing(self, p_float):
        """
        V.SetSpacing(float)
        C++: virtual void SetSpacing(float _arg)
        
        Set the spacing parameter that affects space between layers of
        the tree.  If compression is on, Spacing is the actual distance
        between layers.  If compression is off, actual distance also
        includes a factor of the compactness and maximum cone radius.
        """
        ...
    
    def __delattr__(self, *args, **kwargs):
        """ Implement delattr(self, name). """
        ...
    
    def __getattribute__(self, *args, **kwargs):
        """ Return getattr(self, name). """
        ...
    
    def __init__(self, *args, **kwargs) -> None:
        ...
    
    @staticmethod
    def __new__(*args, **kwargs):
        """ Create and return a new object.  See help(type) for accurate signature. """
        ...
    
    def __repr__(self, *args, **kwargs):
        """ Return repr(self). """
        ...
    
    def __setattr__(self, *args, **kwargs):
        """ Implement setattr(self, name, value). """
        ...
    
    def __str__(self, *args, **kwargs) -> str:
        """ Return str(self). """
        ...
    
    __this__ = ...
    __dict__ = ...
    __vtkname__ = ...


