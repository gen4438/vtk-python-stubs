"""
This type stub file was generated by pyright.
"""

import vtkmodules.vtkCommonExecutionModel as __vtkmodules_vtkCommonExecutionModel

class vtkQuadricClustering(__vtkmodules_vtkCommonExecutionModel.vtkPolyDataAlgorithm):
    """
    vtkQuadricClustering - reduce the number of triangles in a mesh
    
    Superclass: vtkPolyDataAlgorithm
    
    vtkQuadricClustering is a filter to reduce the number of triangles in
    a triangle mesh, forming a good approximation to the original
    geometry.  The input to vtkQuadricClustering is a vtkPolyData object,
    and all types of polygonal data are handled.
    
    The algorithm used is the one described by Peter Lindstrom in his
    Siggraph 2000 paper, "Out-of-Core Simplification of Large Polygonal
    Models."  The general approach of the algorithm is to cluster
    vertices in a uniform binning of space, accumulating the quadric of
    each triangle (pushed out to the triangles vertices) within each bin,
    and then determining an optimal position for a single vertex in a bin
    by using the accumulated quadric. In more detail, the algorithm first
    gets the bounds of the input poly data. It then breaks this bounding
    volume into a user-specified number of spatial bins.  It then reads
    each triangle from the input and hashes its vertices into these bins.
     (If this is the first time a bin has been visited, initialize its
    quadric to the 0 matrix.) The algorithm computes the error quadric
    for this triangle and adds it to the existing quadric of the bin in
    which each vertex is contained. Then, if 2 or more vertices of the
    triangle fall in the same bin, the triangle is dicarded.  If the
    triangle is not discarded, it adds the triangle to the list of output
    triangles as a list of vertex identifiers.  (There is one vertex id
    per bin.)  After all the triangles have been read, the representative
    vertex for each bin is computed (an optimal location is found) using
    the quadric for that bin.  This determines the spatial location of
    the vertices of each of the triangles in the output.
    
    To use this filter, specify the divisions defining the spatial
    subdivision in the x, y, and z directions. You must also specify an
    input vtkPolyData. Then choose to either 1) use the original points
    that minimize the quadric error to produce the output triangles or 2)
    compute an optimal position in each bin to produce the output
    triangles (recommended and default behavior).
    
    This filter can take multiple inputs.  To do this, the user must
    explicitly call StartAppend, Append (once for each input), and
    EndAppend.  StartAppend sets up the data structure to hold the
    quadric matrices.  Append processes each triangle in the input poly
    data it was called on, hashes its vertices to the appropriate bins,
    determines whether to keep this triangle, and updates the appropriate
    quadric matrices.  EndAppend determines the spatial location of each
    of the representative vertices for the visited bins. While this
    approach does not fit into the visualization architecture and
    requires manual control, it has the advantage that extremely large
    data can be processed in pieces and appended to the filter
    piece-by-piece.
    
    @warning
    This filter can drastically affect topology, i.e., topology is not
    preserved.
    
    @warning
    The filter handles input triangle strips and arbitrary polygons.
    Arbitrary polygons are assumed convex: during insertion they are
    triangulated using a fan of triangles from the first point in the
    polygons. If the polygon is concave, this can produce bad results. In
    this case, use vtkTriangleFilter to triangulate the polygons first.
    
    @warning
    The filter also treats polylines and vertices.
    
    @warning
    Note that for certain types of geometry (e.g., a mostly 2D plane with
    jitter in the normal direction), the decimator can perform badly. In
    this situation, set the number of bins in the normal direction to
    one.
    
    @sa
    vtkQuadricDecimation vtkDecimatePro vtkDecimate vtkQuadricLODActor
    """
    def Append(self, vtkPolyData):
        """
        V.Append(vtkPolyData)
        C++: void Append(vtkPolyData *piece)
        
        These methods provide an alternative way of executing the filter.
        PolyData can be added to the result in pieces (append). In this
        mode, the user must specify the bounds of the entire model as an
        argument to the "StartAppend" method.
        """
        ...
    
    def AutoAdjustNumberOfDivisionsOff(self):
        """
        V.AutoAdjustNumberOfDivisionsOff()
        C++: virtual void AutoAdjustNumberOfDivisionsOff()
        
        Enable automatic adjustment of number of divisions. If off, the
        number of divisions specified by the user is always used (as long
        as it is valid). The default is On
        """
        ...
    
    def AutoAdjustNumberOfDivisionsOn(self):
        """
        V.AutoAdjustNumberOfDivisionsOn()
        C++: virtual void AutoAdjustNumberOfDivisionsOn()
        
        Enable automatic adjustment of number of divisions. If off, the
        number of divisions specified by the user is always used (as long
        as it is valid). The default is On
        """
        ...
    
    def CopyCellDataOff(self):
        """
        V.CopyCellDataOff()
        C++: virtual void CopyCellDataOff()
        
        This flag makes the filter copy cell data from input to output
        (the best it can).  It uses input cells that trigger the addition
        of output cells (no averaging).  This is off by default, and does
        not work when append is being called explicitly (non-pipeline
        usage).
        """
        ...
    
    def CopyCellDataOn(self):
        """
        V.CopyCellDataOn()
        C++: virtual void CopyCellDataOn()
        
        This flag makes the filter copy cell data from input to output
        (the best it can).  It uses input cells that trigger the addition
        of output cells (no averaging).  This is off by default, and does
        not work when append is being called explicitly (non-pipeline
        usage).
        """
        ...
    
    def EndAppend(self):
        """
        V.EndAppend()
        C++: void EndAppend()
        
        These methods provide an alternative way of executing the filter.
        PolyData can be added to the result in pieces (append). In this
        mode, the user must specify the bounds of the entire model as an
        argument to the "StartAppend" method.
        """
        ...
    
    def GetAutoAdjustNumberOfDivisions(self):
        """
        V.GetAutoAdjustNumberOfDivisions() -> int
        C++: virtual vtkTypeBool GetAutoAdjustNumberOfDivisions()
        
        Enable automatic adjustment of number of divisions. If off, the
        number of divisions specified by the user is always used (as long
        as it is valid). The default is On
        """
        ...
    
    def GetCopyCellData(self):
        """
        V.GetCopyCellData() -> int
        C++: virtual vtkTypeBool GetCopyCellData()
        
        This flag makes the filter copy cell data from input to output
        (the best it can).  It uses input cells that trigger the addition
        of output cells (no averaging).  This is off by default, and does
        not work when append is being called explicitly (non-pipeline
        usage).
        """
        ...
    
    def GetDivisionOrigin(self):
        """
        V.GetDivisionOrigin() -> (float, float, float)
        C++: virtual double *GetDivisionOrigin()
        
        This is an alternative way to set up the bins.  If you are trying
        to match boundaries between pieces, then you should use these
        methods rather than SetNumberOfDivisions. To use these methods,
        specify the origin and spacing of the spatial binning.
        """
        ...
    
    def GetDivisionSpacing(self):
        """
        V.GetDivisionSpacing() -> (float, float, float)
        C++: virtual double *GetDivisionSpacing()
        
        This is an alternative way to set up the bins.  If you are trying
        to match boundaries between pieces, then you should use these
        methods rather than SetNumberOfDivisions. To use these methods,
        specify the origin and spacing of the spatial binning.
        """
        ...
    
    def GetFeatureEdges(self):
        """
        V.GetFeatureEdges() -> vtkFeatureEdges
        C++: vtkFeatureEdges *GetFeatureEdges()
        
        By default, this flag is off.  When "UseFeatureEdges" is on, then
        quadrics are computed for boundary edges/feature edges.  They
        influence the quadrics (position of points), but not the mesh. 
        Which features to use can be controlled by the filter
        "FeatureEdges".
        """
        ...
    
    def GetFeaturePointsAngle(self):
        """
        V.GetFeaturePointsAngle() -> float
        C++: virtual double GetFeaturePointsAngle()
        
        Set/Get the angle to use in determining whether a point on a
        boundary / feature edge is a feature point.
        """
        ...
    
    def GetFeaturePointsAngleMaxValue(self):
        """
        V.GetFeaturePointsAngleMaxValue() -> float
        C++: virtual double GetFeaturePointsAngleMaxValue()
        
        Set/Get the angle to use in determining whether a point on a
        boundary / feature edge is a feature point.
        """
        ...
    
    def GetFeaturePointsAngleMinValue(self):
        """
        V.GetFeaturePointsAngleMinValue() -> float
        C++: virtual double GetFeaturePointsAngleMinValue()
        
        Set/Get the angle to use in determining whether a point on a
        boundary / feature edge is a feature point.
        """
        ...
    
    def GetNumberOfDivisions(self):
        """
        V.GetNumberOfDivisions() -> (int, int, int)
        C++: int *GetNumberOfDivisions()
        V.GetNumberOfDivisions([int, int, int])
        C++: void GetNumberOfDivisions(int div[3])
        
        Set/Get the number of divisions along each axis for the spatial
        bins. The number of spatial bins is
        NumberOfXDivisions*NumberOfYDivisions* NumberOfZDivisions.  The
        filter may choose to ignore large numbers of divisions if the
        input has few points and AutoAdjustNumberOfDivisions is enabled.
        """
        ...
    
    def GetNumberOfGenerationsFromBase(self, string):
        """
        V.GetNumberOfGenerationsFromBase(string) -> int
        C++: vtkIdType GetNumberOfGenerationsFromBase(const char *type)
            override;
        
        Standard instantition, type and print methods.
        """
        ...
    
    def GetNumberOfGenerationsFromBaseType(self, string):
        """
        V.GetNumberOfGenerationsFromBaseType(string) -> int
        C++: static vtkIdType GetNumberOfGenerationsFromBaseType(
            const char *type)
        
        Standard instantition, type and print methods.
        """
        ...
    
    def GetNumberOfXDivisions(self):
        """
        V.GetNumberOfXDivisions() -> int
        C++: virtual int GetNumberOfXDivisions()
        
        Set/Get the number of divisions along each axis for the spatial
        bins. The number of spatial bins is
        NumberOfXDivisions*NumberOfYDivisions* NumberOfZDivisions.  The
        filter may choose to ignore large numbers of divisions if the
        input has few points and AutoAdjustNumberOfDivisions is enabled.
        """
        ...
    
    def GetNumberOfYDivisions(self):
        """
        V.GetNumberOfYDivisions() -> int
        C++: virtual int GetNumberOfYDivisions()
        
        Set/Get the number of divisions along each axis for the spatial
        bins. The number of spatial bins is
        NumberOfXDivisions*NumberOfYDivisions* NumberOfZDivisions.  The
        filter may choose to ignore large numbers of divisions if the
        input has few points and AutoAdjustNumberOfDivisions is enabled.
        """
        ...
    
    def GetNumberOfZDivisions(self):
        """
        V.GetNumberOfZDivisions() -> int
        C++: virtual int GetNumberOfZDivisions()
        
        Set/Get the number of divisions along each axis for the spatial
        bins. The number of spatial bins is
        NumberOfXDivisions*NumberOfYDivisions* NumberOfZDivisions.  The
        filter may choose to ignore large numbers of divisions if the
        input has few points and AutoAdjustNumberOfDivisions is enabled.
        """
        ...
    
    def GetPreventDuplicateCells(self):
        """
        V.GetPreventDuplicateCells() -> int
        C++: virtual vtkTypeBool GetPreventDuplicateCells()
        
        Specify a boolean indicating whether to remove duplicate cells
        (i.e. triangles).  This is a little slower, and takes more
        memory, but in some cases can reduce the number of cells produced
        by an order of magnitude. By default, this flag is true.
        """
        ...
    
    def GetUseFeatureEdges(self):
        """
        V.GetUseFeatureEdges() -> int
        C++: virtual vtkTypeBool GetUseFeatureEdges()
        
        By default, this flag is off.  When "UseFeatureEdges" is on, then
        quadrics are computed for boundary edges/feature edges.  They
        influence the quadrics (position of points), but not the mesh. 
        Which features to use can be controlled by the filter
        "FeatureEdges".
        """
        ...
    
    def GetUseFeaturePoints(self):
        """
        V.GetUseFeaturePoints() -> int
        C++: virtual vtkTypeBool GetUseFeaturePoints()
        
        By default, this flag is off.  It only has an effect when
        "UseFeatureEdges" is also on.  When "UseFeaturePoints" is on,
        then quadrics are computed for boundary / feature points used in
        the boundary / feature edges.  They influence the quadrics
        (position of points), but not the mesh.
        """
        ...
    
    def GetUseInputPoints(self):
        """
        V.GetUseInputPoints() -> int
        C++: virtual vtkTypeBool GetUseInputPoints()
        
        Normally the point that minimizes the quadric error function is
        used as the output of the bin.  When this flag is on, the bin
        point is forced to be one of the points from the input (the one
        with the smallest error). This option does not work (i.e., input
        points cannot be used) when the append methods (StartAppend(),
        Append(), EndAppend()) are being called directly.
        """
        ...
    
    def GetUseInternalTriangles(self):
        """
        V.GetUseInternalTriangles() -> int
        C++: virtual vtkTypeBool GetUseInternalTriangles()
        
        When this flag is on (and it is on by default), then triangles
        that are completely contained in a bin are added to the bin
        quadrics.  When the the flag is off the filter operates faster,
        but the surface may not be as well behaved.
        """
        ...
    
    def IsA(self, string):
        """
        V.IsA(string) -> int
        C++: vtkTypeBool IsA(const char *type) override;
        
        Standard instantition, type and print methods.
        """
        ...
    
    def IsTypeOf(self, string):
        """
        V.IsTypeOf(string) -> int
        C++: static vtkTypeBool IsTypeOf(const char *type)
        
        Standard instantition, type and print methods.
        """
        ...
    
    def NewInstance(self):
        """
        V.NewInstance() -> vtkQuadricClustering
        C++: vtkQuadricClustering *NewInstance()
        
        Standard instantition, type and print methods.
        """
        ...
    
    def PreventDuplicateCellsOff(self):
        """
        V.PreventDuplicateCellsOff()
        C++: virtual void PreventDuplicateCellsOff()
        
        Specify a boolean indicating whether to remove duplicate cells
        (i.e. triangles).  This is a little slower, and takes more
        memory, but in some cases can reduce the number of cells produced
        by an order of magnitude. By default, this flag is true.
        """
        ...
    
    def PreventDuplicateCellsOn(self):
        """
        V.PreventDuplicateCellsOn()
        C++: virtual void PreventDuplicateCellsOn()
        
        Specify a boolean indicating whether to remove duplicate cells
        (i.e. triangles).  This is a little slower, and takes more
        memory, but in some cases can reduce the number of cells produced
        by an order of magnitude. By default, this flag is true.
        """
        ...
    
    def SafeDownCast(self, vtkObjectBase):
        """
        V.SafeDownCast(vtkObjectBase) -> vtkQuadricClustering
        C++: static vtkQuadricClustering *SafeDownCast(vtkObjectBase *o)
        
        Standard instantition, type and print methods.
        """
        ...
    
    def SetAutoAdjustNumberOfDivisions(self, p_int):
        """
        V.SetAutoAdjustNumberOfDivisions(int)
        C++: virtual void SetAutoAdjustNumberOfDivisions(vtkTypeBool _arg)
        
        Enable automatic adjustment of number of divisions. If off, the
        number of divisions specified by the user is always used (as long
        as it is valid). The default is On
        """
        ...
    
    def SetCopyCellData(self, p_int):
        """
        V.SetCopyCellData(int)
        C++: virtual void SetCopyCellData(vtkTypeBool _arg)
        
        This flag makes the filter copy cell data from input to output
        (the best it can).  It uses input cells that trigger the addition
        of output cells (no averaging).  This is off by default, and does
        not work when append is being called explicitly (non-pipeline
        usage).
        """
        ...
    
    def SetDivisionOrigin(self, p_float, p_float_1, p_float_2):
        """
        V.SetDivisionOrigin(float, float, float)
        C++: void SetDivisionOrigin(double x, double y, double z)
        V.SetDivisionOrigin([float, float, float])
        C++: void SetDivisionOrigin(double o[3])
        
        This is an alternative way to set up the bins.  If you are trying
        to match boundaries between pieces, then you should use these
        methods rather than SetNumberOfDivisions. To use these methods,
        specify the origin and spacing of the spatial binning.
        """
        ...
    
    def SetDivisionSpacing(self, p_float, p_float_1, p_float_2):
        """
        V.SetDivisionSpacing(float, float, float)
        C++: void SetDivisionSpacing(double x, double y, double z)
        V.SetDivisionSpacing([float, float, float])
        C++: void SetDivisionSpacing(double s[3])
        
        This is an alternative way to set up the bins.  If you are trying
        to match boundaries between pieces, then you should use these
        methods rather than SetNumberOfDivisions. To use these methods,
        specify the origin and spacing of the spatial binning.
        """
        ...
    
    def SetFeaturePointsAngle(self, p_float):
        """
        V.SetFeaturePointsAngle(float)
        C++: virtual void SetFeaturePointsAngle(double _arg)
        
        Set/Get the angle to use in determining whether a point on a
        boundary / feature edge is a feature point.
        """
        ...
    
    def SetNumberOfDivisions(self, p_int=..., p_int=..., p_int=...):
        """
        V.SetNumberOfDivisions([int, int, int])
        C++: void SetNumberOfDivisions(int div[3])
        V.SetNumberOfDivisions(int, int, int)
        C++: void SetNumberOfDivisions(int div0, int div1, int div2)
        
        Set/Get the number of divisions along each axis for the spatial
        bins. The number of spatial bins is
        NumberOfXDivisions*NumberOfYDivisions* NumberOfZDivisions.  The
        filter may choose to ignore large numbers of divisions if the
        input has few points and AutoAdjustNumberOfDivisions is enabled.
        """
        ...
    
    def SetNumberOfXDivisions(self, p_int):
        """
        V.SetNumberOfXDivisions(int)
        C++: void SetNumberOfXDivisions(int num)
        
        Set/Get the number of divisions along each axis for the spatial
        bins. The number of spatial bins is
        NumberOfXDivisions*NumberOfYDivisions* NumberOfZDivisions.  The
        filter may choose to ignore large numbers of divisions if the
        input has few points and AutoAdjustNumberOfDivisions is enabled.
        """
        ...
    
    def SetNumberOfYDivisions(self, p_int):
        """
        V.SetNumberOfYDivisions(int)
        C++: void SetNumberOfYDivisions(int num)
        
        Set/Get the number of divisions along each axis for the spatial
        bins. The number of spatial bins is
        NumberOfXDivisions*NumberOfYDivisions* NumberOfZDivisions.  The
        filter may choose to ignore large numbers of divisions if the
        input has few points and AutoAdjustNumberOfDivisions is enabled.
        """
        ...
    
    def SetNumberOfZDivisions(self, p_int):
        """
        V.SetNumberOfZDivisions(int)
        C++: void SetNumberOfZDivisions(int num)
        
        Set/Get the number of divisions along each axis for the spatial
        bins. The number of spatial bins is
        NumberOfXDivisions*NumberOfYDivisions* NumberOfZDivisions.  The
        filter may choose to ignore large numbers of divisions if the
        input has few points and AutoAdjustNumberOfDivisions is enabled.
        """
        ...
    
    def SetPreventDuplicateCells(self, p_int):
        """
        V.SetPreventDuplicateCells(int)
        C++: virtual void SetPreventDuplicateCells(vtkTypeBool _arg)
        
        Specify a boolean indicating whether to remove duplicate cells
        (i.e. triangles).  This is a little slower, and takes more
        memory, but in some cases can reduce the number of cells produced
        by an order of magnitude. By default, this flag is true.
        """
        ...
    
    def SetUseFeatureEdges(self, p_int):
        """
        V.SetUseFeatureEdges(int)
        C++: virtual void SetUseFeatureEdges(vtkTypeBool _arg)
        
        By default, this flag is off.  When "UseFeatureEdges" is on, then
        quadrics are computed for boundary edges/feature edges.  They
        influence the quadrics (position of points), but not the mesh. 
        Which features to use can be controlled by the filter
        "FeatureEdges".
        """
        ...
    
    def SetUseFeaturePoints(self, p_int):
        """
        V.SetUseFeaturePoints(int)
        C++: virtual void SetUseFeaturePoints(vtkTypeBool _arg)
        
        By default, this flag is off.  It only has an effect when
        "UseFeatureEdges" is also on.  When "UseFeaturePoints" is on,
        then quadrics are computed for boundary / feature points used in
        the boundary / feature edges.  They influence the quadrics
        (position of points), but not the mesh.
        """
        ...
    
    def SetUseInputPoints(self, p_int):
        """
        V.SetUseInputPoints(int)
        C++: virtual void SetUseInputPoints(vtkTypeBool _arg)
        
        Normally the point that minimizes the quadric error function is
        used as the output of the bin.  When this flag is on, the bin
        point is forced to be one of the points from the input (the one
        with the smallest error). This option does not work (i.e., input
        points cannot be used) when the append methods (StartAppend(),
        Append(), EndAppend()) are being called directly.
        """
        ...
    
    def SetUseInternalTriangles(self, p_int):
        """
        V.SetUseInternalTriangles(int)
        C++: virtual void SetUseInternalTriangles(vtkTypeBool _arg)
        
        When this flag is on (and it is on by default), then triangles
        that are completely contained in a bin are added to the bin
        quadrics.  When the the flag is off the filter operates faster,
        but the surface may not be as well behaved.
        """
        ...
    
    def StartAppend(self, *float):
        """
        V.StartAppend([float, ...])
        C++: void StartAppend(double *bounds)
        V.StartAppend(float, float, float, float, float, float)
        C++: void StartAppend(double x0, double x1, double y0, double y1,
            double z0, double z1)
        
        These methods provide an alternative way of executing the filter.
        PolyData can be added to the result in pieces (append). In this
        mode, the user must specify the bounds of the entire model as an
        argument to the "StartAppend" method.
        """
        ...
    
    def UseFeatureEdgesOff(self):
        """
        V.UseFeatureEdgesOff()
        C++: virtual void UseFeatureEdgesOff()
        
        By default, this flag is off.  When "UseFeatureEdges" is on, then
        quadrics are computed for boundary edges/feature edges.  They
        influence the quadrics (position of points), but not the mesh. 
        Which features to use can be controlled by the filter
        "FeatureEdges".
        """
        ...
    
    def UseFeatureEdgesOn(self):
        """
        V.UseFeatureEdgesOn()
        C++: virtual void UseFeatureEdgesOn()
        
        By default, this flag is off.  When "UseFeatureEdges" is on, then
        quadrics are computed for boundary edges/feature edges.  They
        influence the quadrics (position of points), but not the mesh. 
        Which features to use can be controlled by the filter
        "FeatureEdges".
        """
        ...
    
    def UseFeaturePointsOff(self):
        """
        V.UseFeaturePointsOff()
        C++: virtual void UseFeaturePointsOff()
        
        By default, this flag is off.  It only has an effect when
        "UseFeatureEdges" is also on.  When "UseFeaturePoints" is on,
        then quadrics are computed for boundary / feature points used in
        the boundary / feature edges.  They influence the quadrics
        (position of points), but not the mesh.
        """
        ...
    
    def UseFeaturePointsOn(self):
        """
        V.UseFeaturePointsOn()
        C++: virtual void UseFeaturePointsOn()
        
        By default, this flag is off.  It only has an effect when
        "UseFeatureEdges" is also on.  When "UseFeaturePoints" is on,
        then quadrics are computed for boundary / feature points used in
        the boundary / feature edges.  They influence the quadrics
        (position of points), but not the mesh.
        """
        ...
    
    def UseInputPointsOff(self):
        """
        V.UseInputPointsOff()
        C++: virtual void UseInputPointsOff()
        
        Normally the point that minimizes the quadric error function is
        used as the output of the bin.  When this flag is on, the bin
        point is forced to be one of the points from the input (the one
        with the smallest error). This option does not work (i.e., input
        points cannot be used) when the append methods (StartAppend(),
        Append(), EndAppend()) are being called directly.
        """
        ...
    
    def UseInputPointsOn(self):
        """
        V.UseInputPointsOn()
        C++: virtual void UseInputPointsOn()
        
        Normally the point that minimizes the quadric error function is
        used as the output of the bin.  When this flag is on, the bin
        point is forced to be one of the points from the input (the one
        with the smallest error). This option does not work (i.e., input
        points cannot be used) when the append methods (StartAppend(),
        Append(), EndAppend()) are being called directly.
        """
        ...
    
    def UseInternalTrianglesOff(self):
        """
        V.UseInternalTrianglesOff()
        C++: virtual void UseInternalTrianglesOff()
        
        When this flag is on (and it is on by default), then triangles
        that are completely contained in a bin are added to the bin
        quadrics.  When the the flag is off the filter operates faster,
        but the surface may not be as well behaved.
        """
        ...
    
    def UseInternalTrianglesOn(self):
        """
        V.UseInternalTrianglesOn()
        C++: virtual void UseInternalTrianglesOn()
        
        When this flag is on (and it is on by default), then triangles
        that are completely contained in a bin are added to the bin
        quadrics.  When the the flag is off the filter operates faster,
        but the surface may not be as well behaved.
        """
        ...
    
    def __delattr__(self, *args, **kwargs):
        """ Implement delattr(self, name). """
        ...
    
    def __getattribute__(self, *args, **kwargs):
        """ Return getattr(self, name). """
        ...
    
    def __init__(self, *args, **kwargs) -> None:
        ...
    
    @staticmethod
    def __new__(*args, **kwargs):
        """ Create and return a new object.  See help(type) for accurate signature. """
        ...
    
    def __repr__(self, *args, **kwargs):
        """ Return repr(self). """
        ...
    
    def __setattr__(self, *args, **kwargs):
        """ Implement setattr(self, name, value). """
        ...
    
    def __str__(self, *args, **kwargs) -> str:
        """ Return str(self). """
        ...
    
    __this__ = ...
    __dict__ = ...
    __vtkname__ = ...


