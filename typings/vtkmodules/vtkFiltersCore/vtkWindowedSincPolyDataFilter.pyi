"""
This type stub file was generated by pyright.
"""

import vtkmodules.vtkCommonExecutionModel as __vtkmodules_vtkCommonExecutionModel

class vtkWindowedSincPolyDataFilter(__vtkmodules_vtkCommonExecutionModel.vtkPolyDataAlgorithm):
    """
    vtkWindowedSincPolyDataFilter - adjust point positions using a
    windowed sinc function interpolation kernel
    
    Superclass: vtkPolyDataAlgorithm
    
    vtkWindowedSincPolyDataFiler adjust point coordinate using a windowed
    sinc function interpolation kernel.  The effect is to "relax" the
    mesh, making the cells better shaped and the vertices more evenly
    distributed. Note that this filter operates the lines, polygons, and
    triangle strips composing an instance of vtkPolyData.  Vertex or
    poly-vertex cells are never modified.
    
    The algorithm proceeds as follows. For each vertex v, a topological
    and geometric analysis is performed to determine which vertices are
    connected to v, and which cells are connected to v. Then, a
    connectivity array is constructed for each vertex. (The connectivity
    array is a list of lists of vertices that directly attach to each
    vertex.) Next, an iteration phase begins over all vertices. For each
    vertex v, the coordinates of v are modified using a windowed sinc
    function interpolation kernel. Taubin describes this methodology is
    the IBM tech report RC-20404 (#90237, dated 3/12/96) "Optimal Surface Smoothing as Filter
    Design" G. Taubin, T. Zhang and G. Golub. (Zhang and Golub are at
    Stanford University).
    
    This report discusses using standard signal processing low-pass
    filters (in particular windowed sinc functions) to smooth polyhedra.
    The transfer functions of the low-pass filters are approximated by
    Chebyshev polynomials. This facilitates applying the filters in an
    iterative diffusion process (as opposed to a kernel convolution). 
    The more smoothing iterations applied, the higher the degree of
    polynomial approximating the low-pass filter transfer function. Each
    smoothing iteration, therefore, applies the next higher term of the
    Chebyshev filter approximation to the polyhedron. This decoupling of
    the filter into an iteratively applied polynomial is possible since
    the Chebyshev polynomials are orthogonal, i.e. increasing the order
    of the approximation to the filter transfer function does not alter
    the previously calculated coefficients for the low order terms.
    
    Note: Care must be taken to avoid smoothing with too few iterations.
    A Chebyshev approximation with too few terms is an poor
    approximation. The first few smoothing iterations represent a severe
    scaling and translation of the data.  Subsequent iterations cause the
    smoothed polyhedron to converge to the true location and scale of the
    object. We have attempted to protect against this by automatically
    adjusting the filter, effectively widening the pass band. This
    adjustment is only possible if the number of iterations is greater
    than 1.  Note that this sacrifices some degree of smoothing for model
    integrity. For those interested, the filter is adjusted by searching
    for a value sigma such that the actual pass band is k_pb + sigma and
    such that the filter transfer function evaluates to unity at k_pb,
    i.e. f(k_pb) = 1
    
    To improve the numerical stability of the solution and minimize the
    scaling the translation effects, the algorithm can translate and
    scale the position coordinates to within the unit cube [-1, 1],
    perform the smoothing, and translate and scale the position
    coordinates back to the original coordinate frame.  This mode is
    controlled with the NormalizeCoordinatesOn() /
    NormalizeCoordinatesOff() methods.  For legacy reasons, the default
    is NormalizeCoordinatesOff.
    
    This implementation is currently limited to using an interpolation
    kernel based on Hamming windows.  Other windows (such as Hann,
    Blackman, Kaiser, Lanczos, Gaussian, and exponential windows) could
    be used instead.
    
    There are some special instance variables used to control the
    execution of this filter. (These ivars basically control what
    vertices can be smoothed, and the creation of the connectivity
    array.) The BoundarySmoothing ivar enables/disables the smoothing
    operation on vertices that are on the "boundary" of the mesh. A
    boundary vertex is one that is surrounded by a semi-cycle of polygons
    (or used by a single line).
    
    Another important ivar is FeatureEdgeSmoothing. If this ivar is
    enabled, then interior vertices are classified as either "simple", "interior
    edge", or "fixed", and smoothed differently. (Interior vertices are
    manifold vertices surrounded by a cycle of polygons; or used by two
    line cells.) The classification is based on the number of feature
    edges attached to v. A feature edge occurs when the angle between the
    two surface normals of a polygon sharing an edge is greater than the
    FeatureAngle ivar. Then, vertices used by no feature edges are
    classified "simple", vertices used by exactly two feature edges are
    classified "interior edge", and all others are "fixed" vertices.
    
    Once the classification is known, the vertices are smoothed
    differently. Corner (i.e., fixed) vertices are not smoothed at all.
    Simple vertices are smoothed as before . Interior edge vertices are
    smoothed only along their two connected edges, and only if the angle
    between the edges is less than the EdgeAngle ivar.
    
    The total smoothing can be controlled by using two ivars. The
    NumberOfIterations determines the maximum number of smoothing passes.
    The NumberOfIterations corresponds to the degree of the polynomial
    that is used to approximate the windowed sinc function. Ten or twenty
    iterations is all the is usually necessary. Contrast this with
    vtkSmoothPolyDataFilter which usually requires 100 to 200 smoothing
    iterations. vtkSmoothPolyDataFilter is also not an approximation to
    an ideal low-pass filter, which can cause the geometry to shrink as
    the amount of smoothing increases.
    
    The second ivar is the specification of the PassBand for the windowed
    sinc filter.  By design, the PassBand is specified as a doubleing
    point number between 0 and 2.  Lower PassBand values produce more
    smoothing. A good default value for the PassBand is 0.1 (for those
    interested, the PassBand (and frequencies) for PolyData are based on
    the valence of the vertices, this limits all the frequency modes in a
    polyhedral mesh to between 0 and 2.)
    
    There are two instance variables that control the generation of error
    data. If the ivar GenerateErrorScalars is on, then a scalar value
    indicating the distance of each vertex from its original position is
    computed. If the ivar GenerateErrorVectors is on, then a vector
    representing change in position is computed.
    
    @warning
    The smoothing operation reduces high frequency information in the
    geometry of the mesh. With excessive smoothing important details may
    be lost. Enabling FeatureEdgeSmoothing helps reduce this effect, but
    cannot entirely eliminate it.
    
    @sa
    vtkSmoothPolyDataFilter vtkDecimate vtkDecimatePro
    """
    def BoundarySmoothingOff(self):
        """
        V.BoundarySmoothingOff()
        C++: virtual void BoundarySmoothingOff()
        
        Turn on/off the smoothing of vertices on the boundary of the
        mesh.
        """
        ...
    
    def BoundarySmoothingOn(self):
        """
        V.BoundarySmoothingOn()
        C++: virtual void BoundarySmoothingOn()
        
        Turn on/off the smoothing of vertices on the boundary of the
        mesh.
        """
        ...
    
    def FeatureEdgeSmoothingOff(self):
        """
        V.FeatureEdgeSmoothingOff()
        C++: virtual void FeatureEdgeSmoothingOff()
        
        Turn on/off smoothing along sharp interior edges.
        """
        ...
    
    def FeatureEdgeSmoothingOn(self):
        """
        V.FeatureEdgeSmoothingOn()
        C++: virtual void FeatureEdgeSmoothingOn()
        
        Turn on/off smoothing along sharp interior edges.
        """
        ...
    
    def GenerateErrorScalarsOff(self):
        """
        V.GenerateErrorScalarsOff()
        C++: virtual void GenerateErrorScalarsOff()
        
        Turn on/off the generation of scalar distance values.
        """
        ...
    
    def GenerateErrorScalarsOn(self):
        """
        V.GenerateErrorScalarsOn()
        C++: virtual void GenerateErrorScalarsOn()
        
        Turn on/off the generation of scalar distance values.
        """
        ...
    
    def GenerateErrorVectorsOff(self):
        """
        V.GenerateErrorVectorsOff()
        C++: virtual void GenerateErrorVectorsOff()
        
        Turn on/off the generation of error vectors.
        """
        ...
    
    def GenerateErrorVectorsOn(self):
        """
        V.GenerateErrorVectorsOn()
        C++: virtual void GenerateErrorVectorsOn()
        
        Turn on/off the generation of error vectors.
        """
        ...
    
    def GetBoundarySmoothing(self):
        """
        V.GetBoundarySmoothing() -> int
        C++: virtual vtkTypeBool GetBoundarySmoothing()
        
        Turn on/off the smoothing of vertices on the boundary of the
        mesh.
        """
        ...
    
    def GetEdgeAngle(self):
        """
        V.GetEdgeAngle() -> float
        C++: virtual double GetEdgeAngle()
        
        Specify the edge angle to control smoothing along edges (either
        interior or boundary).
        """
        ...
    
    def GetEdgeAngleMaxValue(self):
        """
        V.GetEdgeAngleMaxValue() -> float
        C++: virtual double GetEdgeAngleMaxValue()
        
        Specify the edge angle to control smoothing along edges (either
        interior or boundary).
        """
        ...
    
    def GetEdgeAngleMinValue(self):
        """
        V.GetEdgeAngleMinValue() -> float
        C++: virtual double GetEdgeAngleMinValue()
        
        Specify the edge angle to control smoothing along edges (either
        interior or boundary).
        """
        ...
    
    def GetFeatureAngle(self):
        """
        V.GetFeatureAngle() -> float
        C++: virtual double GetFeatureAngle()
        
        Specify the feature angle for sharp edge identification.
        """
        ...
    
    def GetFeatureAngleMaxValue(self):
        """
        V.GetFeatureAngleMaxValue() -> float
        C++: virtual double GetFeatureAngleMaxValue()
        
        Specify the feature angle for sharp edge identification.
        """
        ...
    
    def GetFeatureAngleMinValue(self):
        """
        V.GetFeatureAngleMinValue() -> float
        C++: virtual double GetFeatureAngleMinValue()
        
        Specify the feature angle for sharp edge identification.
        """
        ...
    
    def GetFeatureEdgeSmoothing(self):
        """
        V.GetFeatureEdgeSmoothing() -> int
        C++: virtual vtkTypeBool GetFeatureEdgeSmoothing()
        
        Turn on/off smoothing along sharp interior edges.
        """
        ...
    
    def GetGenerateErrorScalars(self):
        """
        V.GetGenerateErrorScalars() -> int
        C++: virtual vtkTypeBool GetGenerateErrorScalars()
        
        Turn on/off the generation of scalar distance values.
        """
        ...
    
    def GetGenerateErrorVectors(self):
        """
        V.GetGenerateErrorVectors() -> int
        C++: virtual vtkTypeBool GetGenerateErrorVectors()
        
        Turn on/off the generation of error vectors.
        """
        ...
    
    def GetNonManifoldSmoothing(self):
        """
        V.GetNonManifoldSmoothing() -> int
        C++: virtual vtkTypeBool GetNonManifoldSmoothing()
        
        Smooth non-manifold vertices.
        """
        ...
    
    def GetNormalizeCoordinates(self):
        """
        V.GetNormalizeCoordinates() -> int
        C++: virtual vtkTypeBool GetNormalizeCoordinates()
        
        Turn on/off coordinate normalization.  The positions can be
        translated and scaled such that they fit within a [-1, 1] prior
        to the smoothing computation. The default is off.  The numerical
        stability of the solution can be improved by turning
        normalization on.  If normalization is on, the coordinates will
        be rescaled to the original coordinate system after smoothing has
        completed.
        """
        ...
    
    def GetNumberOfGenerationsFromBase(self, string):
        """
        V.GetNumberOfGenerationsFromBase(string) -> int
        C++: vtkIdType GetNumberOfGenerationsFromBase(const char *type)
            override;
        
        Given a the name of a base class of this class type, return the
        distance of inheritance between this class type and the named
        class (how many generations of inheritance are there between this
        class and the named class). If the named class is not in this
        class's inheritance tree, return a negative value. Valid
        responses will always be nonnegative. This method works in
        combination with vtkTypeMacro found in vtkSetGet.h.
        """
        ...
    
    def GetNumberOfGenerationsFromBaseType(self, string):
        """
        V.GetNumberOfGenerationsFromBaseType(string) -> int
        C++: static vtkIdType GetNumberOfGenerationsFromBaseType(
            const char *type)
        
        Given a the name of a base class of this class type, return the
        distance of inheritance between this class type and the named
        class (how many generations of inheritance are there between this
        class and the named class). If the named class is not in this
        class's inheritance tree, return a negative value. Valid
        responses will always be nonnegative. This method works in
        combination with vtkTypeMacro found in vtkSetGet.h.
        """
        ...
    
    def GetNumberOfIterations(self):
        """
        V.GetNumberOfIterations() -> int
        C++: virtual int GetNumberOfIterations()
        
        Specify the number of iterations (or degree of the polynomial
        approximating the windowed sinc function).
        """
        ...
    
    def GetNumberOfIterationsMaxValue(self):
        """
        V.GetNumberOfIterationsMaxValue() -> int
        C++: virtual int GetNumberOfIterationsMaxValue()
        
        Specify the number of iterations (or degree of the polynomial
        approximating the windowed sinc function).
        """
        ...
    
    def GetNumberOfIterationsMinValue(self):
        """
        V.GetNumberOfIterationsMinValue() -> int
        C++: virtual int GetNumberOfIterationsMinValue()
        
        Specify the number of iterations (or degree of the polynomial
        approximating the windowed sinc function).
        """
        ...
    
    def GetPassBand(self):
        """
        V.GetPassBand() -> float
        C++: virtual double GetPassBand()
        
        Set the passband value for the windowed sinc filter
        """
        ...
    
    def GetPassBandMaxValue(self):
        """
        V.GetPassBandMaxValue() -> float
        C++: virtual double GetPassBandMaxValue()
        
        Set the passband value for the windowed sinc filter
        """
        ...
    
    def GetPassBandMinValue(self):
        """
        V.GetPassBandMinValue() -> float
        C++: virtual double GetPassBandMinValue()
        
        Set the passband value for the windowed sinc filter
        """
        ...
    
    def IsA(self, string):
        """
        V.IsA(string) -> int
        C++: vtkTypeBool IsA(const char *type) override;
        
        Return 1 if this class is the same type of (or a subclass of) the
        named class. Returns 0 otherwise. This method works in
        combination with vtkTypeMacro found in vtkSetGet.h.
        """
        ...
    
    def IsTypeOf(self, string):
        """
        V.IsTypeOf(string) -> int
        C++: static vtkTypeBool IsTypeOf(const char *type)
        
        Return 1 if this class type is the same type of (or a subclass
        of) the named class. Returns 0 otherwise. This method works in
        combination with vtkTypeMacro found in vtkSetGet.h.
        """
        ...
    
    def NewInstance(self):
        """
        V.NewInstance() -> vtkWindowedSincPolyDataFilter
        C++: vtkWindowedSincPolyDataFilter *NewInstance()
        """
        ...
    
    def NonManifoldSmoothingOff(self):
        """
        V.NonManifoldSmoothingOff()
        C++: virtual void NonManifoldSmoothingOff()
        
        Smooth non-manifold vertices.
        """
        ...
    
    def NonManifoldSmoothingOn(self):
        """
        V.NonManifoldSmoothingOn()
        C++: virtual void NonManifoldSmoothingOn()
        
        Smooth non-manifold vertices.
        """
        ...
    
    def NormalizeCoordinatesOff(self):
        """
        V.NormalizeCoordinatesOff()
        C++: virtual void NormalizeCoordinatesOff()
        
        Turn on/off coordinate normalization.  The positions can be
        translated and scaled such that they fit within a [-1, 1] prior
        to the smoothing computation. The default is off.  The numerical
        stability of the solution can be improved by turning
        normalization on.  If normalization is on, the coordinates will
        be rescaled to the original coordinate system after smoothing has
        completed.
        """
        ...
    
    def NormalizeCoordinatesOn(self):
        """
        V.NormalizeCoordinatesOn()
        C++: virtual void NormalizeCoordinatesOn()
        
        Turn on/off coordinate normalization.  The positions can be
        translated and scaled such that they fit within a [-1, 1] prior
        to the smoothing computation. The default is off.  The numerical
        stability of the solution can be improved by turning
        normalization on.  If normalization is on, the coordinates will
        be rescaled to the original coordinate system after smoothing has
        completed.
        """
        ...
    
    def SafeDownCast(self, vtkObjectBase):
        """
        V.SafeDownCast(vtkObjectBase) -> vtkWindowedSincPolyDataFilter
        C++: static vtkWindowedSincPolyDataFilter *SafeDownCast(
            vtkObjectBase *o)
        """
        ...
    
    def SetBoundarySmoothing(self, p_int):
        """
        V.SetBoundarySmoothing(int)
        C++: virtual void SetBoundarySmoothing(vtkTypeBool _arg)
        
        Turn on/off the smoothing of vertices on the boundary of the
        mesh.
        """
        ...
    
    def SetEdgeAngle(self, p_float):
        """
        V.SetEdgeAngle(float)
        C++: virtual void SetEdgeAngle(double _arg)
        
        Specify the edge angle to control smoothing along edges (either
        interior or boundary).
        """
        ...
    
    def SetFeatureAngle(self, p_float):
        """
        V.SetFeatureAngle(float)
        C++: virtual void SetFeatureAngle(double _arg)
        
        Specify the feature angle for sharp edge identification.
        """
        ...
    
    def SetFeatureEdgeSmoothing(self, p_int):
        """
        V.SetFeatureEdgeSmoothing(int)
        C++: virtual void SetFeatureEdgeSmoothing(vtkTypeBool _arg)
        
        Turn on/off smoothing along sharp interior edges.
        """
        ...
    
    def SetGenerateErrorScalars(self, p_int):
        """
        V.SetGenerateErrorScalars(int)
        C++: virtual void SetGenerateErrorScalars(vtkTypeBool _arg)
        
        Turn on/off the generation of scalar distance values.
        """
        ...
    
    def SetGenerateErrorVectors(self, p_int):
        """
        V.SetGenerateErrorVectors(int)
        C++: virtual void SetGenerateErrorVectors(vtkTypeBool _arg)
        
        Turn on/off the generation of error vectors.
        """
        ...
    
    def SetNonManifoldSmoothing(self, p_int):
        """
        V.SetNonManifoldSmoothing(int)
        C++: virtual void SetNonManifoldSmoothing(vtkTypeBool _arg)
        
        Smooth non-manifold vertices.
        """
        ...
    
    def SetNormalizeCoordinates(self, p_int):
        """
        V.SetNormalizeCoordinates(int)
        C++: virtual void SetNormalizeCoordinates(vtkTypeBool _arg)
        
        Turn on/off coordinate normalization.  The positions can be
        translated and scaled such that they fit within a [-1, 1] prior
        to the smoothing computation. The default is off.  The numerical
        stability of the solution can be improved by turning
        normalization on.  If normalization is on, the coordinates will
        be rescaled to the original coordinate system after smoothing has
        completed.
        """
        ...
    
    def SetNumberOfIterations(self, p_int):
        """
        V.SetNumberOfIterations(int)
        C++: virtual void SetNumberOfIterations(int _arg)
        
        Specify the number of iterations (or degree of the polynomial
        approximating the windowed sinc function).
        """
        ...
    
    def SetPassBand(self, p_float):
        """
        V.SetPassBand(float)
        C++: virtual void SetPassBand(double _arg)
        
        Set the passband value for the windowed sinc filter
        """
        ...
    
    def __delattr__(self, *args, **kwargs):
        """ Implement delattr(self, name). """
        ...
    
    def __getattribute__(self, *args, **kwargs):
        """ Return getattr(self, name). """
        ...
    
    def __init__(self, *args, **kwargs) -> None:
        ...
    
    @staticmethod
    def __new__(*args, **kwargs):
        """ Create and return a new object.  See help(type) for accurate signature. """
        ...
    
    def __repr__(self, *args, **kwargs):
        """ Return repr(self). """
        ...
    
    def __setattr__(self, *args, **kwargs):
        """ Implement setattr(self, name, value). """
        ...
    
    def __str__(self, *args, **kwargs) -> str:
        """ Return str(self). """
        ...
    
    __this__ = ...
    __dict__ = ...
    __vtkname__ = ...


