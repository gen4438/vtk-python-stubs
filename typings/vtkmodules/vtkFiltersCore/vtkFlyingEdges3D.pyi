"""
This type stub file was generated by pyright.
"""

import vtkmodules.vtkCommonExecutionModel as __vtkmodules_vtkCommonExecutionModel

class vtkFlyingEdges3D(__vtkmodules_vtkCommonExecutionModel.vtkPolyDataAlgorithm):
    """
    vtkFlyingEdges3D - generate isosurface from 3D image data (volume)
    
    Superclass: vtkPolyDataAlgorithm
    
    vtkFlyingEdges3D is a reference implementation of the 3D version of
    the flying edges algorithm. It is designed to be highly scalable
    (i.e., parallelizable) for large data. It implements certain
    performance optimizations including computational trimming to rapidly
    eliminate processing of data regions, packed bit representation of
    case table values, single edge intersection, elimination of point
    merging, and elimination of any reallocs (due to dynamic data
    insertion). Note that computational trimming is a method to reduce
    total computational cost in which partial computational results can
    be used to eliminate future computations.
    
    This is a four-pass algorithm. The first pass processes all x-edges
    and builds x-edge case values (which, when the four x-edges defining
    a voxel are combined, are equivalent to vertex-based case table
    except edge-based approaches are separable in support of parallel
    computing). Next x-voxel rows are processed to gather information
    from yz-edges (basically to count the number of y-z edge
    intersections and triangles generated). In the third pass a prefix
    sum is used to count and allocate memory for the output primitives.
    Finally in the fourth pass output primitives are generated into
    pre-allocated arrays. This implementation uses voxel cell axes (a
    x-y-z triad located at the voxel origin) to ensure that each edge is
    intersected at most one time. Note that this implementation also
    reuses the VTK Marching Cubes case table, although the vertex-based
    MC table is transformed into an edge-based table on object
    instantiation.
    
    See the paper "Flying Edges: A High-Performance Scalable
    Isocontouring Algorithm" by Schroeder, Maynard, Geveci. Proc. of LDAV
    2015. Chicago, IL.
    
    @warning
    This filter is specialized to 3D volumes. This implementation can
    produce degenerate triangles (i.e., zero-area triangles).
    
    @warning
    If you are interested in extracting segmented regions from a label
    mask, consider using vtkDiscreteFlyingEdges3D.
    
    @warning
    This class has been threaded with vtkSMPTools. Using TBB or other
    non-sequential type (set in the CMake variable
    VTK_SMP_IMPLEMENTATION_TYPE) may improve performance significantly.
    
    @sa
    vtkContourFilter vtkFlyingEdges2D vtkSynchronizedTemplates3D
    vtkMarchingCubes vtkDiscreteFlyingEdges3D vtkContour3DLinearGrid
    """
    def ComputeGradientsOff(self):
        """
        V.ComputeGradientsOff()
        C++: virtual void ComputeGradientsOff()
        
        Set/Get the computation of gradients. Gradient computation is
        fairly expensive in both time and storage. Note that if
        ComputeNormals is on, gradients will have to be calculated, but
        will not be stored in the output dataset. If the output data will
        be processed by filters that modify topology or geometry, it may
        be wise to turn Normals and Gradients off.
        """
        ...
    
    def ComputeGradientsOn(self):
        """
        V.ComputeGradientsOn()
        C++: virtual void ComputeGradientsOn()
        
        Set/Get the computation of gradients. Gradient computation is
        fairly expensive in both time and storage. Note that if
        ComputeNormals is on, gradients will have to be calculated, but
        will not be stored in the output dataset. If the output data will
        be processed by filters that modify topology or geometry, it may
        be wise to turn Normals and Gradients off.
        """
        ...
    
    def ComputeNormalsOff(self):
        """
        V.ComputeNormalsOff()
        C++: virtual void ComputeNormalsOff()
        
        Set/Get the computation of normals. Normal computation is fairly
        expensive in both time and storage. If the output data will be
        processed by filters that modify topology or geometry, it may be
        wise to turn Normals and Gradients off.
        """
        ...
    
    def ComputeNormalsOn(self):
        """
        V.ComputeNormalsOn()
        C++: virtual void ComputeNormalsOn()
        
        Set/Get the computation of normals. Normal computation is fairly
        expensive in both time and storage. If the output data will be
        processed by filters that modify topology or geometry, it may be
        wise to turn Normals and Gradients off.
        """
        ...
    
    def ComputeScalarsOff(self):
        """
        V.ComputeScalarsOff()
        C++: virtual void ComputeScalarsOff()
        
        Set/Get the computation of scalars.
        """
        ...
    
    def ComputeScalarsOn(self):
        """
        V.ComputeScalarsOn()
        C++: virtual void ComputeScalarsOn()
        
        Set/Get the computation of scalars.
        """
        ...
    
    def GenerateValues(self, p_int, p_float=..., p_float=...):
        """
        V.GenerateValues(int, [float, float])
        C++: void GenerateValues(int numContours, double range[2])
        V.GenerateValues(int, float, float)
        C++: void GenerateValues(int numContours, double rangeStart,
            double rangeEnd)
        
        Generate numContours equally spaced contour values between
        specified range. Contour values will include min/max range
        values.
        """
        ...
    
    def GetArrayComponent(self):
        """
        V.GetArrayComponent() -> int
        C++: virtual int GetArrayComponent()
        
        Set/get which component of the scalar array to contour on;
        defaults to 0.
        """
        ...
    
    def GetComputeGradients(self):
        """
        V.GetComputeGradients() -> int
        C++: virtual vtkTypeBool GetComputeGradients()
        
        Set/Get the computation of gradients. Gradient computation is
        fairly expensive in both time and storage. Note that if
        ComputeNormals is on, gradients will have to be calculated, but
        will not be stored in the output dataset. If the output data will
        be processed by filters that modify topology or geometry, it may
        be wise to turn Normals and Gradients off.
        """
        ...
    
    def GetComputeNormals(self):
        """
        V.GetComputeNormals() -> int
        C++: virtual vtkTypeBool GetComputeNormals()
        
        Set/Get the computation of normals. Normal computation is fairly
        expensive in both time and storage. If the output data will be
        processed by filters that modify topology or geometry, it may be
        wise to turn Normals and Gradients off.
        """
        ...
    
    def GetComputeScalars(self):
        """
        V.GetComputeScalars() -> int
        C++: virtual vtkTypeBool GetComputeScalars()
        
        Set/Get the computation of scalars.
        """
        ...
    
    def GetInterpolateAttributes(self):
        """
        V.GetInterpolateAttributes() -> int
        C++: virtual vtkTypeBool GetInterpolateAttributes()
        
        Indicate whether to interpolate other attribute data. That is, as
        the isosurface is generated, interpolate all point attribute data
        across the edge. This is independent of scalar interpolation,
        which is controlled by the ComputeScalars flag.
        """
        ...
    
    def GetMTime(self):
        """
        V.GetMTime() -> int
        C++: vtkMTimeType GetMTime() override;
        
        Because we delegate to vtkContourValues.
        """
        ...
    
    def GetNumberOfContours(self):
        """
        V.GetNumberOfContours() -> int
        C++: vtkIdType GetNumberOfContours()
        
        Get the number of contours in the list of contour values.
        """
        ...
    
    def GetNumberOfGenerationsFromBase(self, string):
        """
        V.GetNumberOfGenerationsFromBase(string) -> int
        C++: vtkIdType GetNumberOfGenerationsFromBase(const char *type)
            override;
        
        Given a the name of a base class of this class type, return the
        distance of inheritance between this class type and the named
        class (how many generations of inheritance are there between this
        class and the named class). If the named class is not in this
        class's inheritance tree, return a negative value. Valid
        responses will always be nonnegative. This method works in
        combination with vtkTypeMacro found in vtkSetGet.h.
        """
        ...
    
    def GetNumberOfGenerationsFromBaseType(self, string):
        """
        V.GetNumberOfGenerationsFromBaseType(string) -> int
        C++: static vtkIdType GetNumberOfGenerationsFromBaseType(
            const char *type)
        
        Given a the name of a base class of this class type, return the
        distance of inheritance between this class type and the named
        class (how many generations of inheritance are there between this
        class and the named class). If the named class is not in this
        class's inheritance tree, return a negative value. Valid
        responses will always be nonnegative. This method works in
        combination with vtkTypeMacro found in vtkSetGet.h.
        """
        ...
    
    def GetValue(self, p_int):
        """
        V.GetValue(int) -> float
        C++: double GetValue(int i)
        
        Get the ith contour value.
        """
        ...
    
    def GetValues(self):
        """
        V.GetValues() -> (float, ...)
        C++: double *GetValues()
        V.GetValues([float, ...])
        C++: void GetValues(double *contourValues)
        
        Get a pointer to an array of contour values. There will be
        GetNumberOfContours() values in the list.
        """
        ...
    
    def InterpolateAttributesOff(self):
        """
        V.InterpolateAttributesOff()
        C++: virtual void InterpolateAttributesOff()
        
        Indicate whether to interpolate other attribute data. That is, as
        the isosurface is generated, interpolate all point attribute data
        across the edge. This is independent of scalar interpolation,
        which is controlled by the ComputeScalars flag.
        """
        ...
    
    def InterpolateAttributesOn(self):
        """
        V.InterpolateAttributesOn()
        C++: virtual void InterpolateAttributesOn()
        
        Indicate whether to interpolate other attribute data. That is, as
        the isosurface is generated, interpolate all point attribute data
        across the edge. This is independent of scalar interpolation,
        which is controlled by the ComputeScalars flag.
        """
        ...
    
    def IsA(self, string):
        """
        V.IsA(string) -> int
        C++: vtkTypeBool IsA(const char *type) override;
        
        Return 1 if this class is the same type of (or a subclass of) the
        named class. Returns 0 otherwise. This method works in
        combination with vtkTypeMacro found in vtkSetGet.h.
        """
        ...
    
    def IsTypeOf(self, string):
        """
        V.IsTypeOf(string) -> int
        C++: static vtkTypeBool IsTypeOf(const char *type)
        
        Return 1 if this class type is the same type of (or a subclass
        of) the named class. Returns 0 otherwise. This method works in
        combination with vtkTypeMacro found in vtkSetGet.h.
        """
        ...
    
    def NewInstance(self):
        """
        V.NewInstance() -> vtkFlyingEdges3D
        C++: vtkFlyingEdges3D *NewInstance()
        """
        ...
    
    def SafeDownCast(self, vtkObjectBase):
        """
        V.SafeDownCast(vtkObjectBase) -> vtkFlyingEdges3D
        C++: static vtkFlyingEdges3D *SafeDownCast(vtkObjectBase *o)
        """
        ...
    
    def SetArrayComponent(self, p_int):
        """
        V.SetArrayComponent(int)
        C++: virtual void SetArrayComponent(int _arg)
        
        Set/get which component of the scalar array to contour on;
        defaults to 0.
        """
        ...
    
    def SetComputeGradients(self, p_int):
        """
        V.SetComputeGradients(int)
        C++: virtual void SetComputeGradients(vtkTypeBool _arg)
        
        Set/Get the computation of gradients. Gradient computation is
        fairly expensive in both time and storage. Note that if
        ComputeNormals is on, gradients will have to be calculated, but
        will not be stored in the output dataset. If the output data will
        be processed by filters that modify topology or geometry, it may
        be wise to turn Normals and Gradients off.
        """
        ...
    
    def SetComputeNormals(self, p_int):
        """
        V.SetComputeNormals(int)
        C++: virtual void SetComputeNormals(vtkTypeBool _arg)
        
        Set/Get the computation of normals. Normal computation is fairly
        expensive in both time and storage. If the output data will be
        processed by filters that modify topology or geometry, it may be
        wise to turn Normals and Gradients off.
        """
        ...
    
    def SetComputeScalars(self, p_int):
        """
        V.SetComputeScalars(int)
        C++: virtual void SetComputeScalars(vtkTypeBool _arg)
        
        Set/Get the computation of scalars.
        """
        ...
    
    def SetInterpolateAttributes(self, p_int):
        """
        V.SetInterpolateAttributes(int)
        C++: virtual void SetInterpolateAttributes(vtkTypeBool _arg)
        
        Indicate whether to interpolate other attribute data. That is, as
        the isosurface is generated, interpolate all point attribute data
        across the edge. This is independent of scalar interpolation,
        which is controlled by the ComputeScalars flag.
        """
        ...
    
    def SetNumberOfContours(self, p_int):
        """
        V.SetNumberOfContours(int)
        C++: void SetNumberOfContours(int number)
        
        Set the number of contours to place into the list. You only
        really need to use this method to reduce list size. The method
        SetValue() will automatically increase list size as needed.
        """
        ...
    
    def SetValue(self, p_int, p_float):
        """
        V.SetValue(int, float)
        C++: void SetValue(int i, double value)
        
        Set a particular contour value at contour number i. The index i
        ranges between 0<=i<NumberOfContours.
        """
        ...
    
    def __delattr__(self, *args, **kwargs):
        """ Implement delattr(self, name). """
        ...
    
    def __getattribute__(self, *args, **kwargs):
        """ Return getattr(self, name). """
        ...
    
    def __init__(self, *args, **kwargs) -> None:
        ...
    
    @staticmethod
    def __new__(*args, **kwargs):
        """ Create and return a new object.  See help(type) for accurate signature. """
        ...
    
    def __repr__(self, *args, **kwargs):
        """ Return repr(self). """
        ...
    
    def __setattr__(self, *args, **kwargs):
        """ Implement setattr(self, name, value). """
        ...
    
    def __str__(self, *args, **kwargs) -> str:
        """ Return str(self). """
        ...
    
    __this__ = ...
    __dict__ = ...
    __vtkname__ = ...


