"""
This type stub file was generated by pyright.
"""

from .vtkProbeFilter import vtkProbeFilter

class vtkCompositeDataProbeFilter(vtkProbeFilter):
    """
    vtkCompositeDataProbeFilter - subclass of vtkProbeFilter which
    supports composite datasets in the input.
    
    Superclass: vtkProbeFilter
    
    vtkCompositeDataProbeFilter supports probing into multi-group
    datasets. It sequentially probes through each concrete dataset within
    the composite probing at only those locations at which there were no
    hits when probing earlier datasets. For Hierarchical datasets, this
    traversal through leaf datasets is done in reverse order of levels
    i.e. highest level first.
    
    When dealing with composite datasets, partial arrays are common i.e.
    data-arrays that are not available in all of the blocks. By default,
    this filter only passes those point and cell data-arrays that are
    available in all the blocks i.e. partial array are removed. When
    PassPartialArrays is turned on, this behavior is changed to take a
    union of all arrays present thus partial arrays are passed as well.
    However, for composite dataset input, this filter still produces a
    non-composite output. For all those locations in a block of where a
    particular data array is missing, this filter uses vtkMath::Nan() for
    double and float arrays, while 0 for all other types of arrays i.e
    int, char etc.
    """
    def GetNumberOfGenerationsFromBase(self, string):
        """
        V.GetNumberOfGenerationsFromBase(string) -> int
        C++: vtkIdType GetNumberOfGenerationsFromBase(const char *type)
            override;
        
        Given a the name of a base class of this class type, return the
        distance of inheritance between this class type and the named
        class (how many generations of inheritance are there between this
        class and the named class). If the named class is not in this
        class's inheritance tree, return a negative value. Valid
        responses will always be nonnegative. This method works in
        combination with vtkTypeMacro found in vtkSetGet.h.
        """
        ...
    
    def GetNumberOfGenerationsFromBaseType(self, string):
        """
        V.GetNumberOfGenerationsFromBaseType(string) -> int
        C++: static vtkIdType GetNumberOfGenerationsFromBaseType(
            const char *type)
        
        Given a the name of a base class of this class type, return the
        distance of inheritance between this class type and the named
        class (how many generations of inheritance are there between this
        class and the named class). If the named class is not in this
        class's inheritance tree, return a negative value. Valid
        responses will always be nonnegative. This method works in
        combination with vtkTypeMacro found in vtkSetGet.h.
        """
        ...
    
    def GetPassPartialArrays(self):
        """
        V.GetPassPartialArrays() -> bool
        C++: virtual bool GetPassPartialArrays()
        
        When dealing with composite datasets, partial arrays are common
        i.e. data-arrays that are not available in all of the blocks. By
        default, this filter only passes those point and cell data-arrays
        that are available in all the blocks i.e. partial array are
        removed.  When PassPartialArrays is turned on, this behavior is
        changed to take a union of all arrays present thus partial arrays
        are passed as well. However, for composite dataset input, this
        filter still produces a non-composite output. For all those
        locations in a block of where a particular data array is missing,
        this filter uses vtkMath::Nan() for double and float arrays,
        while 0 for all other types of arrays i.e int, char etc.
        """
        ...
    
    def IsA(self, string):
        """
        V.IsA(string) -> int
        C++: vtkTypeBool IsA(const char *type) override;
        
        Return 1 if this class is the same type of (or a subclass of) the
        named class. Returns 0 otherwise. This method works in
        combination with vtkTypeMacro found in vtkSetGet.h.
        """
        ...
    
    def IsTypeOf(self, string):
        """
        V.IsTypeOf(string) -> int
        C++: static vtkTypeBool IsTypeOf(const char *type)
        
        Return 1 if this class type is the same type of (or a subclass
        of) the named class. Returns 0 otherwise. This method works in
        combination with vtkTypeMacro found in vtkSetGet.h.
        """
        ...
    
    def NewInstance(self):
        """
        V.NewInstance() -> vtkCompositeDataProbeFilter
        C++: vtkCompositeDataProbeFilter *NewInstance()
        """
        ...
    
    def PassPartialArraysOff(self):
        """
        V.PassPartialArraysOff()
        C++: virtual void PassPartialArraysOff()
        
        When dealing with composite datasets, partial arrays are common
        i.e. data-arrays that are not available in all of the blocks. By
        default, this filter only passes those point and cell data-arrays
        that are available in all the blocks i.e. partial array are
        removed.  When PassPartialArrays is turned on, this behavior is
        changed to take a union of all arrays present thus partial arrays
        are passed as well. However, for composite dataset input, this
        filter still produces a non-composite output. For all those
        locations in a block of where a particular data array is missing,
        this filter uses vtkMath::Nan() for double and float arrays,
        while 0 for all other types of arrays i.e int, char etc.
        """
        ...
    
    def PassPartialArraysOn(self):
        """
        V.PassPartialArraysOn()
        C++: virtual void PassPartialArraysOn()
        
        When dealing with composite datasets, partial arrays are common
        i.e. data-arrays that are not available in all of the blocks. By
        default, this filter only passes those point and cell data-arrays
        that are available in all the blocks i.e. partial array are
        removed.  When PassPartialArrays is turned on, this behavior is
        changed to take a union of all arrays present thus partial arrays
        are passed as well. However, for composite dataset input, this
        filter still produces a non-composite output. For all those
        locations in a block of where a particular data array is missing,
        this filter uses vtkMath::Nan() for double and float arrays,
        while 0 for all other types of arrays i.e int, char etc.
        """
        ...
    
    def SafeDownCast(self, vtkObjectBase):
        """
        V.SafeDownCast(vtkObjectBase) -> vtkCompositeDataProbeFilter
        C++: static vtkCompositeDataProbeFilter *SafeDownCast(
            vtkObjectBase *o)
        """
        ...
    
    def SetPassPartialArrays(self, bool):
        """
        V.SetPassPartialArrays(bool)
        C++: virtual void SetPassPartialArrays(bool _arg)
        
        When dealing with composite datasets, partial arrays are common
        i.e. data-arrays that are not available in all of the blocks. By
        default, this filter only passes those point and cell data-arrays
        that are available in all the blocks i.e. partial array are
        removed.  When PassPartialArrays is turned on, this behavior is
        changed to take a union of all arrays present thus partial arrays
        are passed as well. However, for composite dataset input, this
        filter still produces a non-composite output. For all those
        locations in a block of where a particular data array is missing,
        this filter uses vtkMath::Nan() for double and float arrays,
        while 0 for all other types of arrays i.e int, char etc.
        """
        ...
    
    def __delattr__(self, *args, **kwargs):
        """ Implement delattr(self, name). """
        ...
    
    def __getattribute__(self, *args, **kwargs):
        """ Return getattr(self, name). """
        ...
    
    def __init__(self, *args, **kwargs) -> None:
        ...
    
    @staticmethod
    def __new__(*args, **kwargs):
        """ Create and return a new object.  See help(type) for accurate signature. """
        ...
    
    def __repr__(self, *args, **kwargs):
        """ Return repr(self). """
        ...
    
    def __setattr__(self, *args, **kwargs):
        """ Implement setattr(self, name, value). """
        ...
    
    def __str__(self, *args, **kwargs) -> str:
        """ Return str(self). """
        ...
    
    __this__ = ...
    __dict__ = ...
    __vtkname__ = ...


