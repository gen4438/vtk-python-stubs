"""
This type stub file was generated by pyright.
"""

import vtkmodules.vtkCommonExecutionModel as __vtkmodules_vtkCommonExecutionModel

class vtkVoronoi2D(__vtkmodules_vtkCommonExecutionModel.vtkPolyDataAlgorithm):
    """
    vtkVoronoi2D - create 2D Voronoi convex tiling of input points
    
    Superclass: vtkPolyDataAlgorithm
    
    vtkVoronoi2D is a filter that constructs a 2D Voronoi tessellation of
    a list of input points. The points are assumed to lie in a plane.
    These points may be represented by any dataset of type vtkPointSet
    and subclasses. The output of the filter is a polygonal dataset. Each
    output cell is a convex polygon.
    
    The 2D Voronoi tessellation is a tiling of space, where each Voronoi
    tile represents the region nearest to one of the input points.
    Voronoi tessellations are important in computational geometry (and
    many other fields), and are the dual of Delaunay triangulations.
    
    The input to this filter is a list of points specified in 3D, even
    though the triangulation is 2D. Thus the triangulation is constructed
    in the x-y plane, and the z coordinate is ignored (although carried
    through to the output). If you desire to triangulate in a different
    plane, you can use the vtkTransformFilter to transform the points
    into and out of the x-y plane or you can specify a transform to
    vtkVoronoi2D directly.  In the latter case, the input points are
    transformed, the transformed points are triangulated, and the output
    will use the triangulated topology for the original (non-transformed)
    points.  This avoids transforming the data back as would be required
    when using the vtkTransformFilter method.  Specifying a transform
    directly also allows any transform to be used: rigid, non-rigid,
    non-invertible, etc.
    
    This filter is a reference implementation written with simplicity in
    mind. Additional methods are available for debugging / instructional
    purposes. This includes producing a single tile under various stages
    of creation, as well as the Voronoi flower, related to the error
    metric for point insertion / half-space clipping.
    
    Publications are in preparation to describe the algorithm. A brief
    summary is as follows. In parallel, each (generating) input point is
    associated with an initial Voronoi tile, which is simply the bounding
    box of the point set. A locator is then used to identify nearby
    points: each neighbor in turn generates a clipping line positioned
    halfway between the generating point and the neighboring point, and
    orthogonal to the line connecting them. Clips are readily performed
    by evaluationg the vertices of the convex Voronoi tile as being on
    either side (inside,outside) of the clip line. If two intersections
    of the Voronoi tile are found, the portion of the tile "outside" the
    clip line is discarded, resulting in a new convex, Voronoi tile. As
    each clip occurs, the Voronoi "Flower" error metric (the union of
    error spheres) is compared to the extent of the region containing the
    neighboring clip points. The clip region (along with the points
    contained in it) is grown by careful expansion (e.g., outward
    spiraling iterator over all candidate clip points). When the Voronoi
    Flower is contained within the clip region, the algorithm terminates
    and the Voronoi tile is output. Once complete, it is possible to
    construct the Delaunay triangulation from the Voronoi tessellation.
    Note that topological and geometric information is used to generate a
    valid triangulation (e.g., merging points and validating topology).
    
    @warning
    Coincident input points will result in overlapping tiles.  This is
    because the Voronoi tessellation requires unique input points.
    
    @warning
    This is a novel approach which implements an embarrassingly parallel
    algorithm. At the core of the algorithm a locator is used to
    determine points close to a specified position. A
    vtkStaticPointLocator2D is used because it is both threaded (when
    constructed) and supports thread-safe queries. While other locators
    could be used in principal, they must support thread-safe operations.
    
    @warning
    This class has been threaded with vtkSMPTools. Using TBB or other
    non-sequential type (set in the CMake variable
    VTK_SMP_IMPLEMENTATION_TYPE) may improve performance significantly.
    
    @sa
    vtkDelaunay2D vtkTransformFilter vtkStaticPointLocator2D
    """
    def GenerateVoronoiFlowerOff(self):
        """
        V.GenerateVoronoiFlowerOff()
        C++: virtual void GenerateVoronoiFlowerOff()
        
        These methods are for debugging or instructional purposes. If
        GenerateVoronoiFlower is on, and the PointOfIntersect is
        specified, then second and third (optional) outputs are populated
        which contains a representation of the Voronoi flower error
        metric (second output) and the single Voronoi tile (corresponding
        to PointOfInterest) with point scalar values indicating the radii
        of the Voronoi Flower petals (i.e., circles contributing to the
        error metric).
        """
        ...
    
    def GenerateVoronoiFlowerOn(self):
        """
        V.GenerateVoronoiFlowerOn()
        C++: virtual void GenerateVoronoiFlowerOn()
        
        These methods are for debugging or instructional purposes. If
        GenerateVoronoiFlower is on, and the PointOfIntersect is
        specified, then second and third (optional) outputs are populated
        which contains a representation of the Voronoi flower error
        metric (second output) and the single Voronoi tile (corresponding
        to PointOfInterest) with point scalar values indicating the radii
        of the Voronoi Flower petals (i.e., circles contributing to the
        error metric).
        """
        ...
    
    def GetGenerateScalars(self):
        """
        V.GetGenerateScalars() -> int
        C++: virtual int GetGenerateScalars()
        
        Indicate whether to create a scalar array as part of the output.
        No scalars; point ids, or execution thread ids may be output. By
        default no scalars are generated.
        """
        ...
    
    def GetGenerateVoronoiFlower(self):
        """
        V.GetGenerateVoronoiFlower() -> int
        C++: virtual vtkTypeBool GetGenerateVoronoiFlower()
        
        These methods are for debugging or instructional purposes. If
        GenerateVoronoiFlower is on, and the PointOfIntersect is
        specified, then second and third (optional) outputs are populated
        which contains a representation of the Voronoi flower error
        metric (second output) and the single Voronoi tile (corresponding
        to PointOfInterest) with point scalar values indicating the radii
        of the Voronoi Flower petals (i.e., circles contributing to the
        error metric).
        """
        ...
    
    def GetLocator(self):
        """
        V.GetLocator() -> vtkStaticPointLocator2D
        C++: vtkStaticPointLocator2D *GetLocator()
        
        Retrieve the internal locator to manually configure it, for
        example specifying the number of points per bucket. This method
        is generally used for debugging or testing purposes.
        """
        ...
    
    def GetMaximumNumberOfTileClips(self):
        """
        V.GetMaximumNumberOfTileClips() -> int
        C++: virtual vtkIdType GetMaximumNumberOfTileClips()
        
        These methods are for debugging or instructional purposes. When
        the point of interest is specified (i.e., to a non-negative
        number) then the algorithm will only process this single point
        (whose id is the PointOfInterest). The maximum number of clips
        (the MaximumNumberOfTileClips) can be specified. If
        MaximumNumberOfTileClips=0, then the initial tile (single point
        within the bounding box) is produced; if =1 then the split with
        the closest point is produced; and so on. By default the
        PointOfInterest is set to (-1), and the number of clips is
        unlimited (i.e., MaximumNumberOfTileClips=VTK_ID_MAX and
        therefore automatically limited by the algorithm).
        """
        ...
    
    def GetMaximumNumberOfTileClipsMaxValue(self):
        """
        V.GetMaximumNumberOfTileClipsMaxValue() -> int
        C++: virtual vtkIdType GetMaximumNumberOfTileClipsMaxValue()
        
        These methods are for debugging or instructional purposes. When
        the point of interest is specified (i.e., to a non-negative
        number) then the algorithm will only process this single point
        (whose id is the PointOfInterest). The maximum number of clips
        (the MaximumNumberOfTileClips) can be specified. If
        MaximumNumberOfTileClips=0, then the initial tile (single point
        within the bounding box) is produced; if =1 then the split with
        the closest point is produced; and so on. By default the
        PointOfInterest is set to (-1), and the number of clips is
        unlimited (i.e., MaximumNumberOfTileClips=VTK_ID_MAX and
        therefore automatically limited by the algorithm).
        """
        ...
    
    def GetMaximumNumberOfTileClipsMinValue(self):
        """
        V.GetMaximumNumberOfTileClipsMinValue() -> int
        C++: virtual vtkIdType GetMaximumNumberOfTileClipsMinValue()
        
        These methods are for debugging or instructional purposes. When
        the point of interest is specified (i.e., to a non-negative
        number) then the algorithm will only process this single point
        (whose id is the PointOfInterest). The maximum number of clips
        (the MaximumNumberOfTileClips) can be specified. If
        MaximumNumberOfTileClips=0, then the initial tile (single point
        within the bounding box) is produced; if =1 then the split with
        the closest point is produced; and so on. By default the
        PointOfInterest is set to (-1), and the number of clips is
        unlimited (i.e., MaximumNumberOfTileClips=VTK_ID_MAX and
        therefore automatically limited by the algorithm).
        """
        ...
    
    def GetMTime(self):
        """
        V.GetMTime() -> int
        C++: vtkMTimeType GetMTime() override;
        
        Get the MTime of this object also considering the locator.
        """
        ...
    
    def GetNumberOfGenerationsFromBase(self, string):
        """
        V.GetNumberOfGenerationsFromBase(string) -> int
        C++: vtkIdType GetNumberOfGenerationsFromBase(const char *type)
            override;
        
        Standard methods for instantiation, type information, and
        printing.
        """
        ...
    
    def GetNumberOfGenerationsFromBaseType(self, string):
        """
        V.GetNumberOfGenerationsFromBaseType(string) -> int
        C++: static vtkIdType GetNumberOfGenerationsFromBaseType(
            const char *type)
        
        Standard methods for instantiation, type information, and
        printing.
        """
        ...
    
    def GetNumberOfThreadsUsed(self):
        """
        V.GetNumberOfThreadsUsed() -> int
        C++: int GetNumberOfThreadsUsed()
        
        Return the number of threads actually used during execution. This
        is valid only after algorithm execution.
        """
        ...
    
    def GetPadding(self):
        """
        V.GetPadding() -> float
        C++: virtual double GetPadding()
        
        Specify a padding for the bounding box of the points. A >0
        padding is necessary in order to create valid Voronoi tiles on
        the boundary of the tessellation. The padding is specified as a
        fraction of the diagonal length of the bounding box of the
        points.
        """
        ...
    
    def GetPaddingMaxValue(self):
        """
        V.GetPaddingMaxValue() -> float
        C++: virtual double GetPaddingMaxValue()
        
        Specify a padding for the bounding box of the points. A >0
        padding is necessary in order to create valid Voronoi tiles on
        the boundary of the tessellation. The padding is specified as a
        fraction of the diagonal length of the bounding box of the
        points.
        """
        ...
    
    def GetPaddingMinValue(self):
        """
        V.GetPaddingMinValue() -> float
        C++: virtual double GetPaddingMinValue()
        
        Specify a padding for the bounding box of the points. A >0
        padding is necessary in order to create valid Voronoi tiles on
        the boundary of the tessellation. The padding is specified as a
        fraction of the diagonal length of the bounding box of the
        points.
        """
        ...
    
    def GetPointOfInterest(self):
        """
        V.GetPointOfInterest() -> int
        C++: virtual vtkIdType GetPointOfInterest()
        
        These methods are for debugging or instructional purposes. When
        the point of interest is specified (i.e., to a non-negative
        number) then the algorithm will only process this single point
        (whose id is the PointOfInterest). The maximum number of clips
        (the MaximumNumberOfTileClips) can be specified. If
        MaximumNumberOfTileClips=0, then the initial tile (single point
        within the bounding box) is produced; if =1 then the split with
        the closest point is produced; and so on. By default the
        PointOfInterest is set to (-1), and the number of clips is
        unlimited (i.e., MaximumNumberOfTileClips=VTK_ID_MAX and
        therefore automatically limited by the algorithm).
        """
        ...
    
    def GetPointOfInterestMaxValue(self):
        """
        V.GetPointOfInterestMaxValue() -> int
        C++: virtual vtkIdType GetPointOfInterestMaxValue()
        
        These methods are for debugging or instructional purposes. When
        the point of interest is specified (i.e., to a non-negative
        number) then the algorithm will only process this single point
        (whose id is the PointOfInterest). The maximum number of clips
        (the MaximumNumberOfTileClips) can be specified. If
        MaximumNumberOfTileClips=0, then the initial tile (single point
        within the bounding box) is produced; if =1 then the split with
        the closest point is produced; and so on. By default the
        PointOfInterest is set to (-1), and the number of clips is
        unlimited (i.e., MaximumNumberOfTileClips=VTK_ID_MAX and
        therefore automatically limited by the algorithm).
        """
        ...
    
    def GetPointOfInterestMinValue(self):
        """
        V.GetPointOfInterestMinValue() -> int
        C++: virtual vtkIdType GetPointOfInterestMinValue()
        
        These methods are for debugging or instructional purposes. When
        the point of interest is specified (i.e., to a non-negative
        number) then the algorithm will only process this single point
        (whose id is the PointOfInterest). The maximum number of clips
        (the MaximumNumberOfTileClips) can be specified. If
        MaximumNumberOfTileClips=0, then the initial tile (single point
        within the bounding box) is produced; if =1 then the split with
        the closest point is produced; and so on. By default the
        PointOfInterest is set to (-1), and the number of clips is
        unlimited (i.e., MaximumNumberOfTileClips=VTK_ID_MAX and
        therefore automatically limited by the algorithm).
        """
        ...
    
    def GetProjectionPlaneMode(self):
        """
        V.GetProjectionPlaneMode() -> int
        C++: virtual int GetProjectionPlaneMode()
        
        Define the method to project the input 3D points into a 2D plane
        for tessellation. When the VTK_XY_PLANE is set, the z-coordinate
        is simply ignored. When VTK_SET_TRANSFORM_PLANE is set, then a
        transform must be supplied and the points are transformed using
        it. Finally, if VTK_BEST_FITTING_PLANE is set, then the filter
        computes a best fitting plane and projects the points onto it.
        """
        ...
    
    def GetProjectionPlaneModeMaxValue(self):
        """
        V.GetProjectionPlaneModeMaxValue() -> int
        C++: virtual int GetProjectionPlaneModeMaxValue()
        
        Define the method to project the input 3D points into a 2D plane
        for tessellation. When the VTK_XY_PLANE is set, the z-coordinate
        is simply ignored. When VTK_SET_TRANSFORM_PLANE is set, then a
        transform must be supplied and the points are transformed using
        it. Finally, if VTK_BEST_FITTING_PLANE is set, then the filter
        computes a best fitting plane and projects the points onto it.
        """
        ...
    
    def GetProjectionPlaneModeMinValue(self):
        """
        V.GetProjectionPlaneModeMinValue() -> int
        C++: virtual int GetProjectionPlaneModeMinValue()
        
        Define the method to project the input 3D points into a 2D plane
        for tessellation. When the VTK_XY_PLANE is set, the z-coordinate
        is simply ignored. When VTK_SET_TRANSFORM_PLANE is set, then a
        transform must be supplied and the points are transformed using
        it. Finally, if VTK_BEST_FITTING_PLANE is set, then the filter
        computes a best fitting plane and projects the points onto it.
        """
        ...
    
    def GetSpheres(self):
        """
        V.GetSpheres() -> vtkSpheres
        C++: virtual vtkSpheres *GetSpheres()
        
        Return the Voronoi flower (a collection of spheres) for the point
        of interest in the form of a vtkSpheres implicit function. This
        is valid only if GenerateVoronoiFlower and the PointOfInterest
        are set, and after the filter executes. Typically this is used
        for debugging or educational purposes.
        """
        ...
    
    def GetTransform(self):
        """
        V.GetTransform() -> vtkAbstractTransform
        C++: virtual vtkAbstractTransform *GetTransform()
        
        Set / get the transform which is applied to points to generate a
        2D problem.  This maps a 3D dataset into a 2D dataset where
        triangulation can be done on the XY plane.  The points are then
        tessellated and the topology of tessellation are used as the
        output topology.  The output points are the original
        (untransformed) points.  The transform can be any subclass of
        vtkAbstractTransform (thus it does not need to be a linear or
        invertible transform).
        """
        ...
    
    def IsA(self, string):
        """
        V.IsA(string) -> int
        C++: vtkTypeBool IsA(const char *type) override;
        
        Standard methods for instantiation, type information, and
        printing.
        """
        ...
    
    def IsTypeOf(self, string):
        """
        V.IsTypeOf(string) -> int
        C++: static vtkTypeBool IsTypeOf(const char *type)
        
        Standard methods for instantiation, type information, and
        printing.
        """
        ...
    
    def NewInstance(self):
        """
        V.NewInstance() -> vtkVoronoi2D
        C++: vtkVoronoi2D *NewInstance()
        
        Standard methods for instantiation, type information, and
        printing.
        """
        ...
    
    def SafeDownCast(self, vtkObjectBase):
        """
        V.SafeDownCast(vtkObjectBase) -> vtkVoronoi2D
        C++: static vtkVoronoi2D *SafeDownCast(vtkObjectBase *o)
        
        Standard methods for instantiation, type information, and
        printing.
        """
        ...
    
    def SetGenerateScalars(self, p_int):
        """
        V.SetGenerateScalars(int)
        C++: virtual void SetGenerateScalars(int _arg)
        
        Indicate whether to create a scalar array as part of the output.
        No scalars; point ids, or execution thread ids may be output. By
        default no scalars are generated.
        """
        ...
    
    def SetGenerateScalarsToNone(self):
        """
        V.SetGenerateScalarsToNone()
        C++: void SetGenerateScalarsToNone()
        
        Indicate whether to create a scalar array as part of the output.
        No scalars; point ids, or execution thread ids may be output. By
        default no scalars are generated.
        """
        ...
    
    def SetGenerateScalarsToPointIds(self):
        """
        V.SetGenerateScalarsToPointIds()
        C++: void SetGenerateScalarsToPointIds()
        
        Indicate whether to create a scalar array as part of the output.
        No scalars; point ids, or execution thread ids may be output. By
        default no scalars are generated.
        """
        ...
    
    def SetGenerateScalarsToThreadIds(self):
        """
        V.SetGenerateScalarsToThreadIds()
        C++: void SetGenerateScalarsToThreadIds()
        
        Indicate whether to create a scalar array as part of the output.
        No scalars; point ids, or execution thread ids may be output. By
        default no scalars are generated.
        """
        ...
    
    def SetGenerateVoronoiFlower(self, p_int):
        """
        V.SetGenerateVoronoiFlower(int)
        C++: virtual void SetGenerateVoronoiFlower(vtkTypeBool _arg)
        
        These methods are for debugging or instructional purposes. If
        GenerateVoronoiFlower is on, and the PointOfIntersect is
        specified, then second and third (optional) outputs are populated
        which contains a representation of the Voronoi flower error
        metric (second output) and the single Voronoi tile (corresponding
        to PointOfInterest) with point scalar values indicating the radii
        of the Voronoi Flower petals (i.e., circles contributing to the
        error metric).
        """
        ...
    
    def SetMaximumNumberOfTileClips(self, p_int):
        """
        V.SetMaximumNumberOfTileClips(int)
        C++: virtual void SetMaximumNumberOfTileClips(vtkIdType _arg)
        
        These methods are for debugging or instructional purposes. When
        the point of interest is specified (i.e., to a non-negative
        number) then the algorithm will only process this single point
        (whose id is the PointOfInterest). The maximum number of clips
        (the MaximumNumberOfTileClips) can be specified. If
        MaximumNumberOfTileClips=0, then the initial tile (single point
        within the bounding box) is produced; if =1 then the split with
        the closest point is produced; and so on. By default the
        PointOfInterest is set to (-1), and the number of clips is
        unlimited (i.e., MaximumNumberOfTileClips=VTK_ID_MAX and
        therefore automatically limited by the algorithm).
        """
        ...
    
    def SetPadding(self, p_float):
        """
        V.SetPadding(float)
        C++: virtual void SetPadding(double _arg)
        
        Specify a padding for the bounding box of the points. A >0
        padding is necessary in order to create valid Voronoi tiles on
        the boundary of the tessellation. The padding is specified as a
        fraction of the diagonal length of the bounding box of the
        points.
        """
        ...
    
    def SetPointOfInterest(self, p_int):
        """
        V.SetPointOfInterest(int)
        C++: virtual void SetPointOfInterest(vtkIdType _arg)
        
        These methods are for debugging or instructional purposes. When
        the point of interest is specified (i.e., to a non-negative
        number) then the algorithm will only process this single point
        (whose id is the PointOfInterest). The maximum number of clips
        (the MaximumNumberOfTileClips) can be specified. If
        MaximumNumberOfTileClips=0, then the initial tile (single point
        within the bounding box) is produced; if =1 then the split with
        the closest point is produced; and so on. By default the
        PointOfInterest is set to (-1), and the number of clips is
        unlimited (i.e., MaximumNumberOfTileClips=VTK_ID_MAX and
        therefore automatically limited by the algorithm).
        """
        ...
    
    def SetProjectionPlaneMode(self, p_int):
        """
        V.SetProjectionPlaneMode(int)
        C++: virtual void SetProjectionPlaneMode(int _arg)
        
        Define the method to project the input 3D points into a 2D plane
        for tessellation. When the VTK_XY_PLANE is set, the z-coordinate
        is simply ignored. When VTK_SET_TRANSFORM_PLANE is set, then a
        transform must be supplied and the points are transformed using
        it. Finally, if VTK_BEST_FITTING_PLANE is set, then the filter
        computes a best fitting plane and projects the points onto it.
        """
        ...
    
    def SetProjectionPlaneModeToBestFittingPlane(self):
        """
        V.SetProjectionPlaneModeToBestFittingPlane()
        C++: void SetProjectionPlaneModeToBestFittingPlane()
        
        Define the method to project the input 3D points into a 2D plane
        for tessellation. When the VTK_XY_PLANE is set, the z-coordinate
        is simply ignored. When VTK_SET_TRANSFORM_PLANE is set, then a
        transform must be supplied and the points are transformed using
        it. Finally, if VTK_BEST_FITTING_PLANE is set, then the filter
        computes a best fitting plane and projects the points onto it.
        """
        ...
    
    def SetProjectionPlaneModeToSpecifiedTransformPlane(self):
        """
        V.SetProjectionPlaneModeToSpecifiedTransformPlane()
        C++: void SetProjectionPlaneModeToSpecifiedTransformPlane()
        
        Define the method to project the input 3D points into a 2D plane
        for tessellation. When the VTK_XY_PLANE is set, the z-coordinate
        is simply ignored. When VTK_SET_TRANSFORM_PLANE is set, then a
        transform must be supplied and the points are transformed using
        it. Finally, if VTK_BEST_FITTING_PLANE is set, then the filter
        computes a best fitting plane and projects the points onto it.
        """
        ...
    
    def SetProjectionPlaneModeToXYPlane(self):
        """
        V.SetProjectionPlaneModeToXYPlane()
        C++: void SetProjectionPlaneModeToXYPlane()
        
        Define the method to project the input 3D points into a 2D plane
        for tessellation. When the VTK_XY_PLANE is set, the z-coordinate
        is simply ignored. When VTK_SET_TRANSFORM_PLANE is set, then a
        transform must be supplied and the points are transformed using
        it. Finally, if VTK_BEST_FITTING_PLANE is set, then the filter
        computes a best fitting plane and projects the points onto it.
        """
        ...
    
    def SetTransform(self, vtkAbstractTransform):
        """
        V.SetTransform(vtkAbstractTransform)
        C++: virtual void SetTransform(vtkAbstractTransform *)
        
        Set / get the transform which is applied to points to generate a
        2D problem.  This maps a 3D dataset into a 2D dataset where
        triangulation can be done on the XY plane.  The points are then
        tessellated and the topology of tessellation are used as the
        output topology.  The output points are the original
        (untransformed) points.  The transform can be any subclass of
        vtkAbstractTransform (thus it does not need to be a linear or
        invertible transform).
        """
        ...
    
    def __delattr__(self, *args, **kwargs):
        """ Implement delattr(self, name). """
        ...
    
    def __getattribute__(self, *args, **kwargs):
        """ Return getattr(self, name). """
        ...
    
    def __init__(self, *args, **kwargs) -> None:
        ...
    
    @staticmethod
    def __new__(*args, **kwargs):
        """ Create and return a new object.  See help(type) for accurate signature. """
        ...
    
    def __repr__(self, *args, **kwargs):
        """ Return repr(self). """
        ...
    
    def __setattr__(self, *args, **kwargs):
        """ Implement setattr(self, name, value). """
        ...
    
    def __str__(self, *args, **kwargs) -> str:
        """ Return str(self). """
        ...
    
    __this__ = ...
    BEST_FITTING_PLANE = ...
    GenerateScalarsStrategy = ...
    NONE = ...
    POINT_IDS = ...
    ProjectionPlaneStrategy = ...
    SPECIFIED_TRANSFORM_PLANE = ...
    THREAD_IDS = ...
    XY_PLANE = ...
    __dict__ = ...
    __vtkname__ = ...


