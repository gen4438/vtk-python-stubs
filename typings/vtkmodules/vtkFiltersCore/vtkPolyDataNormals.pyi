"""
This type stub file was generated by pyright.
"""

import vtkmodules.vtkCommonExecutionModel as __vtkmodules_vtkCommonExecutionModel

class vtkPolyDataNormals(__vtkmodules_vtkCommonExecutionModel.vtkPolyDataAlgorithm):
    """
    vtkPolyDataNormals - compute normals for polygonal mesh
    
    Superclass: vtkPolyDataAlgorithm
    
    vtkPolyDataNormals is a filter that computes point and/or cell
    normals for a polygonal mesh. The user specifies if they would like
    the point and/or cell normals to be computed by setting the
    ComputeCellNormals and ComputePointNormals flags.
    
    The computed normals (a vtkFloatArray) are set to be the active
    normals (using SetNormals()) of the PointData and/or the CellData
    (respectively) of the output PolyData. The name of these arrays is
    "Normals", so they can be retrieved either with
    vtkArrayDownCast(output->GetPointData()->GetNormals()) or with
    vtkArrayDownCast(output->GetPointData()->GetArray("Normals"))
    
    The filter can reorder polygons to insure consistent orientation
    across polygon neighbors. Sharp edges can be split and points
    duplicated with separate normals to give crisp (rendered) surface
    definition. It is also possible to globally flip the normal
    orientation.
    
    The algorithm works by determining normals for each polygon and then
    averaging them at shared points. When sharp edges are present, the
    edges are split and new points generated to prevent blurry edges (due
    to Gouraud shading).
    
    @warning
    Normals are computed only for polygons and triangle strips. Normals
    are not computed for lines or vertices.
    
    @warning
    Triangle strips are broken up into triangle polygons. You may want to
    restrip the triangles.
    
    @sa
    For high-performance rendering, you could use
    vtkTriangleMeshPointNormals if you know that you have a triangle mesh
    which does not require splitting nor consistency check on the cell
    orientations.
    """
    def AutoOrientNormalsOff(self):
        """
        V.AutoOrientNormalsOff()
        C++: virtual void AutoOrientNormalsOff()
        
        Turn on/off the automatic determination of correct normal
        orientation. NOTE: This assumes a completely closed surface (i.e.
        no boundary edges) and no non-manifold edges. If these
        constraints do not hold, all bets are off. This option adds some
        computational complexity, and is useful if you don't want to have
        to inspect the rendered image to determine whether to turn on the
        FlipNormals flag. However, this flag can work with the
        FlipNormals flag, and if both are set, all the normals in the
        output will point "inward".
        """
        ...
    
    def AutoOrientNormalsOn(self):
        """
        V.AutoOrientNormalsOn()
        C++: virtual void AutoOrientNormalsOn()
        
        Turn on/off the automatic determination of correct normal
        orientation. NOTE: This assumes a completely closed surface (i.e.
        no boundary edges) and no non-manifold edges. If these
        constraints do not hold, all bets are off. This option adds some
        computational complexity, and is useful if you don't want to have
        to inspect the rendered image to determine whether to turn on the
        FlipNormals flag. However, this flag can work with the
        FlipNormals flag, and if both are set, all the normals in the
        output will point "inward".
        """
        ...
    
    def ComputeCellNormalsOff(self):
        """
        V.ComputeCellNormalsOff()
        C++: virtual void ComputeCellNormalsOff()
        
        Turn on/off the computation of cell normals.
        """
        ...
    
    def ComputeCellNormalsOn(self):
        """
        V.ComputeCellNormalsOn()
        C++: virtual void ComputeCellNormalsOn()
        
        Turn on/off the computation of cell normals.
        """
        ...
    
    def ComputePointNormalsOff(self):
        """
        V.ComputePointNormalsOff()
        C++: virtual void ComputePointNormalsOff()
        
        Turn on/off the computation of point normals.
        """
        ...
    
    def ComputePointNormalsOn(self):
        """
        V.ComputePointNormalsOn()
        C++: virtual void ComputePointNormalsOn()
        
        Turn on/off the computation of point normals.
        """
        ...
    
    def ConsistencyOff(self):
        """
        V.ConsistencyOff()
        C++: virtual void ConsistencyOff()
        
        Turn on/off the enforcement of consistent polygon ordering.
        """
        ...
    
    def ConsistencyOn(self):
        """
        V.ConsistencyOn()
        C++: virtual void ConsistencyOn()
        
        Turn on/off the enforcement of consistent polygon ordering.
        """
        ...
    
    def FlipNormalsOff(self):
        """
        V.FlipNormalsOff()
        C++: virtual void FlipNormalsOff()
        
        Turn on/off the global flipping of normal orientation. Flipping
        reverves the meaning of front and back for Frontface and Backface
        culling in vtkProperty.  Flipping modifies both the normal
        direction and the order of a cell's points.
        """
        ...
    
    def FlipNormalsOn(self):
        """
        V.FlipNormalsOn()
        C++: virtual void FlipNormalsOn()
        
        Turn on/off the global flipping of normal orientation. Flipping
        reverves the meaning of front and back for Frontface and Backface
        culling in vtkProperty.  Flipping modifies both the normal
        direction and the order of a cell's points.
        """
        ...
    
    def GetAutoOrientNormals(self):
        """
        V.GetAutoOrientNormals() -> int
        C++: virtual vtkTypeBool GetAutoOrientNormals()
        
        Turn on/off the automatic determination of correct normal
        orientation. NOTE: This assumes a completely closed surface (i.e.
        no boundary edges) and no non-manifold edges. If these
        constraints do not hold, all bets are off. This option adds some
        computational complexity, and is useful if you don't want to have
        to inspect the rendered image to determine whether to turn on the
        FlipNormals flag. However, this flag can work with the
        FlipNormals flag, and if both are set, all the normals in the
        output will point "inward".
        """
        ...
    
    def GetComputeCellNormals(self):
        """
        V.GetComputeCellNormals() -> int
        C++: virtual vtkTypeBool GetComputeCellNormals()
        
        Turn on/off the computation of cell normals.
        """
        ...
    
    def GetComputePointNormals(self):
        """
        V.GetComputePointNormals() -> int
        C++: virtual vtkTypeBool GetComputePointNormals()
        
        Turn on/off the computation of point normals.
        """
        ...
    
    def GetConsistency(self):
        """
        V.GetConsistency() -> int
        C++: virtual vtkTypeBool GetConsistency()
        
        Turn on/off the enforcement of consistent polygon ordering.
        """
        ...
    
    def GetFeatureAngle(self):
        """
        V.GetFeatureAngle() -> float
        C++: virtual double GetFeatureAngle()
        
        Specify the angle that defines a sharp edge. If the difference in
        angle across neighboring polygons is greater than this value, the
        shared edge is considered "sharp".
        """
        ...
    
    def GetFeatureAngleMaxValue(self):
        """
        V.GetFeatureAngleMaxValue() -> float
        C++: virtual double GetFeatureAngleMaxValue()
        
        Specify the angle that defines a sharp edge. If the difference in
        angle across neighboring polygons is greater than this value, the
        shared edge is considered "sharp".
        """
        ...
    
    def GetFeatureAngleMinValue(self):
        """
        V.GetFeatureAngleMinValue() -> float
        C++: virtual double GetFeatureAngleMinValue()
        
        Specify the angle that defines a sharp edge. If the difference in
        angle across neighboring polygons is greater than this value, the
        shared edge is considered "sharp".
        """
        ...
    
    def GetFlipNormals(self):
        """
        V.GetFlipNormals() -> int
        C++: virtual vtkTypeBool GetFlipNormals()
        
        Turn on/off the global flipping of normal orientation. Flipping
        reverves the meaning of front and back for Frontface and Backface
        culling in vtkProperty.  Flipping modifies both the normal
        direction and the order of a cell's points.
        """
        ...
    
    def GetNonManifoldTraversal(self):
        """
        V.GetNonManifoldTraversal() -> int
        C++: virtual vtkTypeBool GetNonManifoldTraversal()
        
        Turn on/off traversal across non-manifold edges. This will
        prevent problems where the consistency of polygonal ordering is
        corrupted due to topological loops.
        """
        ...
    
    def GetNumberOfGenerationsFromBase(self, string):
        """
        V.GetNumberOfGenerationsFromBase(string) -> int
        C++: vtkIdType GetNumberOfGenerationsFromBase(const char *type)
            override;
        
        Given a the name of a base class of this class type, return the
        distance of inheritance between this class type and the named
        class (how many generations of inheritance are there between this
        class and the named class). If the named class is not in this
        class's inheritance tree, return a negative value. Valid
        responses will always be nonnegative. This method works in
        combination with vtkTypeMacro found in vtkSetGet.h.
        """
        ...
    
    def GetNumberOfGenerationsFromBaseType(self, string):
        """
        V.GetNumberOfGenerationsFromBaseType(string) -> int
        C++: static vtkIdType GetNumberOfGenerationsFromBaseType(
            const char *type)
        
        Given a the name of a base class of this class type, return the
        distance of inheritance between this class type and the named
        class (how many generations of inheritance are there between this
        class and the named class). If the named class is not in this
        class's inheritance tree, return a negative value. Valid
        responses will always be nonnegative. This method works in
        combination with vtkTypeMacro found in vtkSetGet.h.
        """
        ...
    
    def GetOutputPointsPrecision(self):
        """
        V.GetOutputPointsPrecision() -> int
        C++: virtual int GetOutputPointsPrecision()
        
        Set/get the desired precision for the output types. See the
        documentation for the vtkAlgorithm::DesiredOutputPrecision enum
        for an explanation of the available precision settings.
        """
        ...
    
    def GetOutputPointsPrecisionMaxValue(self):
        """
        V.GetOutputPointsPrecisionMaxValue() -> int
        C++: virtual int GetOutputPointsPrecisionMaxValue()
        
        Set/get the desired precision for the output types. See the
        documentation for the vtkAlgorithm::DesiredOutputPrecision enum
        for an explanation of the available precision settings.
        """
        ...
    
    def GetOutputPointsPrecisionMinValue(self):
        """
        V.GetOutputPointsPrecisionMinValue() -> int
        C++: virtual int GetOutputPointsPrecisionMinValue()
        
        Set/get the desired precision for the output types. See the
        documentation for the vtkAlgorithm::DesiredOutputPrecision enum
        for an explanation of the available precision settings.
        """
        ...
    
    def GetSplitting(self):
        """
        V.GetSplitting() -> int
        C++: virtual vtkTypeBool GetSplitting()
        
        Turn on/off the splitting of sharp edges.
        """
        ...
    
    def IsA(self, string):
        """
        V.IsA(string) -> int
        C++: vtkTypeBool IsA(const char *type) override;
        
        Return 1 if this class is the same type of (or a subclass of) the
        named class. Returns 0 otherwise. This method works in
        combination with vtkTypeMacro found in vtkSetGet.h.
        """
        ...
    
    def IsTypeOf(self, string):
        """
        V.IsTypeOf(string) -> int
        C++: static vtkTypeBool IsTypeOf(const char *type)
        
        Return 1 if this class type is the same type of (or a subclass
        of) the named class. Returns 0 otherwise. This method works in
        combination with vtkTypeMacro found in vtkSetGet.h.
        """
        ...
    
    def NewInstance(self):
        """
        V.NewInstance() -> vtkPolyDataNormals
        C++: vtkPolyDataNormals *NewInstance()
        """
        ...
    
    def NonManifoldTraversalOff(self):
        """
        V.NonManifoldTraversalOff()
        C++: virtual void NonManifoldTraversalOff()
        
        Turn on/off traversal across non-manifold edges. This will
        prevent problems where the consistency of polygonal ordering is
        corrupted due to topological loops.
        """
        ...
    
    def NonManifoldTraversalOn(self):
        """
        V.NonManifoldTraversalOn()
        C++: virtual void NonManifoldTraversalOn()
        
        Turn on/off traversal across non-manifold edges. This will
        prevent problems where the consistency of polygonal ordering is
        corrupted due to topological loops.
        """
        ...
    
    def SafeDownCast(self, vtkObjectBase):
        """
        V.SafeDownCast(vtkObjectBase) -> vtkPolyDataNormals
        C++: static vtkPolyDataNormals *SafeDownCast(vtkObjectBase *o)
        """
        ...
    
    def SetAutoOrientNormals(self, p_int):
        """
        V.SetAutoOrientNormals(int)
        C++: virtual void SetAutoOrientNormals(vtkTypeBool _arg)
        
        Turn on/off the automatic determination of correct normal
        orientation. NOTE: This assumes a completely closed surface (i.e.
        no boundary edges) and no non-manifold edges. If these
        constraints do not hold, all bets are off. This option adds some
        computational complexity, and is useful if you don't want to have
        to inspect the rendered image to determine whether to turn on the
        FlipNormals flag. However, this flag can work with the
        FlipNormals flag, and if both are set, all the normals in the
        output will point "inward".
        """
        ...
    
    def SetComputeCellNormals(self, p_int):
        """
        V.SetComputeCellNormals(int)
        C++: virtual void SetComputeCellNormals(vtkTypeBool _arg)
        
        Turn on/off the computation of cell normals.
        """
        ...
    
    def SetComputePointNormals(self, p_int):
        """
        V.SetComputePointNormals(int)
        C++: virtual void SetComputePointNormals(vtkTypeBool _arg)
        
        Turn on/off the computation of point normals.
        """
        ...
    
    def SetConsistency(self, p_int):
        """
        V.SetConsistency(int)
        C++: virtual void SetConsistency(vtkTypeBool _arg)
        
        Turn on/off the enforcement of consistent polygon ordering.
        """
        ...
    
    def SetFeatureAngle(self, p_float):
        """
        V.SetFeatureAngle(float)
        C++: virtual void SetFeatureAngle(double _arg)
        
        Specify the angle that defines a sharp edge. If the difference in
        angle across neighboring polygons is greater than this value, the
        shared edge is considered "sharp".
        """
        ...
    
    def SetFlipNormals(self, p_int):
        """
        V.SetFlipNormals(int)
        C++: virtual void SetFlipNormals(vtkTypeBool _arg)
        
        Turn on/off the global flipping of normal orientation. Flipping
        reverves the meaning of front and back for Frontface and Backface
        culling in vtkProperty.  Flipping modifies both the normal
        direction and the order of a cell's points.
        """
        ...
    
    def SetNonManifoldTraversal(self, p_int):
        """
        V.SetNonManifoldTraversal(int)
        C++: virtual void SetNonManifoldTraversal(vtkTypeBool _arg)
        
        Turn on/off traversal across non-manifold edges. This will
        prevent problems where the consistency of polygonal ordering is
        corrupted due to topological loops.
        """
        ...
    
    def SetOutputPointsPrecision(self, p_int):
        """
        V.SetOutputPointsPrecision(int)
        C++: virtual void SetOutputPointsPrecision(int _arg)
        
        Set/get the desired precision for the output types. See the
        documentation for the vtkAlgorithm::DesiredOutputPrecision enum
        for an explanation of the available precision settings.
        """
        ...
    
    def SetSplitting(self, p_int):
        """
        V.SetSplitting(int)
        C++: virtual void SetSplitting(vtkTypeBool _arg)
        
        Turn on/off the splitting of sharp edges.
        """
        ...
    
    def SplittingOff(self):
        """
        V.SplittingOff()
        C++: virtual void SplittingOff()
        
        Turn on/off the splitting of sharp edges.
        """
        ...
    
    def SplittingOn(self):
        """
        V.SplittingOn()
        C++: virtual void SplittingOn()
        
        Turn on/off the splitting of sharp edges.
        """
        ...
    
    def __delattr__(self, *args, **kwargs):
        """ Implement delattr(self, name). """
        ...
    
    def __getattribute__(self, *args, **kwargs):
        """ Return getattr(self, name). """
        ...
    
    def __init__(self, *args, **kwargs) -> None:
        ...
    
    @staticmethod
    def __new__(*args, **kwargs):
        """ Create and return a new object.  See help(type) for accurate signature. """
        ...
    
    def __repr__(self, *args, **kwargs):
        """ Return repr(self). """
        ...
    
    def __setattr__(self, *args, **kwargs):
        """ Implement setattr(self, name, value). """
        ...
    
    def __str__(self, *args, **kwargs) -> str:
        """ Return str(self). """
        ...
    
    __this__ = ...
    __dict__ = ...
    __vtkname__ = ...


