"""
This type stub file was generated by pyright.
"""

import vtkmodules.vtkCommonExecutionModel as __vtkmodules_vtkCommonExecutionModel

class vtkMaskPoints(__vtkmodules_vtkCommonExecutionModel.vtkPolyDataAlgorithm):
    """
    vtkMaskPoints - selectively filter points
    
    Superclass: vtkPolyDataAlgorithm
    
    vtkMaskPoints is a filter that passes through points and point
    attributes from input dataset. (Other geometry is not passed
    through.) It is possible to mask every nth point, and to specify an
    initial offset to begin masking from. It is possible to also generate
    different random selections (jittered strides, real random samples,
    and spatially stratified random samples) from the input data. The
    filter can also generate vertices (topological primitives) as well as
    points. This is useful because vertices are rendered while points are
    not.
    """
    def GenerateVerticesOff(self):
        """
        V.GenerateVerticesOff()
        C++: virtual void GenerateVerticesOff()
        
        Generate output polydata vertices as well as points. A useful
        convenience method because vertices are drawn (they are topology)
        while points are not (they are geometry). By default this method
        is off.
        """
        ...
    
    def GenerateVerticesOn(self):
        """
        V.GenerateVerticesOn()
        C++: virtual void GenerateVerticesOn()
        
        Generate output polydata vertices as well as points. A useful
        convenience method because vertices are drawn (they are topology)
        while points are not (they are geometry). By default this method
        is off.
        """
        ...
    
    def GetGenerateVertices(self):
        """
        V.GetGenerateVertices() -> int
        C++: virtual vtkTypeBool GetGenerateVertices()
        
        Generate output polydata vertices as well as points. A useful
        convenience method because vertices are drawn (they are topology)
        while points are not (they are geometry). By default this method
        is off.
        """
        ...
    
    def GetMaximumNumberOfPoints(self):
        """
        V.GetMaximumNumberOfPoints() -> int
        C++: virtual vtkIdType GetMaximumNumberOfPoints()
        
        Limit the number of points that can be passed through (i.e., sets
        the output sample size).
        """
        ...
    
    def GetMaximumNumberOfPointsMaxValue(self):
        """
        V.GetMaximumNumberOfPointsMaxValue() -> int
        C++: virtual vtkIdType GetMaximumNumberOfPointsMaxValue()
        
        Limit the number of points that can be passed through (i.e., sets
        the output sample size).
        """
        ...
    
    def GetMaximumNumberOfPointsMinValue(self):
        """
        V.GetMaximumNumberOfPointsMinValue() -> int
        C++: virtual vtkIdType GetMaximumNumberOfPointsMinValue()
        
        Limit the number of points that can be passed through (i.e., sets
        the output sample size).
        """
        ...
    
    def GetNumberOfGenerationsFromBase(self, string):
        """
        V.GetNumberOfGenerationsFromBase(string) -> int
        C++: vtkIdType GetNumberOfGenerationsFromBase(const char *type)
            override;
        
        Given a the name of a base class of this class type, return the
        distance of inheritance between this class type and the named
        class (how many generations of inheritance are there between this
        class and the named class). If the named class is not in this
        class's inheritance tree, return a negative value. Valid
        responses will always be nonnegative. This method works in
        combination with vtkTypeMacro found in vtkSetGet.h.
        """
        ...
    
    def GetNumberOfGenerationsFromBaseType(self, string):
        """
        V.GetNumberOfGenerationsFromBaseType(string) -> int
        C++: static vtkIdType GetNumberOfGenerationsFromBaseType(
            const char *type)
        
        Given a the name of a base class of this class type, return the
        distance of inheritance between this class type and the named
        class (how many generations of inheritance are there between this
        class and the named class). If the named class is not in this
        class's inheritance tree, return a negative value. Valid
        responses will always be nonnegative. This method works in
        combination with vtkTypeMacro found in vtkSetGet.h.
        """
        ...
    
    def GetOffset(self):
        """
        V.GetOffset() -> int
        C++: virtual vtkIdType GetOffset()
        
        Start sampling with this point. Ignored by certain random modes.
        """
        ...
    
    def GetOffsetMaxValue(self):
        """
        V.GetOffsetMaxValue() -> int
        C++: virtual vtkIdType GetOffsetMaxValue()
        
        Start sampling with this point. Ignored by certain random modes.
        """
        ...
    
    def GetOffsetMinValue(self):
        """
        V.GetOffsetMinValue() -> int
        C++: virtual vtkIdType GetOffsetMinValue()
        
        Start sampling with this point. Ignored by certain random modes.
        """
        ...
    
    def GetOnRatio(self):
        """
        V.GetOnRatio() -> int
        C++: virtual int GetOnRatio()
        
        Turn on every nth point (strided sampling), ignored by random
        modes.
        """
        ...
    
    def GetOnRatioMaxValue(self):
        """
        V.GetOnRatioMaxValue() -> int
        C++: virtual int GetOnRatioMaxValue()
        
        Turn on every nth point (strided sampling), ignored by random
        modes.
        """
        ...
    
    def GetOnRatioMinValue(self):
        """
        V.GetOnRatioMinValue() -> int
        C++: virtual int GetOnRatioMinValue()
        
        Turn on every nth point (strided sampling), ignored by random
        modes.
        """
        ...
    
    def GetOutputPointsPrecision(self):
        """
        V.GetOutputPointsPrecision() -> int
        C++: virtual int GetOutputPointsPrecision()
        
        Set/get the desired precision for the output types. See the
        documentation for the vtkAlgorithm::DesiredOutputPrecision enum
        for an explanation of the available precision settings.
        """
        ...
    
    def GetProportionalMaximumNumberOfPoints(self):
        """
        V.GetProportionalMaximumNumberOfPoints() -> int
        C++: virtual vtkTypeBool GetProportionalMaximumNumberOfPoints()
        
        THIS ONLY WORKS WITH THE PARALLEL IMPLEMENTATION vtkPMaskPoints
        RUNNING IN PARALLEL. NOTHING WILL CHANGE IF THIS IS NOT THE
        PARALLEL vtkPMaskPoints. Determines whether maximum number of
        points is taken per processor (default) or if the maximum number
        of points is proportionally taken across processors (i.e., number
        of points per processor = points on a processor * maximum number
        of points / total points across all processors).  In the first
        case, the total number of points = maximum number of points *
        number of processors.  In the second case, the total number of
        points = maximum number of points.
        """
        ...
    
    def GetRandomMode(self):
        """
        V.GetRandomMode() -> int
        C++: virtual vtkTypeBool GetRandomMode()
        
        Special flag causes randomization of point selection.
        """
        ...
    
    def GetRandomModeType(self):
        """
        V.GetRandomModeType() -> int
        C++: virtual int GetRandomModeType()
        
        Special mode selector that switches between random mode types. 0
        - randomized strides: randomly strides through the data
        (default); fairly certain that this is not a statistically random
        sample because the output depends on the order of the input and
        the input points do not have an equal chance to appear in the
        output (plus Vitter's incremental random algorithms are more
        complex than this, while not a proof it is good indication this
        isn't a statistically random sample - the closest would be
        algorithm S) 1 - random sample: create a statistically random
        sample using Vitter's incremental algorithm D without A described
        in Vitter "Faster Mthods for Random Sampling", Communications of
        the ACM Volume 27, Issue 7, 1984 (OnRatio and Offset are ignored)
        O(sample size) 2 - spatially stratified random sample: create a
        spatially stratified random sample using the first method
        described in Woodring et al. "In-situ Sampling of a Large-Scale
        Particle Simulation for Interactive Visualization and Analysis",
        Computer Graphics Forum, 2011 (EuroVis 2011). (OnRatio and Offset
        are ignored) O(N log N)
        """
        ...
    
    def GetRandomModeTypeMaxValue(self):
        """
        V.GetRandomModeTypeMaxValue() -> int
        C++: virtual int GetRandomModeTypeMaxValue()
        
        Special mode selector that switches between random mode types. 0
        - randomized strides: randomly strides through the data
        (default); fairly certain that this is not a statistically random
        sample because the output depends on the order of the input and
        the input points do not have an equal chance to appear in the
        output (plus Vitter's incremental random algorithms are more
        complex than this, while not a proof it is good indication this
        isn't a statistically random sample - the closest would be
        algorithm S) 1 - random sample: create a statistically random
        sample using Vitter's incremental algorithm D without A described
        in Vitter "Faster Mthods for Random Sampling", Communications of
        the ACM Volume 27, Issue 7, 1984 (OnRatio and Offset are ignored)
        O(sample size) 2 - spatially stratified random sample: create a
        spatially stratified random sample using the first method
        described in Woodring et al. "In-situ Sampling of a Large-Scale
        Particle Simulation for Interactive Visualization and Analysis",
        Computer Graphics Forum, 2011 (EuroVis 2011). (OnRatio and Offset
        are ignored) O(N log N)
        """
        ...
    
    def GetRandomModeTypeMinValue(self):
        """
        V.GetRandomModeTypeMinValue() -> int
        C++: virtual int GetRandomModeTypeMinValue()
        
        Special mode selector that switches between random mode types. 0
        - randomized strides: randomly strides through the data
        (default); fairly certain that this is not a statistically random
        sample because the output depends on the order of the input and
        the input points do not have an equal chance to appear in the
        output (plus Vitter's incremental random algorithms are more
        complex than this, while not a proof it is good indication this
        isn't a statistically random sample - the closest would be
        algorithm S) 1 - random sample: create a statistically random
        sample using Vitter's incremental algorithm D without A described
        in Vitter "Faster Mthods for Random Sampling", Communications of
        the ACM Volume 27, Issue 7, 1984 (OnRatio and Offset are ignored)
        O(sample size) 2 - spatially stratified random sample: create a
        spatially stratified random sample using the first method
        described in Woodring et al. "In-situ Sampling of a Large-Scale
        Particle Simulation for Interactive Visualization and Analysis",
        Computer Graphics Forum, 2011 (EuroVis 2011). (OnRatio and Offset
        are ignored) O(N log N)
        """
        ...
    
    def GetSingleVertexPerCell(self):
        """
        V.GetSingleVertexPerCell() -> int
        C++: virtual vtkTypeBool GetSingleVertexPerCell()
        
        When vertex generation is enabled, by default vertices are
        produced as multi-vertex cells (more than one per cell), if you
        wish to have a single vertex per cell, enable this flag.
        """
        ...
    
    def IsA(self, string):
        """
        V.IsA(string) -> int
        C++: vtkTypeBool IsA(const char *type) override;
        
        Return 1 if this class is the same type of (or a subclass of) the
        named class. Returns 0 otherwise. This method works in
        combination with vtkTypeMacro found in vtkSetGet.h.
        """
        ...
    
    def IsTypeOf(self, string):
        """
        V.IsTypeOf(string) -> int
        C++: static vtkTypeBool IsTypeOf(const char *type)
        
        Return 1 if this class type is the same type of (or a subclass
        of) the named class. Returns 0 otherwise. This method works in
        combination with vtkTypeMacro found in vtkSetGet.h.
        """
        ...
    
    def NewInstance(self):
        """
        V.NewInstance() -> vtkMaskPoints
        C++: vtkMaskPoints *NewInstance()
        """
        ...
    
    def ProportionalMaximumNumberOfPointsOff(self):
        """
        V.ProportionalMaximumNumberOfPointsOff()
        C++: virtual void ProportionalMaximumNumberOfPointsOff()
        
        THIS ONLY WORKS WITH THE PARALLEL IMPLEMENTATION vtkPMaskPoints
        RUNNING IN PARALLEL. NOTHING WILL CHANGE IF THIS IS NOT THE
        PARALLEL vtkPMaskPoints. Determines whether maximum number of
        points is taken per processor (default) or if the maximum number
        of points is proportionally taken across processors (i.e., number
        of points per processor = points on a processor * maximum number
        of points / total points across all processors).  In the first
        case, the total number of points = maximum number of points *
        number of processors.  In the second case, the total number of
        points = maximum number of points.
        """
        ...
    
    def ProportionalMaximumNumberOfPointsOn(self):
        """
        V.ProportionalMaximumNumberOfPointsOn()
        C++: virtual void ProportionalMaximumNumberOfPointsOn()
        
        THIS ONLY WORKS WITH THE PARALLEL IMPLEMENTATION vtkPMaskPoints
        RUNNING IN PARALLEL. NOTHING WILL CHANGE IF THIS IS NOT THE
        PARALLEL vtkPMaskPoints. Determines whether maximum number of
        points is taken per processor (default) or if the maximum number
        of points is proportionally taken across processors (i.e., number
        of points per processor = points on a processor * maximum number
        of points / total points across all processors).  In the first
        case, the total number of points = maximum number of points *
        number of processors.  In the second case, the total number of
        points = maximum number of points.
        """
        ...
    
    def RandomModeOff(self):
        """
        V.RandomModeOff()
        C++: virtual void RandomModeOff()
        
        Special flag causes randomization of point selection.
        """
        ...
    
    def RandomModeOn(self):
        """
        V.RandomModeOn()
        C++: virtual void RandomModeOn()
        
        Special flag causes randomization of point selection.
        """
        ...
    
    def SafeDownCast(self, vtkObjectBase):
        """
        V.SafeDownCast(vtkObjectBase) -> vtkMaskPoints
        C++: static vtkMaskPoints *SafeDownCast(vtkObjectBase *o)
        """
        ...
    
    def SetGenerateVertices(self, p_int):
        """
        V.SetGenerateVertices(int)
        C++: virtual void SetGenerateVertices(vtkTypeBool _arg)
        
        Generate output polydata vertices as well as points. A useful
        convenience method because vertices are drawn (they are topology)
        while points are not (they are geometry). By default this method
        is off.
        """
        ...
    
    def SetMaximumNumberOfPoints(self, p_int):
        """
        V.SetMaximumNumberOfPoints(int)
        C++: virtual void SetMaximumNumberOfPoints(vtkIdType _arg)
        
        Limit the number of points that can be passed through (i.e., sets
        the output sample size).
        """
        ...
    
    def SetOffset(self, p_int):
        """
        V.SetOffset(int)
        C++: virtual void SetOffset(vtkIdType _arg)
        
        Start sampling with this point. Ignored by certain random modes.
        """
        ...
    
    def SetOnRatio(self, p_int):
        """
        V.SetOnRatio(int)
        C++: virtual void SetOnRatio(int _arg)
        
        Turn on every nth point (strided sampling), ignored by random
        modes.
        """
        ...
    
    def SetOutputPointsPrecision(self, p_int):
        """
        V.SetOutputPointsPrecision(int)
        C++: virtual void SetOutputPointsPrecision(int _arg)
        
        Set/get the desired precision for the output types. See the
        documentation for the vtkAlgorithm::DesiredOutputPrecision enum
        for an explanation of the available precision settings.
        """
        ...
    
    def SetProportionalMaximumNumberOfPoints(self, p_int):
        """
        V.SetProportionalMaximumNumberOfPoints(int)
        C++: virtual void SetProportionalMaximumNumberOfPoints(
            vtkTypeBool _arg)
        
        THIS ONLY WORKS WITH THE PARALLEL IMPLEMENTATION vtkPMaskPoints
        RUNNING IN PARALLEL. NOTHING WILL CHANGE IF THIS IS NOT THE
        PARALLEL vtkPMaskPoints. Determines whether maximum number of
        points is taken per processor (default) or if the maximum number
        of points is proportionally taken across processors (i.e., number
        of points per processor = points on a processor * maximum number
        of points / total points across all processors).  In the first
        case, the total number of points = maximum number of points *
        number of processors.  In the second case, the total number of
        points = maximum number of points.
        """
        ...
    
    def SetRandomMode(self, p_int):
        """
        V.SetRandomMode(int)
        C++: virtual void SetRandomMode(vtkTypeBool _arg)
        
        Special flag causes randomization of point selection.
        """
        ...
    
    def SetRandomModeType(self, p_int):
        """
        V.SetRandomModeType(int)
        C++: virtual void SetRandomModeType(int _arg)
        
        Special mode selector that switches between random mode types. 0
        - randomized strides: randomly strides through the data
        (default); fairly certain that this is not a statistically random
        sample because the output depends on the order of the input and
        the input points do not have an equal chance to appear in the
        output (plus Vitter's incremental random algorithms are more
        complex than this, while not a proof it is good indication this
        isn't a statistically random sample - the closest would be
        algorithm S) 1 - random sample: create a statistically random
        sample using Vitter's incremental algorithm D without A described
        in Vitter "Faster Mthods for Random Sampling", Communications of
        the ACM Volume 27, Issue 7, 1984 (OnRatio and Offset are ignored)
        O(sample size) 2 - spatially stratified random sample: create a
        spatially stratified random sample using the first method
        described in Woodring et al. "In-situ Sampling of a Large-Scale
        Particle Simulation for Interactive Visualization and Analysis",
        Computer Graphics Forum, 2011 (EuroVis 2011). (OnRatio and Offset
        are ignored) O(N log N)
        """
        ...
    
    def SetSingleVertexPerCell(self, p_int):
        """
        V.SetSingleVertexPerCell(int)
        C++: virtual void SetSingleVertexPerCell(vtkTypeBool _arg)
        
        When vertex generation is enabled, by default vertices are
        produced as multi-vertex cells (more than one per cell), if you
        wish to have a single vertex per cell, enable this flag.
        """
        ...
    
    def SingleVertexPerCellOff(self):
        """
        V.SingleVertexPerCellOff()
        C++: virtual void SingleVertexPerCellOff()
        
        When vertex generation is enabled, by default vertices are
        produced as multi-vertex cells (more than one per cell), if you
        wish to have a single vertex per cell, enable this flag.
        """
        ...
    
    def SingleVertexPerCellOn(self):
        """
        V.SingleVertexPerCellOn()
        C++: virtual void SingleVertexPerCellOn()
        
        When vertex generation is enabled, by default vertices are
        produced as multi-vertex cells (more than one per cell), if you
        wish to have a single vertex per cell, enable this flag.
        """
        ...
    
    def __delattr__(self, *args, **kwargs):
        """ Implement delattr(self, name). """
        ...
    
    def __getattribute__(self, *args, **kwargs):
        """ Return getattr(self, name). """
        ...
    
    def __init__(self, *args, **kwargs) -> None:
        ...
    
    @staticmethod
    def __new__(*args, **kwargs):
        """ Create and return a new object.  See help(type) for accurate signature. """
        ...
    
    def __repr__(self, *args, **kwargs):
        """ Return repr(self). """
        ...
    
    def __setattr__(self, *args, **kwargs):
        """ Implement setattr(self, name, value). """
        ...
    
    def __str__(self, *args, **kwargs) -> str:
        """ Return str(self). """
        ...
    
    __this__ = ...
    __dict__ = ...
    __vtkname__ = ...


