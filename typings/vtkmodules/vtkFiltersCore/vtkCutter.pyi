"""
This type stub file was generated by pyright.
"""

import vtkmodules.vtkCommonExecutionModel as __vtkmodules_vtkCommonExecutionModel

class vtkCutter(__vtkmodules_vtkCommonExecutionModel.vtkPolyDataAlgorithm):
    """
    vtkCutter - Cut vtkDataSet with user-specified implicit function
    
    Superclass: vtkPolyDataAlgorithm
    
    vtkCutter is a filter to cut through data using any subclass of
    vtkImplicitFunction. That is, a polygonal surface is created
    corresponding to the implicit function F(x,y,z) = value(s), where you
    can specify one or more values used to cut with.
    
    In VTK, cutting means reducing a cell of dimension N to a cut surface
    of dimension N-1. For example, a tetrahedron when cut by a plane
    (i.e., vtkPlane implicit function) will generate triangles. (In
    comparison, clipping takes a N dimensional cell and creates N
    dimension primitives.)
    
    vtkCutter is generally used to "slice-through" a dataset, generating
    a surface that can be visualized. It is also possible to use
    vtkCutter to do a form of volume rendering. vtkCutter does this by
    generating multiple cut surfaces (usually planes) which are ordered
    (and rendered) from back-to-front. The surfaces are set translucent
    to give a volumetric rendering effect.
    
    Note that data can be cut using either 1) the scalar values
    associated with the dataset or 2) an implicit function associated
    with this class. By default, if an implicit function is set it is
    used to clip the data set, otherwise the dataset scalars are used to
    perform the clipping.
    
    @sa
    vtkImplicitFunction vtkClipPolyData
    """
    def CreateDefaultLocator(self):
        """
        V.CreateDefaultLocator()
        C++: void CreateDefaultLocator()
        
        Create default locator. Used to create one when none is
        specified. The locator is used to merge coincident points.
        """
        ...
    
    def GenerateCutScalarsOff(self):
        """
        V.GenerateCutScalarsOff()
        C++: virtual void GenerateCutScalarsOff()
        
        If this flag is enabled, then the output scalar values will be
        interpolated from the implicit function values, and not the input
        scalar data.
        """
        ...
    
    def GenerateCutScalarsOn(self):
        """
        V.GenerateCutScalarsOn()
        C++: virtual void GenerateCutScalarsOn()
        
        If this flag is enabled, then the output scalar values will be
        interpolated from the implicit function values, and not the input
        scalar data.
        """
        ...
    
    def GenerateTrianglesOff(self):
        """
        V.GenerateTrianglesOff()
        C++: virtual void GenerateTrianglesOff()
        
        If this is enabled (by default), the output will be triangles
        otherwise, the output will be the intersection polygons WARNING:
        if the cutting function is not a plane, the output will be 3D
        poygons, which might be nice to look at but hard to compute with
        downstream.
        """
        ...
    
    def GenerateTrianglesOn(self):
        """
        V.GenerateTrianglesOn()
        C++: virtual void GenerateTrianglesOn()
        
        If this is enabled (by default), the output will be triangles
        otherwise, the output will be the intersection polygons WARNING:
        if the cutting function is not a plane, the output will be 3D
        poygons, which might be nice to look at but hard to compute with
        downstream.
        """
        ...
    
    def GenerateValues(self, p_int, p_float=..., p_float=...):
        """
        V.GenerateValues(int, [float, float])
        C++: void GenerateValues(int numContours, double range[2])
        V.GenerateValues(int, float, float)
        C++: void GenerateValues(int numContours, double rangeStart,
            double rangeEnd)
        
        Generate numContours equally spaced contour values between
        specified range. Contour values will include min/max range
        values.
        """
        ...
    
    def GetCellTypeDimensions(self, *int):
        """
        V.GetCellTypeDimensions([int, ...])
        C++: static void GetCellTypeDimensions(
            unsigned char *cellTypeDimensions)
        
        Normally I would put this in a different class, but since This is
        a temporary fix until we convert this class and contour filter to
        generate unstructured grid output instead of poly data, I am
        leaving it here.
        """
        ...
    
    def GetCutFunction(self):
        """
        V.GetCutFunction() -> vtkImplicitFunction
        C++: virtual vtkImplicitFunction *GetCutFunction()
        
        Specify the implicit function to perform the cutting.
        """
        ...
    
    def GetGenerateCutScalars(self):
        """
        V.GetGenerateCutScalars() -> int
        C++: virtual vtkTypeBool GetGenerateCutScalars()
        
        If this flag is enabled, then the output scalar values will be
        interpolated from the implicit function values, and not the input
        scalar data.
        """
        ...
    
    def GetGenerateTriangles(self):
        """
        V.GetGenerateTriangles() -> int
        C++: virtual vtkTypeBool GetGenerateTriangles()
        
        If this is enabled (by default), the output will be triangles
        otherwise, the output will be the intersection polygons WARNING:
        if the cutting function is not a plane, the output will be 3D
        poygons, which might be nice to look at but hard to compute with
        downstream.
        """
        ...
    
    def GetLocator(self):
        """
        V.GetLocator() -> vtkIncrementalPointLocator
        C++: virtual vtkIncrementalPointLocator *GetLocator()
        
        Specify a spatial locator for merging points. By default, an
        instance of vtkMergePoints is used.
        """
        ...
    
    def GetMTime(self):
        """
        V.GetMTime() -> int
        C++: vtkMTimeType GetMTime() override;
        
        Override GetMTime because we delegate to vtkContourValues and
        refer to vtkImplicitFunction.
        """
        ...
    
    def GetNumberOfContours(self):
        """
        V.GetNumberOfContours() -> int
        C++: vtkIdType GetNumberOfContours()
        
        Get the number of contours in the list of contour values.
        """
        ...
    
    def GetNumberOfGenerationsFromBase(self, string):
        """
        V.GetNumberOfGenerationsFromBase(string) -> int
        C++: vtkIdType GetNumberOfGenerationsFromBase(const char *type)
            override;
        
        Given a the name of a base class of this class type, return the
        distance of inheritance between this class type and the named
        class (how many generations of inheritance are there between this
        class and the named class). If the named class is not in this
        class's inheritance tree, return a negative value. Valid
        responses will always be nonnegative. This method works in
        combination with vtkTypeMacro found in vtkSetGet.h.
        """
        ...
    
    def GetNumberOfGenerationsFromBaseType(self, string):
        """
        V.GetNumberOfGenerationsFromBaseType(string) -> int
        C++: static vtkIdType GetNumberOfGenerationsFromBaseType(
            const char *type)
        
        Given a the name of a base class of this class type, return the
        distance of inheritance between this class type and the named
        class (how many generations of inheritance are there between this
        class and the named class). If the named class is not in this
        class's inheritance tree, return a negative value. Valid
        responses will always be nonnegative. This method works in
        combination with vtkTypeMacro found in vtkSetGet.h.
        """
        ...
    
    def GetOutputPointsPrecision(self):
        """
        V.GetOutputPointsPrecision() -> int
        C++: virtual int GetOutputPointsPrecision()
        
        Set/get the desired precision for the output types. See the
        documentation for the vtkAlgorithm::DesiredOutputPrecision enum
        for an explanation of the available precision settings.
        """
        ...
    
    def GetOutputPointsPrecisionMaxValue(self):
        """
        V.GetOutputPointsPrecisionMaxValue() -> int
        C++: virtual int GetOutputPointsPrecisionMaxValue()
        
        Set/get the desired precision for the output types. See the
        documentation for the vtkAlgorithm::DesiredOutputPrecision enum
        for an explanation of the available precision settings.
        """
        ...
    
    def GetOutputPointsPrecisionMinValue(self):
        """
        V.GetOutputPointsPrecisionMinValue() -> int
        C++: virtual int GetOutputPointsPrecisionMinValue()
        
        Set/get the desired precision for the output types. See the
        documentation for the vtkAlgorithm::DesiredOutputPrecision enum
        for an explanation of the available precision settings.
        """
        ...
    
    def GetSortBy(self):
        """
        V.GetSortBy() -> int
        C++: virtual int GetSortBy()
        
        Set the sorting order for the generated polydata. There are two
        possibilities: Sort by value = 0 - This is the most efficient
        sort. For each cell, all contour values are processed. This is
        the default. Sort by cell = 1 - For each contour value, all cells
        are processed. This order should be used if the extracted
        polygons must be rendered in a back-to-front or front-to-back
        order. This is very problem dependent. For most applications, the
        default order is fine (and faster).
        
        * Sort by cell is going to have a problem if the input has 2D and
        3D cells.
        * Cell data will be scrambled because with
        * vtkPolyData output, verts and lines have lower cell ids than
          triangles.
        """
        ...
    
    def GetSortByAsString(self):
        """
        V.GetSortByAsString() -> string
        C++: const char *GetSortByAsString()
        
        Set the sorting order for the generated polydata. There are two
        possibilities: Sort by value = 0 - This is the most efficient
        sort. For each cell, all contour values are processed. This is
        the default. Sort by cell = 1 - For each contour value, all cells
        are processed. This order should be used if the extracted
        polygons must be rendered in a back-to-front or front-to-back
        order. This is very problem dependent. For most applications, the
        default order is fine (and faster).
        
        * Sort by cell is going to have a problem if the input has 2D and
        3D cells.
        * Cell data will be scrambled because with
        * vtkPolyData output, verts and lines have lower cell ids than
          triangles.
        """
        ...
    
    def GetSortByMaxValue(self):
        """
        V.GetSortByMaxValue() -> int
        C++: virtual int GetSortByMaxValue()
        
        Set the sorting order for the generated polydata. There are two
        possibilities: Sort by value = 0 - This is the most efficient
        sort. For each cell, all contour values are processed. This is
        the default. Sort by cell = 1 - For each contour value, all cells
        are processed. This order should be used if the extracted
        polygons must be rendered in a back-to-front or front-to-back
        order. This is very problem dependent. For most applications, the
        default order is fine (and faster).
        
        * Sort by cell is going to have a problem if the input has 2D and
        3D cells.
        * Cell data will be scrambled because with
        * vtkPolyData output, verts and lines have lower cell ids than
          triangles.
        """
        ...
    
    def GetSortByMinValue(self):
        """
        V.GetSortByMinValue() -> int
        C++: virtual int GetSortByMinValue()
        
        Set the sorting order for the generated polydata. There are two
        possibilities: Sort by value = 0 - This is the most efficient
        sort. For each cell, all contour values are processed. This is
        the default. Sort by cell = 1 - For each contour value, all cells
        are processed. This order should be used if the extracted
        polygons must be rendered in a back-to-front or front-to-back
        order. This is very problem dependent. For most applications, the
        default order is fine (and faster).
        
        * Sort by cell is going to have a problem if the input has 2D and
        3D cells.
        * Cell data will be scrambled because with
        * vtkPolyData output, verts and lines have lower cell ids than
          triangles.
        """
        ...
    
    def GetValue(self, p_int):
        """
        V.GetValue(int) -> float
        C++: double GetValue(int i)
        
        Get the ith contour value.
        """
        ...
    
    def GetValues(self):
        """
        V.GetValues() -> (float, ...)
        C++: double *GetValues()
        V.GetValues([float, ...])
        C++: void GetValues(double *contourValues)
        
        Get a pointer to an array of contour values. There will be
        GetNumberOfContours() values in the list.
        """
        ...
    
    def IsA(self, string):
        """
        V.IsA(string) -> int
        C++: vtkTypeBool IsA(const char *type) override;
        
        Return 1 if this class is the same type of (or a subclass of) the
        named class. Returns 0 otherwise. This method works in
        combination with vtkTypeMacro found in vtkSetGet.h.
        """
        ...
    
    def IsTypeOf(self, string):
        """
        V.IsTypeOf(string) -> int
        C++: static vtkTypeBool IsTypeOf(const char *type)
        
        Return 1 if this class type is the same type of (or a subclass
        of) the named class. Returns 0 otherwise. This method works in
        combination with vtkTypeMacro found in vtkSetGet.h.
        """
        ...
    
    def NewInstance(self):
        """
        V.NewInstance() -> vtkCutter
        C++: vtkCutter *NewInstance()
        """
        ...
    
    def SafeDownCast(self, vtkObjectBase):
        """
        V.SafeDownCast(vtkObjectBase) -> vtkCutter
        C++: static vtkCutter *SafeDownCast(vtkObjectBase *o)
        """
        ...
    
    def SetCutFunction(self, vtkImplicitFunction):
        """
        V.SetCutFunction(vtkImplicitFunction)
        C++: virtual void SetCutFunction(vtkImplicitFunction *)
        
        Specify the implicit function to perform the cutting.
        """
        ...
    
    def SetGenerateCutScalars(self, p_int):
        """
        V.SetGenerateCutScalars(int)
        C++: virtual void SetGenerateCutScalars(vtkTypeBool _arg)
        
        If this flag is enabled, then the output scalar values will be
        interpolated from the implicit function values, and not the input
        scalar data.
        """
        ...
    
    def SetGenerateTriangles(self, p_int):
        """
        V.SetGenerateTriangles(int)
        C++: virtual void SetGenerateTriangles(vtkTypeBool _arg)
        
        If this is enabled (by default), the output will be triangles
        otherwise, the output will be the intersection polygons WARNING:
        if the cutting function is not a plane, the output will be 3D
        poygons, which might be nice to look at but hard to compute with
        downstream.
        """
        ...
    
    def SetLocator(self, vtkIncrementalPointLocator):
        """
        V.SetLocator(vtkIncrementalPointLocator)
        C++: void SetLocator(vtkIncrementalPointLocator *locator)
        
        Specify a spatial locator for merging points. By default, an
        instance of vtkMergePoints is used.
        """
        ...
    
    def SetNumberOfContours(self, p_int):
        """
        V.SetNumberOfContours(int)
        C++: void SetNumberOfContours(int number)
        
        Set the number of contours to place into the list. You only
        really need to use this method to reduce list size. The method
        SetValue() will automatically increase list size as needed.
        """
        ...
    
    def SetOutputPointsPrecision(self, p_int):
        """
        V.SetOutputPointsPrecision(int)
        C++: virtual void SetOutputPointsPrecision(int _arg)
        
        Set/get the desired precision for the output types. See the
        documentation for the vtkAlgorithm::DesiredOutputPrecision enum
        for an explanation of the available precision settings.
        """
        ...
    
    def SetSortBy(self, p_int):
        """
        V.SetSortBy(int)
        C++: virtual void SetSortBy(int _arg)
        
        Set the sorting order for the generated polydata. There are two
        possibilities: Sort by value = 0 - This is the most efficient
        sort. For each cell, all contour values are processed. This is
        the default. Sort by cell = 1 - For each contour value, all cells
        are processed. This order should be used if the extracted
        polygons must be rendered in a back-to-front or front-to-back
        order. This is very problem dependent. For most applications, the
        default order is fine (and faster).
        
        * Sort by cell is going to have a problem if the input has 2D and
        3D cells.
        * Cell data will be scrambled because with
        * vtkPolyData output, verts and lines have lower cell ids than
          triangles.
        """
        ...
    
    def SetSortByToSortByCell(self):
        """
        V.SetSortByToSortByCell()
        C++: void SetSortByToSortByCell()
        
        Set the sorting order for the generated polydata. There are two
        possibilities: Sort by value = 0 - This is the most efficient
        sort. For each cell, all contour values are processed. This is
        the default. Sort by cell = 1 - For each contour value, all cells
        are processed. This order should be used if the extracted
        polygons must be rendered in a back-to-front or front-to-back
        order. This is very problem dependent. For most applications, the
        default order is fine (and faster).
        
        * Sort by cell is going to have a problem if the input has 2D and
        3D cells.
        * Cell data will be scrambled because with
        * vtkPolyData output, verts and lines have lower cell ids than
          triangles.
        """
        ...
    
    def SetSortByToSortByValue(self):
        """
        V.SetSortByToSortByValue()
        C++: void SetSortByToSortByValue()
        
        Set the sorting order for the generated polydata. There are two
        possibilities: Sort by value = 0 - This is the most efficient
        sort. For each cell, all contour values are processed. This is
        the default. Sort by cell = 1 - For each contour value, all cells
        are processed. This order should be used if the extracted
        polygons must be rendered in a back-to-front or front-to-back
        order. This is very problem dependent. For most applications, the
        default order is fine (and faster).
        
        * Sort by cell is going to have a problem if the input has 2D and
        3D cells.
        * Cell data will be scrambled because with
        * vtkPolyData output, verts and lines have lower cell ids than
          triangles.
        """
        ...
    
    def SetValue(self, p_int, p_float):
        """
        V.SetValue(int, float)
        C++: void SetValue(int i, double value)
        
        Set a particular contour value at contour number i. The index i
        ranges between 0<=i<NumberOfContours.
        """
        ...
    
    def __delattr__(self, *args, **kwargs):
        """ Implement delattr(self, name). """
        ...
    
    def __getattribute__(self, *args, **kwargs):
        """ Return getattr(self, name). """
        ...
    
    def __init__(self, *args, **kwargs) -> None:
        ...
    
    @staticmethod
    def __new__(*args, **kwargs):
        """ Create and return a new object.  See help(type) for accurate signature. """
        ...
    
    def __repr__(self, *args, **kwargs):
        """ Return repr(self). """
        ...
    
    def __setattr__(self, *args, **kwargs):
        """ Implement setattr(self, name, value). """
        ...
    
    def __str__(self, *args, **kwargs) -> str:
        """ Return str(self). """
        ...
    
    __this__ = ...
    __dict__ = ...
    __vtkname__ = ...


