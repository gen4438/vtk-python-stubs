"""
This type stub file was generated by pyright.
"""

import vtkmodules.vtkCommonExecutionModel as __vtkmodules_vtkCommonExecutionModel

class vtkDecimatePro(__vtkmodules_vtkCommonExecutionModel.vtkPolyDataAlgorithm):
    """
    vtkDecimatePro - reduce the number of triangles in a mesh
    
    Superclass: vtkPolyDataAlgorithm
    
    vtkDecimatePro is a filter to reduce the number of triangles in a
    triangle mesh, forming a good approximation to the original geometry.
    The input to vtkDecimatePro is a vtkPolyData object, and only
    triangles are treated. If you desire to decimate polygonal meshes,
    first triangulate the polygons with vtkTriangleFilter object.
    
    The implementation of vtkDecimatePro is similar to the algorithm
    originally described in "Decimation of Triangle Meshes", Proc
    Siggraph `92, with three major differences. First, this algorithm
    does not necessarily preserve the topology of the mesh. Second, it is
    guaranteed to give the a mesh reduction factor specified by the user
    (as long as certain constraints are not set - see Caveats). Third, it
    is set up generate progressive meshes, that is a stream of operations
    that can be easily transmitted and incrementally updated (see Hugues
    Hoppe's Siggraph '96 paper on progressive meshes).
    
    The algorithm proceeds as follows. Each vertex in the mesh is
    classified and inserted into a priority queue. The priority is based
    on the error to delete the vertex and retriangulate the hole.
    Vertices that cannot be deleted or triangulated (at this point in the
    algorithm) are skipped. Then, each vertex in the priority queue is
    processed (i.e., deleted followed by hole triangulation using edge
    collapse). This continues until the priority queue is empty. Next,
    all remaining vertices are processed, and the mesh is split into
    separate pieces along sharp edges or at non-manifold attachment
    points and reinserted into the priority queue. Again, the priority
    queue is processed until empty. If the desired reduction is still not
    achieved, the remaining vertices are split as necessary (in a
    recursive fashion) so that it is possible to eliminate every triangle
    as necessary.
    
    To use this object, at a minimum you need to specify the ivar
    TargetReduction. The algorithm is guaranteed to generate a reduced
    mesh at this level as long as the following four conditions are met:
    1) topology modification is allowed (i.e., the ivar PreserveTopology
    is off);
    2) mesh splitting is enabled (i.e., the ivar Splitting is on); 3) the
       algorithm is allowed to modify the boundary of the mesh (i.e., the
    ivar BoundaryVertexDeletion is on); and 4) the maximum allowable
       error (i.e., the ivar MaximumError) is set to VTK_DOUBLE_MAX. 
       Other important parameters to adjust include the FeatureAngle and
       SplitAngle ivars, since these can impact the quality of the final
       mesh. Also, you can set the ivar AccumulateError to force
       incremental error update and distribution to surrounding vertices
       as each vertex is deleted. The accumulated error is a conservative
    global error bounds and decimation error, but requires additional
       memory and time to compute.
    
    @warning
    To guarantee a given level of reduction, the ivar PreserveTopology
    must be off; the ivar Splitting is on; the ivar
    BoundaryVertexDeletion is on; and the ivar MaximumError is set to
    VTK_DOUBLE_MAX.
    
    @warning
    If PreserveTopology is off, and SplitEdges is off; the mesh topology
    may be modified by closing holes.
    
    @warning
    Once mesh splitting begins, the feature angle is set to the split
    angle.
    
    @sa
    vtkDecimate vtkQuadricClustering vtkQuadricDecimation
    """
    def AccumulateErrorOff(self):
        """
        V.AccumulateErrorOff()
        C++: virtual void AccumulateErrorOff()
        
        The computed error can either be computed directly from the mesh
        or the error may be accumulated as the mesh is modified. If the
        error is accumulated, then it represents a global error bounds,
        and the ivar MaximumError becomes a global bounds on mesh error.
        Accumulating the error requires extra memory proportional to the
        number of vertices in the mesh. If AccumulateError is off, then
        the error is not accumulated.
        """
        ...
    
    def AccumulateErrorOn(self):
        """
        V.AccumulateErrorOn()
        C++: virtual void AccumulateErrorOn()
        
        The computed error can either be computed directly from the mesh
        or the error may be accumulated as the mesh is modified. If the
        error is accumulated, then it represents a global error bounds,
        and the ivar MaximumError becomes a global bounds on mesh error.
        Accumulating the error requires extra memory proportional to the
        number of vertices in the mesh. If AccumulateError is off, then
        the error is not accumulated.
        """
        ...
    
    def BoundaryVertexDeletionOff(self):
        """
        V.BoundaryVertexDeletionOff()
        C++: virtual void BoundaryVertexDeletionOff()
        
        Turn on/off the deletion of vertices on the boundary of a mesh.
        This may limit the maximum reduction that may be achieved.
        """
        ...
    
    def BoundaryVertexDeletionOn(self):
        """
        V.BoundaryVertexDeletionOn()
        C++: virtual void BoundaryVertexDeletionOn()
        
        Turn on/off the deletion of vertices on the boundary of a mesh.
        This may limit the maximum reduction that may be achieved.
        """
        ...
    
    def GetAbsoluteError(self):
        """
        V.GetAbsoluteError() -> float
        C++: virtual double GetAbsoluteError()
        
        Same as MaximumError, but to be used when ErrorIsAbsolute is 1
        """
        ...
    
    def GetAbsoluteErrorMaxValue(self):
        """
        V.GetAbsoluteErrorMaxValue() -> float
        C++: virtual double GetAbsoluteErrorMaxValue()
        
        Same as MaximumError, but to be used when ErrorIsAbsolute is 1
        """
        ...
    
    def GetAbsoluteErrorMinValue(self):
        """
        V.GetAbsoluteErrorMinValue() -> float
        C++: virtual double GetAbsoluteErrorMinValue()
        
        Same as MaximumError, but to be used when ErrorIsAbsolute is 1
        """
        ...
    
    def GetAccumulateError(self):
        """
        V.GetAccumulateError() -> int
        C++: virtual vtkTypeBool GetAccumulateError()
        
        The computed error can either be computed directly from the mesh
        or the error may be accumulated as the mesh is modified. If the
        error is accumulated, then it represents a global error bounds,
        and the ivar MaximumError becomes a global bounds on mesh error.
        Accumulating the error requires extra memory proportional to the
        number of vertices in the mesh. If AccumulateError is off, then
        the error is not accumulated.
        """
        ...
    
    def GetBoundaryVertexDeletion(self):
        """
        V.GetBoundaryVertexDeletion() -> int
        C++: virtual vtkTypeBool GetBoundaryVertexDeletion()
        
        Turn on/off the deletion of vertices on the boundary of a mesh.
        This may limit the maximum reduction that may be achieved.
        """
        ...
    
    def GetDegree(self):
        """
        V.GetDegree() -> int
        C++: virtual int GetDegree()
        
        If the number of triangles connected to a vertex exceeds
        "Degree", then the vertex will be split. (NOTE: the complexity of
        the triangulation algorithm is proportional to Degree^2. Setting
        degree small can improve the performance of the algorithm.)
        """
        ...
    
    def GetDegreeMaxValue(self):
        """
        V.GetDegreeMaxValue() -> int
        C++: virtual int GetDegreeMaxValue()
        
        If the number of triangles connected to a vertex exceeds
        "Degree", then the vertex will be split. (NOTE: the complexity of
        the triangulation algorithm is proportional to Degree^2. Setting
        degree small can improve the performance of the algorithm.)
        """
        ...
    
    def GetDegreeMinValue(self):
        """
        V.GetDegreeMinValue() -> int
        C++: virtual int GetDegreeMinValue()
        
        If the number of triangles connected to a vertex exceeds
        "Degree", then the vertex will be split. (NOTE: the complexity of
        the triangulation algorithm is proportional to Degree^2. Setting
        degree small can improve the performance of the algorithm.)
        """
        ...
    
    def GetErrorIsAbsolute(self):
        """
        V.GetErrorIsAbsolute() -> int
        C++: virtual int GetErrorIsAbsolute()
        
        The MaximumError is normally defined as a fraction of the dataset
        bounding diagonal. By setting ErrorIsAbsolute to 1, the error is
        instead defined as that specified by AbsoluteError. By default
        ErrorIsAbsolute=0.
        """
        ...
    
    def GetFeatureAngle(self):
        """
        V.GetFeatureAngle() -> float
        C++: virtual double GetFeatureAngle()
        
        Specify the mesh feature angle. This angle is used to define what
        an edge is (i.e., if the surface normal between two adjacent
        triangles is >= FeatureAngle, an edge exists).
        """
        ...
    
    def GetFeatureAngleMaxValue(self):
        """
        V.GetFeatureAngleMaxValue() -> float
        C++: virtual double GetFeatureAngleMaxValue()
        
        Specify the mesh feature angle. This angle is used to define what
        an edge is (i.e., if the surface normal between two adjacent
        triangles is >= FeatureAngle, an edge exists).
        """
        ...
    
    def GetFeatureAngleMinValue(self):
        """
        V.GetFeatureAngleMinValue() -> float
        C++: virtual double GetFeatureAngleMinValue()
        
        Specify the mesh feature angle. This angle is used to define what
        an edge is (i.e., if the surface normal between two adjacent
        triangles is >= FeatureAngle, an edge exists).
        """
        ...
    
    def GetInflectionPointRatio(self):
        """
        V.GetInflectionPointRatio() -> float
        C++: virtual double GetInflectionPointRatio()
        
        Specify the inflection point ratio. An inflection point occurs
        when the ratio of reduction error between two iterations is
        greater than or equal to the InflectionPointRatio.
        """
        ...
    
    def GetInflectionPointRatioMaxValue(self):
        """
        V.GetInflectionPointRatioMaxValue() -> float
        C++: virtual double GetInflectionPointRatioMaxValue()
        
        Specify the inflection point ratio. An inflection point occurs
        when the ratio of reduction error between two iterations is
        greater than or equal to the InflectionPointRatio.
        """
        ...
    
    def GetInflectionPointRatioMinValue(self):
        """
        V.GetInflectionPointRatioMinValue() -> float
        C++: virtual double GetInflectionPointRatioMinValue()
        
        Specify the inflection point ratio. An inflection point occurs
        when the ratio of reduction error between two iterations is
        greater than or equal to the InflectionPointRatio.
        """
        ...
    
    def GetInflectionPoints(self, *float):
        """
        V.GetInflectionPoints([float, ...])
        C++: void GetInflectionPoints(double *inflectionPoints)
        V.GetInflectionPoints() -> (float, ...)
        C++: double *GetInflectionPoints()
        
        Get a list of inflection points. These are double values 0 < r <=
        1.0 corresponding to reduction level, and there are a total of
        NumberOfInflectionPoints() values. You must provide an array (of
        the correct size) into which the inflection points are written.
        """
        ...
    
    def GetMaximumError(self):
        """
        V.GetMaximumError() -> float
        C++: virtual double GetMaximumError()
        
        Set the largest decimation error that is allowed during the
        decimation process. This may limit the maximum reduction that may
        be achieved. The maximum error is specified as a fraction of the
        maximum length of the input data bounding box.
        """
        ...
    
    def GetMaximumErrorMaxValue(self):
        """
        V.GetMaximumErrorMaxValue() -> float
        C++: virtual double GetMaximumErrorMaxValue()
        
        Set the largest decimation error that is allowed during the
        decimation process. This may limit the maximum reduction that may
        be achieved. The maximum error is specified as a fraction of the
        maximum length of the input data bounding box.
        """
        ...
    
    def GetMaximumErrorMinValue(self):
        """
        V.GetMaximumErrorMinValue() -> float
        C++: virtual double GetMaximumErrorMinValue()
        
        Set the largest decimation error that is allowed during the
        decimation process. This may limit the maximum reduction that may
        be achieved. The maximum error is specified as a fraction of the
        maximum length of the input data bounding box.
        """
        ...
    
    def GetNumberOfGenerationsFromBase(self, string):
        """
        V.GetNumberOfGenerationsFromBase(string) -> int
        C++: vtkIdType GetNumberOfGenerationsFromBase(const char *type)
            override;
        
        Given a the name of a base class of this class type, return the
        distance of inheritance between this class type and the named
        class (how many generations of inheritance are there between this
        class and the named class). If the named class is not in this
        class's inheritance tree, return a negative value. Valid
        responses will always be nonnegative. This method works in
        combination with vtkTypeMacro found in vtkSetGet.h.
        """
        ...
    
    def GetNumberOfGenerationsFromBaseType(self, string):
        """
        V.GetNumberOfGenerationsFromBaseType(string) -> int
        C++: static vtkIdType GetNumberOfGenerationsFromBaseType(
            const char *type)
        
        Given a the name of a base class of this class type, return the
        distance of inheritance between this class type and the named
        class (how many generations of inheritance are there between this
        class and the named class). If the named class is not in this
        class's inheritance tree, return a negative value. Valid
        responses will always be nonnegative. This method works in
        combination with vtkTypeMacro found in vtkSetGet.h.
        """
        ...
    
    def GetNumberOfInflectionPoints(self):
        """
        V.GetNumberOfInflectionPoints() -> int
        C++: vtkIdType GetNumberOfInflectionPoints()
        
        Get the number of inflection points. Only returns a valid value
        after the filter has executed.  The values in the list are mesh
        reduction values at each inflection point. Note: the first
        inflection point always occurs right before non-planar triangles
        are decimated (i.e., as the error becomes non-zero).
        """
        ...
    
    def GetOutputPointsPrecision(self):
        """
        V.GetOutputPointsPrecision() -> int
        C++: virtual int GetOutputPointsPrecision()
        
        Set/get the desired precision for the output types. See the
        documentation for the vtkAlgorithm::DesiredOutputPrecision enum
        for an explanation of the available precision settings.
        """
        ...
    
    def GetPreserveTopology(self):
        """
        V.GetPreserveTopology() -> int
        C++: virtual vtkTypeBool GetPreserveTopology()
        
        Turn on/off whether to preserve the topology of the original
        mesh. If on, mesh splitting and hole elimination will not occur.
        This may limit the maximum reduction that may be achieved.
        """
        ...
    
    def GetPreSplitMesh(self):
        """
        V.GetPreSplitMesh() -> int
        C++: virtual vtkTypeBool GetPreSplitMesh()
        
        In some cases you may wish to split the mesh prior to algorithm
        execution. This separates the mesh into semi-planar patches,
        which are disconnected from each other. This can give superior
        results in some cases. If the ivar PreSplitMesh ivar is enabled,
        the mesh is split with the specified SplitAngle. Otherwise mesh
        splitting is deferred as long as possible.
        """
        ...
    
    def GetSplitAngle(self):
        """
        V.GetSplitAngle() -> float
        C++: virtual double GetSplitAngle()
        
        Specify the mesh split angle. This angle is used to control the
        splitting of the mesh. A split line exists when the surface
        normals between two edge connected triangles are >= SplitAngle.
        """
        ...
    
    def GetSplitAngleMaxValue(self):
        """
        V.GetSplitAngleMaxValue() -> float
        C++: virtual double GetSplitAngleMaxValue()
        
        Specify the mesh split angle. This angle is used to control the
        splitting of the mesh. A split line exists when the surface
        normals between two edge connected triangles are >= SplitAngle.
        """
        ...
    
    def GetSplitAngleMinValue(self):
        """
        V.GetSplitAngleMinValue() -> float
        C++: virtual double GetSplitAngleMinValue()
        
        Specify the mesh split angle. This angle is used to control the
        splitting of the mesh. A split line exists when the surface
        normals between two edge connected triangles are >= SplitAngle.
        """
        ...
    
    def GetSplitting(self):
        """
        V.GetSplitting() -> int
        C++: virtual vtkTypeBool GetSplitting()
        
        Turn on/off the splitting of the mesh at corners, along edges, at
        non-manifold points, or anywhere else a split is required.
        Turning splitting off will better preserve the original topology
        of the mesh, but you may not obtain the requested reduction.
        """
        ...
    
    def GetTargetReduction(self):
        """
        V.GetTargetReduction() -> float
        C++: virtual double GetTargetReduction()
        
        Specify the desired reduction in the total number of polygons
        (e.g., if TargetReduction is set to 0.9, this filter will try to
        reduce the data set to 10% of its original size). Because of
        various constraints, this level of reduction may not be realized.
        If you want to guarantee a particular reduction, you must turn
        off PreserveTopology, turn on SplitEdges and
        BoundaryVertexDeletion, and set the MaximumError to
        VTK_DOUBLE_MAX (these ivars are initialized this way when the
        object is instantiated).
        """
        ...
    
    def GetTargetReductionMaxValue(self):
        """
        V.GetTargetReductionMaxValue() -> float
        C++: virtual double GetTargetReductionMaxValue()
        
        Specify the desired reduction in the total number of polygons
        (e.g., if TargetReduction is set to 0.9, this filter will try to
        reduce the data set to 10% of its original size). Because of
        various constraints, this level of reduction may not be realized.
        If you want to guarantee a particular reduction, you must turn
        off PreserveTopology, turn on SplitEdges and
        BoundaryVertexDeletion, and set the MaximumError to
        VTK_DOUBLE_MAX (these ivars are initialized this way when the
        object is instantiated).
        """
        ...
    
    def GetTargetReductionMinValue(self):
        """
        V.GetTargetReductionMinValue() -> float
        C++: virtual double GetTargetReductionMinValue()
        
        Specify the desired reduction in the total number of polygons
        (e.g., if TargetReduction is set to 0.9, this filter will try to
        reduce the data set to 10% of its original size). Because of
        various constraints, this level of reduction may not be realized.
        If you want to guarantee a particular reduction, you must turn
        off PreserveTopology, turn on SplitEdges and
        BoundaryVertexDeletion, and set the MaximumError to
        VTK_DOUBLE_MAX (these ivars are initialized this way when the
        object is instantiated).
        """
        ...
    
    def IsA(self, string):
        """
        V.IsA(string) -> int
        C++: vtkTypeBool IsA(const char *type) override;
        
        Return 1 if this class is the same type of (or a subclass of) the
        named class. Returns 0 otherwise. This method works in
        combination with vtkTypeMacro found in vtkSetGet.h.
        """
        ...
    
    def IsTypeOf(self, string):
        """
        V.IsTypeOf(string) -> int
        C++: static vtkTypeBool IsTypeOf(const char *type)
        
        Return 1 if this class type is the same type of (or a subclass
        of) the named class. Returns 0 otherwise. This method works in
        combination with vtkTypeMacro found in vtkSetGet.h.
        """
        ...
    
    def NewInstance(self):
        """
        V.NewInstance() -> vtkDecimatePro
        C++: vtkDecimatePro *NewInstance()
        """
        ...
    
    def PreserveTopologyOff(self):
        """
        V.PreserveTopologyOff()
        C++: virtual void PreserveTopologyOff()
        
        Turn on/off whether to preserve the topology of the original
        mesh. If on, mesh splitting and hole elimination will not occur.
        This may limit the maximum reduction that may be achieved.
        """
        ...
    
    def PreserveTopologyOn(self):
        """
        V.PreserveTopologyOn()
        C++: virtual void PreserveTopologyOn()
        
        Turn on/off whether to preserve the topology of the original
        mesh. If on, mesh splitting and hole elimination will not occur.
        This may limit the maximum reduction that may be achieved.
        """
        ...
    
    def PreSplitMeshOff(self):
        """
        V.PreSplitMeshOff()
        C++: virtual void PreSplitMeshOff()
        
        In some cases you may wish to split the mesh prior to algorithm
        execution. This separates the mesh into semi-planar patches,
        which are disconnected from each other. This can give superior
        results in some cases. If the ivar PreSplitMesh ivar is enabled,
        the mesh is split with the specified SplitAngle. Otherwise mesh
        splitting is deferred as long as possible.
        """
        ...
    
    def PreSplitMeshOn(self):
        """
        V.PreSplitMeshOn()
        C++: virtual void PreSplitMeshOn()
        
        In some cases you may wish to split the mesh prior to algorithm
        execution. This separates the mesh into semi-planar patches,
        which are disconnected from each other. This can give superior
        results in some cases. If the ivar PreSplitMesh ivar is enabled,
        the mesh is split with the specified SplitAngle. Otherwise mesh
        splitting is deferred as long as possible.
        """
        ...
    
    def SafeDownCast(self, vtkObjectBase):
        """
        V.SafeDownCast(vtkObjectBase) -> vtkDecimatePro
        C++: static vtkDecimatePro *SafeDownCast(vtkObjectBase *o)
        """
        ...
    
    def SetAbsoluteError(self, p_float):
        """
        V.SetAbsoluteError(float)
        C++: virtual void SetAbsoluteError(double _arg)
        
        Same as MaximumError, but to be used when ErrorIsAbsolute is 1
        """
        ...
    
    def SetAccumulateError(self, p_int):
        """
        V.SetAccumulateError(int)
        C++: virtual void SetAccumulateError(vtkTypeBool _arg)
        
        The computed error can either be computed directly from the mesh
        or the error may be accumulated as the mesh is modified. If the
        error is accumulated, then it represents a global error bounds,
        and the ivar MaximumError becomes a global bounds on mesh error.
        Accumulating the error requires extra memory proportional to the
        number of vertices in the mesh. If AccumulateError is off, then
        the error is not accumulated.
        """
        ...
    
    def SetBoundaryVertexDeletion(self, p_int):
        """
        V.SetBoundaryVertexDeletion(int)
        C++: virtual void SetBoundaryVertexDeletion(vtkTypeBool _arg)
        
        Turn on/off the deletion of vertices on the boundary of a mesh.
        This may limit the maximum reduction that may be achieved.
        """
        ...
    
    def SetDegree(self, p_int):
        """
        V.SetDegree(int)
        C++: virtual void SetDegree(int _arg)
        
        If the number of triangles connected to a vertex exceeds
        "Degree", then the vertex will be split. (NOTE: the complexity of
        the triangulation algorithm is proportional to Degree^2. Setting
        degree small can improve the performance of the algorithm.)
        """
        ...
    
    def SetErrorIsAbsolute(self, p_int):
        """
        V.SetErrorIsAbsolute(int)
        C++: virtual void SetErrorIsAbsolute(int _arg)
        
        The MaximumError is normally defined as a fraction of the dataset
        bounding diagonal. By setting ErrorIsAbsolute to 1, the error is
        instead defined as that specified by AbsoluteError. By default
        ErrorIsAbsolute=0.
        """
        ...
    
    def SetFeatureAngle(self, p_float):
        """
        V.SetFeatureAngle(float)
        C++: virtual void SetFeatureAngle(double _arg)
        
        Specify the mesh feature angle. This angle is used to define what
        an edge is (i.e., if the surface normal between two adjacent
        triangles is >= FeatureAngle, an edge exists).
        """
        ...
    
    def SetInflectionPointRatio(self, p_float):
        """
        V.SetInflectionPointRatio(float)
        C++: virtual void SetInflectionPointRatio(double _arg)
        
        Specify the inflection point ratio. An inflection point occurs
        when the ratio of reduction error between two iterations is
        greater than or equal to the InflectionPointRatio.
        """
        ...
    
    def SetMaximumError(self, p_float):
        """
        V.SetMaximumError(float)
        C++: virtual void SetMaximumError(double _arg)
        
        Set the largest decimation error that is allowed during the
        decimation process. This may limit the maximum reduction that may
        be achieved. The maximum error is specified as a fraction of the
        maximum length of the input data bounding box.
        """
        ...
    
    def SetOutputPointsPrecision(self, p_int):
        """
        V.SetOutputPointsPrecision(int)
        C++: virtual void SetOutputPointsPrecision(int _arg)
        
        Set/get the desired precision for the output types. See the
        documentation for the vtkAlgorithm::DesiredOutputPrecision enum
        for an explanation of the available precision settings.
        """
        ...
    
    def SetPreserveTopology(self, p_int):
        """
        V.SetPreserveTopology(int)
        C++: virtual void SetPreserveTopology(vtkTypeBool _arg)
        
        Turn on/off whether to preserve the topology of the original
        mesh. If on, mesh splitting and hole elimination will not occur.
        This may limit the maximum reduction that may be achieved.
        """
        ...
    
    def SetPreSplitMesh(self, p_int):
        """
        V.SetPreSplitMesh(int)
        C++: virtual void SetPreSplitMesh(vtkTypeBool _arg)
        
        In some cases you may wish to split the mesh prior to algorithm
        execution. This separates the mesh into semi-planar patches,
        which are disconnected from each other. This can give superior
        results in some cases. If the ivar PreSplitMesh ivar is enabled,
        the mesh is split with the specified SplitAngle. Otherwise mesh
        splitting is deferred as long as possible.
        """
        ...
    
    def SetSplitAngle(self, p_float):
        """
        V.SetSplitAngle(float)
        C++: virtual void SetSplitAngle(double _arg)
        
        Specify the mesh split angle. This angle is used to control the
        splitting of the mesh. A split line exists when the surface
        normals between two edge connected triangles are >= SplitAngle.
        """
        ...
    
    def SetSplitting(self, p_int):
        """
        V.SetSplitting(int)
        C++: virtual void SetSplitting(vtkTypeBool _arg)
        
        Turn on/off the splitting of the mesh at corners, along edges, at
        non-manifold points, or anywhere else a split is required.
        Turning splitting off will better preserve the original topology
        of the mesh, but you may not obtain the requested reduction.
        """
        ...
    
    def SetTargetReduction(self, p_float):
        """
        V.SetTargetReduction(float)
        C++: virtual void SetTargetReduction(double _arg)
        
        Specify the desired reduction in the total number of polygons
        (e.g., if TargetReduction is set to 0.9, this filter will try to
        reduce the data set to 10% of its original size). Because of
        various constraints, this level of reduction may not be realized.
        If you want to guarantee a particular reduction, you must turn
        off PreserveTopology, turn on SplitEdges and
        BoundaryVertexDeletion, and set the MaximumError to
        VTK_DOUBLE_MAX (these ivars are initialized this way when the
        object is instantiated).
        """
        ...
    
    def SplittingOff(self):
        """
        V.SplittingOff()
        C++: virtual void SplittingOff()
        
        Turn on/off the splitting of the mesh at corners, along edges, at
        non-manifold points, or anywhere else a split is required.
        Turning splitting off will better preserve the original topology
        of the mesh, but you may not obtain the requested reduction.
        """
        ...
    
    def SplittingOn(self):
        """
        V.SplittingOn()
        C++: virtual void SplittingOn()
        
        Turn on/off the splitting of the mesh at corners, along edges, at
        non-manifold points, or anywhere else a split is required.
        Turning splitting off will better preserve the original topology
        of the mesh, but you may not obtain the requested reduction.
        """
        ...
    
    def __delattr__(self, *args, **kwargs):
        """ Implement delattr(self, name). """
        ...
    
    def __getattribute__(self, *args, **kwargs):
        """ Return getattr(self, name). """
        ...
    
    def __init__(self, *args, **kwargs) -> None:
        ...
    
    @staticmethod
    def __new__(*args, **kwargs):
        """ Create and return a new object.  See help(type) for accurate signature. """
        ...
    
    def __repr__(self, *args, **kwargs):
        """ Return repr(self). """
        ...
    
    def __setattr__(self, *args, **kwargs):
        """ Implement setattr(self, name, value). """
        ...
    
    def __str__(self, *args, **kwargs) -> str:
        """ Return str(self). """
        ...
    
    __this__ = ...
    __dict__ = ...
    __vtkname__ = ...


