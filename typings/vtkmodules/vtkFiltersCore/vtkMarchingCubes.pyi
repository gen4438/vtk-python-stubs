"""
This type stub file was generated by pyright.
"""

import vtkmodules.vtkCommonExecutionModel as __vtkmodules_vtkCommonExecutionModel

class vtkMarchingCubes(__vtkmodules_vtkCommonExecutionModel.vtkPolyDataAlgorithm):
    """
    vtkMarchingCubes - generate isosurface(s) from volume
    
    Superclass: vtkPolyDataAlgorithm
    
    vtkMarchingCubes is a filter that takes as input a volume (e.g., 3D
    structured point set) and generates on output one or more
    isosurfaces. One or more contour values must be specified to generate
    the isosurfaces. Alternatively, you can specify a min/max scalar
    range and the number of contours to generate a series of evenly
    spaced contour values.
    
    @warning
    This filter is specialized to volumes. If you are interested in
    contouring other types of data, use the general vtkContourFilter. If
    you want to contour an image (i.e., a volume slice), use
    vtkMarchingSquares.
    
    @sa
    Much faster implementations for isocontouring are available. In
    particular, vtkFlyingEdges3D and vtkFlyingEdges2D are much faster and
    if built with the right options, multithreaded, and scale well with
    additional processors.
    
    @sa
    If you are interested in extracting surfaces from label maps,
    consider using vtkDiscreteFlyingEdges3D, vtkDiscreteFlyingEdges2D, or
    vtkDiscreteMarchingCubes.
    
    @sa
    vtkFlyingEdges3D vtkFlyingEdges2D vtkSynchronizedTemplates3D
    vtkSynchronizedTemplates2D vtkContourFilter vtkSliceCubes
    vtkMarchingSquares vtkDividingCubes vtkDiscreteMarchingCubes
    """
    def ComputeGradientsOff(self):
        """
        V.ComputeGradientsOff()
        C++: virtual void ComputeGradientsOff()
        
        Set/Get the computation of gradients. Gradient computation is
        fairly expensive in both time and storage. Note that if
        ComputeNormals is on, gradients will have to be calculated, but
        will not be stored in the output dataset.  If the output data
        will be processed by filters that modify topology or geometry, it
        may be wise to turn Normals and Gradients off.
        """
        ...
    
    def ComputeGradientsOn(self):
        """
        V.ComputeGradientsOn()
        C++: virtual void ComputeGradientsOn()
        
        Set/Get the computation of gradients. Gradient computation is
        fairly expensive in both time and storage. Note that if
        ComputeNormals is on, gradients will have to be calculated, but
        will not be stored in the output dataset.  If the output data
        will be processed by filters that modify topology or geometry, it
        may be wise to turn Normals and Gradients off.
        """
        ...
    
    def ComputeNormalsOff(self):
        """
        V.ComputeNormalsOff()
        C++: virtual void ComputeNormalsOff()
        
        Set/Get the computation of normals. Normal computation is fairly
        expensive in both time and storage. If the output data will be
        processed by filters that modify topology or geometry, it may be
        wise to turn Normals and Gradients off.
        """
        ...
    
    def ComputeNormalsOn(self):
        """
        V.ComputeNormalsOn()
        C++: virtual void ComputeNormalsOn()
        
        Set/Get the computation of normals. Normal computation is fairly
        expensive in both time and storage. If the output data will be
        processed by filters that modify topology or geometry, it may be
        wise to turn Normals and Gradients off.
        """
        ...
    
    def ComputeScalarsOff(self):
        """
        V.ComputeScalarsOff()
        C++: virtual void ComputeScalarsOff()
        
        Set/Get the computation of scalars.
        """
        ...
    
    def ComputeScalarsOn(self):
        """
        V.ComputeScalarsOn()
        C++: virtual void ComputeScalarsOn()
        
        Set/Get the computation of scalars.
        """
        ...
    
    def CreateDefaultLocator(self):
        """
        V.CreateDefaultLocator()
        C++: void CreateDefaultLocator()
        
        Create default locator. Used to create one when none is
        specified. The locator is used to merge coincident points.
        """
        ...
    
    def GenerateValues(self, p_int, p_float=..., p_float=...):
        """
        V.GenerateValues(int, [float, float])
        C++: void GenerateValues(int numContours, double range[2])
        V.GenerateValues(int, float, float)
        C++: void GenerateValues(int numContours, double rangeStart,
            double rangeEnd)
        """
        ...
    
    def GetComputeGradients(self):
        """
        V.GetComputeGradients() -> int
        C++: virtual vtkTypeBool GetComputeGradients()
        
        Set/Get the computation of gradients. Gradient computation is
        fairly expensive in both time and storage. Note that if
        ComputeNormals is on, gradients will have to be calculated, but
        will not be stored in the output dataset.  If the output data
        will be processed by filters that modify topology or geometry, it
        may be wise to turn Normals and Gradients off.
        """
        ...
    
    def GetComputeNormals(self):
        """
        V.GetComputeNormals() -> int
        C++: virtual vtkTypeBool GetComputeNormals()
        
        Set/Get the computation of normals. Normal computation is fairly
        expensive in both time and storage. If the output data will be
        processed by filters that modify topology or geometry, it may be
        wise to turn Normals and Gradients off.
        """
        ...
    
    def GetComputeScalars(self):
        """
        V.GetComputeScalars() -> int
        C++: virtual vtkTypeBool GetComputeScalars()
        
        Set/Get the computation of scalars.
        """
        ...
    
    def GetLocator(self):
        """
        V.GetLocator() -> vtkIncrementalPointLocator
        C++: virtual vtkIncrementalPointLocator *GetLocator()
        
        override the default locator.  Useful for changing the number of
        bins for performance or specifying a more aggressive locator.
        """
        ...
    
    def GetMTime(self):
        """
        V.GetMTime() -> int
        C++: vtkMTimeType GetMTime() override;
        
        Return this object's modified time.
        """
        ...
    
    def GetNumberOfContours(self):
        """
        V.GetNumberOfContours() -> int
        C++: vtkIdType GetNumberOfContours()
        """
        ...
    
    def GetNumberOfGenerationsFromBase(self, string):
        """
        V.GetNumberOfGenerationsFromBase(string) -> int
        C++: vtkIdType GetNumberOfGenerationsFromBase(const char *type)
            override;
        
        Given a the name of a base class of this class type, return the
        distance of inheritance between this class type and the named
        class (how many generations of inheritance are there between this
        class and the named class). If the named class is not in this
        class's inheritance tree, return a negative value. Valid
        responses will always be nonnegative. This method works in
        combination with vtkTypeMacro found in vtkSetGet.h.
        """
        ...
    
    def GetNumberOfGenerationsFromBaseType(self, string):
        """
        V.GetNumberOfGenerationsFromBaseType(string) -> int
        C++: static vtkIdType GetNumberOfGenerationsFromBaseType(
            const char *type)
        
        Given a the name of a base class of this class type, return the
        distance of inheritance between this class type and the named
        class (how many generations of inheritance are there between this
        class and the named class). If the named class is not in this
        class's inheritance tree, return a negative value. Valid
        responses will always be nonnegative. This method works in
        combination with vtkTypeMacro found in vtkSetGet.h.
        """
        ...
    
    def GetValue(self, p_int):
        """
        V.GetValue(int) -> float
        C++: double GetValue(int i)
        """
        ...
    
    def GetValues(self):
        """
        V.GetValues() -> (float, ...)
        C++: double *GetValues()
        V.GetValues([float, ...])
        C++: void GetValues(double *contourValues)
        """
        ...
    
    def IsA(self, string):
        """
        V.IsA(string) -> int
        C++: vtkTypeBool IsA(const char *type) override;
        
        Return 1 if this class is the same type of (or a subclass of) the
        named class. Returns 0 otherwise. This method works in
        combination with vtkTypeMacro found in vtkSetGet.h.
        """
        ...
    
    def IsTypeOf(self, string):
        """
        V.IsTypeOf(string) -> int
        C++: static vtkTypeBool IsTypeOf(const char *type)
        
        Return 1 if this class type is the same type of (or a subclass
        of) the named class. Returns 0 otherwise. This method works in
        combination with vtkTypeMacro found in vtkSetGet.h.
        """
        ...
    
    def NewInstance(self):
        """
        V.NewInstance() -> vtkMarchingCubes
        C++: vtkMarchingCubes *NewInstance()
        """
        ...
    
    def SafeDownCast(self, vtkObjectBase):
        """
        V.SafeDownCast(vtkObjectBase) -> vtkMarchingCubes
        C++: static vtkMarchingCubes *SafeDownCast(vtkObjectBase *o)
        """
        ...
    
    def SetComputeGradients(self, p_int):
        """
        V.SetComputeGradients(int)
        C++: virtual void SetComputeGradients(vtkTypeBool _arg)
        
        Set/Get the computation of gradients. Gradient computation is
        fairly expensive in both time and storage. Note that if
        ComputeNormals is on, gradients will have to be calculated, but
        will not be stored in the output dataset.  If the output data
        will be processed by filters that modify topology or geometry, it
        may be wise to turn Normals and Gradients off.
        """
        ...
    
    def SetComputeNormals(self, p_int):
        """
        V.SetComputeNormals(int)
        C++: virtual void SetComputeNormals(vtkTypeBool _arg)
        
        Set/Get the computation of normals. Normal computation is fairly
        expensive in both time and storage. If the output data will be
        processed by filters that modify topology or geometry, it may be
        wise to turn Normals and Gradients off.
        """
        ...
    
    def SetComputeScalars(self, p_int):
        """
        V.SetComputeScalars(int)
        C++: virtual void SetComputeScalars(vtkTypeBool _arg)
        
        Set/Get the computation of scalars.
        """
        ...
    
    def SetLocator(self, vtkIncrementalPointLocator):
        """
        V.SetLocator(vtkIncrementalPointLocator)
        C++: void SetLocator(vtkIncrementalPointLocator *locator)
        
        override the default locator.  Useful for changing the number of
        bins for performance or specifying a more aggressive locator.
        """
        ...
    
    def SetNumberOfContours(self, p_int):
        """
        V.SetNumberOfContours(int)
        C++: void SetNumberOfContours(int number)
        """
        ...
    
    def SetValue(self, p_int, p_float):
        """
        V.SetValue(int, float)
        C++: void SetValue(int i, double value)
        """
        ...
    
    def __delattr__(self, *args, **kwargs):
        """ Implement delattr(self, name). """
        ...
    
    def __getattribute__(self, *args, **kwargs):
        """ Return getattr(self, name). """
        ...
    
    def __init__(self, *args, **kwargs) -> None:
        ...
    
    @staticmethod
    def __new__(*args, **kwargs):
        """ Create and return a new object.  See help(type) for accurate signature. """
        ...
    
    def __repr__(self, *args, **kwargs):
        """ Return repr(self). """
        ...
    
    def __setattr__(self, *args, **kwargs):
        """ Implement setattr(self, name, value). """
        ...
    
    def __str__(self, *args, **kwargs) -> str:
        """ Return str(self). """
        ...
    
    __this__ = ...
    __dict__ = ...
    __vtkname__ = ...


