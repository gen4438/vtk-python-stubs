"""
This type stub file was generated by pyright.
"""

import vtkmodules.vtkCommonExecutionModel as __vtkmodules_vtkCommonExecutionModel

class vtkAppendCompositeDataLeaves(__vtkmodules_vtkCommonExecutionModel.vtkCompositeDataSetAlgorithm):
    """
    vtkAppendCompositeDataLeaves - appends one or more composite datasets
    with the same structure together into a single output composite
    dataset
    
    Superclass: vtkCompositeDataSetAlgorithm
    
    vtkAppendCompositeDataLeaves is a filter that takes input composite
    datasets with the same structure: (1) the same number of entries and
    -- if any children are composites -- the same constraint holds from
    them; and (2) the same type of dataset at each position. It then
    creates an output dataset with the same structure whose leaves
    contain all the cells from the datasets at the corresponding leaves
    of the input datasets.
    
    Currently, this filter only supports "appending" of a few types for
    the leaf nodes and the logic used for each supported data type is as
    follows:
    
    \li vtkUnstructuredGrid - appends all unstructured grids from the
        leaf
        location on all inputs into a single unstructured grid for the
        corresponding location in the output composite dataset. PointData
    and
        CellData arrays are extracted and appended only if they are
    available in
        all datasets.(For example, if one dataset has scalars but another
    does
        not, scalars will not be appended.)
    
    \li vtkPolyData - appends all polydatas from the leaf location on all
    inputs
        into a single polydata for the corresponding location in the
    output
        composite dataset. PointData and CellData arrays are extracted
    and
        appended only if they are available in all datasets.(For example,
    if one
        dataset has scalars but another does not, scalars will not be
    appended.)
    
    \li vtkImageData/vtkUniformGrid - simply passes the first non-null
        grid for a particular location to corresponding location in the
    output.
    
    \li vtkTable - simply passes the first non-null vtkTable for a
        particular
        location to the corresponding location in the output.
    
    Other types of leaf datasets will be ignored and their positions in
    the output dataset will be nullptr pointers.
    
    @sa
    vtkAppendPolyData vtkAppendFilter
    """
    def AppendFieldDataOff(self):
        """
        V.AppendFieldDataOff()
        C++: virtual void AppendFieldDataOff()
        
        Set/get whether the field data of each dataset in the composite
        dataset is copied to the output. If AppendFieldData is non-zero,
        then field data arrays from all the inputs are added to the
        output. If there are duplicates, the array on the first input
        encountered is taken.
        """
        ...
    
    def AppendFieldDataOn(self):
        """
        V.AppendFieldDataOn()
        C++: virtual void AppendFieldDataOn()
        
        Set/get whether the field data of each dataset in the composite
        dataset is copied to the output. If AppendFieldData is non-zero,
        then field data arrays from all the inputs are added to the
        output. If there are duplicates, the array on the first input
        encountered is taken.
        """
        ...
    
    def GetAppendFieldData(self):
        """
        V.GetAppendFieldData() -> int
        C++: virtual vtkTypeBool GetAppendFieldData()
        
        Set/get whether the field data of each dataset in the composite
        dataset is copied to the output. If AppendFieldData is non-zero,
        then field data arrays from all the inputs are added to the
        output. If there are duplicates, the array on the first input
        encountered is taken.
        """
        ...
    
    def GetNumberOfGenerationsFromBase(self, string):
        """
        V.GetNumberOfGenerationsFromBase(string) -> int
        C++: vtkIdType GetNumberOfGenerationsFromBase(const char *type)
            override;
        
        Given a the name of a base class of this class type, return the
        distance of inheritance between this class type and the named
        class (how many generations of inheritance are there between this
        class and the named class). If the named class is not in this
        class's inheritance tree, return a negative value. Valid
        responses will always be nonnegative. This method works in
        combination with vtkTypeMacro found in vtkSetGet.h.
        """
        ...
    
    def GetNumberOfGenerationsFromBaseType(self, string):
        """
        V.GetNumberOfGenerationsFromBaseType(string) -> int
        C++: static vtkIdType GetNumberOfGenerationsFromBaseType(
            const char *type)
        
        Given a the name of a base class of this class type, return the
        distance of inheritance between this class type and the named
        class (how many generations of inheritance are there between this
        class and the named class). If the named class is not in this
        class's inheritance tree, return a negative value. Valid
        responses will always be nonnegative. This method works in
        combination with vtkTypeMacro found in vtkSetGet.h.
        """
        ...
    
    def IsA(self, string):
        """
        V.IsA(string) -> int
        C++: vtkTypeBool IsA(const char *type) override;
        
        Return 1 if this class is the same type of (or a subclass of) the
        named class. Returns 0 otherwise. This method works in
        combination with vtkTypeMacro found in vtkSetGet.h.
        """
        ...
    
    def IsTypeOf(self, string):
        """
        V.IsTypeOf(string) -> int
        C++: static vtkTypeBool IsTypeOf(const char *type)
        
        Return 1 if this class type is the same type of (or a subclass
        of) the named class. Returns 0 otherwise. This method works in
        combination with vtkTypeMacro found in vtkSetGet.h.
        """
        ...
    
    def NewInstance(self):
        """
        V.NewInstance() -> vtkAppendCompositeDataLeaves
        C++: vtkAppendCompositeDataLeaves *NewInstance()
        """
        ...
    
    def SafeDownCast(self, vtkObjectBase):
        """
        V.SafeDownCast(vtkObjectBase) -> vtkAppendCompositeDataLeaves
        C++: static vtkAppendCompositeDataLeaves *SafeDownCast(
            vtkObjectBase *o)
        """
        ...
    
    def SetAppendFieldData(self, p_int):
        """
        V.SetAppendFieldData(int)
        C++: virtual void SetAppendFieldData(vtkTypeBool _arg)
        
        Set/get whether the field data of each dataset in the composite
        dataset is copied to the output. If AppendFieldData is non-zero,
        then field data arrays from all the inputs are added to the
        output. If there are duplicates, the array on the first input
        encountered is taken.
        """
        ...
    
    def __delattr__(self, *args, **kwargs):
        """ Implement delattr(self, name). """
        ...
    
    def __getattribute__(self, *args, **kwargs):
        """ Return getattr(self, name). """
        ...
    
    def __init__(self, *args, **kwargs) -> None:
        ...
    
    @staticmethod
    def __new__(*args, **kwargs):
        """ Create and return a new object.  See help(type) for accurate signature. """
        ...
    
    def __repr__(self, *args, **kwargs):
        """ Return repr(self). """
        ...
    
    def __setattr__(self, *args, **kwargs):
        """ Implement setattr(self, name, value). """
        ...
    
    def __str__(self, *args, **kwargs) -> str:
        """ Return str(self). """
        ...
    
    __this__ = ...
    __dict__ = ...
    __vtkname__ = ...


