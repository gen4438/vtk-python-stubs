"""
This type stub file was generated by pyright.
"""

import vtkmodules.vtkCommonCore as __vtkmodules_vtkCommonCore

class vtkStreamingTessellator(__vtkmodules_vtkCommonCore.vtkObject):
    """
    vtkStreamingTessellator - An algorithm that refines an initial
    simplicial tessellation using edge subdivision
    
    Superclass: vtkObject
    
    This class is a simple algorithm that takes a single starting simplex
    -- a tetrahedron, triangle, or line segment -- and calls a function
    you pass it with (possibly many times) tetrahedra, triangles, or
    lines adaptively sampled from the one you specified. It uses an
    algorithm you specify to control the level of adaptivity.
    
    This class does not create vtkUnstructuredGrid output because it is
    intended for use in mappers as well as filters. Instead, it calls the
    registered function with simplices as they are created.
    
    The subdivision algorithm should change the vertex coordinates (it
    must change both geometric and, if desired, parametric coordinates)
    of the midpoint. These coordinates need not be changed unless the
    EvaluateLocationAndFields() member returns true. The
    vtkStreamingTessellator itself has no way of creating a more accurate
    midpoint vertex.
    
    Here's how to use this class:
    - Call AdaptivelySample1Facet, AdaptivelySample2Facet, or
      AdaptivelySample3Facet, with an edge, triangle, or tetrahedron you
      want tessellated.
    - The adaptive tessellator classifies each edge by passing the
      midpoint values to the vtkEdgeSubdivisionCriterion.
    - After each edge is classified, the tessellator subdivides edges as
      required until the subdivision criterion is satisfied or the
      maximum subdivision depth has been reached.
    - Edges, triangles, or tetrahedra connecting the vertices generated
      by the subdivision algorithm are processed by calling the
      user-defined callback functions (set with SetTetrahedronCallback(),
    SetTriangleCallback(), or SetEdgeCallback() ).
    
    @warning
    Note that the vertices passed to AdaptivelySample3Facet,
    AdaptivelySample2Facet, or AdaptivelySample1Facet must be at least 6,
    5, or 4 entries long, respectively! This is because the
    &lt;r,s,t&gt;, &lt;r,s&gt;, or &lt;r&gt; parametric coordinates of
    the vertices are maintained as the facet is subdivided. This
    information is often required by the subdivision algorithm in order
    to compute an error metric. You may change the number of parametric
    coordinates associated with each vertex using
    vtkStreamingTessellator::SetEmbeddingDimension().
    
    @par Interpolating Field Values: If you wish, you may also use
    vtkStreamingTessellator to interpolate field values at newly created
    vertices. Interpolated field values are stored just beyond the
    parametric coordinates associated with a vertex. They will always be
    double values; it does not make sense to interpolate a boolean or
    string value and your output and subdivision subroutines may always
    cast to a float or use floor() to truncate an interpolated value to
    an integer.
    
    @sa
    vtkEdgeSubdivisionCriterion
    """
    def AdaptivelySample0Facet(self, *float):
        """
        V.AdaptivelySample0Facet([float, ...])
        C++: void AdaptivelySample0Facet(double *v0)
        
        This will adaptively subdivide the tetrahedron (3-facet),
        triangle (2-facet), or edge (1-facet) until the subdivision
        algorithm returns false for every edge or the maximum recursion
        depth is reached.
        
        * Use SetMaximumNumberOfSubdivisions to change the maximum
        * recursion depth.
        
        * The AdaptivelySample0Facet method is provided as a convenience.
        * Obviously, there is no way to adaptively subdivide a vertex.
        * Instead the input vertex is passed unchanged to the output
        * via a call to the registered VertexProcessorFunction callback.
        
        * .SECTION Warning
        * This assumes that you have called SetSubdivisionAlgorithm(),
        * SetEdgeCallback(), SetTriangleCallback(), and
          SetTetrahedronCallback()
        * with valid values!
        """
        ...
    
    def AdaptivelySample1Facet(self, *float, **kwargs):
        """
        V.AdaptivelySample1Facet([float, ...], [float, ...])
        C++: void AdaptivelySample1Facet(double *v0, double *v1)
        
        This will adaptively subdivide the tetrahedron (3-facet),
        triangle (2-facet), or edge (1-facet) until the subdivision
        algorithm returns false for every edge or the maximum recursion
        depth is reached.
        
        * Use SetMaximumNumberOfSubdivisions to change the maximum
        * recursion depth.
        
        * The AdaptivelySample0Facet method is provided as a convenience.
        * Obviously, there is no way to adaptively subdivide a vertex.
        * Instead the input vertex is passed unchanged to the output
        * via a call to the registered VertexProcessorFunction callback.
        
        * .SECTION Warning
        * This assumes that you have called SetSubdivisionAlgorithm(),
        * SetEdgeCallback(), SetTriangleCallback(), and
          SetTetrahedronCallback()
        * with valid values!
        """
        ...
    
    def AdaptivelySample2Facet(self, *float, **kwargs):
        """
        V.AdaptivelySample2Facet([float, ...], [float, ...], [float, ...])
        C++: void AdaptivelySample2Facet(double *v0, double *v1,
            double *v2)
        
        This will adaptively subdivide the tetrahedron (3-facet),
        triangle (2-facet), or edge (1-facet) until the subdivision
        algorithm returns false for every edge or the maximum recursion
        depth is reached.
        
        * Use SetMaximumNumberOfSubdivisions to change the maximum
        * recursion depth.
        
        * The AdaptivelySample0Facet method is provided as a convenience.
        * Obviously, there is no way to adaptively subdivide a vertex.
        * Instead the input vertex is passed unchanged to the output
        * via a call to the registered VertexProcessorFunction callback.
        
        * .SECTION Warning
        * This assumes that you have called SetSubdivisionAlgorithm(),
        * SetEdgeCallback(), SetTriangleCallback(), and
          SetTetrahedronCallback()
        * with valid values!
        """
        ...
    
    def AdaptivelySample3Facet(self, *float, **kwargs):
        """
        V.AdaptivelySample3Facet([float, ...], [float, ...], [float, ...],
             [float, ...])
        C++: void AdaptivelySample3Facet(double *v0, double *v1,
            double *v2, double *v3)
        
        This will adaptively subdivide the tetrahedron (3-facet),
        triangle (2-facet), or edge (1-facet) until the subdivision
        algorithm returns false for every edge or the maximum recursion
        depth is reached.
        
        * Use SetMaximumNumberOfSubdivisions to change the maximum
        * recursion depth.
        
        * The AdaptivelySample0Facet method is provided as a convenience.
        * Obviously, there is no way to adaptively subdivide a vertex.
        * Instead the input vertex is passed unchanged to the output
        * via a call to the registered VertexProcessorFunction callback.
        
        * .SECTION Warning
        * This assumes that you have called SetSubdivisionAlgorithm(),
        * SetEdgeCallback(), SetTriangleCallback(), and
          SetTetrahedronCallback()
        * with valid values!
        """
        ...
    
    def GetCaseCount(self, p_int):
        """
        V.GetCaseCount(int) -> int
        C++: vtkIdType GetCaseCount(int c)
        
        Reset/access the histogram of subdivision cases encountered. The
        histogram may be used to examine coverage during testing as well
        as characterizing the tessellation algorithm's performance. You
        should call ResetCounts() once, at the beginning of a stream of
        tetrahedra. It must be called before AdaptivelySample3Facet() to
        prevent uninitialized memory reads.
        
        * These functions have no effect (and return 0) when
          PARAVIEW_DEBUG_TESSELLATOR has not been defined.
        * By default, PARAVIEW_DEBUG_TESSELLATOR is not defined, and your
        code will be fast and efficient. Really!
        """
        ...
    
    def GetConstPrivateData(self):
        """
        V.GetConstPrivateData() -> void
        C++: virtual const void *GetConstPrivateData()
        
        Get/Set a constant void pointer passed to the simplex output
        functions.
        """
        ...
    
    def GetEmbeddingDimension(self, p_int):
        """
        V.GetEmbeddingDimension(int) -> int
        C++: int GetEmbeddingDimension(int k)
        
        Get/Set the number of parameter-space coordinates associated with
        each input and output point. The default is k for k -facets. You
        may specify a different dimension, d, for each type of k -facet
        to be processed. For example, SetEmbeddingDimension( 2, 3 ) would
        associate r, s, andt coordinates with each input and output point
        generated by AdaptivelySample2Facet but does not say anything
        about input or output points generated byAdaptivelySample1Facet.
        Call SetEmbeddingDimension( -1, d ) to specify the same dimension
        for all possible k values.d may not exceed 8, as that would be
        plain silly.
        """
        ...
    
    def GetFieldSize(self, p_int):
        """
        V.GetFieldSize(int) -> int
        C++: int GetFieldSize(int k)
        
        Get/Set the number of field value coordinates associated with
        each input and output point. The default is 0; no field values
        are interpolated. You may specify a different size, s, for each
        type of k -facet to be processed. For example, SetFieldSize( 2, 3
        ) would associate 3 field value coordinates with each input and
        output point of an AdaptivelySample2Facet call, but does not say
        anything about input or output points of AdaptivelySample1Facet.
        Call SetFieldSize( -1, s ) to specify the same dimension for all
        possible k values.s may not exceed
        vtkStreamingTessellator::MaxFieldSize. This is a compile-time
        constant that defaults to 18, which is large enough for a scalar,
        vector, tensor, normal, and texture coordinate to be included at
        each point.
        
        * Normally, you will not call SetFieldSize() directly; instead,
          subclasses of
        * vtkEdgeSubdivisionCriterion, such as
          vtkShoeMeshSubdivisionAlgorithm, will call it
        * for you.
        
        * In any event, setting FieldSize to a non-zero value means you
          must pass field
        * values to the AdaptivelySamplekFacet routines; For example,
        * 
         * vtkStreamingTessellator* t = vtkStreamingTessellator::New();
         * t->SetFieldSize( 1, 3 );
         * t->SetEmbeddingDimension( 1, 1 ); // not really required, this is the default
         * double p0[3+1+3] = { x0, y0, z0, r0, fx0, fy0, fz0 };
         * double p1[3+1+3] = { x1, y1, z1, r1, fx1, fy1, fz1 };
         * t->AdaptivelySample1Facet( p0, p1 );
         * 
        * This would adaptively sample an curve (1-facet) with geometry
          and
        * a vector field at every output point on the curve.
        """
        ...
    
    def GetMaximumNumberOfSubdivisions(self):
        """
        V.GetMaximumNumberOfSubdivisions() -> int
        C++: int GetMaximumNumberOfSubdivisions()
        
        Get/Set the maximum number of subdivisions that may occur.
        """
        ...
    
    def GetNumberOfGenerationsFromBase(self, string):
        """
        V.GetNumberOfGenerationsFromBase(string) -> int
        C++: vtkIdType GetNumberOfGenerationsFromBase(const char *type)
            override;
        
        Given a the name of a base class of this class type, return the
        distance of inheritance between this class type and the named
        class (how many generations of inheritance are there between this
        class and the named class). If the named class is not in this
        class's inheritance tree, return a negative value. Valid
        responses will always be nonnegative. This method works in
        combination with vtkTypeMacro found in vtkSetGet.h.
        """
        ...
    
    def GetNumberOfGenerationsFromBaseType(self, string):
        """
        V.GetNumberOfGenerationsFromBaseType(string) -> int
        C++: static vtkIdType GetNumberOfGenerationsFromBaseType(
            const char *type)
        
        Given a the name of a base class of this class type, return the
        distance of inheritance between this class type and the named
        class (how many generations of inheritance are there between this
        class and the named class). If the named class is not in this
        class's inheritance tree, return a negative value. Valid
        responses will always be nonnegative. This method works in
        combination with vtkTypeMacro found in vtkSetGet.h.
        """
        ...
    
    def GetPrivateData(self):
        """
        V.GetPrivateData() -> void
        C++: virtual void *GetPrivateData()
        
        Get/Set a void pointer passed to the triangle and edge output
        functions.
        """
        ...
    
    def GetSubcaseCount(self, p_int, p_int_1):
        """
        V.GetSubcaseCount(int, int) -> int
        C++: vtkIdType GetSubcaseCount(int casenum, int sub)
        
        Reset/access the histogram of subdivision cases encountered. The
        histogram may be used to examine coverage during testing as well
        as characterizing the tessellation algorithm's performance. You
        should call ResetCounts() once, at the beginning of a stream of
        tetrahedra. It must be called before AdaptivelySample3Facet() to
        prevent uninitialized memory reads.
        
        * These functions have no effect (and return 0) when
          PARAVIEW_DEBUG_TESSELLATOR has not been defined.
        * By default, PARAVIEW_DEBUG_TESSELLATOR is not defined, and your
        code will be fast and efficient. Really!
        """
        ...
    
    def GetSubdivisionAlgorithm(self):
        """
        V.GetSubdivisionAlgorithm() -> vtkEdgeSubdivisionCriterion
        C++: virtual vtkEdgeSubdivisionCriterion *GetSubdivisionAlgorithm(
            )
        
        Get/Set the algorithm used to determine whether an edge should be
        subdivided or left as-is. This is used once for each call to
        AdaptivelySample1Facet (which is recursive and will call itself
        resulting in additional edges to be checked) or three times for
        each call to AdaptivelySample2Facet (also recursive).
        """
        ...
    
    def IsA(self, string):
        """
        V.IsA(string) -> int
        C++: vtkTypeBool IsA(const char *type) override;
        
        Return 1 if this class is the same type of (or a subclass of) the
        named class. Returns 0 otherwise. This method works in
        combination with vtkTypeMacro found in vtkSetGet.h.
        """
        ...
    
    def IsTypeOf(self, string):
        """
        V.IsTypeOf(string) -> int
        C++: static vtkTypeBool IsTypeOf(const char *type)
        
        Return 1 if this class type is the same type of (or a subclass
        of) the named class. Returns 0 otherwise. This method works in
        combination with vtkTypeMacro found in vtkSetGet.h.
        """
        ...
    
    def NewInstance(self):
        """
        V.NewInstance() -> vtkStreamingTessellator
        C++: vtkStreamingTessellator *NewInstance()
        """
        ...
    
    def ResetCounts(self):
        """
        V.ResetCounts()
        C++: void ResetCounts()
        
        Reset/access the histogram of subdivision cases encountered. The
        histogram may be used to examine coverage during testing as well
        as characterizing the tessellation algorithm's performance. You
        should call ResetCounts() once, at the beginning of a stream of
        tetrahedra. It must be called before AdaptivelySample3Facet() to
        prevent uninitialized memory reads.
        
        * These functions have no effect (and return 0) when
          PARAVIEW_DEBUG_TESSELLATOR has not been defined.
        * By default, PARAVIEW_DEBUG_TESSELLATOR is not defined, and your
        code will be fast and efficient. Really!
        """
        ...
    
    def SafeDownCast(self, vtkObjectBase):
        """
        V.SafeDownCast(vtkObjectBase) -> vtkStreamingTessellator
        C++: static vtkStreamingTessellator *SafeDownCast(
            vtkObjectBase *o)
        """
        ...
    
    def SetConstPrivateData(self, void):
        """
        V.SetConstPrivateData(void)
        C++: virtual void SetConstPrivateData(const void *ConstPrivate)
        
        Get/Set a constant void pointer passed to the simplex output
        functions.
        """
        ...
    
    def SetEmbeddingDimension(self, p_int, p_int_1):
        """
        V.SetEmbeddingDimension(int, int)
        C++: virtual void SetEmbeddingDimension(int k, int d)
        
        Get/Set the number of parameter-space coordinates associated with
        each input and output point. The default is k for k -facets. You
        may specify a different dimension, d, for each type of k -facet
        to be processed. For example, SetEmbeddingDimension( 2, 3 ) would
        associate r, s, andt coordinates with each input and output point
        generated by AdaptivelySample2Facet but does not say anything
        about input or output points generated byAdaptivelySample1Facet.
        Call SetEmbeddingDimension( -1, d ) to specify the same dimension
        for all possible k values.d may not exceed 8, as that would be
        plain silly.
        """
        ...
    
    def SetFieldSize(self, p_int, p_int_1):
        """
        V.SetFieldSize(int, int)
        C++: virtual void SetFieldSize(int k, int s)
        
        Get/Set the number of field value coordinates associated with
        each input and output point. The default is 0; no field values
        are interpolated. You may specify a different size, s, for each
        type of k -facet to be processed. For example, SetFieldSize( 2, 3
        ) would associate 3 field value coordinates with each input and
        output point of an AdaptivelySample2Facet call, but does not say
        anything about input or output points of AdaptivelySample1Facet.
        Call SetFieldSize( -1, s ) to specify the same dimension for all
        possible k values.s may not exceed
        vtkStreamingTessellator::MaxFieldSize. This is a compile-time
        constant that defaults to 18, which is large enough for a scalar,
        vector, tensor, normal, and texture coordinate to be included at
        each point.
        
        * Normally, you will not call SetFieldSize() directly; instead,
          subclasses of
        * vtkEdgeSubdivisionCriterion, such as
          vtkShoeMeshSubdivisionAlgorithm, will call it
        * for you.
        
        * In any event, setting FieldSize to a non-zero value means you
          must pass field
        * values to the AdaptivelySamplekFacet routines; For example,
        * 
         * vtkStreamingTessellator* t = vtkStreamingTessellator::New();
         * t->SetFieldSize( 1, 3 );
         * t->SetEmbeddingDimension( 1, 1 ); // not really required, this is the default
         * double p0[3+1+3] = { x0, y0, z0, r0, fx0, fy0, fz0 };
         * double p1[3+1+3] = { x1, y1, z1, r1, fx1, fy1, fz1 };
         * t->AdaptivelySample1Facet( p0, p1 );
         * 
        * This would adaptively sample an curve (1-facet) with geometry
          and
        * a vector field at every output point on the curve.
        """
        ...
    
    def SetMaximumNumberOfSubdivisions(self, p_int):
        """
        V.SetMaximumNumberOfSubdivisions(int)
        C++: virtual void SetMaximumNumberOfSubdivisions(
            int num_subdiv_in)
        
        Get/Set the maximum number of subdivisions that may occur.
        """
        ...
    
    def SetPrivateData(self, void):
        """
        V.SetPrivateData(void)
        C++: virtual void SetPrivateData(void *Private)
        
        Get/Set a void pointer passed to the triangle and edge output
        functions.
        """
        ...
    
    def SetSubdivisionAlgorithm(self, vtkEdgeSubdivisionCriterion):
        """
        V.SetSubdivisionAlgorithm(vtkEdgeSubdivisionCriterion)
        C++: virtual void SetSubdivisionAlgorithm(
            vtkEdgeSubdivisionCriterion *)
        
        Get/Set the algorithm used to determine whether an edge should be
        subdivided or left as-is. This is used once for each call to
        AdaptivelySample1Facet (which is recursive and will call itself
        resulting in additional edges to be checked) or three times for
        each call to AdaptivelySample2Facet (also recursive).
        """
        ...
    
    def __delattr__(self, *args, **kwargs):
        """ Implement delattr(self, name). """
        ...
    
    def __getattribute__(self, *args, **kwargs):
        """ Return getattr(self, name). """
        ...
    
    def __init__(self, *args, **kwargs) -> None:
        ...
    
    @staticmethod
    def __new__(*args, **kwargs):
        """ Create and return a new object.  See help(type) for accurate signature. """
        ...
    
    def __repr__(self, *args, **kwargs):
        """ Return repr(self). """
        ...
    
    def __setattr__(self, *args, **kwargs):
        """ Implement setattr(self, name, value). """
        ...
    
    def __str__(self, *args, **kwargs) -> str:
        """ Return str(self). """
        ...
    
    __this__ = ...
    MaxFieldSize = ...
    __dict__ = ...
    __vtkname__ = ...


