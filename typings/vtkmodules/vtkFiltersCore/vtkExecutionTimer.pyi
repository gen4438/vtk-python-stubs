"""
This type stub file was generated by pyright.
"""

import vtkmodules.vtkCommonCore as __vtkmodules_vtkCommonCore

class vtkExecutionTimer(__vtkmodules_vtkCommonCore.vtkObject):
    """
    vtkExecutionTimer - Time filter execution
    
    Superclass: vtkObject
    
    This object monitors a single filter for StartEvent and EndEvent.
    Each time it hears StartEvent it records the time.  Each time it
    hears EndEvent it measures the elapsed time (both CPU and wall-clock)
    since the most recent StartEvent.  Internally we use vtkTimerLog for
    measurements.
    
    By default we simply store the elapsed time.  You are welcome to
    subclass and override TimerFinished() to do anything you want.
    """
    def GetElapsedCPUTime(self):
        """
        V.GetElapsedCPUTime() -> float
        C++: virtual double GetElapsedCPUTime()
        
        Get the total CPU time (in seconds) that elapsed between
        StartEvent and EndEvent.  This is undefined before the filter has
        finished executing.
        """
        ...
    
    def GetElapsedWallClockTime(self):
        """
        V.GetElapsedWallClockTime() -> float
        C++: virtual double GetElapsedWallClockTime()
        
        Get the total wall clock time (in seconds) that elapsed between
        StartEvent and EndEvent.  This is undefined before the filter has
        finished executing.
        """
        ...
    
    def GetFilter(self):
        """
        V.GetFilter() -> vtkAlgorithm
        C++: virtual vtkAlgorithm *GetFilter()
        
        Set/get the filter to be monitored.  The only real constraint
        here is that the vtkExecutive associated with the filter must
        fire StartEvent and EndEvent before and after the filter is
        executed.  All VTK executives should do this.
        """
        ...
    
    def GetNumberOfGenerationsFromBase(self, string):
        """
        V.GetNumberOfGenerationsFromBase(string) -> int
        C++: vtkIdType GetNumberOfGenerationsFromBase(const char *type)
            override;
        
        Given a the name of a base class of this class type, return the
        distance of inheritance between this class type and the named
        class (how many generations of inheritance are there between this
        class and the named class). If the named class is not in this
        class's inheritance tree, return a negative value. Valid
        responses will always be nonnegative. This method works in
        combination with vtkTypeMacro found in vtkSetGet.h.
        """
        ...
    
    def GetNumberOfGenerationsFromBaseType(self, string):
        """
        V.GetNumberOfGenerationsFromBaseType(string) -> int
        C++: static vtkIdType GetNumberOfGenerationsFromBaseType(
            const char *type)
        
        Given a the name of a base class of this class type, return the
        distance of inheritance between this class type and the named
        class (how many generations of inheritance are there between this
        class and the named class). If the named class is not in this
        class's inheritance tree, return a negative value. Valid
        responses will always be nonnegative. This method works in
        combination with vtkTypeMacro found in vtkSetGet.h.
        """
        ...
    
    def IsA(self, string):
        """
        V.IsA(string) -> int
        C++: vtkTypeBool IsA(const char *type) override;
        
        Return 1 if this class is the same type of (or a subclass of) the
        named class. Returns 0 otherwise. This method works in
        combination with vtkTypeMacro found in vtkSetGet.h.
        """
        ...
    
    def IsTypeOf(self, string):
        """
        V.IsTypeOf(string) -> int
        C++: static vtkTypeBool IsTypeOf(const char *type)
        
        Return 1 if this class type is the same type of (or a subclass
        of) the named class. Returns 0 otherwise. This method works in
        combination with vtkTypeMacro found in vtkSetGet.h.
        """
        ...
    
    def NewInstance(self):
        """
        V.NewInstance() -> vtkExecutionTimer
        C++: vtkExecutionTimer *NewInstance()
        """
        ...
    
    def SafeDownCast(self, vtkObjectBase):
        """
        V.SafeDownCast(vtkObjectBase) -> vtkExecutionTimer
        C++: static vtkExecutionTimer *SafeDownCast(vtkObjectBase *o)
        """
        ...
    
    def SetFilter(self, vtkAlgorithm):
        """
        V.SetFilter(vtkAlgorithm)
        C++: void SetFilter(vtkAlgorithm *filter)
        
        Set/get the filter to be monitored.  The only real constraint
        here is that the vtkExecutive associated with the filter must
        fire StartEvent and EndEvent before and after the filter is
        executed.  All VTK executives should do this.
        """
        ...
    
    def __delattr__(self, *args, **kwargs):
        """ Implement delattr(self, name). """
        ...
    
    def __getattribute__(self, *args, **kwargs):
        """ Return getattr(self, name). """
        ...
    
    def __init__(self, *args, **kwargs) -> None:
        ...
    
    @staticmethod
    def __new__(*args, **kwargs):
        """ Create and return a new object.  See help(type) for accurate signature. """
        ...
    
    def __repr__(self, *args, **kwargs):
        """ Return repr(self). """
        ...
    
    def __setattr__(self, *args, **kwargs):
        """ Implement setattr(self, name, value). """
        ...
    
    def __str__(self, *args, **kwargs) -> str:
        """ Return str(self). """
        ...
    
    __this__ = ...
    __dict__ = ...
    __vtkname__ = ...


