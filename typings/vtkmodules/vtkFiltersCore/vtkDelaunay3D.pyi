"""
This type stub file was generated by pyright.
"""

import vtkmodules.vtkCommonExecutionModel as __vtkmodules_vtkCommonExecutionModel

class vtkDelaunay3D(__vtkmodules_vtkCommonExecutionModel.vtkUnstructuredGridAlgorithm):
    """
    vtkDelaunay3D - create 3D Delaunay triangulation of input points
    
    Superclass: vtkUnstructuredGridAlgorithm
    
    vtkDelaunay3D is a filter that constructs a 3D Delaunay triangulation
    from a list of input points. These points may be represented by any
    dataset of type vtkPointSet and subclasses. The output of the filter
    is an unstructured grid dataset. Usually the output is a tetrahedral
    mesh, but if a non-zero alpha distance value is specified (called the
    "alpha" value), then only tetrahedra, triangles, edges, and vertices
    laying within the alpha radius are output. In other words, non-zero
    alpha values may result in arbitrary combinations of tetrahedra,
    triangles, lines, and vertices. (The notion of alpha value is derived
    from Edelsbrunner's work on "alpha shapes".) Note that a modification
    to alpha shapes enables output of combinations of tetrahedra,
    triangles, lines, and/or verts (see the boolean ivars AlphaTets,
    AlphaTris, AlphaLines, AlphaVerts).
    
    The 3D Delaunay triangulation is defined as the triangulation that
    satisfies the Delaunay criterion for n-dimensional simplexes (in this
    case n=3 and the simplexes are tetrahedra). This criterion states
    that a circumsphere of each simplex in a triangulation contains only
    the n+1 defining points of the simplex. (See text for more
    information.) While in two dimensions this translates into an
    "optimal" triangulation, this is not true in 3D, since a measurement
    for optimality in 3D is not agreed on.
    
    Delaunay triangulations are used to build topological structures from
    unorganized (or unstructured) points. The input to this filter is a
    list of points specified in 3D. (If you wish to create 2D
    triangulations see vtkDelaunay2D.) The output is an unstructured
    grid.
    
    The Delaunay triangulation can be numerically sensitive. To prevent
    problems, try to avoid injecting points that will result in triangles
    with bad aspect ratios (1000:1 or greater). In practice this means
    inserting points that are "widely dispersed", and enables smooth
    transition of triangle sizes throughout the mesh. (You may even want
    to add extra points to create a better point distribution.) If
    numerical problems are present, you will see a warning message to
    this effect at the end of the triangulation process.
    
    @warning
    Points arranged on a regular lattice (termed degenerate cases) can be
    triangulated in more than one way (at least according to the Delaunay
    criterion). The choice of triangulation (as implemented by this
    algorithm) depends on the order of the input points. The first four
    points will form a tetrahedron; other degenerate points (relative to
    this initial tetrahedron) will not break it.
    
    @warning
    Points that are coincident (or nearly so) may be discarded by the
    algorithm.  This is because the Delaunay triangulation requires
    unique input points.  You can control the definition of coincidence
    with the "Tolerance" instance variable.
    
    @warning
    The output of the Delaunay triangulation is supposedly a convex hull.
    In certain cases this implementation may not generate the convex
    hull. This behavior can be controlled by the Offset instance
    variable. Offset is a multiplier used to control the size of the
    initial triangulation. The larger the offset value, the more likely
    you will generate a convex hull; and the more likely you are to see
    numerical problems.
    
    @warning
    The implementation of this algorithm varies from the 2D Delaunay
    algorithm (i.e., vtkDelaunay2D) in an important way. When points are
    injected into the triangulation, the search for the enclosing
    tetrahedron is quite different. In the 3D case, the closest
    previously inserted point point is found, and then the connected
    tetrahedra are searched to find the containing one. (In 2D, a "walk"
    towards the enclosing triangle is performed.) If the triangulation is
    Delaunay, then an enclosing tetrahedron will be found. However, in
    degenerate cases an enclosing tetrahedron may not be found and the
    point will be rejected.
    
    @sa
    vtkDelaunay2D vtkGaussianSplatter vtkUnstructuredGrid
    """
    def AlphaLinesOff(self):
        """
        V.AlphaLinesOff()
        C++: virtual void AlphaLinesOff()
        
        Boolean controls whether lines are output for non-zero alpha
        values.
        """
        ...
    
    def AlphaLinesOn(self):
        """
        V.AlphaLinesOn()
        C++: virtual void AlphaLinesOn()
        
        Boolean controls whether lines are output for non-zero alpha
        values.
        """
        ...
    
    def AlphaTetsOff(self):
        """
        V.AlphaTetsOff()
        C++: virtual void AlphaTetsOff()
        
        Boolean controls whether tetrahedra are output for non-zero alpha
        values.
        """
        ...
    
    def AlphaTetsOn(self):
        """
        V.AlphaTetsOn()
        C++: virtual void AlphaTetsOn()
        
        Boolean controls whether tetrahedra are output for non-zero alpha
        values.
        """
        ...
    
    def AlphaTrisOff(self):
        """
        V.AlphaTrisOff()
        C++: virtual void AlphaTrisOff()
        
        Boolean controls whether triangles are output for non-zero alpha
        values.
        """
        ...
    
    def AlphaTrisOn(self):
        """
        V.AlphaTrisOn()
        C++: virtual void AlphaTrisOn()
        
        Boolean controls whether triangles are output for non-zero alpha
        values.
        """
        ...
    
    def AlphaVertsOff(self):
        """
        V.AlphaVertsOff()
        C++: virtual void AlphaVertsOff()
        
        Boolean controls whether vertices are output for non-zero alpha
        values.
        """
        ...
    
    def AlphaVertsOn(self):
        """
        V.AlphaVertsOn()
        C++: virtual void AlphaVertsOn()
        
        Boolean controls whether vertices are output for non-zero alpha
        values.
        """
        ...
    
    def BoundingTriangulationOff(self):
        """
        V.BoundingTriangulationOff()
        C++: virtual void BoundingTriangulationOff()
        
        Boolean controls whether bounding triangulation points (and
        associated triangles) are included in the output. (These are
        introduced as an initial triangulation to begin the triangulation
        process. This feature is nice for debugging output.)
        """
        ...
    
    def BoundingTriangulationOn(self):
        """
        V.BoundingTriangulationOn()
        C++: virtual void BoundingTriangulationOn()
        
        Boolean controls whether bounding triangulation points (and
        associated triangles) are included in the output. (These are
        introduced as an initial triangulation to begin the triangulation
        process. This feature is nice for debugging output.)
        """
        ...
    
    def CreateDefaultLocator(self):
        """
        V.CreateDefaultLocator()
        C++: void CreateDefaultLocator()
        
        Create default locator. Used to create one when none is
        specified. The locator is used to eliminate "coincident" points.
        """
        ...
    
    def EndPointInsertion(self):
        """
        V.EndPointInsertion()
        C++: void EndPointInsertion()
        
        Invoke this method after all points have been inserted. The
        purpose of the method is to clean up internal data structures.
        Note that the (vtkUnstructuredGrid *)Mesh returned from
        InitPointInsertion() is NOT deleted, you still are responsible
        for cleaning that up.
        """
        ...
    
    def GetAlpha(self):
        """
        V.GetAlpha() -> float
        C++: virtual double GetAlpha()
        
        Specify alpha (or distance) value to control output of this
        filter.  For a non-zero alpha value, only verts, edges, faces, or
        tetra contained within the circumsphere (of radius alpha) will be
        output. Otherwise, only tetrahedra will be output. Note that the
        flags AlphaTets, AlphaTris, AlphaLines, and AlphaVerts control
        whether these primitives are output when Alpha is non-zero. (By
        default all tets, triangles, lines and verts satisfying the alpha
        shape criterion are output.)
        """
        ...
    
    def GetAlphaLines(self):
        """
        V.GetAlphaLines() -> int
        C++: virtual vtkTypeBool GetAlphaLines()
        
        Boolean controls whether lines are output for non-zero alpha
        values.
        """
        ...
    
    def GetAlphaMaxValue(self):
        """
        V.GetAlphaMaxValue() -> float
        C++: virtual double GetAlphaMaxValue()
        
        Specify alpha (or distance) value to control output of this
        filter.  For a non-zero alpha value, only verts, edges, faces, or
        tetra contained within the circumsphere (of radius alpha) will be
        output. Otherwise, only tetrahedra will be output. Note that the
        flags AlphaTets, AlphaTris, AlphaLines, and AlphaVerts control
        whether these primitives are output when Alpha is non-zero. (By
        default all tets, triangles, lines and verts satisfying the alpha
        shape criterion are output.)
        """
        ...
    
    def GetAlphaMinValue(self):
        """
        V.GetAlphaMinValue() -> float
        C++: virtual double GetAlphaMinValue()
        
        Specify alpha (or distance) value to control output of this
        filter.  For a non-zero alpha value, only verts, edges, faces, or
        tetra contained within the circumsphere (of radius alpha) will be
        output. Otherwise, only tetrahedra will be output. Note that the
        flags AlphaTets, AlphaTris, AlphaLines, and AlphaVerts control
        whether these primitives are output when Alpha is non-zero. (By
        default all tets, triangles, lines and verts satisfying the alpha
        shape criterion are output.)
        """
        ...
    
    def GetAlphaTets(self):
        """
        V.GetAlphaTets() -> int
        C++: virtual vtkTypeBool GetAlphaTets()
        
        Boolean controls whether tetrahedra are output for non-zero alpha
        values.
        """
        ...
    
    def GetAlphaTris(self):
        """
        V.GetAlphaTris() -> int
        C++: virtual vtkTypeBool GetAlphaTris()
        
        Boolean controls whether triangles are output for non-zero alpha
        values.
        """
        ...
    
    def GetAlphaVerts(self):
        """
        V.GetAlphaVerts() -> int
        C++: virtual vtkTypeBool GetAlphaVerts()
        
        Boolean controls whether vertices are output for non-zero alpha
        values.
        """
        ...
    
    def GetBoundingTriangulation(self):
        """
        V.GetBoundingTriangulation() -> int
        C++: virtual vtkTypeBool GetBoundingTriangulation()
        
        Boolean controls whether bounding triangulation points (and
        associated triangles) are included in the output. (These are
        introduced as an initial triangulation to begin the triangulation
        process. This feature is nice for debugging output.)
        """
        ...
    
    def GetLocator(self):
        """
        V.GetLocator() -> vtkIncrementalPointLocator
        C++: virtual vtkIncrementalPointLocator *GetLocator()
        
        Set / get a spatial locator for merging points. By default, an
        instance of vtkPointLocator is used.
        """
        ...
    
    def GetMTime(self):
        """
        V.GetMTime() -> int
        C++: vtkMTimeType GetMTime() override;
        
        Return the MTime also considering the locator.
        """
        ...
    
    def GetNumberOfGenerationsFromBase(self, string):
        """
        V.GetNumberOfGenerationsFromBase(string) -> int
        C++: vtkIdType GetNumberOfGenerationsFromBase(const char *type)
            override;
        
        Given a the name of a base class of this class type, return the
        distance of inheritance between this class type and the named
        class (how many generations of inheritance are there between this
        class and the named class). If the named class is not in this
        class's inheritance tree, return a negative value. Valid
        responses will always be nonnegative. This method works in
        combination with vtkTypeMacro found in vtkSetGet.h.
        """
        ...
    
    def GetNumberOfGenerationsFromBaseType(self, string):
        """
        V.GetNumberOfGenerationsFromBaseType(string) -> int
        C++: static vtkIdType GetNumberOfGenerationsFromBaseType(
            const char *type)
        
        Given a the name of a base class of this class type, return the
        distance of inheritance between this class type and the named
        class (how many generations of inheritance are there between this
        class and the named class). If the named class is not in this
        class's inheritance tree, return a negative value. Valid
        responses will always be nonnegative. This method works in
        combination with vtkTypeMacro found in vtkSetGet.h.
        """
        ...
    
    def GetOffset(self):
        """
        V.GetOffset() -> float
        C++: virtual double GetOffset()
        
        Specify a multiplier to control the size of the initial, bounding
        Delaunay triangulation.
        """
        ...
    
    def GetOffsetMaxValue(self):
        """
        V.GetOffsetMaxValue() -> float
        C++: virtual double GetOffsetMaxValue()
        
        Specify a multiplier to control the size of the initial, bounding
        Delaunay triangulation.
        """
        ...
    
    def GetOffsetMinValue(self):
        """
        V.GetOffsetMinValue() -> float
        C++: virtual double GetOffsetMinValue()
        
        Specify a multiplier to control the size of the initial, bounding
        Delaunay triangulation.
        """
        ...
    
    def GetOutputPointsPrecision(self):
        """
        V.GetOutputPointsPrecision() -> int
        C++: virtual int GetOutputPointsPrecision()
        
        Set/get the desired precision for the output types. See the
        documentation for the vtkAlgorithm::DesiredOutputPrecision enum
        for an explanation of the available precision settings.
        """
        ...
    
    def GetTolerance(self):
        """
        V.GetTolerance() -> float
        C++: virtual double GetTolerance()
        
        Specify a tolerance to control discarding of closely spaced
        points. This tolerance is specified as a fraction of the diagonal
        length of the bounding box of the points.
        """
        ...
    
    def GetToleranceMaxValue(self):
        """
        V.GetToleranceMaxValue() -> float
        C++: virtual double GetToleranceMaxValue()
        
        Specify a tolerance to control discarding of closely spaced
        points. This tolerance is specified as a fraction of the diagonal
        length of the bounding box of the points.
        """
        ...
    
    def GetToleranceMinValue(self):
        """
        V.GetToleranceMinValue() -> float
        C++: virtual double GetToleranceMinValue()
        
        Specify a tolerance to control discarding of closely spaced
        points. This tolerance is specified as a fraction of the diagonal
        length of the bounding box of the points.
        """
        ...
    
    def InsertPoint(self, vtkUnstructuredGrid, vtkPoints, p_int, p_float=..., p_float=..., p_float=..., *args, **kwargs):
        """
        V.InsertPoint(vtkUnstructuredGrid, vtkPoints, int, [float, float,
            float], vtkIdList)
        C++: void InsertPoint(vtkUnstructuredGrid *Mesh,
            vtkPoints *points, vtkIdType id, double x[3],
            vtkIdList *holeTetras)
        
        This is a helper method used with InitPointInsertion() to create
        tetrahedronalizations of points. Its purpose is to inject point
        at coordinates specified into tetrahedronalization. The point id
        is an index into the list of points in the mesh structure.  (See
        vtkDelaunay3D::InitPointInsertion() for more information.)  When
        you have completed inserting points, traverse the mesh structure
        to extract desired tetrahedra (or tetra faces and edges).The
        holeTetras id list lists all the tetrahedra that are deleted
        (invalid) in the mesh structure.
        """
        ...
    
    def IsA(self, string):
        """
        V.IsA(string) -> int
        C++: vtkTypeBool IsA(const char *type) override;
        
        Return 1 if this class is the same type of (or a subclass of) the
        named class. Returns 0 otherwise. This method works in
        combination with vtkTypeMacro found in vtkSetGet.h.
        """
        ...
    
    def IsTypeOf(self, string):
        """
        V.IsTypeOf(string) -> int
        C++: static vtkTypeBool IsTypeOf(const char *type)
        
        Return 1 if this class type is the same type of (or a subclass
        of) the named class. Returns 0 otherwise. This method works in
        combination with vtkTypeMacro found in vtkSetGet.h.
        """
        ...
    
    def NewInstance(self):
        """
        V.NewInstance() -> vtkDelaunay3D
        C++: vtkDelaunay3D *NewInstance()
        """
        ...
    
    def SafeDownCast(self, vtkObjectBase):
        """
        V.SafeDownCast(vtkObjectBase) -> vtkDelaunay3D
        C++: static vtkDelaunay3D *SafeDownCast(vtkObjectBase *o)
        """
        ...
    
    def SetAlpha(self, p_float):
        """
        V.SetAlpha(float)
        C++: virtual void SetAlpha(double _arg)
        
        Specify alpha (or distance) value to control output of this
        filter.  For a non-zero alpha value, only verts, edges, faces, or
        tetra contained within the circumsphere (of radius alpha) will be
        output. Otherwise, only tetrahedra will be output. Note that the
        flags AlphaTets, AlphaTris, AlphaLines, and AlphaVerts control
        whether these primitives are output when Alpha is non-zero. (By
        default all tets, triangles, lines and verts satisfying the alpha
        shape criterion are output.)
        """
        ...
    
    def SetAlphaLines(self, p_int):
        """
        V.SetAlphaLines(int)
        C++: virtual void SetAlphaLines(vtkTypeBool _arg)
        
        Boolean controls whether lines are output for non-zero alpha
        values.
        """
        ...
    
    def SetAlphaTets(self, p_int):
        """
        V.SetAlphaTets(int)
        C++: virtual void SetAlphaTets(vtkTypeBool _arg)
        
        Boolean controls whether tetrahedra are output for non-zero alpha
        values.
        """
        ...
    
    def SetAlphaTris(self, p_int):
        """
        V.SetAlphaTris(int)
        C++: virtual void SetAlphaTris(vtkTypeBool _arg)
        
        Boolean controls whether triangles are output for non-zero alpha
        values.
        """
        ...
    
    def SetAlphaVerts(self, p_int):
        """
        V.SetAlphaVerts(int)
        C++: virtual void SetAlphaVerts(vtkTypeBool _arg)
        
        Boolean controls whether vertices are output for non-zero alpha
        values.
        """
        ...
    
    def SetBoundingTriangulation(self, p_int):
        """
        V.SetBoundingTriangulation(int)
        C++: virtual void SetBoundingTriangulation(vtkTypeBool _arg)
        
        Boolean controls whether bounding triangulation points (and
        associated triangles) are included in the output. (These are
        introduced as an initial triangulation to begin the triangulation
        process. This feature is nice for debugging output.)
        """
        ...
    
    def SetLocator(self, vtkIncrementalPointLocator):
        """
        V.SetLocator(vtkIncrementalPointLocator)
        C++: void SetLocator(vtkIncrementalPointLocator *locator)
        
        Set / get a spatial locator for merging points. By default, an
        instance of vtkPointLocator is used.
        """
        ...
    
    def SetOffset(self, p_float):
        """
        V.SetOffset(float)
        C++: virtual void SetOffset(double _arg)
        
        Specify a multiplier to control the size of the initial, bounding
        Delaunay triangulation.
        """
        ...
    
    def SetOutputPointsPrecision(self, p_int):
        """
        V.SetOutputPointsPrecision(int)
        C++: virtual void SetOutputPointsPrecision(int _arg)
        
        Set/get the desired precision for the output types. See the
        documentation for the vtkAlgorithm::DesiredOutputPrecision enum
        for an explanation of the available precision settings.
        """
        ...
    
    def SetTolerance(self, p_float):
        """
        V.SetTolerance(float)
        C++: virtual void SetTolerance(double _arg)
        
        Specify a tolerance to control discarding of closely spaced
        points. This tolerance is specified as a fraction of the diagonal
        length of the bounding box of the points.
        """
        ...
    
    def __delattr__(self, *args, **kwargs):
        """ Implement delattr(self, name). """
        ...
    
    def __getattribute__(self, *args, **kwargs):
        """ Return getattr(self, name). """
        ...
    
    def __init__(self, *args, **kwargs) -> None:
        ...
    
    @staticmethod
    def __new__(*args, **kwargs):
        """ Create and return a new object.  See help(type) for accurate signature. """
        ...
    
    def __repr__(self, *args, **kwargs):
        """ Return repr(self). """
        ...
    
    def __setattr__(self, *args, **kwargs):
        """ Implement setattr(self, name, value). """
        ...
    
    def __str__(self, *args, **kwargs) -> str:
        """ Return str(self). """
        ...
    
    __this__ = ...
    __dict__ = ...
    __vtkname__ = ...


