"""
This type stub file was generated by pyright.
"""

import vtkmodules.vtkCommonExecutionModel as __vtkmodules_vtkCommonExecutionModel

VTK_COLOR_BY_INPUT = ...
VTK_COLOR_BY_SOURCE = ...
class vtkProgrammableAttributeDataFilter(__vtkmodules_vtkCommonExecutionModel.vtkDataSetAlgorithm):
    """
    vtkProgrammableAttributeDataFilter - manipulate attribute (cell and
    point) data via a user-specified function
    
    Superclass: vtkDataSetAlgorithm
    
    vtkProgrammableAttributeDataFilter is a filter that allows you to
    write a custom procedure to manipulate attribute data - either point
    or cell data. For example, you could generate scalars based on a
    complex formula; convert vectors to normals; compute scalar values as
    a function of vectors, texture coords, and/or any other point data
    attribute; and so on. The filter takes multiple inputs (input plus an
    auxiliary input list), so you can write procedures that combine
    several dataset point attributes. Note that the output of the filter
    is the same type (topology/geometry) as the input.
    
    The filter works as follows. It operates like any other filter (i.e.,
    checking and managing modified and execution times, processing
    Update() and Execute() methods, managing release of data, etc.), but
    the difference is that the Execute() method simply invokes a
    user-specified function with an optional (void *) argument (typically
    the "this" pointer in C++). It is also possible to specify a function
    to delete the argument via ExecuteMethodArgDelete().
    
    To use the filter, you write a procedure to process the input
    datasets, process the data, and generate output data. Typically, this
    means grabbing the input point or cell data (using GetInput() and
    maybe GetInputList()), operating on it (creating new point and cell
    attributes such as scalars, vectors, etc.), and then setting the
    point and/or cell attributes in the output dataset (you'll need to
    use GetOutput() to access the output). (Note: besides C++, it is
    possible to do the same thing in Java or other languages that wrap
    the C++ core.) Remember, proper filter protocol requires that you
    don't modify the input data - you create new output data from the
    input.
    
    @warning
    This filter operates on any combination of the filter input plus a
    list of additional inputs (at a minimum you must set the filter input
    via SetInput()).  It is up to you check whether the input is valid,
    and to insure that the output is valid. Also, you have to write the
    control structure for the traversal and operation on the point and
    cell attribute data.
    
    @warning
    By default the output point and cell data will be copied through from
    the input point data (using reference counting).  You can control
    this using the output's CopyAllOff() flag, or by using individual
    flags for each point data field (i.e., scalars, vectors, etc.)
    
    @warning
    The output of this filter is the abstract type vtkDataSet, even if
    your input is a concrete type like vtkPolyData. Thus you may need to
    use vtkCastToConcrete to obtain the output as a particular concrete
    type, or one of the special methods of the superclass (e.g.,
    vtkDataSetAlgorithm::GetPolyDataOutput) to retrieve output of the
    correct type.
    
    @warning
    The filter correctly manages modified time and network execution in
    most cases. However, if you change the definition of the filter
    function, you'll want to send a manual Modified() method to the
    filter to force it to reexecute.
    """
    def AddInput(self, vtkDataSet):
        """
        V.AddInput(vtkDataSet)
        C++: void AddInput(vtkDataSet *in)
        
        Add a dataset to the list of data to process.
        """
        ...
    
    def GetInputList(self):
        """
        V.GetInputList() -> vtkDataSetCollection
        C++: vtkDataSetCollection *GetInputList()
        
        Return the list of inputs.
        """
        ...
    
    def GetNumberOfGenerationsFromBase(self, string):
        """
        V.GetNumberOfGenerationsFromBase(string) -> int
        C++: vtkIdType GetNumberOfGenerationsFromBase(const char *type)
            override;
        
        Given a the name of a base class of this class type, return the
        distance of inheritance between this class type and the named
        class (how many generations of inheritance are there between this
        class and the named class). If the named class is not in this
        class's inheritance tree, return a negative value. Valid
        responses will always be nonnegative. This method works in
        combination with vtkTypeMacro found in vtkSetGet.h.
        """
        ...
    
    def GetNumberOfGenerationsFromBaseType(self, string):
        """
        V.GetNumberOfGenerationsFromBaseType(string) -> int
        C++: static vtkIdType GetNumberOfGenerationsFromBaseType(
            const char *type)
        
        Given a the name of a base class of this class type, return the
        distance of inheritance between this class type and the named
        class (how many generations of inheritance are there between this
        class and the named class). If the named class is not in this
        class's inheritance tree, return a negative value. Valid
        responses will always be nonnegative. This method works in
        combination with vtkTypeMacro found in vtkSetGet.h.
        """
        ...
    
    def IsA(self, string):
        """
        V.IsA(string) -> int
        C++: vtkTypeBool IsA(const char *type) override;
        
        Return 1 if this class is the same type of (or a subclass of) the
        named class. Returns 0 otherwise. This method works in
        combination with vtkTypeMacro found in vtkSetGet.h.
        """
        ...
    
    def IsTypeOf(self, string):
        """
        V.IsTypeOf(string) -> int
        C++: static vtkTypeBool IsTypeOf(const char *type)
        
        Return 1 if this class type is the same type of (or a subclass
        of) the named class. Returns 0 otherwise. This method works in
        combination with vtkTypeMacro found in vtkSetGet.h.
        """
        ...
    
    def NewInstance(self):
        """
        V.NewInstance() -> vtkProgrammableAttributeDataFilter
        C++: vtkProgrammableAttributeDataFilter *NewInstance()
        """
        ...
    
    def RemoveInput(self, vtkDataSet):
        """
        V.RemoveInput(vtkDataSet)
        C++: void RemoveInput(vtkDataSet *in)
        
        Remove a dataset from the list of data to process.
        """
        ...
    
    def SafeDownCast(self, vtkObjectBase):
        """
        V.SafeDownCast(vtkObjectBase)
            -> vtkProgrammableAttributeDataFilter
        C++: static vtkProgrammableAttributeDataFilter *SafeDownCast(
            vtkObjectBase *o)
        """
        ...
    
    def SetExecuteMethod(self, function):
        """
        V.SetExecuteMethod(function)
        C++: void SetExecuteMethod(void (*f)(void *), void *arg)
        
        Specify the function to use to operate on the point attribute
        data. Note that the function takes a single (void *) argument.
        """
        ...
    
    def __delattr__(self, *args, **kwargs):
        """ Implement delattr(self, name). """
        ...
    
    def __getattribute__(self, *args, **kwargs):
        """ Return getattr(self, name). """
        ...
    
    def __init__(self, *args, **kwargs) -> None:
        ...
    
    @staticmethod
    def __new__(*args, **kwargs):
        """ Create and return a new object.  See help(type) for accurate signature. """
        ...
    
    def __repr__(self, *args, **kwargs):
        """ Return repr(self). """
        ...
    
    def __setattr__(self, *args, **kwargs):
        """ Implement setattr(self, name, value). """
        ...
    
    def __str__(self, *args, **kwargs) -> str:
        """ Return str(self). """
        ...
    
    __this__ = ...
    __dict__ = ...
    __vtkname__ = ...


class vtkProgrammableFilter(__vtkmodules_vtkCommonExecutionModel.vtkPassInputTypeAlgorithm):
    """
    vtkProgrammableFilter - a user-programmable filter
    
    Superclass: vtkPassInputTypeAlgorithm
    
    vtkProgrammableFilter is a filter that can be programmed by the user.
     To use the filter you define a function that retrieves input of the
    correct type, creates data, and then manipulates the output of the
    filter.  Using this filter avoids the need for subclassing - and the
    function can be defined in an interpreter wrapper language such as
    Java.
    
    The trickiest part of using this filter is that the input and output
    methods are unusual and cannot be compile-time type checked. Instead,
    as a user of this filter it is your responsibility to set and get the
    correct input and output types.
    
    @warning
    The filter correctly manages modified time and network execution in
    most cases. However, if you change the definition of the filter
    function, you'll want to send a manual Modified() method to the
    filter to force it to reexecute.
    
    @sa
    vtkProgrammablePointDataFilter vtkProgrammableSource
    """
    def CopyArraysOff(self):
        """
        V.CopyArraysOff()
        C++: virtual void CopyArraysOff()
        
        When CopyArrays is true, all arrays are copied to the output iff
        input and output are of the same type. False by default.
        """
        ...
    
    def CopyArraysOn(self):
        """
        V.CopyArraysOn()
        C++: virtual void CopyArraysOn()
        
        When CopyArrays is true, all arrays are copied to the output iff
        input and output are of the same type. False by default.
        """
        ...
    
    def GetCopyArrays(self):
        """
        V.GetCopyArrays() -> bool
        C++: virtual bool GetCopyArrays()
        
        When CopyArrays is true, all arrays are copied to the output iff
        input and output are of the same type. False by default.
        """
        ...
    
    def GetGraphInput(self):
        """
        V.GetGraphInput() -> vtkGraph
        C++: vtkGraph *GetGraphInput()
        
        Get the input as a concrete type. This method is typically used
        by the writer of the filter function to get the input as a
        particular type (i.e., it essentially does type casting). It is
        the users responsibility to know the correct type of the input
        data.
        """
        ...
    
    def GetMoleculeInput(self):
        """
        V.GetMoleculeInput() -> vtkMolecule
        C++: vtkMolecule *GetMoleculeInput()
        
        Get the input as a concrete type. This method is typically used
        by the writer of the filter function to get the input as a
        particular type (i.e., it essentially does type casting). It is
        the users responsibility to know the correct type of the input
        data.
        """
        ...
    
    def GetNumberOfGenerationsFromBase(self, string):
        """
        V.GetNumberOfGenerationsFromBase(string) -> int
        C++: vtkIdType GetNumberOfGenerationsFromBase(const char *type)
            override;
        
        Given a the name of a base class of this class type, return the
        distance of inheritance between this class type and the named
        class (how many generations of inheritance are there between this
        class and the named class). If the named class is not in this
        class's inheritance tree, return a negative value. Valid
        responses will always be nonnegative. This method works in
        combination with vtkTypeMacro found in vtkSetGet.h.
        """
        ...
    
    def GetNumberOfGenerationsFromBaseType(self, string):
        """
        V.GetNumberOfGenerationsFromBaseType(string) -> int
        C++: static vtkIdType GetNumberOfGenerationsFromBaseType(
            const char *type)
        
        Given a the name of a base class of this class type, return the
        distance of inheritance between this class type and the named
        class (how many generations of inheritance are there between this
        class and the named class). If the named class is not in this
        class's inheritance tree, return a negative value. Valid
        responses will always be nonnegative. This method works in
        combination with vtkTypeMacro found in vtkSetGet.h.
        """
        ...
    
    def GetPolyDataInput(self):
        """
        V.GetPolyDataInput() -> vtkPolyData
        C++: vtkPolyData *GetPolyDataInput()
        
        Get the input as a concrete type. This method is typically used
        by the writer of the filter function to get the input as a
        particular type (i.e., it essentially does type casting). It is
        the users responsibility to know the correct type of the input
        data.
        """
        ...
    
    def GetRectilinearGridInput(self):
        """
        V.GetRectilinearGridInput() -> vtkRectilinearGrid
        C++: vtkRectilinearGrid *GetRectilinearGridInput()
        
        Get the input as a concrete type. This method is typically used
        by the writer of the filter function to get the input as a
        particular type (i.e., it essentially does type casting). It is
        the users responsibility to know the correct type of the input
        data.
        """
        ...
    
    def GetStructuredGridInput(self):
        """
        V.GetStructuredGridInput() -> vtkStructuredGrid
        C++: vtkStructuredGrid *GetStructuredGridInput()
        
        Get the input as a concrete type. This method is typically used
        by the writer of the filter function to get the input as a
        particular type (i.e., it essentially does type casting). It is
        the users responsibility to know the correct type of the input
        data.
        """
        ...
    
    def GetStructuredPointsInput(self):
        """
        V.GetStructuredPointsInput() -> vtkStructuredPoints
        C++: vtkStructuredPoints *GetStructuredPointsInput()
        
        Get the input as a concrete type. This method is typically used
        by the writer of the filter function to get the input as a
        particular type (i.e., it essentially does type casting). It is
        the users responsibility to know the correct type of the input
        data.
        """
        ...
    
    def GetTableInput(self):
        """
        V.GetTableInput() -> vtkTable
        C++: vtkTable *GetTableInput()
        
        Get the input as a concrete type. This method is typically used
        by the writer of the filter function to get the input as a
        particular type (i.e., it essentially does type casting). It is
        the users responsibility to know the correct type of the input
        data.
        """
        ...
    
    def GetUnstructuredGridInput(self):
        """
        V.GetUnstructuredGridInput() -> vtkUnstructuredGrid
        C++: vtkUnstructuredGrid *GetUnstructuredGridInput()
        
        Get the input as a concrete type. This method is typically used
        by the writer of the filter function to get the input as a
        particular type (i.e., it essentially does type casting). It is
        the users responsibility to know the correct type of the input
        data.
        """
        ...
    
    def IsA(self, string):
        """
        V.IsA(string) -> int
        C++: vtkTypeBool IsA(const char *type) override;
        
        Return 1 if this class is the same type of (or a subclass of) the
        named class. Returns 0 otherwise. This method works in
        combination with vtkTypeMacro found in vtkSetGet.h.
        """
        ...
    
    def IsTypeOf(self, string):
        """
        V.IsTypeOf(string) -> int
        C++: static vtkTypeBool IsTypeOf(const char *type)
        
        Return 1 if this class type is the same type of (or a subclass
        of) the named class. Returns 0 otherwise. This method works in
        combination with vtkTypeMacro found in vtkSetGet.h.
        """
        ...
    
    def NewInstance(self):
        """
        V.NewInstance() -> vtkProgrammableFilter
        C++: vtkProgrammableFilter *NewInstance()
        """
        ...
    
    def SafeDownCast(self, vtkObjectBase):
        """
        V.SafeDownCast(vtkObjectBase) -> vtkProgrammableFilter
        C++: static vtkProgrammableFilter *SafeDownCast(vtkObjectBase *o)
        """
        ...
    
    def SetCopyArrays(self, bool):
        """
        V.SetCopyArrays(bool)
        C++: virtual void SetCopyArrays(bool _arg)
        
        When CopyArrays is true, all arrays are copied to the output iff
        input and output are of the same type. False by default.
        """
        ...
    
    def SetExecuteMethod(self, function):
        """
        V.SetExecuteMethod(function)
        C++: void SetExecuteMethod(void (*f)(void *), void *arg)
        
        Specify the function to use to operate on the point attribute
        data. Note that the function takes a single (void *) argument.
        """
        ...
    
    def __delattr__(self, *args, **kwargs):
        """ Implement delattr(self, name). """
        ...
    
    def __getattribute__(self, *args, **kwargs):
        """ Return getattr(self, name). """
        ...
    
    def __init__(self, *args, **kwargs) -> None:
        ...
    
    @staticmethod
    def __new__(*args, **kwargs):
        """ Create and return a new object.  See help(type) for accurate signature. """
        ...
    
    def __repr__(self, *args, **kwargs):
        """ Return repr(self). """
        ...
    
    def __setattr__(self, *args, **kwargs):
        """ Implement setattr(self, name, value). """
        ...
    
    def __str__(self, *args, **kwargs) -> str:
        """ Return str(self). """
        ...
    
    __this__ = ...
    __dict__ = ...
    __vtkname__ = ...


class vtkProgrammableGlyphFilter(__vtkmodules_vtkCommonExecutionModel.vtkPolyDataAlgorithm):
    """
    vtkProgrammableGlyphFilter - control the generation and placement of
    glyphs at input points
    
    Superclass: vtkPolyDataAlgorithm
    
    vtkProgrammableGlyphFilter is a filter that allows you to place a
    glyph at each input point in the dataset. In addition, the filter is
    programmable which means the user has control over the generation of
    the glyph. The glyphs can be controlled via the point data attributes
    (e.g., scalars, vectors, etc.) or any other information in the input
    dataset.
    
    This is the way the filter works. You must define an input dataset
    which at a minimum contains points with associated attribute values.
    Also, the Source instance variable must be set which is of type
    vtkPolyData. Then, for each point in the input, the PointId is set to
    the current point id, and a user-defined function is called (i.e.,
    GlyphMethod). In this method you can manipulate the Source data
    (including changing to a different Source object). After the
    GlyphMethod is called, vtkProgrammableGlyphFilter will invoke an
    Update() on its Source object, and then copy its data to the output
    of the vtkProgrammableGlyphFilter. Therefore the output of this
    filter is of type vtkPolyData.
    
    Another option to this filter is the way you color the glyphs. You
    can use the scalar data from the input or the source. The instance
    variable ColorMode controls this behavior.
    
    @warning
    This filter operates on point data attributes. If you want to use
    cell data attributes, use a filter like vtkCellCenters to generate
    points at the centers of cells, and then use these points.
    
    @warning
    Note that the data attributes (cell and point) are passed to the
    output of this filter from the Source object. This works well as long
    as you are not changing the class of the Source object during
    execution. However, if the class of the Source object changes, then
    the potential exists that the data attributes might change during
    execution (e.g., scalars available from one source and not the next),
    possibly fouling up the copying of data attributes to the output. In
    this case, you may have to manually set the output's copy flags
    (e.g., CopyScalarsOn/Off(), CopyVectorsOn/Off(), etc.) to control
    what's being copied.
    
    @sa
    vtkGlyph3D vtkTensorGlyph vtkCellCenters
    """
    def GetColorMode(self):
        """
        V.GetColorMode() -> int
        C++: virtual int GetColorMode()
        
        Either color by the input or source scalar data.
        """
        ...
    
    def GetColorModeAsString(self):
        """
        V.GetColorModeAsString() -> string
        C++: const char *GetColorModeAsString()
        
        Either color by the input or source scalar data.
        """
        ...
    
    def GetNumberOfGenerationsFromBase(self, string):
        """
        V.GetNumberOfGenerationsFromBase(string) -> int
        C++: vtkIdType GetNumberOfGenerationsFromBase(const char *type)
            override;
        
        Given a the name of a base class of this class type, return the
        distance of inheritance between this class type and the named
        class (how many generations of inheritance are there between this
        class and the named class). If the named class is not in this
        class's inheritance tree, return a negative value. Valid
        responses will always be nonnegative. This method works in
        combination with vtkTypeMacro found in vtkSetGet.h.
        """
        ...
    
    def GetNumberOfGenerationsFromBaseType(self, string):
        """
        V.GetNumberOfGenerationsFromBaseType(string) -> int
        C++: static vtkIdType GetNumberOfGenerationsFromBaseType(
            const char *type)
        
        Given a the name of a base class of this class type, return the
        distance of inheritance between this class type and the named
        class (how many generations of inheritance are there between this
        class and the named class). If the named class is not in this
        class's inheritance tree, return a negative value. Valid
        responses will always be nonnegative. This method works in
        combination with vtkTypeMacro found in vtkSetGet.h.
        """
        ...
    
    def GetPoint(self):
        """
        V.GetPoint() -> (float, float, float)
        C++: virtual double *GetPoint()
        
        Get the current point coordinates during processing. Value only
        valid during the Execute() method of this filter. (Meant to be
        called by the GlyphMethod().)
        """
        ...
    
    def GetPointData(self):
        """
        V.GetPointData() -> vtkPointData
        C++: virtual vtkPointData *GetPointData()
        
        Get the set of point data attributes for the input. A convenience
        to the programmer to be used in the GlyphMethod(). Only valid
        during the Execute() method of this filter.
        """
        ...
    
    def GetPointId(self):
        """
        V.GetPointId() -> int
        C++: virtual vtkIdType GetPointId()
        
        Get the current point id during processing. Value only valid
        during the Execute() method of this filter. (Meant to be called
        by the GlyphMethod().)
        """
        ...
    
    def GetSource(self):
        """
        V.GetSource() -> vtkPolyData
        C++: vtkPolyData *GetSource()
        
        Set/Get the source to use for this glyph. Note that
        SetSourceData() does not set a pipeline connection but directly
        uses the polydata.
        """
        ...
    
    def IsA(self, string):
        """
        V.IsA(string) -> int
        C++: vtkTypeBool IsA(const char *type) override;
        
        Return 1 if this class is the same type of (or a subclass of) the
        named class. Returns 0 otherwise. This method works in
        combination with vtkTypeMacro found in vtkSetGet.h.
        """
        ...
    
    def IsTypeOf(self, string):
        """
        V.IsTypeOf(string) -> int
        C++: static vtkTypeBool IsTypeOf(const char *type)
        
        Return 1 if this class type is the same type of (or a subclass
        of) the named class. Returns 0 otherwise. This method works in
        combination with vtkTypeMacro found in vtkSetGet.h.
        """
        ...
    
    def NewInstance(self):
        """
        V.NewInstance() -> vtkProgrammableGlyphFilter
        C++: vtkProgrammableGlyphFilter *NewInstance()
        """
        ...
    
    def SafeDownCast(self, vtkObjectBase):
        """
        V.SafeDownCast(vtkObjectBase) -> vtkProgrammableGlyphFilter
        C++: static vtkProgrammableGlyphFilter *SafeDownCast(
            vtkObjectBase *o)
        """
        ...
    
    def SetColorMode(self, p_int):
        """
        V.SetColorMode(int)
        C++: virtual void SetColorMode(int _arg)
        
        Either color by the input or source scalar data.
        """
        ...
    
    def SetColorModeToColorByInput(self):
        """
        V.SetColorModeToColorByInput()
        C++: void SetColorModeToColorByInput()
        
        Either color by the input or source scalar data.
        """
        ...
    
    def SetColorModeToColorBySource(self):
        """
        V.SetColorModeToColorBySource()
        C++: void SetColorModeToColorBySource()
        
        Either color by the input or source scalar data.
        """
        ...
    
    def SetGlyphMethod(self, function):
        """
        V.SetGlyphMethod(function)
        C++: void SetGlyphMethod(void (*f)(void *), void *arg)
        
        Specify function to be called for each input point.
        """
        ...
    
    def SetSourceConnection(self, vtkAlgorithmOutput):
        """
        V.SetSourceConnection(vtkAlgorithmOutput)
        C++: void SetSourceConnection(vtkAlgorithmOutput *output)
        
        Setup a connection for the source to use as the glyph. Note: you
        can change the source during execution of this filter. This is
        equivalent to SetInputConnection(1, output);
        """
        ...
    
    def SetSourceData(self, vtkPolyData):
        """
        V.SetSourceData(vtkPolyData)
        C++: void SetSourceData(vtkPolyData *source)
        
        Set/Get the source to use for this glyph. Note that
        SetSourceData() does not set a pipeline connection but directly
        uses the polydata.
        """
        ...
    
    def __delattr__(self, *args, **kwargs):
        """ Implement delattr(self, name). """
        ...
    
    def __getattribute__(self, *args, **kwargs):
        """ Return getattr(self, name). """
        ...
    
    def __init__(self, *args, **kwargs) -> None:
        ...
    
    @staticmethod
    def __new__(*args, **kwargs):
        """ Create and return a new object.  See help(type) for accurate signature. """
        ...
    
    def __repr__(self, *args, **kwargs):
        """ Return repr(self). """
        ...
    
    def __setattr__(self, *args, **kwargs):
        """ Implement setattr(self, name, value). """
        ...
    
    def __str__(self, *args, **kwargs) -> str:
        """ Return str(self). """
        ...
    
    __this__ = ...
    __dict__ = ...
    __vtkname__ = ...


__loader__ = ...
__spec__ = ...
