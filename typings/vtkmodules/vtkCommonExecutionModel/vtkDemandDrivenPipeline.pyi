"""
This type stub file was generated by pyright.
"""

from .vtkExecutive import vtkExecutive

class vtkDemandDrivenPipeline(vtkExecutive):
    """
    vtkDemandDrivenPipeline - Executive supporting on-demand execution.
    
    Superclass: vtkExecutive
    
    vtkDemandDrivenPipeline is an executive that will execute an
    algorithm only when its outputs are out-of-date with respect to its
    inputs.
    """
    def DATA_NOT_GENERATED(self):
        """
        V.DATA_NOT_GENERATED() -> vtkInformationIntegerKey
        C++: static vtkInformationIntegerKey *DATA_NOT_GENERATED()
        
        Key to store a mark for an output that will not be generated.
        Algorithms use this to tell the executive that they will not
        generate certain outputs for a REQUEST_DATA.@ingroup
        InformationKeys
        """
        ...
    
    def GetNumberOfGenerationsFromBase(self, string):
        """
        V.GetNumberOfGenerationsFromBase(string) -> int
        C++: vtkIdType GetNumberOfGenerationsFromBase(const char *type)
            override;
        
        Given a the name of a base class of this class type, return the
        distance of inheritance between this class type and the named
        class (how many generations of inheritance are there between this
        class and the named class). If the named class is not in this
        class's inheritance tree, return a negative value. Valid
        responses will always be nonnegative. This method works in
        combination with vtkTypeMacro found in vtkSetGet.h.
        """
        ...
    
    def GetNumberOfGenerationsFromBaseType(self, string):
        """
        V.GetNumberOfGenerationsFromBaseType(string) -> int
        C++: static vtkIdType GetNumberOfGenerationsFromBaseType(
            const char *type)
        
        Given a the name of a base class of this class type, return the
        distance of inheritance between this class type and the named
        class (how many generations of inheritance are there between this
        class and the named class). If the named class is not in this
        class's inheritance tree, return a negative value. Valid
        responses will always be nonnegative. This method works in
        combination with vtkTypeMacro found in vtkSetGet.h.
        """
        ...
    
    def GetPipelineMTime(self):
        """
        V.GetPipelineMTime() -> int
        C++: virtual vtkMTimeType GetPipelineMTime()
        
        Get the PipelineMTime for this exective.
        """
        ...
    
    def GetReleaseDataFlag(self, p_int):
        """
        V.GetReleaseDataFlag(int) -> int
        C++: virtual int GetReleaseDataFlag(int port)
        
        Get whether the given output port releases data when it is
        consumed.
        """
        ...
    
    def IsA(self, string):
        """
        V.IsA(string) -> int
        C++: vtkTypeBool IsA(const char *type) override;
        
        Return 1 if this class is the same type of (or a subclass of) the
        named class. Returns 0 otherwise. This method works in
        combination with vtkTypeMacro found in vtkSetGet.h.
        """
        ...
    
    def IsTypeOf(self, string):
        """
        V.IsTypeOf(string) -> int
        C++: static vtkTypeBool IsTypeOf(const char *type)
        
        Return 1 if this class type is the same type of (or a subclass
        of) the named class. Returns 0 otherwise. This method works in
        combination with vtkTypeMacro found in vtkSetGet.h.
        """
        ...
    
    def NewDataObject(self, string):
        """
        V.NewDataObject(string) -> vtkDataObject
        C++: static vtkDataObject *NewDataObject(const char *type)
        
        Create (New) and return a data object of the given type. This is
        here for backwards compatibility. Use
        vtkDataObjectTypes::NewDataObject() instead.
        """
        ...
    
    def NewInstance(self):
        """
        V.NewInstance() -> vtkDemandDrivenPipeline
        C++: vtkDemandDrivenPipeline *NewInstance()
        """
        ...
    
    def RELEASE_DATA(self):
        """
        V.RELEASE_DATA() -> vtkInformationIntegerKey
        C++: static vtkInformationIntegerKey *RELEASE_DATA()
        
        Key to specify in pipeline information the request that data be
        released after it is used.@ingroup InformationKeys
        """
        ...
    
    def REQUEST_DATA(self):
        """
        V.REQUEST_DATA() -> vtkInformationRequestKey
        C++: static vtkInformationRequestKey *REQUEST_DATA()
        
        Key defining a request to make sure the output data are up to
        date.@ingroup InformationKeys
        """
        ...
    
    def REQUEST_DATA_NOT_GENERATED(self):
        """
        V.REQUEST_DATA_NOT_GENERATED() -> vtkInformationRequestKey
        C++: static vtkInformationRequestKey *REQUEST_DATA_NOT_GENERATED()
        
        Key defining a request to mark outputs that will NOT be generated
        during a REQUEST_DATA.@ingroup InformationKeys
        """
        ...
    
    def REQUEST_DATA_OBJECT(self):
        """
        V.REQUEST_DATA_OBJECT() -> vtkInformationRequestKey
        C++: static vtkInformationRequestKey *REQUEST_DATA_OBJECT()
        
        Key defining a request to make sure the output data objects
        exist.@ingroup InformationKeys
        """
        ...
    
    def REQUEST_INFORMATION(self):
        """
        V.REQUEST_INFORMATION() -> vtkInformationRequestKey
        C++: static vtkInformationRequestKey *REQUEST_INFORMATION()
        
        Key defining a request to make sure the output information is up
        to date.@ingroup InformationKeys
        """
        ...
    
    def SafeDownCast(self, vtkObjectBase):
        """
        V.SafeDownCast(vtkObjectBase) -> vtkDemandDrivenPipeline
        C++: static vtkDemandDrivenPipeline *SafeDownCast(
            vtkObjectBase *o)
        """
        ...
    
    def SetReleaseDataFlag(self, p_int, p_int_1):
        """
        V.SetReleaseDataFlag(int, int) -> int
        C++: virtual int SetReleaseDataFlag(int port, int n)
        
        Set whether the given output port releases data when it is
        consumed.  Returns 1 if the value changes and 0 otherwise.
        """
        ...
    
    def Update(self):
        """
        V.Update() -> int
        C++: vtkTypeBool Update() override;
        V.Update(int) -> int
        C++: vtkTypeBool Update(int port) override;
        
        Bring the algorithm's outputs up-to-date.  Returns 1 for success
        and 0 for failure.
        """
        ...
    
    def UpdateData(self, p_int):
        """
        V.UpdateData(int) -> int
        C++: virtual int UpdateData(int outputPort)
        
        Bring the output data up to date.  This should be called only
        when information is up to date.  Use the Update method if it is
        not known that the information is up to date.
        """
        ...
    
    def UpdateDataObject(self):
        """
        V.UpdateDataObject() -> int
        C++: int UpdateDataObject() override;
        
        Bring the output data object's existence up to date.  This does
        not actually produce data, but does create the data object that
        will store data produced during the UpdateData step.
        """
        ...
    
    def UpdateInformation(self):
        """
        V.UpdateInformation() -> int
        C++: int UpdateInformation() override;
        
        Bring the output information up to date.
        """
        ...
    
    def UpdatePipelineMTime(self):
        """
        V.UpdatePipelineMTime() -> int
        C++: virtual int UpdatePipelineMTime()
        
        Bring the PipelineMTime up to date.
        """
        ...
    
    def __delattr__(self, *args, **kwargs):
        """ Implement delattr(self, name). """
        ...
    
    def __getattribute__(self, *args, **kwargs):
        """ Return getattr(self, name). """
        ...
    
    def __init__(self, *args, **kwargs) -> None:
        ...
    
    @staticmethod
    def __new__(*args, **kwargs):
        """ Create and return a new object.  See help(type) for accurate signature. """
        ...
    
    def __repr__(self, *args, **kwargs):
        """ Return repr(self). """
        ...
    
    def __setattr__(self, *args, **kwargs):
        """ Implement setattr(self, name, value). """
        ...
    
    def __str__(self, *args, **kwargs) -> str:
        """ Return str(self). """
        ...
    
    __this__ = ...
    __dict__ = ...
    __vtkname__ = ...


