"""
This type stub file was generated by pyright.
"""

import vtkmodules.vtkCommonCore as __vtkmodules_vtkCommonCore

class vtkExtentTranslator(__vtkmodules_vtkCommonCore.vtkObject):
    """
    vtkExtentTranslator - Generates a structured extent from unstructured.
    
    Superclass: vtkObject
    
    vtkExtentTranslator generates a structured extent from an
    unstructured extent.  It uses a recursive scheme that splits the
    largest axis.  A hard coded extent can be used for a starting point.
    """
    def GetExtent(self):
        """
        V.GetExtent() -> (int, int, int, int, int, int)
        C++: virtual int *GetExtent()
        
        Set the Piece/NumPieces. Set the WholeExtent and then call
        PieceToExtent. The result can be obtained from the Extent ivar.
        """
        ...
    
    def GetGhostLevel(self):
        """
        V.GetGhostLevel() -> int
        C++: virtual int GetGhostLevel()
        
        Set the Piece/NumPieces. Set the WholeExtent and then call
        PieceToExtent. The result can be obtained from the Extent ivar.
        """
        ...
    
    def GetNumberOfGenerationsFromBase(self, string):
        """
        V.GetNumberOfGenerationsFromBase(string) -> int
        C++: vtkIdType GetNumberOfGenerationsFromBase(const char *type)
            override;
        
        Given a the name of a base class of this class type, return the
        distance of inheritance between this class type and the named
        class (how many generations of inheritance are there between this
        class and the named class). If the named class is not in this
        class's inheritance tree, return a negative value. Valid
        responses will always be nonnegative. This method works in
        combination with vtkTypeMacro found in vtkSetGet.h.
        """
        ...
    
    def GetNumberOfGenerationsFromBaseType(self, string):
        """
        V.GetNumberOfGenerationsFromBaseType(string) -> int
        C++: static vtkIdType GetNumberOfGenerationsFromBaseType(
            const char *type)
        
        Given a the name of a base class of this class type, return the
        distance of inheritance between this class type and the named
        class (how many generations of inheritance are there between this
        class and the named class). If the named class is not in this
        class's inheritance tree, return a negative value. Valid
        responses will always be nonnegative. This method works in
        combination with vtkTypeMacro found in vtkSetGet.h.
        """
        ...
    
    def GetNumberOfPieces(self):
        """
        V.GetNumberOfPieces() -> int
        C++: virtual int GetNumberOfPieces()
        
        Set the Piece/NumPieces. Set the WholeExtent and then call
        PieceToExtent. The result can be obtained from the Extent ivar.
        """
        ...
    
    def GetPiece(self):
        """
        V.GetPiece() -> int
        C++: virtual int GetPiece()
        
        Set the Piece/NumPieces. Set the WholeExtent and then call
        PieceToExtent. The result can be obtained from the Extent ivar.
        """
        ...
    
    def GetSplitMode(self):
        """
        V.GetSplitMode() -> int
        C++: virtual int GetSplitMode()
        """
        ...
    
    def GetWholeExtent(self):
        """
        V.GetWholeExtent() -> (int, int, int, int, int, int)
        C++: virtual int *GetWholeExtent()
        
        Set the Piece/NumPieces. Set the WholeExtent and then call
        PieceToExtent. The result can be obtained from the Extent ivar.
        """
        ...
    
    def IsA(self, string):
        """
        V.IsA(string) -> int
        C++: vtkTypeBool IsA(const char *type) override;
        
        Return 1 if this class is the same type of (or a subclass of) the
        named class. Returns 0 otherwise. This method works in
        combination with vtkTypeMacro found in vtkSetGet.h.
        """
        ...
    
    def IsTypeOf(self, string):
        """
        V.IsTypeOf(string) -> int
        C++: static vtkTypeBool IsTypeOf(const char *type)
        
        Return 1 if this class type is the same type of (or a subclass
        of) the named class. Returns 0 otherwise. This method works in
        combination with vtkTypeMacro found in vtkSetGet.h.
        """
        ...
    
    def NewInstance(self):
        """
        V.NewInstance() -> vtkExtentTranslator
        C++: vtkExtentTranslator *NewInstance()
        """
        ...
    
    def PieceToExtent(self):
        """
        V.PieceToExtent() -> int
        C++: virtual int PieceToExtent()
        
        These are the main methods that should be called. These methods
        are responsible for converting a piece to an extent. The
        signatures without arguments are only thread safe when each
        thread accesses a different instance. The signatures with
        arguments are fully thread safe.
        """
        ...
    
    def PieceToExtentByPoints(self):
        """
        V.PieceToExtentByPoints() -> int
        C++: virtual int PieceToExtentByPoints()
        
        These are the main methods that should be called. These methods
        are responsible for converting a piece to an extent. The
        signatures without arguments are only thread safe when each
        thread accesses a different instance. The signatures with
        arguments are fully thread safe.
        """
        ...
    
    def PieceToExtentThreadSafe(self, p_int, p_int_1, p_int_2, *int, **kwargs):
        """
        V.PieceToExtentThreadSafe(int, int, int, [int, ...], [int, ...],
            int, int) -> int
        C++: virtual int PieceToExtentThreadSafe(int piece, int numPieces,
             int ghostLevel, int *wholeExtent, int *resultExtent,
            int splitMode, int byPoints)
        
        These are the main methods that should be called. These methods
        are responsible for converting a piece to an extent. The
        signatures without arguments are only thread safe when each
        thread accesses a different instance. The signatures with
        arguments are fully thread safe.
        """
        ...
    
    def SafeDownCast(self, vtkObjectBase):
        """
        V.SafeDownCast(vtkObjectBase) -> vtkExtentTranslator
        C++: static vtkExtentTranslator *SafeDownCast(vtkObjectBase *o)
        """
        ...
    
    def SetExtent(self, p_int, p_int_1, p_int_2, p_int_3, p_int_4, p_int_5):
        """
        V.SetExtent(int, int, int, int, int, int)
        C++: virtual void SetExtent(int _arg1, int _arg2, int _arg3,
            int _arg4, int _arg5, int _arg6)
        V.SetExtent((int, int, int, int, int, int))
        C++: virtual void SetExtent(const int _arg[6])
        
        Set the Piece/NumPieces. Set the WholeExtent and then call
        PieceToExtent. The result can be obtained from the Extent ivar.
        """
        ...
    
    def SetGhostLevel(self, p_int):
        """
        V.SetGhostLevel(int)
        C++: virtual void SetGhostLevel(int _arg)
        
        Set the Piece/NumPieces. Set the WholeExtent and then call
        PieceToExtent. The result can be obtained from the Extent ivar.
        """
        ...
    
    def SetNumberOfPieces(self, p_int):
        """
        V.SetNumberOfPieces(int)
        C++: virtual void SetNumberOfPieces(int _arg)
        
        Set the Piece/NumPieces. Set the WholeExtent and then call
        PieceToExtent. The result can be obtained from the Extent ivar.
        """
        ...
    
    def SetPiece(self, p_int):
        """
        V.SetPiece(int)
        C++: virtual void SetPiece(int _arg)
        
        Set the Piece/NumPieces. Set the WholeExtent and then call
        PieceToExtent. The result can be obtained from the Extent ivar.
        """
        ...
    
    def SetSplitModeToBlock(self):
        """
        V.SetSplitModeToBlock()
        C++: void SetSplitModeToBlock()
        
        How should the streamer break up extents. Block mode tries to
        break an extent up into cube blocks.  It always chooses the
        largest axis to split. Slab mode first breaks up the Z axis.  If
        it gets to one slice, then it starts breaking up other axes.
        """
        ...
    
    def SetSplitModeToXSlab(self):
        """
        V.SetSplitModeToXSlab()
        C++: void SetSplitModeToXSlab()
        """
        ...
    
    def SetSplitModeToYSlab(self):
        """
        V.SetSplitModeToYSlab()
        C++: void SetSplitModeToYSlab()
        """
        ...
    
    def SetSplitModeToZSlab(self):
        """
        V.SetSplitModeToZSlab()
        C++: void SetSplitModeToZSlab()
        """
        ...
    
    def SetSplitPath(self, p_int, *int):
        """
        V.SetSplitPath(int, [int, ...])
        C++: void SetSplitPath(int len, int *splitpath)
        
        By default the translator creates N structured subextents by
        repeatedly splitting the largest current dimension until there
        are N pieces. If you do not want it always split the largest
        dimension, for instance when the shortest dimension is the
        slowest changing and thus least coherent in memory, use this to
        tell the translator which dimensions to split.
        """
        ...
    
    def SetWholeExtent(self, p_int, p_int_1, p_int_2, p_int_3, p_int_4, p_int_5):
        """
        V.SetWholeExtent(int, int, int, int, int, int)
        C++: virtual void SetWholeExtent(int _arg1, int _arg2, int _arg3,
            int _arg4, int _arg5, int _arg6)
        V.SetWholeExtent((int, int, int, int, int, int))
        C++: virtual void SetWholeExtent(const int _arg[6])
        
        Set the Piece/NumPieces. Set the WholeExtent and then call
        PieceToExtent. The result can be obtained from the Extent ivar.
        """
        ...
    
    def UPDATE_SPLIT_MODE(self):
        """
        V.UPDATE_SPLIT_MODE() -> vtkInformationIntegerRequestKey
        C++: static vtkInformationIntegerRequestKey *UPDATE_SPLIT_MODE()
        
        Key used to request a particular split mode. This is used by
        vtkStreamingDemandDrivenPipeline.
        """
        ...
    
    def __delattr__(self, *args, **kwargs):
        """ Implement delattr(self, name). """
        ...
    
    def __getattribute__(self, *args, **kwargs):
        """ Return getattr(self, name). """
        ...
    
    def __init__(self, *args, **kwargs) -> None:
        ...
    
    @staticmethod
    def __new__(*args, **kwargs):
        """ Create and return a new object.  See help(type) for accurate signature. """
        ...
    
    def __repr__(self, *args, **kwargs):
        """ Return repr(self). """
        ...
    
    def __setattr__(self, *args, **kwargs):
        """ Implement setattr(self, name, value). """
        ...
    
    def __str__(self, *args, **kwargs) -> str:
        """ Return str(self). """
        ...
    
    __this__ = ...
    BLOCK_MODE = ...
    Modes = ...
    X_SLAB_MODE = ...
    Y_SLAB_MODE = ...
    Z_SLAB_MODE = ...
    __dict__ = ...
    __vtkname__ = ...


