"""
This type stub file was generated by pyright.
"""

import vtkmodules.vtkCommonCore as __vtkmodules_vtkCommonCore

class vtkSphereTree(__vtkmodules_vtkCommonCore.vtkObject):
    """
    vtkSphereTree - class to build and traverse sphere trees
    
    Superclass: vtkObject
    
    vtkSphereTree is a helper class used to build and traverse sphere
    trees. Various types of trees can be constructed for different VTK
    dataset types, as well well as different approaches to organize the
    tree into hierarchies.
    
    Typically building a complete sphere tree consists of two parts: 1)
    creating spheres for each cell in the dataset, then 2) creating an
    organizing hierarchy. The structure of the hierarchy varies depending
    on the topological characteristics of the dataset.
    
    Once the tree is constructed, various geometric operations are
    available for quickly selecting cells based on sphere tree
    operations; for example, process all cells intersecting a plane
    (i.e., use the sphere tree to identify candidate cells for plane
    intersection).
    
    This class does not necessarily create optimal sphere trees because
    some of its requirements (fast build time, provide simple reference
    code, a single bounding sphere per cell, etc.) precludes optimal
    performance. It is also oriented to computing on cells versus the
    classic problem of collision detection for polygonal models. For more
    information you want to read Gareth Bradshaw's PhD thesis "Bounding
    Volume Hierarchies for Level-of-Detail Collision Handling" which does
    a nice job of laying out the challenges and important algorithms
    relative to sphere trees and BVH (bounding volume hierarchies).
    
    @sa
    vtkSphereTreeFilter vtkPlaneCutter
    """
    def Build(self):
        """
        V.Build()
        C++: void Build()
        V.Build(vtkDataSet)
        C++: void Build(vtkDataSet *input)
        
        Build the sphere tree (if necessary) from the data set specified.
        The build time is recorded so the sphere tree will only build if
        something has changed. An alternative method is available to both
        set the dataset and then build the sphere tree.
        """
        ...
    
    def BuildHierarchyOff(self):
        """
        V.BuildHierarchyOff()
        C++: virtual void BuildHierarchyOff()
        
        Control whether the tree hierarchy is built. If not, then just
        cell spheres are created (one for each cell).
        """
        ...
    
    def BuildHierarchyOn(self):
        """
        V.BuildHierarchyOn()
        C++: virtual void BuildHierarchyOn()
        
        Control whether the tree hierarchy is built. If not, then just
        cell spheres are created (one for each cell).
        """
        ...
    
    def GetBuildHierarchy(self):
        """
        V.GetBuildHierarchy() -> bool
        C++: virtual bool GetBuildHierarchy()
        
        Control whether the tree hierarchy is built. If not, then just
        cell spheres are created (one for each cell).
        """
        ...
    
    def GetCellSpheres(self):
        """
        V.GetCellSpheres() -> (float, ...)
        C++: const double *GetCellSpheres()
        
        Special methods to retrieve the sphere tree data. This is
        generally used for debugging or with filters like
        vtkSphereTreeFilter. Both methods return an array of double*
        where four doubles represent a sphere (center + radius). In the
        first method a sphere per cell is returned. In the second method
        the user must also specify a level in the sphere tree (used to
        retrieve the hierarchy of the tree). Note that null pointers can
        be returned if the request is not consistent with the state of
        the sphere tree.
        """
        ...
    
    def GetDataSet(self):
        """
        V.GetDataSet() -> vtkDataSet
        C++: virtual vtkDataSet *GetDataSet()
        
        Specify the dataset from which to build the sphere tree.
        """
        ...
    
    def GetMaxLevel(self):
        """
        V.GetMaxLevel() -> int
        C++: virtual int GetMaxLevel()
        
        Specify the maximum number of levels for the tree. By default,
        the number of levels is set to ten. If the number of levels is
        set to one or less, then no hierarchy is built (i.e., just the
        spheres for each cell are created). Note that the actual level of
        the tree may be less than this value depending on the number of
        cells and Resolution factor.
        """
        ...
    
    def GetMaxLevelMaxValue(self):
        """
        V.GetMaxLevelMaxValue() -> int
        C++: virtual int GetMaxLevelMaxValue()
        
        Specify the maximum number of levels for the tree. By default,
        the number of levels is set to ten. If the number of levels is
        set to one or less, then no hierarchy is built (i.e., just the
        spheres for each cell are created). Note that the actual level of
        the tree may be less than this value depending on the number of
        cells and Resolution factor.
        """
        ...
    
    def GetMaxLevelMinValue(self):
        """
        V.GetMaxLevelMinValue() -> int
        C++: virtual int GetMaxLevelMinValue()
        
        Specify the maximum number of levels for the tree. By default,
        the number of levels is set to ten. If the number of levels is
        set to one or less, then no hierarchy is built (i.e., just the
        spheres for each cell are created). Note that the actual level of
        the tree may be less than this value depending on the number of
        cells and Resolution factor.
        """
        ...
    
    def GetNumberOfGenerationsFromBase(self, string):
        """
        V.GetNumberOfGenerationsFromBase(string) -> int
        C++: vtkIdType GetNumberOfGenerationsFromBase(const char *type)
            override;
        
        Standard type related macros and PrintSelf() method.
        """
        ...
    
    def GetNumberOfGenerationsFromBaseType(self, string):
        """
        V.GetNumberOfGenerationsFromBaseType(string) -> int
        C++: static vtkIdType GetNumberOfGenerationsFromBaseType(
            const char *type)
        
        Standard type related macros and PrintSelf() method.
        """
        ...
    
    def GetNumberOfLevels(self):
        """
        V.GetNumberOfLevels() -> int
        C++: virtual int GetNumberOfLevels()
        
        Get the current depth of the sphere tree. This value may change
        each time the sphere tree is built and the branching factor
        (i.e., resolution) changes. Note that after building the sphere
        tree there are [0,this->NumberOfLevels) defined levels.
        """
        ...
    
    def GetResolution(self):
        """
        V.GetResolution() -> int
        C++: virtual int GetResolution()
        
        Sphere tree creation requires gathering spheres into groups. The
        Resolution variable is a rough guide to the size of each group
        (the size different meanings depending on the type of data
        (structured versus unstructured). For example, in 3D structured
        data, blocks of resolution Resolution^3 are created. By default
        the Resolution is three.
        """
        ...
    
    def GetResolutionMaxValue(self):
        """
        V.GetResolutionMaxValue() -> int
        C++: virtual int GetResolutionMaxValue()
        
        Sphere tree creation requires gathering spheres into groups. The
        Resolution variable is a rough guide to the size of each group
        (the size different meanings depending on the type of data
        (structured versus unstructured). For example, in 3D structured
        data, blocks of resolution Resolution^3 are created. By default
        the Resolution is three.
        """
        ...
    
    def GetResolutionMinValue(self):
        """
        V.GetResolutionMinValue() -> int
        C++: virtual int GetResolutionMinValue()
        
        Sphere tree creation requires gathering spheres into groups. The
        Resolution variable is a rough guide to the size of each group
        (the size different meanings depending on the type of data
        (structured versus unstructured). For example, in 3D structured
        data, blocks of resolution Resolution^3 are created. By default
        the Resolution is three.
        """
        ...
    
    def GetTreeSpheres(self, p_int, p_int_1):
        """
        V.GetTreeSpheres(int, int) -> (float, ...)
        C++: const double *GetTreeSpheres(int level,
            vtkIdType &numSpheres)
        
        Special methods to retrieve the sphere tree data. This is
        generally used for debugging or with filters like
        vtkSphereTreeFilter. Both methods return an array of double*
        where four doubles represent a sphere (center + radius). In the
        first method a sphere per cell is returned. In the second method
        the user must also specify a level in the sphere tree (used to
        retrieve the hierarchy of the tree). Note that null pointers can
        be returned if the request is not consistent with the state of
        the sphere tree.
        """
        ...
    
    def IsA(self, string):
        """
        V.IsA(string) -> int
        C++: vtkTypeBool IsA(const char *type) override;
        
        Standard type related macros and PrintSelf() method.
        """
        ...
    
    def IsTypeOf(self, string):
        """
        V.IsTypeOf(string) -> int
        C++: static vtkTypeBool IsTypeOf(const char *type)
        
        Standard type related macros and PrintSelf() method.
        """
        ...
    
    def NewInstance(self):
        """
        V.NewInstance() -> vtkSphereTree
        C++: vtkSphereTree *NewInstance()
        
        Standard type related macros and PrintSelf() method.
        """
        ...
    
    def SafeDownCast(self, vtkObjectBase):
        """
        V.SafeDownCast(vtkObjectBase) -> vtkSphereTree
        C++: static vtkSphereTree *SafeDownCast(vtkObjectBase *o)
        
        Standard type related macros and PrintSelf() method.
        """
        ...
    
    def SelectLine(self, p_float=..., p_float=..., p_float=..., *args, **kwargs):
        """
        V.SelectLine([float, float, float], [float, float, float], int)
            -> (int, ...)
        C++: const unsigned char *SelectLine(double origin[3],
            double ray[3], vtkIdType &numSelected)
        V.SelectLine([float, float, float], [float, float, float],
            vtkIdList)
        C++: void SelectLine(double origin[3], double ray[3],
            vtkIdList *cellIds)
        
        Methods for cell selection based on a geometric query. Internally
        different methods are used depending on the dataset type. The
        array returned is set to non-zero for each cell that intersects
        the geometric entity. SelectPoint marks all cells with a non-zero
        value that may contain a point. SelectLine marks all cells that
        may intersect an infinite line. SelectPlane marks all cells that
        may intersect with an infinite plane.
        """
        ...
    
    def SelectPlane(self, p_float=..., p_float=..., p_float=..., *args, **kwargs):
        """
        V.SelectPlane([float, float, float], [float, float, float], int)
            -> (int, ...)
        C++: const unsigned char *SelectPlane(double origin[3],
            double normal[3], vtkIdType &numSelected)
        V.SelectPlane([float, float, float], [float, float, float],
            vtkIdList)
        C++: void SelectPlane(double origin[3], double normal[3],
            vtkIdList *cellIds)
        
        Methods for cell selection based on a geometric query. Internally
        different methods are used depending on the dataset type. The
        array returned is set to non-zero for each cell that intersects
        the geometric entity. SelectPoint marks all cells with a non-zero
        value that may contain a point. SelectLine marks all cells that
        may intersect an infinite line. SelectPlane marks all cells that
        may intersect with an infinite plane.
        """
        ...
    
    def SelectPoint(self, p_float=..., p_float=..., p_float=..., *args, **kwargs):
        """
        V.SelectPoint([float, float, float], int) -> (int, ...)
        C++: const unsigned char *SelectPoint(double point[3],
            vtkIdType &numSelected)
        V.SelectPoint([float, float, float], vtkIdList)
        C++: void SelectPoint(double point[3], vtkIdList *cellIds)
        
        Methods for cell selection based on a geometric query. Internally
        different methods are used depending on the dataset type. The
        array returned is set to non-zero for each cell that intersects
        the geometric entity. SelectPoint marks all cells with a non-zero
        value that may contain a point. SelectLine marks all cells that
        may intersect an infinite line. SelectPlane marks all cells that
        may intersect with an infinite plane.
        """
        ...
    
    def SetBuildHierarchy(self, bool):
        """
        V.SetBuildHierarchy(bool)
        C++: virtual void SetBuildHierarchy(bool _arg)
        
        Control whether the tree hierarchy is built. If not, then just
        cell spheres are created (one for each cell).
        """
        ...
    
    def SetDataSet(self, vtkDataSet):
        """
        V.SetDataSet(vtkDataSet)
        C++: virtual void SetDataSet(vtkDataSet *)
        
        Specify the dataset from which to build the sphere tree.
        """
        ...
    
    def SetMaxLevel(self, p_int):
        """
        V.SetMaxLevel(int)
        C++: virtual void SetMaxLevel(int _arg)
        
        Specify the maximum number of levels for the tree. By default,
        the number of levels is set to ten. If the number of levels is
        set to one or less, then no hierarchy is built (i.e., just the
        spheres for each cell are created). Note that the actual level of
        the tree may be less than this value depending on the number of
        cells and Resolution factor.
        """
        ...
    
    def SetResolution(self, p_int):
        """
        V.SetResolution(int)
        C++: virtual void SetResolution(int _arg)
        
        Sphere tree creation requires gathering spheres into groups. The
        Resolution variable is a rough guide to the size of each group
        (the size different meanings depending on the type of data
        (structured versus unstructured). For example, in 3D structured
        data, blocks of resolution Resolution^3 are created. By default
        the Resolution is three.
        """
        ...
    
    def __delattr__(self, *args, **kwargs):
        """ Implement delattr(self, name). """
        ...
    
    def __getattribute__(self, *args, **kwargs):
        """ Return getattr(self, name). """
        ...
    
    def __init__(self, *args, **kwargs) -> None:
        ...
    
    @staticmethod
    def __new__(*args, **kwargs):
        """ Create and return a new object.  See help(type) for accurate signature. """
        ...
    
    def __repr__(self, *args, **kwargs):
        """ Return repr(self). """
        ...
    
    def __setattr__(self, *args, **kwargs):
        """ Implement setattr(self, name, value). """
        ...
    
    def __str__(self, *args, **kwargs) -> str:
        """ Return str(self). """
        ...
    
    __this__ = ...
    __dict__ = ...
    __vtkname__ = ...


