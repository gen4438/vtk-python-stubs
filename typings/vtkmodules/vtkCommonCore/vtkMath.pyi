"""
This type stub file was generated by pyright.
"""

from .vtkObject import vtkObject

class vtkMath(vtkObject):
    """
    vtkMath - performs common math operations
    
    Superclass: vtkObject
    
    vtkMath provides methods to perform common math operations. These
    include providing constants such as Pi; conversion from degrees to
    radians; vector operations such as dot and cross products and vector
    norm; matrix determinant for 2x2 and 3x3 matrices; univariate
    polynomial solvers; and for random number generation (for backward
    compatibility only).
    @sa
    vtkMinimalStandardRandomSequence, vtkBoxMuellerRandomSequence,
    vtkQuaternion
    """
    def Add(self, , , p_float=..., p_float=..., p_float=...):
        """
        V.Add((float, float, float), (float, float, float), [float, float,
             float])
        C++: static void Add(const double a[3], const double b[3],
            double c[3])
        
        Addition of two 3-vectors (double version). Result is stored in c
        according to c = a + b.
        """
        ...
    
    def AngleBetweenVectors(self, , ):
        """
        V.AngleBetweenVectors((float, float, float), (float, float, float)
            ) -> float
        C++: static double AngleBetweenVectors(const double v1[3],
            const double v2[3])
        
        Compute angle in radians between two vectors.
        """
        ...
    
    def AreBoundsInitialized(self, ):
        """
        V.AreBoundsInitialized((float, float, float, float, float, float))
             -> int
        C++: static vtkTypeBool AreBoundsInitialized(
            const double bounds[6])
        
        Are the bounds initialized?
        """
        ...
    
    def BeginCombination(self, p_int, p_int_1):
        """
        V.BeginCombination(int, int) -> (int, ...)
        C++: static int *BeginCombination(int m, int n)
        
        Start iterating over "m choose n" objects. This function returns
        an array of n integers, each from 0 to m-1. These integers
        represent the n items chosen from the set [0,m[.
        
        * You are responsible for calling vtkMath::FreeCombination() once
        the iterator is no longer needed.
        
        * Warning: this gets large very quickly, especially when n nears
          m/2!
        * (Hint: think of Pascal's triangle.)
        """
        ...
    
    def Binomial(self, p_int, p_int_1):
        """
        V.Binomial(int, int) -> int
        C++: static vtkTypeInt64 Binomial(int m, int n)
        
        The number of combinations of n objects from a pool of m objects
        (m>n). This is commonly known as "m choose n" and sometimes
        denoted $_mC_n $ or $\left(\begin{array}{c}m \
        n\end{array}\right) $.
        """
        ...
    
    def BoundsIsWithinOtherBounds(self, , , ):
        """
        V.BoundsIsWithinOtherBounds((float, float, float, float, float,
            float), (float, float, float, float, float, float), (float,
            float, float)) -> int
        C++: static vtkTypeBool BoundsIsWithinOtherBounds(
            const double bounds1[6], const double bounds2[6],
            const double delta[3])
        
        Return true if first 3D bounds is within the second 3D bounds
        Bounds is x-min, x-max, y-min, y-max, z-min, z-max Delta is the
        error margin along each axis (usually a small number)
        """
        ...
    
    def Ceil(self, p_float):
        """
        V.Ceil(float) -> int
        C++: static int Ceil(double x)
        
        Rounds a double to the nearest integer not less than itself. This
        is faster than ceil() but provides undefined output on overflow.
        """
        ...
    
    def CeilLog2(self, p_int):
        """
        V.CeilLog2(int) -> int
        C++: static int CeilLog2(vtkTypeUInt64 x)
        
        Gives the exponent of the lowest power of two not less than x. Or
        in mathspeak, return the smallest "i" for which 2^i >= x. If x is
        zero, then the return value will be zero.
        """
        ...
    
    def ClampAndNormalizeValue(self, p_float, ):
        """
        V.ClampAndNormalizeValue(float, (float, float)) -> float
        C++: static double ClampAndNormalizeValue(double value,
            const double range[2])
        
        Clamp a value against a range and then normalize it between 0 and
        1. If range[0]==range[1], the result is 0.
        \pre valid_range: range[0]<=range[1]
        \post valid_result: result>=0.0 && result<=1.0
        """
        ...
    
    def ClampValue(self, *float, **kwargs):
        """
        V.ClampValue([float, ...], (float, float))
        C++: static void ClampValue(double *value, const double range[2])
        V.ClampValue(float, (float, float), [float, ...])
        C++: static void ClampValue(double value, const double range[2],
            double *clamped_value)
        
        Clamp some values against a range The method without
        'clamped_values' will perform in-place clamping.
        """
        ...
    
    def ClampValues(self, *float, **kwargs):
        """
        V.ClampValues([float, ...], int, (float, float))
        C++: static void ClampValues(double *values, int nb_values,
            const double range[2])
        V.ClampValues((float, ...), int, (float, float), [float, ...])
        C++: static void ClampValues(const double *values, int nb_values,
            const double range[2], double *clamped_values)
        
        Clamp some values against a range The method without
        'clamped_values' will perform in-place clamping.
        """
        ...
    
    def Cross(self, , , p_float=..., p_float=..., p_float=...):
        """
        V.Cross((float, float, float), (float, float, float), [float,
            float, float])
        C++: static void Cross(const double a[3], const double b[3],
            double c[3])
        
        Cross product of two 3-vectors. Result (a x b) is stored in c.
        (double version)
        """
        ...
    
    def DegreesFromRadians(self, p_float):
        """
        V.DegreesFromRadians(float) -> float
        C++: static double DegreesFromRadians(double radians)
        
        Convert radians into degrees
        """
        ...
    
    def Determinant2x2(self, p_float, p_float_1, p_float_2, p_float_3):
        """
        V.Determinant2x2(float, float, float, float) -> float
        C++: static double Determinant2x2(double a, double b, double c,
            double d)
        V.Determinant2x2((float, float), (float, float)) -> float
        C++: static double Determinant2x2(const double c1[2],
            const double c2[2])
        
        Calculate the determinant of a 2x2 matrix: | a b | | c d |
        """
        ...
    
    def Determinant3x3(self, , , ):
        """
        V.Determinant3x3(((float, float, float), (float, float, float), (
            float, float, float))) -> float
        C++: static double Determinant3x3(const double A[3][3])
        V.Determinant3x3((float, float, float), (float, float, float), (
            float, float, float)) -> float
        C++: static double Determinant3x3(const double c1[3],
            const double c2[3], const double c3[3])
        V.Determinant3x3(float, float, float, float, float, float, float,
            float, float) -> float
        C++: static double Determinant3x3(double a1, double a2, double a3,
             double b1, double b2, double b3, double c1, double c2,
            double c3)
        
        Return the determinant of a 3x3 matrix.
        """
        ...
    
    def Diagonalize3x3(self, , , ):
        """
        V.Diagonalize3x3(((float, float, float), (float, float, float), (
            float, float, float)), [float, float, float], [[float, float,
            float], [float, float, float], [float, float, float]])
        C++: static void Diagonalize3x3(const double A[3][3], double w[3],
             double V[3][3])
        
        Diagonalize a symmetric 3x3 matrix and return the eigenvalues in
        w and the eigenvectors in the columns of V.  The matrix V will
        have a positive determinant, and the three eigenvectors will be
        aligned as closely as possible with the x, y, and z axes.
        """
        ...
    
    def Distance2BetweenPoints(self, , ):
        """
        V.Distance2BetweenPoints((float, float, float), (float, float,
            float)) -> float
        C++: static double Distance2BetweenPoints(const double p1[3],
            const double p2[3])
        
        Compute distance squared between two points p1 and p2. (double
        version).
        """
        ...
    
    def Dot(self, , ):
        """
        V.Dot((float, float, float), (float, float, float)) -> float
        C++: static double Dot(const double a[3], const double b[3])
        
        Dot product of two 3-vectors (double version).
        """
        ...
    
    def Dot2D(self, , ):
        """
        V.Dot2D((float, float), (float, float)) -> float
        C++: static double Dot2D(const double x[2], const double y[2])
        
        Dot product of two 2-vectors. (double version).
        """
        ...
    
    def ExtentIsWithinOtherExtent(self, , ):
        """
        V.ExtentIsWithinOtherExtent((int, int, int, int, int, int), (int,
            int, int, int, int, int)) -> int
        C++: static vtkTypeBool ExtentIsWithinOtherExtent(
            const int extent1[6], const int extent2[6])
        
        Return true if first 3D extent is within second 3D extent Extent
        is x-min, x-max, y-min, y-max, z-min, z-max
        """
        ...
    
    def Factorial(self, p_int):
        """
        V.Factorial(int) -> int
        C++: static vtkTypeInt64 Factorial(int N)
        
        Compute N factorial, N! = N*(N-1) * (N-2)...*3*2*1. 0! is taken
        to be 1.
        """
        ...
    
    def Floor(self, p_float):
        """
        V.Floor(float) -> int
        C++: static int Floor(double x)
        
        Rounds a double to the nearest integer not greater than itself.
        This is faster than floor() but provides undefined output on
        overflow.
        """
        ...
    
    def FreeCombination(self, *int):
        """
        V.FreeCombination([int, ...])
        C++: static void FreeCombination(int *combination)
        
        Free the "iterator" array created by vtkMath::BeginCombination.
        """
        ...
    
    def Gaussian(self):
        """
        V.Gaussian() -> float
        C++: static double Gaussian()
        V.Gaussian(float, float) -> float
        C++: static double Gaussian(double mean, double std)
        
        Generate pseudo-random numbers distributed according to the
        standard normal distribution.
        
        * DON'T USE Random(), RandomSeed(), GetSeed(), Gaussian()
        * THIS IS STATIC SO THIS IS PRONE TO ERRORS (SPECIALLY FOR
          REGRESSION TESTS)
        * THIS IS HERE FOR BACKWARD COMPATIBILITY ONLY.
        * Instead, for a sequence of random numbers with a uniform
          distribution
        * create a vtkMinimalStandardRandomSequence object.
        * For a sequence of random numbers with a gaussian/normal
          distribution
        * create a vtkBoxMuellerRandomSequence object.
        """
        ...
    
    def GaussianAmplitude(self, p_float, p_float_1):
        """
        V.GaussianAmplitude(float, float) -> float
        C++: static double GaussianAmplitude(const double variance,
            const double distanceFromMean)
        V.GaussianAmplitude(float, float, float) -> float
        C++: static double GaussianAmplitude(const double mean,
            const double variance, const double position)
        
        Compute the amplitude of a Gaussian function with mean=0 and
        specified variance. That is, 1./(std::sqrt(2 Pi * variance)) *
        exp(-distanceFromMean^2/(2.*variance)).
        """
        ...
    
    def GaussianWeight(self, p_float, p_float_1):
        """
        V.GaussianWeight(float, float) -> float
        C++: static double GaussianWeight(const double variance,
            const double distanceFromMean)
        V.GaussianWeight(float, float, float) -> float
        C++: static double GaussianWeight(const double mean,
            const double variance, const double position)
        
        Compute the amplitude of an unnormalized Gaussian function with
        mean=0 and specified variance. That is,
        exp(-distanceFromMean^2/(2.*variance)). When distanceFromMean =
        0, this function returns 1.
        """
        ...
    
    def GetAdjustedScalarRange(self, vtkDataArray, p_int, p_float=..., p_float=...):
        """
        V.GetAdjustedScalarRange(vtkDataArray, int, [float, float]) -> int
        C++: static vtkTypeBool GetAdjustedScalarRange(
            vtkDataArray *array, int comp, double range[2])
        
        Get a vtkDataArray's scalar range for a given component. If the
        vtkDataArray's data type is unsigned char (VTK_UNSIGNED_CHAR) the
        range is adjusted to the whole data type range [0, 255.0]. Same
        goes for unsigned short (VTK_UNSIGNED_SHORT) but the upper bound
        is also adjusted down to 4095.0 if was between ]255, 4095.0].
        Return 1 on success, 0 otherwise.
        """
        ...
    
    def GetNumberOfGenerationsFromBase(self, string):
        """
        V.GetNumberOfGenerationsFromBase(string) -> int
        C++: vtkIdType GetNumberOfGenerationsFromBase(const char *type)
            override;
        
        Given a the name of a base class of this class type, return the
        distance of inheritance between this class type and the named
        class (how many generations of inheritance are there between this
        class and the named class). If the named class is not in this
        class's inheritance tree, return a negative value. Valid
        responses will always be nonnegative. This method works in
        combination with vtkTypeMacro found in vtkSetGet.h.
        """
        ...
    
    def GetNumberOfGenerationsFromBaseType(self, string):
        """
        V.GetNumberOfGenerationsFromBaseType(string) -> int
        C++: static vtkIdType GetNumberOfGenerationsFromBaseType(
            const char *type)
        
        Given a the name of a base class of this class type, return the
        distance of inheritance between this class type and the named
        class (how many generations of inheritance are there between this
        class and the named class). If the named class is not in this
        class's inheritance tree, return a negative value. Valid
        responses will always be nonnegative. This method works in
        combination with vtkTypeMacro found in vtkSetGet.h.
        """
        ...
    
    def GetScalarTypeFittingRange(self, p_float, p_float_1, p_float_2, p_float_3):
        """
        V.GetScalarTypeFittingRange(float, float, float, float) -> int
        C++: static int GetScalarTypeFittingRange(double range_min,
            double range_max, double scale=1.0, double shift=0.0)
        
        Return the scalar type that is most likely to have enough
        precision to store a given range of data once it has been scaled
        and shifted (i.e. [range_min * scale + shift, range_max * scale +
        shift]. If any one of the parameters is not an integer number
        (decimal part != 0), the search will default to float types only
        (float or double) Return -1 on error or no scalar type found.
        """
        ...
    
    def GetSeed(self):
        """
        V.GetSeed() -> int
        C++: static int GetSeed()
        
        Return the current seed used by the random number generator.
        
        * DON'T USE Random(), RandomSeed(), GetSeed(), Gaussian()
        * THIS IS STATIC SO THIS IS PRONE TO ERRORS (SPECIALLY FOR
          REGRESSION TESTS)
        * THIS IS HERE FOR BACKWARD COMPATIBILITY ONLY.
        * Instead, for a sequence of random numbers with a uniform
          distribution
        * create a vtkMinimalStandardRandomSequence object.
        * For a sequence of random numbers with a gaussian/normal
          distribution
        * create a vtkBoxMuellerRandomSequence object.
        """
        ...
    
    def HSVToRGB(self, , p_float=..., p_float=..., p_float=...):
        """
        V.HSVToRGB((float, float, float), [float, float, float])
        C++: static void HSVToRGB(const double hsv[3], double rgb[3])
        V.HSVToRGB(float, float, float, [float, ...], [float, ...],
            [float, ...])
        C++: static void HSVToRGB(double h, double s, double v, double *r,
             double *g, double *b)
        
        Convert color in HSV format (Hue, Saturation, Value) to RGB
        format (Red, Green, Blue). The input color is not modified. The
        input 'hsv' must be float values in the range [0, 1]. The
        elements of each component of the output 'rgb' are in the range
        [0, 1].
        """
        ...
    
    def Identity3x3(self, *args, **kwargs):
        """
        V.Identity3x3([[float, float, float], [float, float, float],
            [float, float, float]])
        C++: static void Identity3x3(double A[3][3])
        
        Set A to the identity matrix.
        """
        ...
    
    def Inf(self):
        """
        V.Inf() -> float
        C++: static double Inf()
        
        Special IEEE-754 number used to represent positive infinity.
        """
        ...
    
    def Invert3x3(self, , , ):
        """
        V.Invert3x3(((float, float, float), (float, float, float), (float,
             float, float)), [[float, float, float], [float, float,
            float], [float, float, float]])
        C++: static void Invert3x3(const double A[3][3], double AI[3][3])
        
        Invert a 3x3 matrix. The input matrix is A. The output is stored
        in AI.
        """
        ...
    
    def IsA(self, string):
        """
        V.IsA(string) -> int
        C++: vtkTypeBool IsA(const char *type) override;
        
        Return 1 if this class is the same type of (or a subclass of) the
        named class. Returns 0 otherwise. This method works in
        combination with vtkTypeMacro found in vtkSetGet.h.
        """
        ...
    
    def IsFinite(self, p_float):
        """
        V.IsFinite(float) -> bool
        C++: static bool IsFinite(double x)
        
        Test if a number has finite value i.e. it is normal, subnormal or
        zero, but not infinite or Nan.
        """
        ...
    
    def IsInf(self, p_float):
        """
        V.IsInf(float) -> int
        C++: static vtkTypeBool IsInf(double x)
        
        Test if a number is equal to the special floating point value
        infinity.
        """
        ...
    
    def IsNan(self, p_float):
        """
        V.IsNan(float) -> int
        C++: static vtkTypeBool IsNan(double x)
        
        Test if a number is equal to the special floating point value
        Not-A-Number (Nan).
        """
        ...
    
    def IsPowerOfTwo(self, p_int):
        """
        V.IsPowerOfTwo(int) -> bool
        C++: static bool IsPowerOfTwo(vtkTypeUInt64 x)
        
        Returns true if integer is a power of two.
        """
        ...
    
    def IsTypeOf(self, string):
        """
        V.IsTypeOf(string) -> int
        C++: static vtkTypeBool IsTypeOf(const char *type)
        
        Return 1 if this class type is the same type of (or a subclass
        of) the named class. Returns 0 otherwise. This method works in
        combination with vtkTypeMacro found in vtkSetGet.h.
        """
        ...
    
    def LabToRGB(self, , p_float=..., p_float=..., p_float=...):
        """
        V.LabToRGB((float, float, float), [float, float, float])
        C++: static void LabToRGB(const double lab[3], double rgb[3])
        V.LabToRGB(float, float, float, [float, ...], [float, ...],
            [float, ...])
        C++: static void LabToRGB(double L, double a, double b,
            double *red, double *green, double *blue)
        
        Convert color from the CIE-L*ab system to RGB.
        """
        ...
    
    def LabToXYZ(self, , p_float=..., p_float=..., p_float=...):
        """
        V.LabToXYZ((float, float, float), [float, float, float])
        C++: static void LabToXYZ(const double lab[3], double xyz[3])
        V.LabToXYZ(float, float, float, [float, ...], [float, ...],
            [float, ...])
        C++: static void LabToXYZ(double L, double a, double b, double *x,
             double *y, double *z)
        
        Convert color from the CIE-L*ab system to CIE XYZ.
        """
        ...
    
    def LinearSolve3x3(self, , , ):
        """
        V.LinearSolve3x3(((float, float, float), (float, float, float), (
            float, float, float)), (float, float, float), [float, float,
            float])
        C++: static void LinearSolve3x3(const double A[3][3],
            const double x[3], double y[3])
        
        Solve Ay = x for y and place the result in y.  The matrix A is
        destroyed in the process.
        """
        ...
    
    def LUFactor3x3(self, *args, **kwargs):
        """
        V.LUFactor3x3([[float, float, float], [float, float, float],
            [float, float, float]], [int, int, int])
        C++: static void LUFactor3x3(double A[3][3], int index[3])
        
        LU Factorization of a 3x3 matrix.
        """
        ...
    
    def LUSolve3x3(self, , , ):
        """
        V.LUSolve3x3(((float, float, float), (float, float, float), (
            float, float, float)), (int, int, int), [float, float, float])
        C++: static void LUSolve3x3(const double A[3][3],
            const int index[3], double x[3])
        
        LU back substitution for a 3x3 matrix.
        """
        ...
    
    def Matrix3x3ToQuaternion(self, , , ):
        """
        V.Matrix3x3ToQuaternion(((float, float, float), (float, float,
            float), (float, float, float)), [float, float, float, float])
        C++: static void Matrix3x3ToQuaternion(const double A[3][3],
            double quat[4])
        
        Convert a 3x3 matrix into a quaternion.  This will provide the
        best possible answer even if the matrix is not a pure rotation
        matrix. The quaternion is in the form [w, x, y, z]. The method
        used is that of B.K.P. Horn. See:
        https://people.csail.mit.edu/bkph/articles/Quaternions.pdf
        @sa QuaternionToMatrix3x3() MultiplyQuaternion()
        @sa vtkQuaternion
        """
        ...
    
    def Multiply3x3(self, , , ):
        """
        V.Multiply3x3(((float, float, float), (float, float, float), (
            float, float, float)), (float, float, float), [float, float,
            float])
        C++: static void Multiply3x3(const double A[3][3],
            const double in[3], double out[3])
        V.Multiply3x3(((float, float, float), (float, float, float), (
            float, float, float)), ((float, float, float), (float, float,
            float), (float, float, float)), [[float, float, float],
            [float, float, float], [float, float, float]])
        C++: static void Multiply3x3(const double A[3][3],
            const double B[3][3], double C[3][3])
        
        Multiply a vector by a 3x3 matrix.  The result is placed in out.
        """
        ...
    
    def MultiplyQuaternion(self, , , p_float=..., p_float=..., p_float=..., p_float=...):
        """
        V.MultiplyQuaternion((float, float, float, float), (float, float,
            float, float), [float, float, float, float])
        C++: static void MultiplyQuaternion(const double q1[4],
            const double q2[4], double q[4])
        
        Multiply two quaternions. This is used to concatenate rotations.
        Quaternions are in the form [w, x, y, z].
        @sa Matrix3x3ToQuaternion() QuaternionToMatrix3x3()
        @sa vtkQuaternion
        """
        ...
    
    def MultiplyScalar(self, p_float=..., p_float=..., p_float=..., *args, **kwargs):
        """
        V.MultiplyScalar([float, float, float], float)
        C++: static void MultiplyScalar(double a[3], double s)
        
        Multiplies a 3-vector by a scalar (double version). This modifies
        the input 3-vector.
        """
        ...
    
    def MultiplyScalar2D(self, p_float=..., p_float=..., *args, **kwargs):
        """
        V.MultiplyScalar2D([float, float], float)
        C++: static void MultiplyScalar2D(double a[2], double s)
        
        Multiplies a 2-vector by a scalar (double version). This modifies
        the input 2-vector.
        """
        ...
    
    def Nan(self):
        """
        V.Nan() -> float
        C++: static double Nan()
        
        Special IEEE-754 number used to represent Not-A-Number (Nan).
        """
        ...
    
    def NearestPowerOfTwo(self, p_int):
        """
        V.NearestPowerOfTwo(int) -> int
        C++: static int NearestPowerOfTwo(int x)
        
        Compute the nearest power of two that is not less than x. The
        return value is 1 if x is less than or equal to zero, and is
        VTK_INT_MIN if result is too large to fit in an int.
        """
        ...
    
    def NegInf(self):
        """
        V.NegInf() -> float
        C++: static double NegInf()
        
        Special IEEE-754 number used to represent negative infinity.
        """
        ...
    
    def NewInstance(self):
        """
        V.NewInstance() -> vtkMath
        C++: vtkMath *NewInstance()
        """
        ...
    
    def NextCombination(self, p_int, p_int_1, *int):
        """
        V.NextCombination(int, int, [int, ...]) -> int
        C++: static int NextCombination(int m, int n, int *combination)
        
        Given m, n, and a valid combination of n integers in the range
        [0,m[, this function alters the integers into the next
        combination in a sequence of all combinations of n items from a
        pool of m.
        
        * If the combination is the last item in the sequence on input,
        * then combination is unaltered and 0 is returned.
        * Otherwise, 1 is returned and combination is updated.
        """
        ...
    
    def Norm(self, float_tuple, p_int):
        """
        V.Norm((float, ...), int) -> float
        C++: static double Norm(const double *x, int n)
        V.Norm((float, float, float)) -> float
        C++: static double Norm(const double v[3])
        
        Compute the norm of n-vector. x is the vector, n is its length.
        """
        ...
    
    def Norm2D(self, ):
        """
        V.Norm2D((float, float)) -> float
        C++: static double Norm2D(const double x[2])
        
        Compute the norm of a 2-vector. (double version).
        """
        ...
    
    def Normalize(self, p_float=..., p_float=..., p_float=...):
        """
        V.Normalize([float, float, float]) -> float
        C++: static double Normalize(double v[3])
        
        Normalize (in place) a 3-vector. Returns norm of vector (double
        version).
        """
        ...
    
    def Normalize2D(self, p_float=..., p_float=...):
        """
        V.Normalize2D([float, float]) -> float
        C++: static double Normalize2D(double v[2])
        
        Normalize (in place) a 2-vector. Returns norm of vector. (double
        version).
        """
        ...
    
    def Orthogonalize3x3(self, , , ):
        """
        V.Orthogonalize3x3(((float, float, float), (float, float, float),
            (float, float, float)), [[float, float, float], [float, float,
             float], [float, float, float]])
        C++: static void Orthogonalize3x3(const double A[3][3],
            double B[3][3])
        
        Orthogonalize a 3x3 matrix and put the result in B.  If matrix A
        has a negative determinant, then B will be a rotation plus a flip
        i.e. it will have a determinant of -1.
        """
        ...
    
    def Outer(self, , , *args, **kwargs):
        """
        V.Outer((float, float, float), (float, float, float), [[float,
            float, float], [float, float, float], [float, float, float]])
        C++: static void Outer(const double a[3], const double b[3],
            double c[3][3])
        
        Outer product of two 3-vectors (double version).
        """
        ...
    
    def Outer2D(self, , , *args, **kwargs):
        """
        V.Outer2D((float, float), (float, float), [[float, float], [float,
             float]])
        C++: static void Outer2D(const double x[2], const double y[2],
            double A[2][2])
        
        Outer product of two 2-vectors (double version).
        """
        ...
    
    def Perpendiculars(self, , p_float=..., p_float=..., p_float=..., *args, **kwargs):
        """
        V.Perpendiculars((float, float, float), [float, float, float],
            [float, float, float], float)
        C++: static void Perpendiculars(const double v1[3], double v2[3],
            double v3[3], double theta)
        
        Given a unit vector v1, find two unit vectors v2 and v3 such that
        v1 cross v2 = v3 (i.e. the vectors are perpendicular to each
        other). There is an infinite number of such vectors, specify an
        angle theta to choose one set.  If you want only one
        perpendicular vector, specify nullptr for v3.
        """
        ...
    
    def Pi(self):
        """
        V.Pi() -> float
        C++: static double Pi()
        
        A mathematical constant. This version is atan(1.0) * 4.0
        """
        ...
    
    def PlaneIntersectsAABB(self, , , ):
        """
        V.PlaneIntersectsAABB((float, float, float, float, float, float),
            (float, float, float), (float, float, float)) -> int
        C++: static int PlaneIntersectsAABB(const double bounds[6],
            const double normal[3], const double point[3])
        
        Implements Plane / Axis-Aligned Bounding-Box intersection as
        described in Graphics Gems IV, Ned Greene; pp. 75-76. Variable
        names are based on the description in the book. This function
        returns +1 if the box lies fully in the positive side of the
        plane (by convention, the side to which the plane's normal points
        to), -1 if the box fully lies in the negative side and 0 if the
        plane intersects the box.  -2 is returned if any of the arguments
        is invalid.
        """
        ...
    
    def PointIsWithinBounds(self, , , ):
        """
        V.PointIsWithinBounds((float, float, float), (float, float, float,
             float, float, float), (float, float, float)) -> int
        C++: static vtkTypeBool PointIsWithinBounds(const double point[3],
             const double bounds[6], const double delta[3])
        
        Return true if point is within the given 3D bounds Bounds is
        x-min, x-max, y-min, y-max, z-min, z-max Delta is the error
        margin along each axis (usually a small number)
        """
        ...
    
    def ProjectVector(self, , , p_float=..., p_float=..., p_float=...):
        """
        V.ProjectVector((float, float, float), (float, float, float),
            [float, float, float]) -> bool
        C++: static bool ProjectVector(const double a[3],
            const double b[3], double projection[3])
        
        Compute the projection of vector a on vector b and return it in
        projection[3]. If b is a zero vector, the function returns false
        and 'projection' is invalid. Otherwise, it returns true.
        """
        ...
    
    def ProjectVector2D(self, , , p_float=..., p_float=...):
        """
        V.ProjectVector2D((float, float), (float, float), [float, float])
            -> bool
        C++: static bool ProjectVector2D(const double a[2],
            const double b[2], double projection[2])
        
        Compute the projection of 2D vector a on 2D vector b and returns
        the result in projection[2]. If b is a zero vector, the function
        returns false and 'projection' is invalid. Otherwise, it returns
        true.
        """
        ...
    
    def QuadraticRoot(self, p_float, p_float_1, p_float_2, p_float_3, p_float_4, *float):
        """
        V.QuadraticRoot(float, float, float, float, float, [float, ...])
            -> int
        C++: static int QuadraticRoot(double a, double b, double c,
            double min, double max, double *u)
        
        find roots of ax^2+bx+c=0  in the interval min,max. place the
        roots in u[2] and return how many roots found
        """
        ...
    
    def QuaternionToMatrix3x3(self, , *args, **kwargs):
        """
        V.QuaternionToMatrix3x3((float, float, float, float), [[float,
            float, float], [float, float, float], [float, float, float]])
        C++: static void QuaternionToMatrix3x3(const double quat[4],
            double A[3][3])
        
        Convert a quaternion to a 3x3 rotation matrix.  The quaternion
        does not have to be normalized beforehand. The quaternion must be
        in the form [w, x, y, z].
        @sa Matrix3x3ToQuaternion() MultiplyQuaternion()
        @sa vtkQuaternion
        """
        ...
    
    def RadiansFromDegrees(self, p_float):
        """
        V.RadiansFromDegrees(float) -> float
        C++: static double RadiansFromDegrees(double degrees)
        
        Convert degrees into radians
        """
        ...
    
    def Random(self):
        """
        V.Random() -> float
        C++: static double Random()
        V.Random(float, float) -> float
        C++: static double Random(double min, double max)
        
        Generate pseudo-random numbers distributed according to the
        uniform distribution between 0.0 and 1.0. This is used to provide
        portability across different systems.
        
        * DON'T USE Random(), RandomSeed(), GetSeed(), Gaussian()
        * THIS IS STATIC SO THIS IS PRONE TO ERRORS (SPECIALLY FOR
          REGRESSION TESTS)
        * THIS IS HERE FOR BACKWARD COMPATIBILITY ONLY.
        * Instead, for a sequence of random numbers with a uniform
          distribution
        * create a vtkMinimalStandardRandomSequence object.
        * For a sequence of random numbers with a gaussian/normal
          distribution
        * create a vtkBoxMuellerRandomSequence object.
        """
        ...
    
    def RandomSeed(self, p_int):
        """
        V.RandomSeed(int)
        C++: static void RandomSeed(int s)
        
        Initialize seed value. NOTE: Random() has the bad property that
        the first random number returned after RandomSeed() is called is
        proportional to the seed value! To help solve this, call
        RandomSeed() a few times inside seed. This doesn't ruin the
        repeatability of Random().
        
        * DON'T USE Random(), RandomSeed(), GetSeed(), Gaussian()
        * THIS IS STATIC SO THIS IS PRONE TO ERRORS (SPECIALLY FOR
          REGRESSION TESTS)
        * THIS IS HERE FOR BACKWARD COMPATIBILITY ONLY.
        * Instead, for a sequence of random numbers with a uniform
          distribution
        * create a vtkMinimalStandardRandomSequence object.
        * For a sequence of random numbers with a gaussian/normal
          distribution
        * create a vtkBoxMuellerRandomSequence object.
        """
        ...
    
    def RGBToHSV(self, , p_float=..., p_float=..., p_float=...):
        """
        V.RGBToHSV((float, float, float), [float, float, float])
        C++: static void RGBToHSV(const double rgb[3], double hsv[3])
        V.RGBToHSV(float, float, float, [float, ...], [float, ...],
            [float, ...])
        C++: static void RGBToHSV(double r, double g, double b, double *h,
             double *s, double *v)
        
        Convert color in RGB format (Red, Green, Blue) to HSV format
        (Hue, Saturation, Value). The input color is not modified. The
        input RGB must be float values in the range [0, 1]. The output
        ranges are hue [0, 1], saturation [0, 1], and value [0, 1].
        """
        ...
    
    def RGBToLab(self, , p_float=..., p_float=..., p_float=...):
        """
        V.RGBToLab((float, float, float), [float, float, float])
        C++: static void RGBToLab(const double rgb[3], double lab[3])
        V.RGBToLab(float, float, float, [float, ...], [float, ...],
            [float, ...])
        C++: static void RGBToLab(double red, double green, double blue,
            double *L, double *a, double *b)
        
        Convert color from the RGB system to CIE-L*ab. The input RGB must
        be values in the range [0, 1]. The output ranges of 'L' is [0,
        100]. The output range of 'a' and 'b' are approximately [-110,
        110].
        """
        ...
    
    def RGBToXYZ(self, , p_float=..., p_float=..., p_float=...):
        """
        V.RGBToXYZ((float, float, float), [float, float, float])
        C++: static void RGBToXYZ(const double rgb[3], double xyz[3])
        V.RGBToXYZ(float, float, float, [float, ...], [float, ...],
            [float, ...])
        C++: static void RGBToXYZ(double r, double g, double b, double *x,
             double *y, double *z)
        
        Convert color from the RGB system to CIE XYZ.
        """
        ...
    
    def RotateVectorByNormalizedQuaternion(self, , , p_float=..., p_float=..., p_float=...):
        """
        V.RotateVectorByNormalizedQuaternion((float, float, float), (
            float, float, float, float), [float, float, float])
        C++: static void RotateVectorByNormalizedQuaternion(
            const double v[3], const double q[4], double r[3])
        
        rotate a vector by a normalized quaternion using //
        https://en.wikipedia.org/wiki/Rodrigues%27_rotation_formula
        """
        ...
    
    def RotateVectorByWXYZ(self, , , p_float=..., p_float=..., p_float=...):
        """
        V.RotateVectorByWXYZ((float, float, float), (float, float, float,
            float), [float, float, float])
        C++: static void RotateVectorByWXYZ(const double v[3],
            const double q[4], double r[3])
        
        rotate a vector by WXYZ using //
        https://en.wikipedia.org/wiki/Rodrigues%27_rotation_formula
        """
        ...
    
    def Round(self, p_float):
        """
        V.Round(float) -> int
        C++: static int Round(double f)
        """
        ...
    
    def SafeDownCast(self, vtkObjectBase):
        """
        V.SafeDownCast(vtkObjectBase) -> vtkMath
        C++: static vtkMath *SafeDownCast(vtkObjectBase *o)
        """
        ...
    
    def SingularValueDecomposition3x3(self, , , ):
        """
        V.SingularValueDecomposition3x3(((float, float, float), (float,
            float, float), (float, float, float)), [[float, float, float],
             [float, float, float], [float, float, float]], [float, float,
             float], [[float, float, float], [float, float, float],
            [float, float, float]])
        C++: static void SingularValueDecomposition3x3(
            const double A[3][3], double U[3][3], double w[3],
            double VT[3][3])
        
        Perform singular value decomposition on a 3x3 matrix.  This is
        not done using a conventional SVD algorithm, instead it is done
        using Orthogonalize3x3 and Diagonalize3x3.  Both output matrices
        U and VT will have positive determinants, and the w values will
        be arranged such that the three rows of VT are aligned as closely
        as possible with the x, y, and z axes respectively.  If the
        determinant of A is negative, then the three w values will be
        negative.
        """
        ...
    
    def Solve3PointCircle(self, , , , p_float=..., p_float=..., p_float=...):
        """
        V.Solve3PointCircle((float, float, float), (float, float, float),
            (float, float, float), [float, float, float]) -> float
        C++: static double Solve3PointCircle(const double p1[3],
            const double p2[3], const double p3[3], double center[3])
        
        In Euclidean space, there is a unique circle passing through any
        given three non-collinear points P1, P2, and P3. Using Cartesian
        coordinates to represent these points as spatial vectors, it is
        possible to use the dot product and cross product to calculate
        the radius and center of the circle. See:
        http://en.wikipedia.org/wiki/Circumscribed_circle and more
        specifically the section Barycentric coordinates from cross- and
        dot-products
        """
        ...
    
    def Subtract(self, , , p_float=..., p_float=..., p_float=...):
        """
        V.Subtract((float, float, float), (float, float, float), [float,
            float, float])
        C++: static void Subtract(const double a[3], const double b[3],
            double c[3])
        
        Subtraction of two 3-vectors (double version). Result is stored
        in c according to c = a - b.
        """
        ...
    
    def Transpose3x3(self, , , ):
        """
        V.Transpose3x3(((float, float, float), (float, float, float), (
            float, float, float)), [[float, float, float], [float, float,
            float], [float, float, float]])
        C++: static void Transpose3x3(const double A[3][3],
            double AT[3][3])
        
        Transpose a 3x3 matrix. The input matrix is A. The output is
        stored in AT.
        """
        ...
    
    def UninitializeBounds(self, p_float=..., p_float=..., p_float=..., p_float=..., p_float=..., p_float=...):
        """
        V.UninitializeBounds([float, float, float, float, float, float])
        C++: static void UninitializeBounds(double bounds[6])
        
        Set the bounds to an uninitialized state
        """
        ...
    
    def XYZToLab(self, , p_float=..., p_float=..., p_float=...):
        """
        V.XYZToLab((float, float, float), [float, float, float])
        C++: static void XYZToLab(const double xyz[3], double lab[3])
        V.XYZToLab(float, float, float, [float, ...], [float, ...],
            [float, ...])
        C++: static void XYZToLab(double x, double y, double z, double *L,
             double *a, double *b)
        
        Convert Color from the CIE XYZ system to CIE-L*ab.
        """
        ...
    
    def XYZToRGB(self, , p_float=..., p_float=..., p_float=...):
        """
        V.XYZToRGB((float, float, float), [float, float, float])
        C++: static void XYZToRGB(const double xyz[3], double rgb[3])
        V.XYZToRGB(float, float, float, [float, ...], [float, ...],
            [float, ...])
        C++: static void XYZToRGB(double x, double y, double z, double *r,
             double *g, double *b)
        
        Convert color from the CIE XYZ system to RGB.
        """
        ...
    
    def __delattr__(self, *args, **kwargs):
        """ Implement delattr(self, name). """
        ...
    
    def __getattribute__(self, *args, **kwargs):
        """ Return getattr(self, name). """
        ...
    
    def __init__(self, *args, **kwargs) -> None:
        ...
    
    @staticmethod
    def __new__(*args, **kwargs):
        """ Create and return a new object.  See help(type) for accurate signature. """
        ...
    
    def __repr__(self, *args, **kwargs):
        """ Return repr(self). """
        ...
    
    def __setattr__(self, *args, **kwargs):
        """ Implement setattr(self, name, value). """
        ...
    
    def __str__(self, *args, **kwargs) -> str:
        """ Return str(self). """
        ...
    
    __this__ = ...
    __dict__ = ...
    __vtkname__ = ...


