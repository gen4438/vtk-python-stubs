"""
This type stub file was generated by pyright.
"""

from .object import object

class vtkArrayExtents(object):
    """
    vtkArrayExtents - Stores the number of dimensions and valid
    coordinate ranges along each dimension for vtkArray.
    
    vtkArrayExtents describes the number of dimensions and coordinate
    ranges along each dimension of an N-way collection of values.  It is
    used to retrieve and update the extents of a vtkArray object.
    
    Conceptually, vtkArrayExtents is a collection of vtkArrayRange
    objects, one per dimension, that store the half-open range of valid
    coordinates (the "extent") for that dimension.  Because each extent
    is stored as a range rather than a size, you can: create arrays that
    use one-based coordinates for consistency with mathematics and tools
    such as MATLAB; easily represent arbitrary subsets of an array; and
    easily store and manipulate distributed arrays using "global"
    coordinates.
    
    Convenience constructors are provided for creating extents along one,
    two, and three dimensions.  For higher dimensions, you can:
    
    Use the static Uniform() factory method to create extents that have
    the same size along an arbitrary number of dimensions.
    
    Use the default constructor and the Append() method to "grow" your
    extents to the correct number of dimensions.
    
    Use the default constructuor, SetDimensions() and operator[] to
    assign a size along each dimension.
    
    @sa
    vtkArray, vtkArrayRange, vtkArrayCoordinates
    
    @par Thanks: Developed by Timothy M. Shead (tshead@sandia.gov) at
    Sandia National Laboratories.
    
    vtkArrayExtents()
    explicit vtkArrayExtents(const CoordinateT i)
    explicit vtkArrayExtents(const vtkArrayRange &i)
    vtkArrayExtents(const CoordinateT i, const CoordinateT j)
    vtkArrayExtents(const vtkArrayRange &i, const vtkArrayRange &j)
    vtkArrayExtents(const CoordinateT i, const CoordinateT j,
        const CoordinateT k)
    vtkArrayExtents(const vtkArrayRange &i, const vtkArrayRange &j,
        const vtkArrayRange &k)
    vtkArrayExtents(const &vtkArrayExtents)
    """
    def Append(self, vtkArrayRange):
        """
        V.Append(vtkArrayRange)
        C++: void Append(const vtkArrayRange &extent)
        
        Grow the number of dimensions by one, specifying the extent of
        the new dimension.
        """
        ...
    
    def Contains(self, vtkArrayCoordinates):
        """
        V.Contains(vtkArrayCoordinates) -> bool
        C++: bool Contains(const vtkArrayCoordinates &coordinates)
        
        Returns true if the given array coordinates are completely
        contained by the current extents (i.e. extent begin <= coordinate
        and coordinate < extent end along every dimension).  Returns
        false if the array coordinates are outside the current extents,
        or contain a different number of dimensions.
        """
        ...
    
    def GetDimensions(self):
        """
        V.GetDimensions() -> int
        C++: DimensionT GetDimensions()
        
        Return the current number of dimensions.
        """
        ...
    
    def GetExtent(self, p_int):
        """
        V.GetExtent(int) -> vtkArrayRange
        C++: vtkArrayRange GetExtent(DimensionT i)
        
        Get the extent of the i-th dimension.
        """
        ...
    
    def GetLeftToRightCoordinatesN(self, p_int, vtkArrayCoordinates):
        """
        V.GetLeftToRightCoordinatesN(int, vtkArrayCoordinates)
        C++: void GetLeftToRightCoordinatesN(SizeT n,
            vtkArrayCoordinates &coordinates)
        
        Returns coordinates that reference the n-th value in the extents,
        where n is in the range [0, GetSize()).  The returned coordinates
        will be ordered so that the left-most indices vary fastest.  This
        is equivalent to column-major ordering for matrices, and
        corresponds to the order in which consecutive array values would
        be stored in languages such as Fortran, MATLAB, Octave, and R.
        """
        ...
    
    def GetRightToLeftCoordinatesN(self, p_int, vtkArrayCoordinates):
        """
        V.GetRightToLeftCoordinatesN(int, vtkArrayCoordinates)
        C++: void GetRightToLeftCoordinatesN(SizeT n,
            vtkArrayCoordinates &coordinates)
        
        Returns coordinates that reference the n-th value in the extents,
        where n is in the range [0, GetSize()).  The returned coordinates
        will be ordered so that the right-most indices vary fastest. 
        This is equivalent to row-major ordering for matrices, and
        corresponds to the order in which consecutive array values would
        be stored in languages including C and C++.
        """
        ...
    
    def GetSize(self):
        """
        V.GetSize() -> int
        C++: SizeT GetSize()
        
        Return the number of values that *could* be stored using the
        current extents.  This is equal to the product of the size of the
        extent along each dimension.
        """
        ...
    
    def SameShape(self, vtkArrayExtents):
        """
        V.SameShape(vtkArrayExtents) -> bool
        C++: bool SameShape(const vtkArrayExtents &rhs)
        
        Returns true iff the given extents have the same number of
        dimensions and size along each dimension.  Note that the ranges
        along each dimension may have different values, so long as their
        sizes match.
        """
        ...
    
    def SetDimensions(self, p_int):
        """
        V.SetDimensions(int)
        C++: void SetDimensions(DimensionT dimensions)
        
        Set the current number of dimensions.  Note that this method
        resets the extent along each dimension to an empty range, so you
        must assign each dimension's extent explicitly using operator[]
        after calling SetDimensions().
        """
        ...
    
    def SetExtent(self, p_int, vtkArrayRange):
        """
        V.SetExtent(int, vtkArrayRange)
        C++: void SetExtent(DimensionT i, const vtkArrayRange &)
        
        Set the extent of the i-th dimension.
        """
        ...
    
    def Uniform(self, p_int, p_int_1):
        """
        V.Uniform(int, int) -> vtkArrayExtents
        C++: static vtkArrayExtents Uniform(DimensionT n, CoordinateT m)
        
        Create n-dimensional extents with extent [0, m) along each
        dimension. This is useful for creating e.g: a square matrix.
        """
        ...
    
    def ZeroBased(self):
        """
        V.ZeroBased() -> bool
        C++: bool ZeroBased()
        
        Returns true iff every range in the current extents is
        zero-based. This is useful as a precondition test for legacy
        filters/operations that predate the switch to range-based extents
        and assume that all extents are zero-based.  In general, new code
        should be written to work with arbitrary range extents, so won't
        need to perform this check.
        """
        ...
    
    def __delitem__(self, *args, **kwargs):
        """ Delete self[key]. """
        ...
    
    def __eq__(self, *args, **kwargs) -> bool:
        """ Return self==value. """
        ...
    
    def __getattribute__(self, *args, **kwargs):
        """ Return getattr(self, name). """
        ...
    
    def __getitem__(self, *args, **kwargs):
        """ Return self[key]. """
        ...
    
    def __ge__(self, *args, **kwargs) -> bool:
        """ Return self>=value. """
        ...
    
    def __gt__(self, *args, **kwargs) -> bool:
        """ Return self>value. """
        ...
    
    def __hash__(self, *args, **kwargs) -> int:
        """ Return hash(self). """
        ...
    
    def __init__(self) -> None:
        ...
    
    def __len__(self, *args, **kwargs):
        """ Return len(self). """
        ...
    
    def __le__(self, *args, **kwargs) -> bool:
        """ Return self<=value. """
        ...
    
    def __lt__(self, *args, **kwargs) -> bool:
        """ Return self<value. """
        ...
    
    @staticmethod
    def __new__(*args, **kwargs):
        """ Create and return a new object.  See help(type) for accurate signature. """
        ...
    
    def __ne__(self, *args, **kwargs) -> bool:
        """ Return self!=value. """
        ...
    
    def __repr__(self, *args, **kwargs):
        """ Return repr(self). """
        ...
    
    def __setitem__(self, *args, **kwargs):
        """ Set self[key] to value. """
        ...
    
    def __str__(self, *args, **kwargs) -> str:
        """ Return str(self). """
        ...
    


