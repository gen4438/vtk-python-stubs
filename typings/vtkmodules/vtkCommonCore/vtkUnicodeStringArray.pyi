"""
This type stub file was generated by pyright.
"""

from .vtkAbstractArray import vtkAbstractArray

class vtkUnicodeStringArray(vtkAbstractArray):
    """
    vtkUnicodeStringArray - Subclass of vtkAbstractArray that holds
    vtkUnicodeStrings
    
    Superclass: vtkAbstractArray
    
    @par Thanks: Developed by Timothy M. Shead (tshead@sandia.gov) at
    Sandia National Laboratories.
    """
    def Allocate(self, p_int, p_int_1):
        """
        V.Allocate(int, int) -> int
        C++: vtkTypeBool Allocate(vtkIdType sz, vtkIdType ext=1000)
            override;
        
        Allocate memory for this array. Delete old storage only if
        necessary. Note that ext is no longer used. This method will
        reset MaxId to -1 and resize the array capacity such that
        this->Size >= numValues. If numValues is 0, all memory will be
        freed. Return 1 on success, 0 on failure.
        """
        ...
    
    def ClearLookup(self):
        """
        V.ClearLookup()
        C++: void ClearLookup() override;
        
        Delete the associated fast lookup data structure on this array,
        if it exists.  The lookup will be rebuilt on the next call to a
        lookup function.
        """
        ...
    
    def DataChanged(self):
        """
        V.DataChanged()
        C++: void DataChanged() override;
        
        Tell the array explicitly that the data has changed. This is only
        necessary to call when you modify the array contents without
        using the array's API (i.e. you retrieve a pointer to the data
        and modify the array contents).  You need to call this so that
        the fast lookup will know to rebuild itself.  Otherwise, the
        lookup functions will give incorrect results.
        """
        ...
    
    def DeepCopy(self, vtkAbstractArray):
        """
        V.DeepCopy(vtkAbstractArray)
        C++: void DeepCopy(vtkAbstractArray *da) override;
        
        Deep copy of data. Implementation left to subclasses, which
        should support as many type conversions as possible given the
        data type.
        
        * Subclasses should call vtkAbstractArray::DeepCopy() so that the
        * information object (if one exists) is copied from da.
        """
        ...
    
    def GetActualMemorySize(self):
        """
        V.GetActualMemorySize() -> int
        C++: unsigned long GetActualMemorySize() override;
        
        Return the memory in kibibytes (1024 bytes) consumed by this data
        array. Used to support streaming and reading/writing data. The
        value returned is guaranteed to be greater than or equal to the
        memory required to actually represent the data represented by
        this object. The information returned is valid only after the
        pipeline has been updated.
        """
        ...
    
    def GetDataType(self):
        """
        V.GetDataType() -> int
        C++: int GetDataType() override;
        
        Return the underlying data type. An integer indicating data type
        is returned as specified in vtkType.h.
        """
        ...
    
    def GetDataTypeSize(self):
        """
        V.GetDataTypeSize() -> int
        C++: int GetDataTypeSize() override;
        
        Return the size of the underlying data type.  For a bit, 0 is
        returned.  For string 0 is returned. Arrays with variable length
        components return 0.
        """
        ...
    
    def GetElementComponentSize(self):
        """
        V.GetElementComponentSize() -> int
        C++: int GetElementComponentSize() override;
        
        Return the size, in bytes, of the lowest-level element of an
        array.  For vtkDataArray and subclasses this is the size of the
        data type.  For vtkStringArray, this is
        sizeof(vtkStdString::value_type), which winds up being
        sizeof(char).
        """
        ...
    
    def GetNumberOfGenerationsFromBase(self, string):
        """
        V.GetNumberOfGenerationsFromBase(string) -> int
        C++: vtkIdType GetNumberOfGenerationsFromBase(const char *type)
            override;
        
        Given a the name of a base class of this class type, return the
        distance of inheritance between this class type and the named
        class (how many generations of inheritance are there between this
        class and the named class). If the named class is not in this
        class's inheritance tree, return a negative value. Valid
        responses will always be nonnegative. This method works in
        combination with vtkTypeMacro found in vtkSetGet.h.
        """
        ...
    
    def GetNumberOfGenerationsFromBaseType(self, string):
        """
        V.GetNumberOfGenerationsFromBaseType(string) -> int
        C++: static vtkIdType GetNumberOfGenerationsFromBaseType(
            const char *type)
        
        Given a the name of a base class of this class type, return the
        distance of inheritance between this class type and the named
        class (how many generations of inheritance are there between this
        class and the named class). If the named class is not in this
        class's inheritance tree, return a negative value. Valid
        responses will always be nonnegative. This method works in
        combination with vtkTypeMacro found in vtkSetGet.h.
        """
        ...
    
    def GetUTF8Value(self, p_int):
        """
        V.GetUTF8Value(int) -> string
        C++: const char *GetUTF8Value(vtkIdType i)
        """
        ...
    
    def GetValue(self, p_int):
        """
        V.GetValue(int) -> unicode
        C++: vtkUnicodeString &GetValue(vtkIdType i)
        """
        ...
    
    def GetVariantValue(self, p_int):
        """
        V.GetVariantValue(int) -> vtkVariant
        C++: vtkVariant GetVariantValue(vtkIdType idx) override;
        
        Retrieve value from the array as a variant.
        """
        ...
    
    def GetVoidPointer(self, p_int):
        """
        V.GetVoidPointer(int) -> void
        C++: void *GetVoidPointer(vtkIdType id) override;
        
        Return a void pointer. For image pipeline interface and other
        special pointer manipulation. Use of this method is discouraged,
        as newer arrays require a deep-copy of the array data in order to
        return a suitable pointer. See vtkArrayDispatch for a safer
        alternative for fast data access.
        """
        ...
    
    def Initialize(self):
        """
        V.Initialize()
        C++: void Initialize() override;
        
        Release storage and reset array to initial state.
        """
        ...
    
    def InsertNextTuple(self, p_int, vtkAbstractArray):
        """
        V.InsertNextTuple(int, vtkAbstractArray) -> int
        C++: vtkIdType InsertNextTuple(vtkIdType j,
            vtkAbstractArray *source) override;
        
        Insert the tuple from srcTupleIdx in the source array at the end
        of this array. Note that memory allocation is performed as
        necessary to hold the data. Returns the tuple index at which the
        data was inserted.
        """
        ...
    
    def InsertNextUTF8Value(self, string):
        """
        V.InsertNextUTF8Value(string)
        C++: void InsertNextUTF8Value(const char *)
        """
        ...
    
    def InsertNextValue(self, unicode):
        """
        V.InsertNextValue(unicode) -> int
        C++: vtkIdType InsertNextValue(const vtkUnicodeString &)
        """
        ...
    
    def InsertTuple(self, p_int, p_int_1, vtkAbstractArray):
        """
        V.InsertTuple(int, int, vtkAbstractArray)
        C++: void InsertTuple(vtkIdType i, vtkIdType j,
            vtkAbstractArray *source) override;
        
        Insert the tuple at srcTupleIdx in the source array into this
        array at dstTupleIdx. Note that memory allocation is performed as
        necessary to hold the data.
        """
        ...
    
    def InsertTuples(self, vtkIdList, vtkIdList_1, vtkAbstractArray):
        """
        V.InsertTuples(vtkIdList, vtkIdList, vtkAbstractArray)
        C++: void InsertTuples(vtkIdList *dstIds, vtkIdList *srcIds,
            vtkAbstractArray *source) override;
        V.InsertTuples(int, int, int, vtkAbstractArray)
        C++: void InsertTuples(vtkIdType dstStart, vtkIdType n,
            vtkIdType srcStart, vtkAbstractArray *source) override;
        
        Copy the tuples indexed in srcIds from the source array to the
        tuple locations indexed by dstIds in this array. Note that memory
        allocation is performed as necessary to hold the data.
        """
        ...
    
    def InsertValue(self, p_int, unicode):
        """
        V.InsertValue(int, unicode)
        C++: void InsertValue(vtkIdType idx, const vtkUnicodeString &)
        """
        ...
    
    def InsertVariantValue(self, p_int, vtkVariant):
        """
        V.InsertVariantValue(int, vtkVariant)
        C++: void InsertVariantValue(vtkIdType idx, vtkVariant value)
            override;
        
        Insert a value into the array from a variant.  This method does
        bounds checking.
        """
        ...
    
    def InterpolateTuple(self, p_int, vtkIdList, vtkAbstractArray, *float):
        """
        V.InterpolateTuple(int, vtkIdList, vtkAbstractArray, [float, ...])
        C++: void InterpolateTuple(vtkIdType i, vtkIdList *ptIndices,
            vtkAbstractArray *source, double *weights) override;
        V.InterpolateTuple(int, int, vtkAbstractArray, int,
            vtkAbstractArray, float)
        C++: void InterpolateTuple(vtkIdType i, vtkIdType id1,
            vtkAbstractArray *source1, vtkIdType id2,
            vtkAbstractArray *source2, double t) override;
        
        Set the tuple at dstTupleIdx in this array to the interpolated
        tuple value, given the ptIndices in the source array and
        associated interpolation weights. This method assumes that the
        two arrays are of the same type and structure.
        """
        ...
    
    def IsA(self, string):
        """
        V.IsA(string) -> int
        C++: vtkTypeBool IsA(const char *type) override;
        
        Return 1 if this class is the same type of (or a subclass of) the
        named class. Returns 0 otherwise. This method works in
        combination with vtkTypeMacro found in vtkSetGet.h.
        """
        ...
    
    def IsNumeric(self):
        """
        V.IsNumeric() -> int
        C++: int IsNumeric() override;
        
        This method is here to make backward compatibility easier.  It
        must return true if and only if an array contains numeric data.
        """
        ...
    
    def IsTypeOf(self, string):
        """
        V.IsTypeOf(string) -> int
        C++: static vtkTypeBool IsTypeOf(const char *type)
        
        Return 1 if this class type is the same type of (or a subclass
        of) the named class. Returns 0 otherwise. This method works in
        combination with vtkTypeMacro found in vtkSetGet.h.
        """
        ...
    
    def LookupValue(self, vtkVariant):
        """
        V.LookupValue(vtkVariant) -> int
        C++: vtkIdType LookupValue(vtkVariant value) override;
        V.LookupValue(vtkVariant, vtkIdList)
        C++: void LookupValue(vtkVariant value, vtkIdList *ids) override;
        
        Return the value indices where a specific value appears.
        """
        ...
    
    def NewInstance(self):
        """
        V.NewInstance() -> vtkUnicodeStringArray
        C++: vtkUnicodeStringArray *NewInstance()
        """
        ...
    
    def NewIterator(self):
        """
        V.NewIterator() -> vtkArrayIterator
        C++: vtkArrayIterator *NewIterator() override;
        
        Subclasses must override this method and provide the right kind
        of templated vtkArrayIteratorTemplate.
        """
        ...
    
    def Resize(self, p_int):
        """
        V.Resize(int) -> int
        C++: vtkTypeBool Resize(vtkIdType numTuples) override;
        
        Resize the array to the requested number of tuples and preserve
        data. Increasing the array size may allocate extra memory beyond
        what was requested. MaxId will not be modified when increasing
        array size. Decreasing the array size will trim memory to the
        requested size and may update MaxId if the valid id range is
        truncated. Requesting an array size of 0 will free all memory.
        Returns 1 if resizing succeeded and 0 otherwise.
        """
        ...
    
    def SafeDownCast(self, vtkObjectBase):
        """
        V.SafeDownCast(vtkObjectBase) -> vtkUnicodeStringArray
        C++: static vtkUnicodeStringArray *SafeDownCast(vtkObjectBase *o)
        """
        ...
    
    def SetNumberOfTuples(self, p_int):
        """
        V.SetNumberOfTuples(int)
        C++: void SetNumberOfTuples(vtkIdType number) override;
        
        Set the number of tuples (a component group) in the array. Note
        that this may allocate space depending on the number of
        components. Also note that if allocation is performed no copy is
        performed so existing data will be lost (if data conservation is
        sought, one may use the Resize method instead).
        """
        ...
    
    def SetTuple(self, p_int, p_int_1, vtkAbstractArray):
        """
        V.SetTuple(int, int, vtkAbstractArray)
        C++: void SetTuple(vtkIdType i, vtkIdType j,
            vtkAbstractArray *source) override;
        
        Set the tuple at dstTupleIdx in this array to the tuple at
        srcTupleIdx in the source array. This method assumes that the two
        arrays have the same type and structure. Note that range checking
        and memory allocation is not performed; use in conjunction with
        SetNumberOfTuples() to allocate space.
        """
        ...
    
    def SetUTF8Value(self, p_int, string):
        """
        V.SetUTF8Value(int, string)
        C++: void SetUTF8Value(vtkIdType i, const char *)
        """
        ...
    
    def SetValue(self, p_int, unicode):
        """
        V.SetValue(int, unicode)
        C++: void SetValue(vtkIdType i, const vtkUnicodeString &)
        """
        ...
    
    def SetVariantValue(self, p_int, vtkVariant):
        """
        V.SetVariantValue(int, vtkVariant)
        C++: void SetVariantValue(vtkIdType idx, vtkVariant value)
            override;
        
        Set a value in the array from a variant.  This method does NOT do
        bounds checking.
        """
        ...
    
    def SetVoidArray(self, void, p_int, p_int_1):
        """
        V.SetVoidArray(void, int, int)
        C++: void SetVoidArray(void *array, vtkIdType size, int save)
            override;
        V.SetVoidArray(void, int, int, int)
        C++: void SetVoidArray(void *array, vtkIdType size, int save,
            int deleteMethod) override;
        
        This method lets the user specify data to be held by the array. 
        The array argument is a pointer to the data.  size is the size of
        the array supplied by the user.  Set save to 1 to keep the class
        from deleting the array when it cleans up or reallocates memory. 
        The class uses the actual array provided; it does not copy the
        data from the supplied array. If specified, the delete method
        determines how the data array will be deallocated. If the delete
        method is VTK_DATA_ARRAY_FREE, free() will be used. If the delete
        method is VTK_DATA_ARRAY_DELETE, delete[] will be used. If the
        delete method is VTK_DATA_ARRAY_ALIGNED_FREE _aligned_free() will
        be used on windows, while free() will be used everywhere else. If
        the delete method is VTK_DATA_ARRAY_USER_DEFINED a custom free
        function can be assigned to be called using SetArrayFreeFunction,
        if no custom function is assigned we will default to free(). The
        default is FREE. (Note not all subclasses can support
        deleteMethod.)
        """
        ...
    
    def Squeeze(self):
        """
        V.Squeeze()
        C++: void Squeeze() override;
        
        Free any unnecessary memory. Description: Resize object to just
        fit data requirement. Reclaims extra memory.
        """
        ...
    
    def __delattr__(self, *args, **kwargs):
        """ Implement delattr(self, name). """
        ...
    
    def __getattribute__(self, *args, **kwargs):
        """ Return getattr(self, name). """
        ...
    
    def __init__(self, *args, **kwargs) -> None:
        ...
    
    @staticmethod
    def __new__(*args, **kwargs):
        """ Create and return a new object.  See help(type) for accurate signature. """
        ...
    
    def __repr__(self, *args, **kwargs):
        """ Return repr(self). """
        ...
    
    def __setattr__(self, *args, **kwargs):
        """ Implement setattr(self, name, value). """
        ...
    
    def __str__(self, *args, **kwargs) -> str:
        """ Return str(self). """
        ...
    
    __this__ = ...
    __dict__ = ...
    __vtkname__ = ...


