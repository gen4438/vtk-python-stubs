"""
This type stub file was generated by pyright.
"""

from .vtkAbstractArray import vtkAbstractArray

class vtkDataArray(vtkAbstractArray):
    """
    vtkDataArray - abstract superclass for arrays of numeric data
    
    Superclass: vtkAbstractArray
    
    vtkDataArray is an abstract superclass for data array objects
    containing numeric data.  It extends the API defined in
    vtkAbstractArray.  vtkDataArray is an abstract superclass for data
    array objects. This class defines an API that all array objects must
    support. Note that the concrete subclasses of this class represent
    data in native form (char, int, etc.) and often have specialized more
    efficient methods for operating on this data (for example, getting
    pointers to data or getting/inserting data in native form). 
    Subclasses of vtkDataArray are assumed to contain data whose
    components are meaningful when cast to and from double.
    
    @sa
    vtkBitArray vtkGenericDataArray
    """
    def COMPONENT_RANGE(self):
        """
        V.COMPONENT_RANGE() -> vtkInformationDoubleVectorKey
        C++: static vtkInformationDoubleVectorKey *COMPONENT_RANGE()
        
        This key is used to hold tight bounds on the range of one
        component over all tuples of the array. Two values (a minimum and
        maximum) are stored for each component. When GetRange() is called
        when no tuples are present in the array this value is set to {
        VTK_DOUBLE_MAX, VTK_DOUBLE_MIN }.
        """
        ...
    
    def CopyComponent(self, p_int, vtkDataArray, p_int_1):
        """
        V.CopyComponent(int, vtkDataArray, int)
        C++: virtual void CopyComponent(int dstComponent,
            vtkDataArray *src, int srcComponent)
        
        Copy a component from one data array into a component on this
        data array. This method copies the specified component
        ("srcComponent") from the specified data array ("src") to the
        specified component ("dstComponent") over all the tuples in this
        data array.  This method can be used to extract a component
        (column) from one data array and paste that data into a component
        on this data array.
        """
        ...
    
    def CopyInformation(self, vtkInformation, p_int):
        """
        V.CopyInformation(vtkInformation, int) -> int
        C++: int CopyInformation(vtkInformation *infoFrom, int deep=1)
            override;
        
        Copy information instance. Arrays use information objects in a
        variety of ways. It is important to have flexibility in this
        regard because certain keys should not be copied, while others
        must be. NOTE: Up to the implmenter to make sure that keys not
        intended to be copied are excluded here.
        """
        ...
    
    def CreateDataArray(self, p_int):
        """
        V.CreateDataArray(int) -> vtkDataArray
        C++: static vtkDataArray *CreateDataArray(int dataType)
        
        Creates an array for dataType where dataType is one of VTK_BIT,
        VTK_CHAR, VTK_SIGNED_CHAR, VTK_UNSIGNED_CHAR, VTK_SHORT,
        VTK_UNSIGNED_SHORT, VTK_INT, VTK_UNSIGNED_INT, VTK_LONG,
        VTK_UNSIGNED_LONG, VTK_DOUBLE, VTK_DOUBLE, VTK_ID_TYPE. Note that
        the data array returned has be deleted by the user.
        """
        ...
    
    def CreateDefaultLookupTable(self):
        """
        V.CreateDefaultLookupTable()
        C++: void CreateDefaultLookupTable()
        
        Create default lookup table. Generally used to create one when
        none is available.
        """
        ...
    
    def DeepCopy(self, vtkAbstractArray):
        """
        V.DeepCopy(vtkAbstractArray)
        C++: void DeepCopy(vtkAbstractArray *aa) override;
        V.DeepCopy(vtkDataArray)
        C++: virtual void DeepCopy(vtkDataArray *da)
        
        Deep copy of data. Copies data from different data arrays even if
        they are different types (using doubleing-point exchange).
        """
        ...
    
    def FastDownCast(self, vtkAbstractArray):
        """
        V.FastDownCast(vtkAbstractArray) -> vtkDataArray
        C++: static vtkDataArray *FastDownCast(vtkAbstractArray *source)
        
        Perform a fast, safe cast from a vtkAbstractArray to a
        vtkDataArray. This method checks if source->GetArrayType()
        returns DataArray or a more derived type, and performs a
        static_cast to return source as a vtkDataArray pointer.
        Otherwise, nullptr is returned.
        """
        ...
    
    def Fill(self, p_float):
        """
        V.Fill(float)
        C++: virtual void Fill(double value)
        
        Fill all values of a data array with a specified value.
        """
        ...
    
    def FillComponent(self, p_int, p_float):
        """
        V.FillComponent(int, float)
        C++: virtual void FillComponent(int compIdx, double value)
        
        Fill a component of a data array with a specified value. This
        method sets the specified component to specified value for all
        tuples in the data array.  This methods can be used to initialize
        or reinitialize a single component of a multi-component array.
        """
        ...
    
    def GetActualMemorySize(self):
        """
        V.GetActualMemorySize() -> int
        C++: unsigned long GetActualMemorySize() override;
        
        Return the memory in kibibytes (1024 bytes) consumed by this data
        array. Used to support streaming and reading/writing data. The
        value returned is guaranteed to be greater than or equal to the
        memory required to actually represent the data represented by
        this object. The information returned is valid only after the
        pipeline has been updated.
        """
        ...
    
    def GetArrayType(self):
        """
        V.GetArrayType() -> int
        C++: int GetArrayType() override;
        
        Method for type-checking in FastDownCast implementations.
        """
        ...
    
    def GetComponent(self, p_int, p_int_1):
        """
        V.GetComponent(int, int) -> float
        C++: virtual double GetComponent(vtkIdType tupleIdx, int compIdx)
        
        Return the data component at the location specified by tupleIdx
        and compIdx.
        """
        ...
    
    def GetData(self, p_int, p_int_1, p_int_2, p_int_3, vtkDoubleArray):
        """
        V.GetData(int, int, int, int, vtkDoubleArray)
        C++: virtual void GetData(vtkIdType tupleMin, vtkIdType tupleMax,
            int compMin, int compMax, vtkDoubleArray *data)
        
        Get the data as a double array in the range (tupleMin,tupleMax)
        and (compMin, compMax). The resulting double array consists of
        all data in the tuple range specified and only the component
        range specified. This process typically requires casting the data
        from native form into doubleing point values. This method is
        provided as a convenience for data exchange, and is not very
        fast.
        """
        ...
    
    def GetDataTypeMax(self):
        """
        V.GetDataTypeMax() -> float
        C++: double GetDataTypeMax()
        V.GetDataTypeMax(int) -> float
        C++: static double GetDataTypeMax(int type)
        
        These methods return the Min and Max possible range of the native
        data type. For example if a vtkScalars consists of unsigned char
        data these will return (0,255).
        """
        ...
    
    def GetDataTypeMin(self):
        """
        V.GetDataTypeMin() -> float
        C++: double GetDataTypeMin()
        V.GetDataTypeMin(int) -> float
        C++: static double GetDataTypeMin(int type)
        
        These methods return the Min and Max possible range of the native
        data type. For example if a vtkScalars consists of unsigned char
        data these will return (0,255).
        """
        ...
    
    def GetDataTypeRange(self, p_float=..., p_float=...):
        """
        V.GetDataTypeRange([float, float])
        C++: void GetDataTypeRange(double range[2])
        V.GetDataTypeRange(int, [float, float])
        C++: static void GetDataTypeRange(int type, double range[2])
        
        These methods return the Min and Max possible range of the native
        data type. For example if a vtkScalars consists of unsigned char
        data these will return (0,255).
        """
        ...
    
    def GetElementComponentSize(self):
        """
        V.GetElementComponentSize() -> int
        C++: int GetElementComponentSize() override;
        
        Return the size, in bytes, of the lowest-level element of an
        array.  For vtkDataArray and subclasses this is the size of the
        data type.
        """
        ...
    
    def GetFiniteRange(self, p_float=..., p_float=..., *args, **kwargs):
        """
        V.GetFiniteRange([float, float], int)
        C++: void GetFiniteRange(double range[2], int comp)
        V.GetFiniteRange(int) -> (float, float)
        C++: double *GetFiniteRange(int comp)
        V.GetFiniteRange() -> (float, float)
        C++: double *GetFiniteRange()
        V.GetFiniteRange([float, float])
        C++: void GetFiniteRange(double range[2])
        
        The range of the data array values for the given component will
        be returned in the provided range array argument. If comp is -1,
        the range of the magnitude (L2 norm) over all components will be
        provided. The range is computed and then cached, and will not be
        re-computed on subsequent calls to GetRange() unless the array is
        modified or the requested component changes. THIS METHOD IS NOT
        THREAD SAFE.
        """
        ...
    
    def GetLookupTable(self):
        """
        V.GetLookupTable() -> vtkLookupTable
        C++: virtual vtkLookupTable *GetLookupTable()
        
        Set/get the lookup table associated with this scalar data, if
        any.
        """
        ...
    
    def GetMaxNorm(self):
        """
        V.GetMaxNorm() -> float
        C++: virtual double GetMaxNorm()
        
        Return the maximum norm for the tuples. Note that the max. is
        computed every time GetMaxNorm is called.
        """
        ...
    
    def GetNumberOfGenerationsFromBase(self, string):
        """
        V.GetNumberOfGenerationsFromBase(string) -> int
        C++: vtkIdType GetNumberOfGenerationsFromBase(const char *type)
            override;
        
        Given a the name of a base class of this class type, return the
        distance of inheritance between this class type and the named
        class (how many generations of inheritance are there between this
        class and the named class). If the named class is not in this
        class's inheritance tree, return a negative value. Valid
        responses will always be nonnegative. This method works in
        combination with vtkTypeMacro found in vtkSetGet.h.
        """
        ...
    
    def GetNumberOfGenerationsFromBaseType(self, string):
        """
        V.GetNumberOfGenerationsFromBaseType(string) -> int
        C++: static vtkIdType GetNumberOfGenerationsFromBaseType(
            const char *type)
        
        Given a the name of a base class of this class type, return the
        distance of inheritance between this class type and the named
        class (how many generations of inheritance are there between this
        class and the named class). If the named class is not in this
        class's inheritance tree, return a negative value. Valid
        responses will always be nonnegative. This method works in
        combination with vtkTypeMacro found in vtkSetGet.h.
        """
        ...
    
    def GetRange(self, p_float=..., p_float=..., *args, **kwargs):
        """
        V.GetRange([float, float], int)
        C++: void GetRange(double range[2], int comp)
        V.GetRange(int) -> (float, float)
        C++: double *GetRange(int comp)
        V.GetRange() -> (float, float)
        C++: double *GetRange()
        V.GetRange([float, float])
        C++: void GetRange(double range[2])
        
        The range of the data array values for the given component will
        be returned in the provided range array argument. If comp is -1,
        the range of the magnitude (L2 norm) over all components will be
        provided. The range is computed and then cached, and will not be
        re-computed on subsequent calls to GetRange() unless the array is
        modified or the requested component changes. THIS METHOD IS NOT
        THREAD SAFE.
        """
        ...
    
    def GetTuple(self, p_int):
        """
        V.GetTuple(int) -> (float, ...)
        C++: virtual double *GetTuple(vtkIdType tupleIdx)
        V.GetTuple(int, [float, ...])
        C++: virtual void GetTuple(vtkIdType tupleIdx, double *tuple)
        
        Get the data tuple at tupleIdx. Return it as a pointer to an
        array. Note: this method is not thread-safe, and the pointer is
        only valid as long as another method invocation to a vtk object
        is not performed.
        """
        ...
    
    def GetTuple1(self, p_int):
        """
        V.GetTuple1(int) -> float
        C++: double GetTuple1(vtkIdType tupleIdx)
        
        These methods are included as convenience for the wrappers.
        GetTuple() and SetTuple() which return/take arrays can not be
        used from wrapped languages. These methods can be used instead.
        """
        ...
    
    def GetTuple2(self, p_int):
        """
        V.GetTuple2(int) -> (float, float)
        C++: double *GetTuple2(vtkIdType tupleIdx)
        
        These methods are included as convenience for the wrappers.
        GetTuple() and SetTuple() which return/take arrays can not be
        used from wrapped languages. These methods can be used instead.
        """
        ...
    
    def GetTuple3(self, p_int):
        """
        V.GetTuple3(int) -> (float, float, float)
        C++: double *GetTuple3(vtkIdType tupleIdx)
        
        These methods are included as convenience for the wrappers.
        GetTuple() and SetTuple() which return/take arrays can not be
        used from wrapped languages. These methods can be used instead.
        """
        ...
    
    def GetTuple4(self, p_int):
        """
        V.GetTuple4(int) -> (float, float, float, float)
        C++: double *GetTuple4(vtkIdType tupleIdx)
        
        These methods are included as convenience for the wrappers.
        GetTuple() and SetTuple() which return/take arrays can not be
        used from wrapped languages. These methods can be used instead.
        """
        ...
    
    def GetTuple6(self, p_int):
        """
        V.GetTuple6(int) -> (float, float, float, float, float, float)
        C++: double *GetTuple6(vtkIdType tupleIdx)
        
        These methods are included as convenience for the wrappers.
        GetTuple() and SetTuple() which return/take arrays can not be
        used from wrapped languages. These methods can be used instead.
        """
        ...
    
    def GetTuple9(self, p_int):
        """
        V.GetTuple9(int) -> (float, float, float, float, float, float,
            float, float, float)
        C++: double *GetTuple9(vtkIdType tupleIdx)
        
        These methods are included as convenience for the wrappers.
        GetTuple() and SetTuple() which return/take arrays can not be
        used from wrapped languages. These methods can be used instead.
        """
        ...
    
    def GetTuples(self, vtkIdList, vtkAbstractArray):
        """
        V.GetTuples(vtkIdList, vtkAbstractArray)
        C++: void GetTuples(vtkIdList *tupleIds, vtkAbstractArray *output)
             override;
        V.GetTuples(int, int, vtkAbstractArray)
        C++: void GetTuples(vtkIdType p1, vtkIdType p2,
            vtkAbstractArray *output) override;
        
        Given a list of tuple ids, return an array of tuples. You must
        insure that the output array has been previously allocated with
        enough space to hold the data.
        """
        ...
    
    def InsertComponent(self, p_int, p_int_1, p_float):
        """
        V.InsertComponent(int, int, float)
        C++: virtual void InsertComponent(vtkIdType tupleIdx, int compIdx,
             double value)
        
        Insert value at the location specified by tupleIdx and compIdx.
        Note that memory allocation is performed as necessary to hold the
        data.
        """
        ...
    
    def InsertNextTuple(self, p_int, vtkAbstractArray):
        """
        V.InsertNextTuple(int, vtkAbstractArray) -> int
        C++: vtkIdType InsertNextTuple(vtkIdType srcTupleIdx,
            vtkAbstractArray *source) override;
        V.InsertNextTuple((float, ...)) -> int
        C++: virtual vtkIdType InsertNextTuple(const double *tuple)
        
        Insert the tuple from srcTupleIdx in the source array at the end
        of this array. Note that memory allocation is performed as
        necessary to hold the data. Returns the tuple index at which the
        data was inserted.
        """
        ...
    
    def InsertNextTuple1(self, p_float):
        """
        V.InsertNextTuple1(float)
        C++: void InsertNextTuple1(double value)
        
        These methods are included as convenience for the wrappers.
        InsertTuple() which takes arrays can not be used from wrapped
        languages. These methods can be used instead.
        """
        ...
    
    def InsertNextTuple2(self, p_float, p_float_1):
        """
        V.InsertNextTuple2(float, float)
        C++: void InsertNextTuple2(double val0, double val1)
        
        These methods are included as convenience for the wrappers.
        InsertTuple() which takes arrays can not be used from wrapped
        languages. These methods can be used instead.
        """
        ...
    
    def InsertNextTuple3(self, p_float, p_float_1, p_float_2):
        """
        V.InsertNextTuple3(float, float, float)
        C++: void InsertNextTuple3(double val0, double val1, double val2)
        
        These methods are included as convenience for the wrappers.
        InsertTuple() which takes arrays can not be used from wrapped
        languages. These methods can be used instead.
        """
        ...
    
    def InsertNextTuple4(self, p_float, p_float_1, p_float_2, p_float_3):
        """
        V.InsertNextTuple4(float, float, float, float)
        C++: void InsertNextTuple4(double val0, double val1, double val2,
            double val3)
        
        These methods are included as convenience for the wrappers.
        InsertTuple() which takes arrays can not be used from wrapped
        languages. These methods can be used instead.
        """
        ...
    
    def InsertNextTuple6(self, p_float, p_float_1, p_float_2, p_float_3, p_float_4, p_float_5):
        """
        V.InsertNextTuple6(float, float, float, float, float, float)
        C++: void InsertNextTuple6(double val0, double val1, double val2,
            double val3, double val4, double val5)
        
        These methods are included as convenience for the wrappers.
        InsertTuple() which takes arrays can not be used from wrapped
        languages. These methods can be used instead.
        """
        ...
    
    def InsertNextTuple9(self, p_float, p_float_1, p_float_2, p_float_3, p_float_4, p_float_5, p_float_6, p_float_7, p_float_8):
        """
        V.InsertNextTuple9(float, float, float, float, float, float,
            float, float, float)
        C++: void InsertNextTuple9(double val0, double val1, double val2,
            double val3, double val4, double val5, double val6,
            double val7, double val8)
        
        These methods are included as convenience for the wrappers.
        InsertTuple() which takes arrays can not be used from wrapped
        languages. These methods can be used instead.
        """
        ...
    
    def InsertTuple(self, p_int, p_int_1, vtkAbstractArray):
        """
        V.InsertTuple(int, int, vtkAbstractArray)
        C++: void InsertTuple(vtkIdType dstTupleIdx,
            vtkIdType srcTupleIdx, vtkAbstractArray *source) override;
        V.InsertTuple(int, (float, ...))
        C++: virtual void InsertTuple(vtkIdType tupleIdx,
            const double *tuple)
        
        Insert the tuple at srcTupleIdx in the source array into this
        array at dstTupleIdx. Note that memory allocation is performed as
        necessary to hold the data.
        """
        ...
    
    def InsertTuple1(self, p_int, p_float):
        """
        V.InsertTuple1(int, float)
        C++: void InsertTuple1(vtkIdType tupleIdx, double value)
        
        These methods are included as convenience for the wrappers.
        InsertTuple() which takes arrays can not be used from wrapped
        languages. These methods can be used instead.
        """
        ...
    
    def InsertTuple2(self, p_int, p_float, p_float_1):
        """
        V.InsertTuple2(int, float, float)
        C++: void InsertTuple2(vtkIdType tupleIdx, double val0,
            double val1)
        
        These methods are included as convenience for the wrappers.
        InsertTuple() which takes arrays can not be used from wrapped
        languages. These methods can be used instead.
        """
        ...
    
    def InsertTuple3(self, p_int, p_float, p_float_1, p_float_2):
        """
        V.InsertTuple3(int, float, float, float)
        C++: void InsertTuple3(vtkIdType tupleIdx, double val0,
            double val1, double val2)
        
        These methods are included as convenience for the wrappers.
        InsertTuple() which takes arrays can not be used from wrapped
        languages. These methods can be used instead.
        """
        ...
    
    def InsertTuple4(self, p_int, p_float, p_float_1, p_float_2, p_float_3):
        """
        V.InsertTuple4(int, float, float, float, float)
        C++: void InsertTuple4(vtkIdType tupleIdx, double val0,
            double val1, double val2, double val3)
        
        These methods are included as convenience for the wrappers.
        InsertTuple() which takes arrays can not be used from wrapped
        languages. These methods can be used instead.
        """
        ...
    
    def InsertTuple6(self, p_int, p_float, p_float_1, p_float_2, p_float_3, p_float_4, p_float_5):
        """
        V.InsertTuple6(int, float, float, float, float, float, float)
        C++: void InsertTuple6(vtkIdType tupleIdx, double val0,
            double val1, double val2, double val3, double val4,
            double val5)
        
        These methods are included as convenience for the wrappers.
        InsertTuple() which takes arrays can not be used from wrapped
        languages. These methods can be used instead.
        """
        ...
    
    def InsertTuple9(self, p_int, p_float, p_float_1, p_float_2, p_float_3, p_float_4, p_float_5, p_float_6, p_float_7, p_float_8):
        """
        V.InsertTuple9(int, float, float, float, float, float, float,
            float, float, float)
        C++: void InsertTuple9(vtkIdType tupleIdx, double val0,
            double val1, double val2, double val3, double val4,
            double val5, double val6, double val7, double val8)
        
        These methods are included as convenience for the wrappers.
        InsertTuple() which takes arrays can not be used from wrapped
        languages. These methods can be used instead.
        """
        ...
    
    def InsertTuples(self, vtkIdList, vtkIdList_1, vtkAbstractArray):
        """
        V.InsertTuples(vtkIdList, vtkIdList, vtkAbstractArray)
        C++: void InsertTuples(vtkIdList *dstIds, vtkIdList *srcIds,
            vtkAbstractArray *source) override;
        V.InsertTuples(int, int, int, vtkAbstractArray)
        C++: void InsertTuples(vtkIdType dstStart, vtkIdType n,
            vtkIdType srcStart, vtkAbstractArray *source) override;
        
        Copy the tuples indexed in srcIds from the source array to the
        tuple locations indexed by dstIds in this array. Note that memory
        allocation is performed as necessary to hold the data.
        """
        ...
    
    def InterpolateTuple(self, p_int, vtkIdList, vtkAbstractArray, *float):
        """
        V.InterpolateTuple(int, vtkIdList, vtkAbstractArray, [float, ...])
        C++: void InterpolateTuple(vtkIdType dstTupleIdx,
            vtkIdList *ptIndices, vtkAbstractArray *source,
            double *weights) override;
        V.InterpolateTuple(int, int, vtkAbstractArray, int,
            vtkAbstractArray, float)
        C++: void InterpolateTuple(vtkIdType dstTupleIdx,
            vtkIdType srcTupleIdx1, vtkAbstractArray *source1,
            vtkIdType srcTupleIdx2, vtkAbstractArray *source2, double t)
            override;
        
        Set the tuple at dstTupleIdx in this array to the interpolated
        tuple value, given the ptIndices in the source array and
        associated interpolation weights. This method assumes that the
        two arrays are of the same type and structure.
        """
        ...
    
    def IsA(self, string):
        """
        V.IsA(string) -> int
        C++: vtkTypeBool IsA(const char *type) override;
        
        Return 1 if this class is the same type of (or a subclass of) the
        named class. Returns 0 otherwise. This method works in
        combination with vtkTypeMacro found in vtkSetGet.h.
        """
        ...
    
    def IsNumeric(self):
        """
        V.IsNumeric() -> int
        C++: int IsNumeric() override;
        
        This method is here to make backward compatibility easier.  It
        must return true if and only if an array contains numeric data.
        All vtkDataArray subclasses contain numeric data, hence this
        method always returns 1(true).
        """
        ...
    
    def IsTypeOf(self, string):
        """
        V.IsTypeOf(string) -> int
        C++: static vtkTypeBool IsTypeOf(const char *type)
        
        Return 1 if this class type is the same type of (or a subclass
        of) the named class. Returns 0 otherwise. This method works in
        combination with vtkTypeMacro found in vtkSetGet.h.
        """
        ...
    
    def L2_NORM_FINITE_RANGE(self):
        """
        V.L2_NORM_FINITE_RANGE() -> vtkInformationDoubleVectorKey
        C++: static vtkInformationDoubleVectorKey *L2_NORM_FINITE_RANGE()
        
        This key is used to hold tight bounds on the $L_2$ norm of tuples
        in the array. Two values (a minimum and maximum) are stored for
        each component. When GetFiniteRange() is called when no tuples
        are present in the array this value is set to { VTK_DOUBLE_MAX,
        VTK_DOUBLE_MIN }.
        """
        ...
    
    def L2_NORM_RANGE(self):
        """
        V.L2_NORM_RANGE() -> vtkInformationDoubleVectorKey
        C++: static vtkInformationDoubleVectorKey *L2_NORM_RANGE()
        
        This key is used to hold tight bounds on the $L_2$ norm of tuples
        in the array. Two values (a minimum and maximum) are stored for
        each component. When GetRange() is called when no tuples are
        present in the array this value is set to { VTK_DOUBLE_MAX,
        VTK_DOUBLE_MIN }.
        """
        ...
    
    def Modified(self):
        """
        V.Modified()
        C++: void Modified() override;
        
        Removes out-of-date L2_NORM_RANGE() and L2_NORM_FINITE_RANGE()
        values.
        """
        ...
    
    def NewInstance(self):
        """
        V.NewInstance() -> vtkDataArray
        C++: vtkDataArray *NewInstance()
        """
        ...
    
    def RemoveFirstTuple(self):
        """
        V.RemoveFirstTuple()
        C++: virtual void RemoveFirstTuple()
        
        These methods remove tuples from the data array. They shift data
        and resize array, so the data array is still valid after this
        operation. Note, this operation is fairly slow.
        """
        ...
    
    def RemoveLastTuple(self):
        """
        V.RemoveLastTuple()
        C++: virtual void RemoveLastTuple()
        
        These methods remove tuples from the data array. They shift data
        and resize array, so the data array is still valid after this
        operation. Note, this operation is fairly slow.
        """
        ...
    
    def RemoveTuple(self, p_int):
        """
        V.RemoveTuple(int)
        C++: virtual void RemoveTuple(vtkIdType tupleIdx)
        
        These methods remove tuples from the data array. They shift data
        and resize array, so the data array is still valid after this
        operation. Note, this operation is fairly slow.
        """
        ...
    
    def SafeDownCast(self, vtkObjectBase):
        """
        V.SafeDownCast(vtkObjectBase) -> vtkDataArray
        C++: static vtkDataArray *SafeDownCast(vtkObjectBase *o)
        """
        ...
    
    def SetComponent(self, p_int, p_int_1, p_float):
        """
        V.SetComponent(int, int, float)
        C++: virtual void SetComponent(vtkIdType tupleIdx, int compIdx,
            double value)
        
        Set the data component at the location specified by tupleIdx and
        compIdx to value. Note that i is less than NumberOfTuples and j
        is less than NumberOfComponents. Make sure enough memory has been
        allocated (use SetNumberOfTuples() and SetNumberOfComponents()).
        """
        ...
    
    def SetLookupTable(self, vtkLookupTable):
        """
        V.SetLookupTable(vtkLookupTable)
        C++: void SetLookupTable(vtkLookupTable *lut)
        
        Set/get the lookup table associated with this scalar data, if
        any.
        """
        ...
    
    def SetTuple(self, p_int, p_int_1, vtkAbstractArray):
        """
        V.SetTuple(int, int, vtkAbstractArray)
        C++: void SetTuple(vtkIdType dstTupleIdx, vtkIdType srcTupleIdx,
            vtkAbstractArray *source) override;
        V.SetTuple(int, (float, ...))
        C++: virtual void SetTuple(vtkIdType tupleIdx,
            const double *tuple)
        
        Set the tuple at dstTupleIdx in this array to the tuple at
        srcTupleIdx in the source array. This method assumes that the two
        arrays have the same type and structure. Note that range checking
        and memory allocation is not performed; use in conjunction with
        SetNumberOfTuples() to allocate space.
        """
        ...
    
    def SetTuple1(self, p_int, p_float):
        """
        V.SetTuple1(int, float)
        C++: void SetTuple1(vtkIdType tupleIdx, double value)
        
        These methods are included as convenience for the wrappers.
        GetTuple() and SetTuple() which return/take arrays can not be
        used from wrapped languages. These methods can be used instead.
        """
        ...
    
    def SetTuple2(self, p_int, p_float, p_float_1):
        """
        V.SetTuple2(int, float, float)
        C++: void SetTuple2(vtkIdType tupleIdx, double val0, double val1)
        
        These methods are included as convenience for the wrappers.
        GetTuple() and SetTuple() which return/take arrays can not be
        used from wrapped languages. These methods can be used instead.
        """
        ...
    
    def SetTuple3(self, p_int, p_float, p_float_1, p_float_2):
        """
        V.SetTuple3(int, float, float, float)
        C++: void SetTuple3(vtkIdType tupleIdx, double val0, double val1,
            double val2)
        
        These methods are included as convenience for the wrappers.
        GetTuple() and SetTuple() which return/take arrays can not be
        used from wrapped languages. These methods can be used instead.
        """
        ...
    
    def SetTuple4(self, p_int, p_float, p_float_1, p_float_2, p_float_3):
        """
        V.SetTuple4(int, float, float, float, float)
        C++: void SetTuple4(vtkIdType tupleIdx, double val0, double val1,
            double val2, double val3)
        
        These methods are included as convenience for the wrappers.
        GetTuple() and SetTuple() which return/take arrays can not be
        used from wrapped languages. These methods can be used instead.
        """
        ...
    
    def SetTuple6(self, p_int, p_float, p_float_1, p_float_2, p_float_3, p_float_4, p_float_5):
        """
        V.SetTuple6(int, float, float, float, float, float, float)
        C++: void SetTuple6(vtkIdType tupleIdx, double val0, double val1,
            double val2, double val3, double val4, double val5)
        
        These methods are included as convenience for the wrappers.
        GetTuple() and SetTuple() which return/take arrays can not be
        used from wrapped languages. These methods can be used instead.
        """
        ...
    
    def SetTuple9(self, p_int, p_float, p_float_1, p_float_2, p_float_3, p_float_4, p_float_5, p_float_6, p_float_7, p_float_8):
        """
        V.SetTuple9(int, float, float, float, float, float, float, float,
            float, float)
        C++: void SetTuple9(vtkIdType tupleIdx, double val0, double val1,
            double val2, double val3, double val4, double val5,
            double val6, double val7, double val8)
        
        These methods are included as convenience for the wrappers.
        GetTuple() and SetTuple() which return/take arrays can not be
        used from wrapped languages. These methods can be used instead.
        """
        ...
    
    def ShallowCopy(self, vtkDataArray):
        """
        V.ShallowCopy(vtkDataArray)
        C++: virtual void ShallowCopy(vtkDataArray *other)
        
        Create a shallow copy of other into this, if possible. Shallow
        copies are only possible: (a) if both arrays are the same data
        type (b) if both arrays are the same array type (e.g. AOS vs.
        SOA) (c) if both arrays support shallow copies (e.g. vtkBitArray
        currently does not.) If a shallow copy is not possible, a deep
        copy will be performed instead.
        """
        ...
    
    def UNITS_LABEL(self):
        """
        V.UNITS_LABEL() -> vtkInformationStringKey
        C++: static vtkInformationStringKey *UNITS_LABEL()
        
        A human-readable string indicating the units for the array data.
        """
        ...
    
    def WriteVoidPointer(self, p_int, p_int_1):
        """
        V.WriteVoidPointer(int, int) -> void
        C++: virtual void *WriteVoidPointer(vtkIdType valueIdx,
            vtkIdType numValues)
        
        Get the address of a particular data index. Make sure data is
        allocated for the number of items requested. If needed, increase
        MaxId to mark any new value ranges as in-use.
        """
        ...
    
    def __delattr__(self, *args, **kwargs):
        """ Implement delattr(self, name). """
        ...
    
    def __getattribute__(self, *args, **kwargs):
        """ Return getattr(self, name). """
        ...
    
    def __init__(self, *args, **kwargs) -> None:
        ...
    
    @staticmethod
    def __new__(*args, **kwargs):
        """ Create and return a new object.  See help(type) for accurate signature. """
        ...
    
    def __repr__(self, *args, **kwargs):
        """ Return repr(self). """
        ...
    
    def __setattr__(self, *args, **kwargs):
        """ Implement setattr(self, name, value). """
        ...
    
    def __str__(self, *args, **kwargs) -> str:
        """ Return str(self). """
        ...
    
    __this__ = ...
    __dict__ = ...
    __vtkname__ = ...


