"""
This type stub file was generated by pyright.
"""

from .vtkDataArray import vtkDataArray

class vtkBitArray(vtkDataArray):
    """
    vtkBitArray - dynamic, self-adjusting array of bits
    
    Superclass: vtkDataArray
    
    vtkBitArray is an array of bits (0/1 data value). The array is packed
    so that each byte stores eight bits. vtkBitArray provides methods for
    insertion and retrieval of bits, and will automatically resize itself
    to hold new data.
    """
    def Allocate(self, p_int, p_int_1):
        """
        V.Allocate(int, int) -> int
        C++: vtkTypeBool Allocate(vtkIdType sz, vtkIdType ext=1000)
            override;
        
        Allocate memory for this array. Delete old storage only if
        necessary. Note that ext is no longer used.
        """
        ...
    
    def ClearLookup(self):
        """
        V.ClearLookup()
        C++: void ClearLookup() override;
        
        Delete the associated fast lookup data structure on this array,
        if it exists.  The lookup will be rebuilt on the next call to a
        lookup function.
        """
        ...
    
    def DataChanged(self):
        """
        V.DataChanged()
        C++: void DataChanged() override;
        
        Tell the array explicitly that the data has changed. This is only
        necessary to call when you modify the array contents without
        using the array's API (i.e. you retrieve a pointer to the data
        and modify the array contents).  You need to call this so that
        the fast lookup will know to rebuild itself.  Otherwise, the
        lookup functions will give incorrect results.
        """
        ...
    
    def DeepCopy(self, vtkDataArray):
        """
        V.DeepCopy(vtkDataArray)
        C++: void DeepCopy(vtkDataArray *da) override;
        V.DeepCopy(vtkAbstractArray)
        C++: void DeepCopy(vtkAbstractArray *aa) override;
        
        Deep copy of another bit array.
        """
        ...
    
    def GetDataType(self):
        """
        V.GetDataType() -> int
        C++: int GetDataType() override;
        
        Return the underlying data type. An integer indicating data type
        is returned as specified in vtkType.h.
        """
        ...
    
    def GetDataTypeSize(self):
        """
        V.GetDataTypeSize() -> int
        C++: int GetDataTypeSize() override;
        
        Return the size of the underlying data type.  For a bit, 0 is
        returned.  For string 0 is returned. Arrays with variable length
        components return 0.
        """
        ...
    
    def GetNumberOfGenerationsFromBase(self, string):
        """
        V.GetNumberOfGenerationsFromBase(string) -> int
        C++: vtkIdType GetNumberOfGenerationsFromBase(const char *type)
            override;
        
        Given a the name of a base class of this class type, return the
        distance of inheritance between this class type and the named
        class (how many generations of inheritance are there between this
        class and the named class). If the named class is not in this
        class's inheritance tree, return a negative value. Valid
        responses will always be nonnegative. This method works in
        combination with vtkTypeMacro found in vtkSetGet.h.
        """
        ...
    
    def GetNumberOfGenerationsFromBaseType(self, string):
        """
        V.GetNumberOfGenerationsFromBaseType(string) -> int
        C++: static vtkIdType GetNumberOfGenerationsFromBaseType(
            const char *type)
        
        Given a the name of a base class of this class type, return the
        distance of inheritance between this class type and the named
        class (how many generations of inheritance are there between this
        class and the named class). If the named class is not in this
        class's inheritance tree, return a negative value. Valid
        responses will always be nonnegative. This method works in
        combination with vtkTypeMacro found in vtkSetGet.h.
        """
        ...
    
    def GetPointer(self, p_int):
        """
        V.GetPointer(int) -> (int, ...)
        C++: unsigned char *GetPointer(vtkIdType id)
        
        Direct manipulation of the underlying data.
        """
        ...
    
    def GetTuple(self, p_int):
        """
        V.GetTuple(int) -> (float, ...)
        C++: double *GetTuple(vtkIdType i) override;
        V.GetTuple(int, [float, ...])
        C++: void GetTuple(vtkIdType i, double *tuple) override;
        
        Get a pointer to a tuple at the ith location. This is a dangerous
        method (it is not thread safe since a pointer is returned).
        """
        ...
    
    def GetValue(self, p_int):
        """
        V.GetValue(int) -> int
        C++: int GetValue(vtkIdType id)
        
        Get the data at a particular index.
        """
        ...
    
    def GetVoidPointer(self, p_int):
        """
        V.GetVoidPointer(int) -> void
        C++: void *GetVoidPointer(vtkIdType id) override;
        
        Return a void pointer. For image pipeline interface and other
        special pointer manipulation. Use of this method is discouraged,
        as newer arrays require a deep-copy of the array data in order to
        return a suitable pointer. See vtkArrayDispatch for a safer
        alternative for fast data access.
        """
        ...
    
    def Initialize(self):
        """
        V.Initialize()
        C++: void Initialize() override;
        
        Release storage and reset array to initial state.
        """
        ...
    
    def InsertComponent(self, p_int, p_int_1, p_float):
        """
        V.InsertComponent(int, int, float)
        C++: void InsertComponent(vtkIdType i, int j, double c) override;
        
        Insert the data component at ith tuple and jth component
        location. Note that memory allocation is performed as necessary
        to hold the data.
        """
        ...
    
    def InsertNextTuple(self, p_int, vtkAbstractArray):
        """
        V.InsertNextTuple(int, vtkAbstractArray) -> int
        C++: vtkIdType InsertNextTuple(vtkIdType j,
            vtkAbstractArray *source) override;
        V.InsertNextTuple((float, ...)) -> int
        C++: vtkIdType InsertNextTuple(const double *tuple) override;
        
        Insert the jth tuple in the source array, at the end in this
        array. Note that memory allocation is performed as necessary to
        hold the data. Returns the location at which the data was
        inserted.
        """
        ...
    
    def InsertNextValue(self, p_int):
        """
        V.InsertNextValue(int) -> int
        C++: vtkIdType InsertNextValue(int i)
        """
        ...
    
    def InsertTuple(self, p_int, p_int_1, vtkAbstractArray):
        """
        V.InsertTuple(int, int, vtkAbstractArray)
        C++: void InsertTuple(vtkIdType i, vtkIdType j,
            vtkAbstractArray *source) override;
        V.InsertTuple(int, (float, ...))
        C++: void InsertTuple(vtkIdType i, const double *tuple) override;
        
        Insert the jth tuple in the source array, at ith location in this
        array. Note that memory allocation is performed as necessary to
        hold the data.
        """
        ...
    
    def InsertTuples(self, vtkIdList, vtkIdList_1, vtkAbstractArray):
        """
        V.InsertTuples(vtkIdList, vtkIdList, vtkAbstractArray)
        C++: void InsertTuples(vtkIdList *dstIds, vtkIdList *srcIds,
            vtkAbstractArray *source) override;
        V.InsertTuples(int, int, int, vtkAbstractArray)
        C++: void InsertTuples(vtkIdType dstStart, vtkIdType n,
            vtkIdType srcStart, vtkAbstractArray *source) override;
        
        Copy the tuples indexed in srcIds from the source array to the
        tuple locations indexed by dstIds in this array. Note that memory
        allocation is performed as necessary to hold the data.
        """
        ...
    
    def InsertValue(self, p_int, p_int_1):
        """
        V.InsertValue(int, int)
        C++: void InsertValue(vtkIdType id, int i)
        
        Inserts values and checks to make sure there is enough memory
        """
        ...
    
    def InsertVariantValue(self, p_int, vtkVariant):
        """
        V.InsertVariantValue(int, vtkVariant)
        C++: void InsertVariantValue(vtkIdType idx, vtkVariant value)
            override;
        
        Inserts values from a variant and checks to ensure there is
        enough memory
        """
        ...
    
    def IsA(self, string):
        """
        V.IsA(string) -> int
        C++: vtkTypeBool IsA(const char *type) override;
        
        Return 1 if this class is the same type of (or a subclass of) the
        named class. Returns 0 otherwise. This method works in
        combination with vtkTypeMacro found in vtkSetGet.h.
        """
        ...
    
    def IsTypeOf(self, string):
        """
        V.IsTypeOf(string) -> int
        C++: static vtkTypeBool IsTypeOf(const char *type)
        
        Return 1 if this class type is the same type of (or a subclass
        of) the named class. Returns 0 otherwise. This method works in
        combination with vtkTypeMacro found in vtkSetGet.h.
        """
        ...
    
    def LookupValue(self, vtkVariant):
        """
        V.LookupValue(vtkVariant) -> int
        C++: vtkIdType LookupValue(vtkVariant value) override;
        V.LookupValue(vtkVariant, vtkIdList)
        C++: void LookupValue(vtkVariant value, vtkIdList *ids) override;
        V.LookupValue(int) -> int
        C++: vtkIdType LookupValue(int value)
        V.LookupValue(int, vtkIdList)
        C++: void LookupValue(int value, vtkIdList *ids)
        
        Return the indices where a specific value appears.
        """
        ...
    
    def NewInstance(self):
        """
        V.NewInstance() -> vtkBitArray
        C++: vtkBitArray *NewInstance()
        """
        ...
    
    def NewIterator(self):
        """
        V.NewIterator() -> vtkArrayIterator
        C++: vtkArrayIterator *NewIterator() override;
        
        Returns a new vtkBitArrayIterator instance.
        """
        ...
    
    def RemoveFirstTuple(self):
        """
        V.RemoveFirstTuple()
        C++: void RemoveFirstTuple() override;
        
        These methods remove tuples from the data array. They shift data
        and resize array, so the data array is still valid after this
        operation. Note, this operation is fairly slow.
        """
        ...
    
    def RemoveLastTuple(self):
        """
        V.RemoveLastTuple()
        C++: void RemoveLastTuple() override;
        
        These methods remove tuples from the data array. They shift data
        and resize array, so the data array is still valid after this
        operation. Note, this operation is fairly slow.
        """
        ...
    
    def RemoveTuple(self, p_int):
        """
        V.RemoveTuple(int)
        C++: void RemoveTuple(vtkIdType id) override;
        
        These methods remove tuples from the data array. They shift data
        and resize array, so the data array is still valid after this
        operation. Note, this operation is fairly slow.
        """
        ...
    
    def Resize(self, p_int):
        """
        V.Resize(int) -> int
        C++: vtkTypeBool Resize(vtkIdType numTuples) override;
        
        Resize the array while conserving the data.
        """
        ...
    
    def SafeDownCast(self, vtkObjectBase):
        """
        V.SafeDownCast(vtkObjectBase) -> vtkBitArray
        C++: static vtkBitArray *SafeDownCast(vtkObjectBase *o)
        """
        ...
    
    def SetComponent(self, p_int, p_int_1, p_float):
        """
        V.SetComponent(int, int, float)
        C++: void SetComponent(vtkIdType i, int j, double c) override;
        
        Set the data component at the ith tuple and jth component
        location. Note that i is less then NumberOfTuples and j is less
        then NumberOfComponents. Make sure enough memory has been
        allocated (use SetNumberOfTuples() and  SetNumberOfComponents()).
        """
        ...
    
    def SetNumberOfTuples(self, p_int):
        """
        V.SetNumberOfTuples(int)
        C++: void SetNumberOfTuples(vtkIdType number) override;
        
        Set the number of n-tuples in the array.
        """
        ...
    
    def SetTuple(self, p_int, p_int_1, vtkAbstractArray):
        """
        V.SetTuple(int, int, vtkAbstractArray)
        C++: void SetTuple(vtkIdType i, vtkIdType j,
            vtkAbstractArray *source) override;
        V.SetTuple(int, (float, ...))
        C++: void SetTuple(vtkIdType i, const double *tuple) override;
        
        Set the tuple at the ith location using the jth tuple in the
        source array. This method assumes that the two arrays have the
        same type and structure. Note that range checking and memory
        allocation is not performed; use in conjunction with
        SetNumberOfTuples() to allocate space.
        """
        ...
    
    def SetValue(self, p_int, p_int_1):
        """
        V.SetValue(int, int)
        C++: void SetValue(vtkIdType id, int value)
        
        Set the data at a particular index. Does not do range checking.
        Make sure you use the method SetNumberOfValues() before inserting
        data.
        """
        ...
    
    def SetVariantValue(self, p_int, vtkVariant):
        """
        V.SetVariantValue(int, vtkVariant)
        C++: void SetVariantValue(vtkIdType idx, vtkVariant value)
            override;
        
        Set a value in the array from a variant.
        """
        ...
    
    def SetVoidArray(self, void, p_int, p_int_1):
        """
        V.SetVoidArray(void, int, int)
        C++: void SetVoidArray(void *array, vtkIdType size, int save)
            override;
        V.SetVoidArray(void, int, int, int)
        C++: void SetVoidArray(void *array, vtkIdType size, int save,
            int deleteMethod) override;
        
        This method lets the user specify data to be held by the array. 
        The array argument is a pointer to the data.  size is the size of
        the array supplied by the user.  Set save to 1 to keep the class
        from deleting the array when it cleans up or reallocates memory.
        The class uses the actual array provided; it does not copy the
        data from the supplied array. If the delete method is
        VTK_DATA_ARRAY_USER_DEFINED a custom free function can be
        assigned to be called using SetArrayFreeFunction, if no custom
        function is assigned we will default to delete[].
        """
        ...
    
    def Squeeze(self):
        """
        V.Squeeze()
        C++: void Squeeze() override;
        
        Free any unneeded memory.
        """
        ...
    
    def WritePointer(self, p_int, p_int_1):
        """
        V.WritePointer(int, int) -> (int, ...)
        C++: unsigned char *WritePointer(vtkIdType id, vtkIdType number)
        
        Get the address of a particular data index. Make sure data is
        allocated for the number of items requested. Set MaxId according
        to the number of data values requested.
        """
        ...
    
    def WriteVoidPointer(self, p_int, p_int_1):
        """
        V.WriteVoidPointer(int, int) -> void
        C++: void *WriteVoidPointer(vtkIdType id, vtkIdType number)
            override;
        
        Get the address of a particular data index. Make sure data is
        allocated for the number of items requested. If needed, increase
        MaxId to mark any new value ranges as in-use.
        """
        ...
    
    def __delattr__(self, *args, **kwargs):
        """ Implement delattr(self, name). """
        ...
    
    def __getattribute__(self, *args, **kwargs):
        """ Return getattr(self, name). """
        ...
    
    def __init__(self, *args, **kwargs) -> None:
        ...
    
    @staticmethod
    def __new__(*args, **kwargs):
        """ Create and return a new object.  See help(type) for accurate signature. """
        ...
    
    def __repr__(self, *args, **kwargs):
        """ Return repr(self). """
        ...
    
    def __setattr__(self, *args, **kwargs):
        """ Implement setattr(self, name, value). """
        ...
    
    def __str__(self, *args, **kwargs) -> str:
        """ Return str(self). """
        ...
    
    __this__ = ...
    DeleteMethod = ...
    VTK_DATA_ARRAY_ALIGNED_FREE = ...
    VTK_DATA_ARRAY_DELETE = ...
    VTK_DATA_ARRAY_FREE = ...
    VTK_DATA_ARRAY_USER_DEFINED = ...
    __dict__ = ...
    __vtkname__ = ...


