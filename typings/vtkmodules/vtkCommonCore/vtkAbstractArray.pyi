"""
This type stub file was generated by pyright.
"""

from .vtkObject import vtkObject

class vtkAbstractArray(vtkObject):
    """
    vtkAbstractArray - Abstract superclass for all arrays
    
    Superclass: vtkObject
    
    vtkAbstractArray is an abstract superclass for data array objects.
    This class defines an API that all subclasses must support.  The data
    type must be assignable and copy-constructible, but no other
    assumptions about its type are made.  Most of the subclasses of this
    array deal with numeric data either as scalars or tuples of scalars. 
    A program can use the IsNumeric() method to check whether an instance
    of vtkAbstractArray contains numbers.  It is also possible to test
    for this by attempting to SafeDownCast an array to an instance of
    vtkDataArray, although this assumes that all numeric arrays will
    always be descended from vtkDataArray.
    
    Every array has a character-string name. The naming of the array
    occurs automatically when it is instantiated, but you are free to
    change this name using the SetName() method.  (The array name is used
    for data manipulation.)
    
    This class (and subclasses) use two forms of addressing elements:
    - Value Indexing: The index of an element assuming an
      array-of-structs memory layout.
    - Tuple/Component Indexing: Explicitly specify the tuple and
      component indices.
    
    It is also worth pointing out that the behavior of the "Insert*"
    methods of classes in this hierarchy may not behave as expected. They
    work exactly as the corresponding "Set*" methods, except that memory
    allocation will be performed if acting on a value past the end of the
    array. If the data already exists, "inserting" will overwrite
    existing values, rather than shift the array contents and insert the
    new data at the specified location.
    
    @sa
    vtkDataArray vtkStringArray vtkCellArray
    """
    def Allocate(self, p_int, p_int_1):
        """
        V.Allocate(int, int) -> int
        C++: virtual vtkTypeBool Allocate(vtkIdType numValues,
            vtkIdType ext=1000)
        
        Allocate memory for this array. Delete old storage only if
        necessary. Note that ext is no longer used. This method will
        reset MaxId to -1 and resize the array capacity such that
        this->Size >= numValues. If numValues is 0, all memory will be
        freed. Return 1 on success, 0 on failure.
        """
        ...
    
    def ClearLookup(self):
        """
        V.ClearLookup()
        C++: virtual void ClearLookup()
        
        Delete the associated fast lookup data structure on this array,
        if it exists.  The lookup will be rebuilt on the next call to a
        lookup function.
        """
        ...
    
    def CopyComponentNames(self, vtkAbstractArray):
        """
        V.CopyComponentNames(vtkAbstractArray) -> int
        C++: int CopyComponentNames(vtkAbstractArray *da)
        
        Copies the component names from the inputed array to the current
        array make sure that the current array has the same number of
        components as the input array
        """
        ...
    
    def CopyInformation(self, vtkInformation, p_int):
        """
        V.CopyInformation(vtkInformation, int) -> int
        C++: virtual int CopyInformation(vtkInformation *infoFrom,
            int deep=1)
        
        Copy information instance. Arrays use information objects in a
        variety of ways. It is important to have flexibility in this
        regard because certain keys should not be copied, while others
        must be.
        
        * NOTE: Subclasses must always call their superclass's
          CopyInformation
        * method, so that all classes in the hierarchy get a chance to
          remove
        * keys they do not wish to be copied. The subclass will not need
          to
        * explicitly copy the keys as it's handled here.
        """
        ...
    
    def CreateArray(self, p_int):
        """
        V.CreateArray(int) -> vtkAbstractArray
        C++: static vtkAbstractArray *CreateArray(int dataType)
        
        Creates an array for dataType where dataType is one of VTK_BIT,
        VTK_CHAR, VTK_UNSIGNED_CHAR, VTK_SHORT, VTK_UNSIGNED_SHORT,
        VTK_INT, VTK_UNSIGNED_INT, VTK_LONG, VTK_UNSIGNED_LONG,
        VTK_DOUBLE, VTK_DOUBLE, VTK_ID_TYPE, VTK_STRING. Note that the
        data array returned has to be deleted by the user.
        """
        ...
    
    def DataChanged(self):
        """
        V.DataChanged()
        C++: virtual void DataChanged()
        
        Tell the array explicitly that the data has changed. This is only
        necessary to call when you modify the array contents without
        using the array's API (i.e. you retrieve a pointer to the data
        and modify the array contents).  You need to call this so that
        the fast lookup will know to rebuild itself.  Otherwise, the
        lookup functions will give incorrect results.
        """
        ...
    
    def DeepCopy(self, vtkAbstractArray):
        """
        V.DeepCopy(vtkAbstractArray)
        C++: virtual void DeepCopy(vtkAbstractArray *da)
        
        Deep copy of data. Implementation left to subclasses, which
        should support as many type conversions as possible given the
        data type.
        
        * Subclasses should call vtkAbstractArray::DeepCopy() so that the
        * information object (if one exists) is copied from da.
        """
        ...
    
    def DISCRETE_VALUES(self):
        """
        V.DISCRETE_VALUES() -> vtkInformationVariantVectorKey
        C++: static vtkInformationVariantVectorKey *DISCRETE_VALUES()
        
        A key used to hold discrete values taken on either by the tuples
        of the array (when present in this->GetInformation()) or
        individual components (when present in one entry of the
        PER_COMPONENT() information vector).
        """
        ...
    
    def DISCRETE_VALUE_SAMPLE_PARAMETERS(self):
        """
        V.DISCRETE_VALUE_SAMPLE_PARAMETERS()
            -> vtkInformationDoubleVectorKey
        C++: static vtkInformationDoubleVectorKey *DISCRETE_VALUE_SAMPLE_PARAMETERS(
            )
        
        A key used to hold conditions under which cached discrete values
        were generated; the value is a 2-vector of doubles. The first
        entry corresponds to the maximum uncertainty that prominent
        values exist but have not been detected. The second entry
        corresponds to the smallest relative frequency a value is allowed
        to have and still appear on the list.
        """
        ...
    
    def ExportToVoidPointer(self, void):
        """
        V.ExportToVoidPointer(void)
        C++: virtual void ExportToVoidPointer(void *out_ptr)
        
        This method copies the array data to the void pointer specified
        by the user.  It is up to the user to allocate enough memory for
        the void pointer.
        """
        ...
    
    def GetActualMemorySize(self):
        """
        V.GetActualMemorySize() -> int
        C++: virtual unsigned long GetActualMemorySize()
        
        Return the memory in kibibytes (1024 bytes) consumed by this data
        array. Used to support streaming and reading/writing data. The
        value returned is guaranteed to be greater than or equal to the
        memory required to actually represent the data represented by
        this object. The information returned is valid only after the
        pipeline has been updated.
        """
        ...
    
    def GetArrayType(self):
        """
        V.GetArrayType() -> int
        C++: virtual int GetArrayType()
        
        Method for type-checking in FastDownCast implementations. See
        also vtkArrayDownCast.
        """
        ...
    
    def GetComponentName(self, p_int):
        """
        V.GetComponentName(int) -> string
        C++: const char *GetComponentName(vtkIdType component)
        
        Get the component name for a given component. Note: will return
        the actual string that is stored
        """
        ...
    
    def GetDataSize(self):
        """
        V.GetDataSize() -> int
        C++: virtual vtkIdType GetDataSize()
        
        Returns the size of the data in DataTypeSize units. Thus, the
        number of bytes for the data can be computed by GetDataSize() *
        GetDataTypeSize(). Non-contiguous or variable- size arrays need
        to override this method.
        """
        ...
    
    def GetDataType(self):
        """
        V.GetDataType() -> int
        C++: virtual int GetDataType()
        
        Return the underlying data type. An integer indicating data type
        is returned as specified in vtkType.h.
        """
        ...
    
    def GetDataTypeAsString(self):
        """
        V.GetDataTypeAsString() -> string
        C++: virtual const char *GetDataTypeAsString(void)
        
        Get the name of a data type as a string.
        """
        ...
    
    def GetDataTypeSize(self):
        """
        V.GetDataTypeSize() -> int
        C++: virtual int GetDataTypeSize()
        V.GetDataTypeSize(int) -> int
        C++: static int GetDataTypeSize(int type)
        
        Return the size of the underlying data type.  For a bit, 0 is
        returned.  For string 0 is returned. Arrays with variable length
        components return 0.
        """
        ...
    
    def GetElementComponentSize(self):
        """
        V.GetElementComponentSize() -> int
        C++: virtual int GetElementComponentSize()
        
        Return the size, in bytes, of the lowest-level element of an
        array.  For vtkDataArray and subclasses this is the size of the
        data type.  For vtkStringArray, this is
        sizeof(vtkStdString::value_type), which winds up being
        sizeof(char).
        """
        ...
    
    def GetInformation(self):
        """
        V.GetInformation() -> vtkInformation
        C++: vtkInformation *GetInformation()
        
        Get an information object that can be used to annotate the array.
        This will always return an instance of vtkInformation, if one is
        not currently associated with the array it will be created.
        """
        ...
    
    def GetMaxDiscreteValues(self):
        """
        V.GetMaxDiscreteValues() -> int
        C++: virtual unsigned int GetMaxDiscreteValues()
        
        Get/Set the maximum number of prominent values this array may
        contain before it is considered continuous.  Default value is 32.
        """
        ...
    
    def GetMaxId(self):
        """
        V.GetMaxId() -> int
        C++: vtkIdType GetMaxId()
        
        What is the maximum id currently in the array.
        """
        ...
    
    def GetName(self):
        """
        V.GetName() -> string
        C++: virtual char *GetName()
        
        Set/get array's name
        """
        ...
    
    def GetNumberOfComponents(self):
        """
        V.GetNumberOfComponents() -> int
        C++: int GetNumberOfComponents()
        
        Set/Get the dimension (n) of the components. Must be >= 1. Make
        sure that this is set before allocation.
        """
        ...
    
    def GetNumberOfComponentsMaxValue(self):
        """
        V.GetNumberOfComponentsMaxValue() -> int
        C++: virtual int GetNumberOfComponentsMaxValue()
        
        Set/Get the dimension (n) of the components. Must be >= 1. Make
        sure that this is set before allocation.
        """
        ...
    
    def GetNumberOfComponentsMinValue(self):
        """
        V.GetNumberOfComponentsMinValue() -> int
        C++: virtual int GetNumberOfComponentsMinValue()
        
        Set/Get the dimension (n) of the components. Must be >= 1. Make
        sure that this is set before allocation.
        """
        ...
    
    def GetNumberOfGenerationsFromBase(self, string):
        """
        V.GetNumberOfGenerationsFromBase(string) -> int
        C++: vtkIdType GetNumberOfGenerationsFromBase(const char *type)
            override;
        
        Given a the name of a base class of this class type, return the
        distance of inheritance between this class type and the named
        class (how many generations of inheritance are there between this
        class and the named class). If the named class is not in this
        class's inheritance tree, return a negative value. Valid
        responses will always be nonnegative. This method works in
        combination with vtkTypeMacro found in vtkSetGet.h.
        """
        ...
    
    def GetNumberOfGenerationsFromBaseType(self, string):
        """
        V.GetNumberOfGenerationsFromBaseType(string) -> int
        C++: static vtkIdType GetNumberOfGenerationsFromBaseType(
            const char *type)
        
        Given a the name of a base class of this class type, return the
        distance of inheritance between this class type and the named
        class (how many generations of inheritance are there between this
        class and the named class). If the named class is not in this
        class's inheritance tree, return a negative value. Valid
        responses will always be nonnegative. This method works in
        combination with vtkTypeMacro found in vtkSetGet.h.
        """
        ...
    
    def GetNumberOfTuples(self):
        """
        V.GetNumberOfTuples() -> int
        C++: vtkIdType GetNumberOfTuples()
        
        Get the number of complete tuples (a component group) in the
        array.
        """
        ...
    
    def GetNumberOfValues(self):
        """
        V.GetNumberOfValues() -> int
        C++: vtkIdType GetNumberOfValues()
        
        Get the total number of values in the array. This is typically
        equivalent to (numTuples * numComponents). The exception is
        during incremental array construction for subclasses that support
        component insertion, which may result in an incomplete trailing
        tuple.
        """
        ...
    
    def GetProminentComponentValues(self, p_int, vtkVariantArray, p_float, p_float_1):
        """
        V.GetProminentComponentValues(int, vtkVariantArray, float, float)
        C++: virtual void GetProminentComponentValues(int comp,
            vtkVariantArray *values, double uncertainty=1.e-6,
            double minimumProminence=1.e-3)
        
        Populate the given vtkVariantArray with a set of distinct values
        taken on by the requested component (or, when passed -1, by the
        tuples as a whole). If the set of prominent values has more than
        32 entries, then the array is assumed to be continuous in nature
        and no values are returned.
        
        * This method takes 2 parameters: uncertainty and
          minimumProminence.
        * Note that this set of returned values may not be complete if
        * uncertainty and minimumProminence are both larger than 0.0;
        * in order to perform interactively, a subsample of the array is
        * used to determine the set of values.
        
        * The first parameter ( uncertainty, U) is the maximum acceptable
        * probability that a prominent value will not be detected.
        * Setting this to 0 will cause every value in the array to be
          examined.
        
        * The second parameter ( minimumProminence, P) specifies the
          smallest
        * relative frequency (in [0,1]) with which a value in the array
          may
        * occur and still be considered prominent. Setting this to 0
        * will force every value in the array to be traversed.
        * Using numbers close to 0 for this parameter quickly causes
        * the number of samples required to obtain the given uncertainty
          to
        * subsume the entire array, as rare occurrences require frequent
        * sampling to detect.
        
        * For an array with T tuples and given uncertainty U and
          mininumum
        * prominence P, we sample N values, with N = f(T; P, U).
        * We want f to be sublinear in T in order to interactively handle
        large
        * arrays; in practice, we can make f independent of T:
        * $ N >= \frac{5}{P}\mathrm{ln}\left(\frac{1}{PU}\right) $,
        * but note that small values of P are costly to achieve.
        * The default parameters will locate prominent values that occur
          at least
        * 1 out of every 1000 samples with a confidence ...
         [Truncated]
        """
        ...
    
    def GetSize(self):
        """
        V.GetSize() -> int
        C++: vtkIdType GetSize()
        
        Return the size of the data.
        """
        ...
    
    def GetTuples(self, vtkIdList, vtkAbstractArray):
        """
        V.GetTuples(vtkIdList, vtkAbstractArray)
        C++: virtual void GetTuples(vtkIdList *tupleIds,
            vtkAbstractArray *output)
        V.GetTuples(int, int, vtkAbstractArray)
        C++: virtual void GetTuples(vtkIdType p1, vtkIdType p2,
            vtkAbstractArray *output)
        
        Given a list of tuple ids, return an array of tuples. You must
        insure that the output array has been previously allocated with
        enough space to hold the data.
        """
        ...
    
    def GetVariantValue(self, p_int):
        """
        V.GetVariantValue(int) -> vtkVariant
        C++: virtual vtkVariant GetVariantValue(vtkIdType valueIdx)
        
        Retrieve value from the array as a variant.
        """
        ...
    
    def GetVoidPointer(self, p_int):
        """
        V.GetVoidPointer(int) -> void
        C++: virtual void *GetVoidPointer(vtkIdType valueIdx)
        
        Return a void pointer. For image pipeline interface and other
        special pointer manipulation. Use of this method is discouraged,
        as newer arrays require a deep-copy of the array data in order to
        return a suitable pointer. See vtkArrayDispatch for a safer
        alternative for fast data access.
        """
        ...
    
    def GUI_HIDE(self):
        """
        V.GUI_HIDE() -> vtkInformationIntegerKey
        C++: static vtkInformationIntegerKey *GUI_HIDE()
        
        This key is a hint to end user interface that this array is
        internal and should not be shown to the end user.
        """
        ...
    
    def HasAComponentName(self):
        """
        V.HasAComponentName() -> bool
        C++: bool HasAComponentName()
        
        Returns if any component has had a name assigned
        """
        ...
    
    def HasInformation(self):
        """
        V.HasInformation() -> bool
        C++: bool HasInformation()
        
        Inquire if this array has an instance of vtkInformation already
        associated with it.
        """
        ...
    
    def HasStandardMemoryLayout(self):
        """
        V.HasStandardMemoryLayout() -> bool
        C++: virtual bool HasStandardMemoryLayout()
        
        Returns true if this array uses the standard memory layout
        defined in the VTK user guide, e.g. a contiguous array: {t1c1,
        t1c2, t1c3, ... t1cM, t2c1, ... tNcM} where t1c2 is the second
        component of the first tuple.
        """
        ...
    
    def Initialize(self):
        """
        V.Initialize()
        C++: virtual void Initialize()
        
        Release storage and reset array to initial state.
        """
        ...
    
    def InsertNextTuple(self, p_int, vtkAbstractArray):
        """
        V.InsertNextTuple(int, vtkAbstractArray) -> int
        C++: virtual vtkIdType InsertNextTuple(vtkIdType srcTupleIdx,
            vtkAbstractArray *source)
        
        Insert the tuple from srcTupleIdx in the source array at the end
        of this array. Note that memory allocation is performed as
        necessary to hold the data. Returns the tuple index at which the
        data was inserted.
        """
        ...
    
    def InsertTuple(self, p_int, p_int_1, vtkAbstractArray):
        """
        V.InsertTuple(int, int, vtkAbstractArray)
        C++: virtual void InsertTuple(vtkIdType dstTupleIdx,
            vtkIdType srcTupleIdx, vtkAbstractArray *source)
        
        Insert the tuple at srcTupleIdx in the source array into this
        array at dstTupleIdx. Note that memory allocation is performed as
        necessary to hold the data.
        """
        ...
    
    def InsertTuples(self, vtkIdList, vtkIdList_1, vtkAbstractArray):
        """
        V.InsertTuples(vtkIdList, vtkIdList, vtkAbstractArray)
        C++: virtual void InsertTuples(vtkIdList *dstIds,
            vtkIdList *srcIds, vtkAbstractArray *source)
        V.InsertTuples(int, int, int, vtkAbstractArray)
        C++: virtual void InsertTuples(vtkIdType dstStart, vtkIdType n,
            vtkIdType srcStart, vtkAbstractArray *source)
        
        Copy the tuples indexed in srcIds from the source array to the
        tuple locations indexed by dstIds in this array. Note that memory
        allocation is performed as necessary to hold the data.
        """
        ...
    
    def InsertVariantValue(self, p_int, vtkVariant):
        """
        V.InsertVariantValue(int, vtkVariant)
        C++: virtual void InsertVariantValue(vtkIdType valueIdx,
            vtkVariant value)
        
        Insert a value into the array from a variant.  This method does
        bounds checking.
        """
        ...
    
    def InterpolateTuple(self, p_int, vtkIdList, vtkAbstractArray, *float):
        """
        V.InterpolateTuple(int, vtkIdList, vtkAbstractArray, [float, ...])
        C++: virtual void InterpolateTuple(vtkIdType dstTupleIdx,
            vtkIdList *ptIndices, vtkAbstractArray *source,
            double *weights)
        V.InterpolateTuple(int, int, vtkAbstractArray, int,
            vtkAbstractArray, float)
        C++: virtual void InterpolateTuple(vtkIdType dstTupleIdx,
            vtkIdType srcTupleIdx1, vtkAbstractArray *source1,
            vtkIdType srcTupleIdx2, vtkAbstractArray *source2, double t)
        
        Set the tuple at dstTupleIdx in this array to the interpolated
        tuple value, given the ptIndices in the source array and
        associated interpolation weights. This method assumes that the
        two arrays are of the same type and structure.
        """
        ...
    
    def IsA(self, string):
        """
        V.IsA(string) -> int
        C++: vtkTypeBool IsA(const char *type) override;
        
        Return 1 if this class is the same type of (or a subclass of) the
        named class. Returns 0 otherwise. This method works in
        combination with vtkTypeMacro found in vtkSetGet.h.
        """
        ...
    
    def IsNumeric(self):
        """
        V.IsNumeric() -> int
        C++: virtual int IsNumeric()
        
        This method is here to make backward compatibility easier.  It
        must return true if and only if an array contains numeric data.
        """
        ...
    
    def IsTypeOf(self, string):
        """
        V.IsTypeOf(string) -> int
        C++: static vtkTypeBool IsTypeOf(const char *type)
        
        Return 1 if this class type is the same type of (or a subclass
        of) the named class. Returns 0 otherwise. This method works in
        combination with vtkTypeMacro found in vtkSetGet.h.
        """
        ...
    
    def LookupValue(self, vtkVariant):
        """
        V.LookupValue(vtkVariant) -> int
        C++: virtual vtkIdType LookupValue(vtkVariant value)
        V.LookupValue(vtkVariant, vtkIdList)
        C++: virtual void LookupValue(vtkVariant value,
            vtkIdList *valueIds)
        
        Return the value indices where a specific value appears.
        """
        ...
    
    def Modified(self):
        """
        V.Modified()
        C++: void Modified() override;
        
        Removes out-of-date PER_COMPONENT() and PER_FINITE_COMPONENT()
        values.
        """
        ...
    
    def NewInstance(self):
        """
        V.NewInstance() -> vtkAbstractArray
        C++: vtkAbstractArray *NewInstance()
        """
        ...
    
    def NewIterator(self):
        """
        V.NewIterator() -> vtkArrayIterator
        C++: virtual vtkArrayIterator *NewIterator()
        
        Subclasses must override this method and provide the right kind
        of templated vtkArrayIteratorTemplate.
        """
        ...
    
    def PER_COMPONENT(self):
        """
        V.PER_COMPONENT() -> vtkInformationInformationVectorKey
        C++: static vtkInformationInformationVectorKey *PER_COMPONENT()
        
        This key is used to hold a vector of COMPONENT_VALUES (and, for
        vtkDataArray subclasses, COMPONENT_RANGE) keys -- one for each
        component of the array.  You may add additional per-component
        key-value pairs to information objects in this vector. However if
        you do so, you must be sure to either (1) set COMPONENT_VALUES to
        an invalid variant and set COMPONENT_RANGE to {VTK_DOUBLE_MAX,
        VTK_DOUBLE_MIN} or (2) call ComputeUniqueValues(component) and
        ComputeRange(component) beforemodifying the information object.
        Otherwise it is possible for modifications to the array to take
        place without the bounds on the component being updated.
        """
        ...
    
    def PER_FINITE_COMPONENT(self):
        """
        V.PER_FINITE_COMPONENT() -> vtkInformationInformationVectorKey
        C++: static vtkInformationInformationVectorKey *PER_FINITE_COMPONENT(
            )
        
        This key is used to hold a vector of COMPONENT_VALUES (and, for
        vtkDataArray subclasses, COMPONENT_RANGE) keys -- one for each
        component of the array.  You may add additional per-component
        key-value pairs to information objects in this vector. However if
        you do so, you must be sure to either (1) set COMPONENT_VALUES to
        an invalid variant and set COMPONENT_RANGE to {VTK_DOUBLE_MAX,
        VTK_DOUBLE_MIN} or (2) call ComputeUniqueValues(component) and
        ComputeFiniteRange(component) beforemodifying the information
        object. Otherwise it is possible for modifications to the array
        to take place without the bounds on the component being updated.
        """
        ...
    
    def Reset(self):
        """
        V.Reset()
        C++: void Reset()
        
        Reset to an empty state, without freeing any memory.
        """
        ...
    
    def Resize(self, p_int):
        """
        V.Resize(int) -> int
        C++: virtual vtkTypeBool Resize(vtkIdType numTuples)
        
        Resize the array to the requested number of tuples and preserve
        data. Increasing the array size may allocate extra memory beyond
        what was requested. MaxId will not be modified when increasing
        array size. Decreasing the array size will trim memory to the
        requested size and may update MaxId if the valid id range is
        truncated. Requesting an array size of 0 will free all memory.
        Returns 1 if resizing succeeded and 0 otherwise.
        """
        ...
    
    def SafeDownCast(self, vtkObjectBase):
        """
        V.SafeDownCast(vtkObjectBase) -> vtkAbstractArray
        C++: static vtkAbstractArray *SafeDownCast(vtkObjectBase *o)
        """
        ...
    
    def SetComponentName(self, p_int, string):
        """
        V.SetComponentName(int, string)
        C++: void SetComponentName(vtkIdType component, const char *name)
        
        Set the name for a component. `component` must be >= 0.
        """
        ...
    
    def SetMaxDiscreteValues(self, p_int):
        """
        V.SetMaxDiscreteValues(int)
        C++: virtual void SetMaxDiscreteValues(unsigned int _arg)
        
        Get/Set the maximum number of prominent values this array may
        contain before it is considered continuous.  Default value is 32.
        """
        ...
    
    def SetName(self, string):
        """
        V.SetName(string)
        C++: virtual void SetName(const char *_arg)
        
        Set/get array's name
        """
        ...
    
    def SetNumberOfComponents(self, p_int):
        """
        V.SetNumberOfComponents(int)
        C++: virtual void SetNumberOfComponents(int _arg)
        
        Set/Get the dimension (n) of the components. Must be >= 1. Make
        sure that this is set before allocation.
        """
        ...
    
    def SetNumberOfTuples(self, p_int):
        """
        V.SetNumberOfTuples(int)
        C++: virtual void SetNumberOfTuples(vtkIdType numTuples)
        
        Set the number of tuples (a component group) in the array. Note
        that this may allocate space depending on the number of
        components. Also note that if allocation is performed no copy is
        performed so existing data will be lost (if data conservation is
        sought, one may use the Resize method instead).
        """
        ...
    
    def SetNumberOfValues(self, p_int):
        """
        V.SetNumberOfValues(int) -> bool
        C++: virtual bool SetNumberOfValues(vtkIdType numValues)
        
        Specify the number of values (tuples * components) for this
        object to hold. Does an allocation as well as setting the MaxId
        ivar. Used in conjunction with SetValue() method for fast
        insertion. Preserves existing data and returns true if allocation
        succeeds, or false otherwise.
        """
        ...
    
    def SetTuple(self, p_int, p_int_1, vtkAbstractArray):
        """
        V.SetTuple(int, int, vtkAbstractArray)
        C++: virtual void SetTuple(vtkIdType dstTupleIdx,
            vtkIdType srcTupleIdx, vtkAbstractArray *source)
        
        Set the tuple at dstTupleIdx in this array to the tuple at
        srcTupleIdx in the source array. This method assumes that the two
        arrays have the same type and structure. Note that range checking
        and memory allocation is not performed; use in conjunction with
        SetNumberOfTuples() to allocate space.
        """
        ...
    
    def SetVariantValue(self, p_int, vtkVariant):
        """
        V.SetVariantValue(int, vtkVariant)
        C++: virtual void SetVariantValue(vtkIdType valueIdx,
            vtkVariant value)
        
        Set a value in the array from a variant.  This method does NOT do
        bounds checking.
        """
        ...
    
    def SetVoidArray(self, void, p_int, p_int_1):
        """
        V.SetVoidArray(void, int, int)
        C++: virtual void SetVoidArray(void *array, vtkIdType size,
            int save)
        V.SetVoidArray(void, int, int, int)
        C++: virtual void SetVoidArray(void *array, vtkIdType size,
            int save, int deleteMethod)
        
        This method lets the user specify data to be held by the array. 
        The array argument is a pointer to the data.  size is the size of
        the array supplied by the user.  Set save to 1 to keep the class
        from deleting the array when it cleans up or reallocates memory. 
        The class uses the actual array provided; it does not copy the
        data from the supplied array. If specified, the delete method
        determines how the data array will be deallocated. If the delete
        method is VTK_DATA_ARRAY_FREE, free() will be used. If the delete
        method is VTK_DATA_ARRAY_DELETE, delete[] will be used. If the
        delete method is VTK_DATA_ARRAY_ALIGNED_FREE _aligned_free() will
        be used on windows, while free() will be used everywhere else. If
        the delete method is VTK_DATA_ARRAY_USER_DEFINED a custom free
        function can be assigned to be called using SetArrayFreeFunction,
        if no custom function is assigned we will default to free(). The
        default is FREE. (Note not all subclasses can support
        deleteMethod.)
        """
        ...
    
    def Squeeze(self):
        """
        V.Squeeze()
        C++: virtual void Squeeze()
        
        Free any unnecessary memory. Description: Resize object to just
        fit data requirement. Reclaims extra memory.
        """
        ...
    
    def __delattr__(self, *args, **kwargs):
        """ Implement delattr(self, name). """
        ...
    
    def __getattribute__(self, *args, **kwargs):
        """ Return getattr(self, name). """
        ...
    
    def __init__(self, *args, **kwargs) -> None:
        ...
    
    @staticmethod
    def __new__(*args, **kwargs):
        """ Create and return a new object.  See help(type) for accurate signature. """
        ...
    
    def __repr__(self, *args, **kwargs):
        """ Return repr(self). """
        ...
    
    def __setattr__(self, *args, **kwargs):
        """ Implement setattr(self, name, value). """
        ...
    
    def __str__(self, *args, **kwargs) -> str:
        """ Return str(self). """
        ...
    
    __this__ = ...
    AbstractArray = ...
    AoSDataArrayTemplate = ...
    DataArray = ...
    DataArrayTemplate = ...
    DeleteMethod = ...
    MappedDataArray = ...
    MAX_DISCRETE_VALUES = ...
    ScaleSoADataArrayTemplate = ...
    SoADataArrayTemplate = ...
    TypedDataArray = ...
    VTK_DATA_ARRAY_ALIGNED_FREE = ...
    VTK_DATA_ARRAY_DELETE = ...
    VTK_DATA_ARRAY_FREE = ...
    VTK_DATA_ARRAY_USER_DEFINED = ...
    __dict__ = ...
    __vtkname__ = ...


