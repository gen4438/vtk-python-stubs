"""
This type stub file was generated by pyright.
"""

import vtkmodules.vtkCommonCore as __vtkmodules_vtkCommonCore

class vtkLight(__vtkmodules_vtkCommonCore.vtkObject):
    """
    vtkLight - a virtual light for 3D rendering
    
    Superclass: vtkObject
    
    vtkLight is a virtual light for 3D rendering. It provides methods to
    locate and point the light, turn it on and off, and set its
    brightness and color. In addition to the basic infinite distance
    point light source attributes, you also can specify the light
    attenuation values and cone angle. These attributes are only used if
    the light is a positional light. The default is a directional light
    (e.g. infinite point light source).
    
    Lights have a type that describes how the light should move with
    respect to the camera.  A Headlight is always located at the current
    camera position and shines on the camera's focal point.  A
    CameraLight also moves with the camera, but may not be coincident to
    it.  CameraLights are defined in a normalized coordinate space where
    the camera is located at (0, 0, 1), the camera is looking at (0, 0,
    0), and up is (0, 1, 0).  Finally, a SceneLight is part of the scene
    itself and does not move with the camera. (Renderers are responsible
    for moving the light based on its type.)
    
    Lights have a transformation matrix that describes the space in which
    they are positioned.  A light's world space position and focal point
    are defined by their local position and focal point, transformed by
    their transformation matrix (if it exists).
    """
    def DeepCopy(self, vtkLight):
        """
        V.DeepCopy(vtkLight)
        C++: void DeepCopy(vtkLight *light)
        
        Perform deep copy of this light.
        """
        ...
    
    def GetAmbientColor(self):
        """
        V.GetAmbientColor() -> (float, float, float)
        C++: virtual double *GetAmbientColor()
        
        Set/Get the color of the light. It is possible to set the
        ambient, diffuse and specular colors separately. The SetColor()
        method sets the diffuse and specular colors to the same color
        (this is a feature to preserve backward compatibility.)
        """
        ...
    
    def GetAttenuationValues(self):
        """
        V.GetAttenuationValues() -> (float, float, float)
        C++: virtual double *GetAttenuationValues()
        
        Set/Get the quadratic attenuation constants. They are specified
        as constant, linear, and quadratic, in that order.
        """
        ...
    
    def GetConeAngle(self):
        """
        V.GetConeAngle() -> float
        C++: virtual double GetConeAngle()
        
        Set/Get the lighting cone angle of a positional light in degrees.
        This is the angle between the axis of the cone and a ray along
        the edge of the cone. A value of 90 (or more) indicates that you
        want no spot lighting effects just a positional light.
        """
        ...
    
    def GetDiffuseColor(self):
        """
        V.GetDiffuseColor() -> (float, float, float)
        C++: virtual double *GetDiffuseColor()
        
        Set/Get the color of the light. It is possible to set the
        ambient, diffuse and specular colors separately. The SetColor()
        method sets the diffuse and specular colors to the same color
        (this is a feature to preserve backward compatibility.)
        """
        ...
    
    def GetExponent(self):
        """
        V.GetExponent() -> float
        C++: virtual double GetExponent()
        
        Set/Get the exponent of the cosine used in positional lighting.
        """
        ...
    
    def GetExponentMaxValue(self):
        """
        V.GetExponentMaxValue() -> float
        C++: virtual double GetExponentMaxValue()
        
        Set/Get the exponent of the cosine used in positional lighting.
        """
        ...
    
    def GetExponentMinValue(self):
        """
        V.GetExponentMinValue() -> float
        C++: virtual double GetExponentMinValue()
        
        Set/Get the exponent of the cosine used in positional lighting.
        """
        ...
    
    def GetFocalPoint(self):
        """
        V.GetFocalPoint() -> (float, float, float)
        C++: virtual double *GetFocalPoint()
        
        Set/Get the point at which the light is shining. Note: The focal
        point of the light is defined in the coordinate space indicated
        by its transformation matrix (if it exists). Thus, to get the
        light's world space focal point, use
        vtkGetTransformedFocalPoint() instead of vtkGetFocalPoint().
        """
        ...
    
    def GetInformation(self):
        """
        V.GetInformation() -> vtkInformation
        C++: virtual vtkInformation *GetInformation()
        
        Set/Get the information object associated with the light.
        """
        ...
    
    def GetIntensity(self):
        """
        V.GetIntensity() -> float
        C++: virtual double GetIntensity()
        
        Set/Get the brightness of the light (from one to zero).
        """
        ...
    
    def GetLightType(self):
        """
        V.GetLightType() -> int
        C++: virtual int GetLightType()
        
        Set/Get the type of the light. A SceneLight is a light located in
        the world coordinate space.  A light is initially created as a
        scene light.
        
        * A Headlight is always located at the camera and is pointed at
          the
        * camera's focal point.  The renderer is free to modify the
          position and
        * focal point of the camera at any time.
        
        * A CameraLight is also attached to the camera, but is not
          necessarily
        * located at the camera's position.  CameraLights are defined in
          a
        * coordinate space where the camera is located at (0, 0, 1),
          looking
        * towards (0, 0, 0) at a distance of 1, with up being (0, 1, 0).
        * CameraLight uses the transform matrix to establish this space.
        
        * Note: All SetLightType(), and SetLightTypeTo*() calls clear the
        * light's transform matrix.
        """
        ...
    
    def GetNumberOfGenerationsFromBase(self, string):
        """
        V.GetNumberOfGenerationsFromBase(string) -> int
        C++: vtkIdType GetNumberOfGenerationsFromBase(const char *type)
            override;
        
        Given a the name of a base class of this class type, return the
        distance of inheritance between this class type and the named
        class (how many generations of inheritance are there between this
        class and the named class). If the named class is not in this
        class's inheritance tree, return a negative value. Valid
        responses will always be nonnegative. This method works in
        combination with vtkTypeMacro found in vtkSetGet.h.
        """
        ...
    
    def GetNumberOfGenerationsFromBaseType(self, string):
        """
        V.GetNumberOfGenerationsFromBaseType(string) -> int
        C++: static vtkIdType GetNumberOfGenerationsFromBaseType(
            const char *type)
        
        Given a the name of a base class of this class type, return the
        distance of inheritance between this class type and the named
        class (how many generations of inheritance are there between this
        class and the named class). If the named class is not in this
        class's inheritance tree, return a negative value. Valid
        responses will always be nonnegative. This method works in
        combination with vtkTypeMacro found in vtkSetGet.h.
        """
        ...
    
    def GetPosition(self):
        """
        V.GetPosition() -> (float, float, float)
        C++: virtual double *GetPosition()
        
        Set/Get the position of the light. Note: The position of the
        light is defined in the coordinate space indicated by its
        transformation matrix (if it exists). Thus, to get the light's
        world space position, use vtkGetTransformedPosition() instead of
        vtkGetPosition().
        """
        ...
    
    def GetPositional(self):
        """
        V.GetPositional() -> int
        C++: virtual vtkTypeBool GetPositional()
        
        Turn positional lighting on or off.
        """
        ...
    
    def GetShadowAttenuation(self):
        """
        V.GetShadowAttenuation() -> float
        C++: virtual float GetShadowAttenuation()
        
        Set/Get the shadow intensity By default a light will be
        completely blocked when in shadow by setting this value to less
        than 1.0 you can control how much light is attenuated when in
        shadow
        """
        ...
    
    def GetSpecularColor(self):
        """
        V.GetSpecularColor() -> (float, float, float)
        C++: virtual double *GetSpecularColor()
        
        Set/Get the color of the light. It is possible to set the
        ambient, diffuse and specular colors separately. The SetColor()
        method sets the diffuse and specular colors to the same color
        (this is a feature to preserve backward compatibility.)
        """
        ...
    
    def GetSwitch(self):
        """
        V.GetSwitch() -> int
        C++: virtual vtkTypeBool GetSwitch()
        
        Turn the light on or off.
        """
        ...
    
    def GetTransformedFocalPoint(self, p_float, p_float_1, p_float_2):
        """
        V.GetTransformedFocalPoint(float, float, float)
        C++: void GetTransformedFocalPoint(double &a0, double &a1,
            double &a2)
        V.GetTransformedFocalPoint([float, float, float])
        C++: void GetTransformedFocalPoint(double a[3])
        V.GetTransformedFocalPoint() -> (float, float, float)
        C++: double *GetTransformedFocalPoint()
        
        Get the focal point of the light, modified by the transformation
        matrix (if it exists).
        """
        ...
    
    def GetTransformedPosition(self, p_float, p_float_1, p_float_2):
        """
        V.GetTransformedPosition(float, float, float)
        C++: void GetTransformedPosition(double &a0, double &a1,
            double &a2)
        V.GetTransformedPosition([float, float, float])
        C++: void GetTransformedPosition(double a[3])
        V.GetTransformedPosition() -> (float, float, float)
        C++: double *GetTransformedPosition()
        
        Get the position of the light, modified by the transformation
        matrix (if it exists).
        """
        ...
    
    def GetTransformMatrix(self):
        """
        V.GetTransformMatrix() -> vtkMatrix4x4
        C++: virtual vtkMatrix4x4 *GetTransformMatrix()
        
        Set/Get the light's transformation matrix.  If a matrix is set
        for a light, the light's parameters (position and focal point)
        are transformed by the matrix before being rendered.
        """
        ...
    
    def IsA(self, string):
        """
        V.IsA(string) -> int
        C++: vtkTypeBool IsA(const char *type) override;
        
        Return 1 if this class is the same type of (or a subclass of) the
        named class. Returns 0 otherwise. This method works in
        combination with vtkTypeMacro found in vtkSetGet.h.
        """
        ...
    
    def IsTypeOf(self, string):
        """
        V.IsTypeOf(string) -> int
        C++: static vtkTypeBool IsTypeOf(const char *type)
        
        Return 1 if this class type is the same type of (or a subclass
        of) the named class. Returns 0 otherwise. This method works in
        combination with vtkTypeMacro found in vtkSetGet.h.
        """
        ...
    
    def LightTypeIsCameraLight(self):
        """
        V.LightTypeIsCameraLight() -> int
        C++: int LightTypeIsCameraLight()
        
        Query the type of the light.
        """
        ...
    
    def LightTypeIsHeadlight(self):
        """
        V.LightTypeIsHeadlight() -> int
        C++: int LightTypeIsHeadlight()
        
        Query the type of the light.
        """
        ...
    
    def LightTypeIsSceneLight(self):
        """
        V.LightTypeIsSceneLight() -> int
        C++: int LightTypeIsSceneLight()
        
        Query the type of the light.
        """
        ...
    
    def NewInstance(self):
        """
        V.NewInstance() -> vtkLight
        C++: vtkLight *NewInstance()
        """
        ...
    
    def PositionalOff(self):
        """
        V.PositionalOff()
        C++: virtual void PositionalOff()
        
        Turn positional lighting on or off.
        """
        ...
    
    def PositionalOn(self):
        """
        V.PositionalOn()
        C++: virtual void PositionalOn()
        
        Turn positional lighting on or off.
        """
        ...
    
    def Render(self, vtkRenderer, p_int):
        """
        V.Render(vtkRenderer, int)
        C++: virtual void Render(vtkRenderer *, int)
        
        Abstract interface to renderer. Each concrete subclass of
        vtkLight will load its data into the graphics system in response
        to this method invocation. The actual loading is performed by a
        vtkLightDevice subclass, which will get created automatically.
        """
        ...
    
    def SafeDownCast(self, vtkObjectBase):
        """
        V.SafeDownCast(vtkObjectBase) -> vtkLight
        C++: static vtkLight *SafeDownCast(vtkObjectBase *o)
        """
        ...
    
    def SetAmbientColor(self, p_float, p_float_1, p_float_2):
        """
        V.SetAmbientColor(float, float, float)
        C++: virtual void SetAmbientColor(double _arg1, double _arg2,
            double _arg3)
        V.SetAmbientColor((float, float, float))
        C++: virtual void SetAmbientColor(const double _arg[3])
        
        Set/Get the color of the light. It is possible to set the
        ambient, diffuse and specular colors separately. The SetColor()
        method sets the diffuse and specular colors to the same color
        (this is a feature to preserve backward compatibility.)
        """
        ...
    
    def SetAttenuationValues(self, p_float, p_float_1, p_float_2):
        """
        V.SetAttenuationValues(float, float, float)
        C++: virtual void SetAttenuationValues(double _arg1, double _arg2,
             double _arg3)
        V.SetAttenuationValues((float, float, float))
        C++: virtual void SetAttenuationValues(const double _arg[3])
        
        Set/Get the quadratic attenuation constants. They are specified
        as constant, linear, and quadratic, in that order.
        """
        ...
    
    def SetColor(self, p_float, p_float_1, p_float_2):
        """
        V.SetColor(float, float, float)
        C++: void SetColor(double, double, double)
        V.SetColor((float, float, float))
        C++: void SetColor(const double a[3])
        
        Set/Get the color of the light. It is possible to set the
        ambient, diffuse and specular colors separately. The SetColor()
        method sets the diffuse and specular colors to the same color
        (this is a feature to preserve backward compatibility.)
        """
        ...
    
    def SetConeAngle(self, p_float):
        """
        V.SetConeAngle(float)
        C++: virtual void SetConeAngle(double _arg)
        
        Set/Get the lighting cone angle of a positional light in degrees.
        This is the angle between the axis of the cone and a ray along
        the edge of the cone. A value of 90 (or more) indicates that you
        want no spot lighting effects just a positional light.
        """
        ...
    
    def SetDiffuseColor(self, p_float, p_float_1, p_float_2):
        """
        V.SetDiffuseColor(float, float, float)
        C++: virtual void SetDiffuseColor(double _arg1, double _arg2,
            double _arg3)
        V.SetDiffuseColor((float, float, float))
        C++: virtual void SetDiffuseColor(const double _arg[3])
        
        Set/Get the color of the light. It is possible to set the
        ambient, diffuse and specular colors separately. The SetColor()
        method sets the diffuse and specular colors to the same color
        (this is a feature to preserve backward compatibility.)
        """
        ...
    
    def SetDirectionAngle(self, p_float, p_float_1):
        """
        V.SetDirectionAngle(float, float)
        C++: void SetDirectionAngle(double elevation, double azimuth)
        V.SetDirectionAngle((float, float))
        C++: void SetDirectionAngle(const double ang[2])
        
        Set the position and focal point of a light based on elevation
        and azimuth.  The light is moved so it is shining from the given
        angle. Angles are given in degrees.  If the light is a positional
        light, it is made directional instead.
        """
        ...
    
    def SetExponent(self, p_float):
        """
        V.SetExponent(float)
        C++: virtual void SetExponent(double _arg)
        
        Set/Get the exponent of the cosine used in positional lighting.
        """
        ...
    
    def SetFocalPoint(self, p_float, p_float_1, p_float_2):
        """
        V.SetFocalPoint(float, float, float)
        C++: virtual void SetFocalPoint(double _arg1, double _arg2,
            double _arg3)
        V.SetFocalPoint((float, float, float))
        C++: virtual void SetFocalPoint(const double _arg[3])
        
        Set/Get the point at which the light is shining. Note: The focal
        point of the light is defined in the coordinate space indicated
        by its transformation matrix (if it exists). Thus, to get the
        light's world space focal point, use
        vtkGetTransformedFocalPoint() instead of vtkGetFocalPoint().
        """
        ...
    
    def SetInformation(self, vtkInformation):
        """
        V.SetInformation(vtkInformation)
        C++: virtual void SetInformation(vtkInformation *)
        
        Set/Get the information object associated with the light.
        """
        ...
    
    def SetIntensity(self, p_float):
        """
        V.SetIntensity(float)
        C++: virtual void SetIntensity(double _arg)
        
        Set/Get the brightness of the light (from one to zero).
        """
        ...
    
    def SetLightType(self, p_int):
        """
        V.SetLightType(int)
        C++: virtual void SetLightType(int)
        
        Set/Get the type of the light. A SceneLight is a light located in
        the world coordinate space.  A light is initially created as a
        scene light.
        
        * A Headlight is always located at the camera and is pointed at
          the
        * camera's focal point.  The renderer is free to modify the
          position and
        * focal point of the camera at any time.
        
        * A CameraLight is also attached to the camera, but is not
          necessarily
        * located at the camera's position.  CameraLights are defined in
          a
        * coordinate space where the camera is located at (0, 0, 1),
          looking
        * towards (0, 0, 0) at a distance of 1, with up being (0, 1, 0).
        * CameraLight uses the transform matrix to establish this space.
        
        * Note: All SetLightType(), and SetLightTypeTo*() calls clear the
        * light's transform matrix.
        """
        ...
    
    def SetLightTypeToCameraLight(self):
        """
        V.SetLightTypeToCameraLight()
        C++: void SetLightTypeToCameraLight()
        
        Set/Get the type of the light. A SceneLight is a light located in
        the world coordinate space.  A light is initially created as a
        scene light.
        
        * A Headlight is always located at the camera and is pointed at
          the
        * camera's focal point.  The renderer is free to modify the
          position and
        * focal point of the camera at any time.
        
        * A CameraLight is also attached to the camera, but is not
          necessarily
        * located at the camera's position.  CameraLights are defined in
          a
        * coordinate space where the camera is located at (0, 0, 1),
          looking
        * towards (0, 0, 0) at a distance of 1, with up being (0, 1, 0).
        * CameraLight uses the transform matrix to establish this space.
        
        * Note: All SetLightType(), and SetLightTypeTo*() calls clear the
        * light's transform matrix.
        """
        ...
    
    def SetLightTypeToHeadlight(self):
        """
        V.SetLightTypeToHeadlight()
        C++: void SetLightTypeToHeadlight()
        
        Set/Get the type of the light. A SceneLight is a light located in
        the world coordinate space.  A light is initially created as a
        scene light.
        
        * A Headlight is always located at the camera and is pointed at
          the
        * camera's focal point.  The renderer is free to modify the
          position and
        * focal point of the camera at any time.
        
        * A CameraLight is also attached to the camera, but is not
          necessarily
        * located at the camera's position.  CameraLights are defined in
          a
        * coordinate space where the camera is located at (0, 0, 1),
          looking
        * towards (0, 0, 0) at a distance of 1, with up being (0, 1, 0).
        * CameraLight uses the transform matrix to establish this space.
        
        * Note: All SetLightType(), and SetLightTypeTo*() calls clear the
        * light's transform matrix.
        """
        ...
    
    def SetLightTypeToSceneLight(self):
        """
        V.SetLightTypeToSceneLight()
        C++: void SetLightTypeToSceneLight()
        
        Set/Get the type of the light. A SceneLight is a light located in
        the world coordinate space.  A light is initially created as a
        scene light.
        
        * A Headlight is always located at the camera and is pointed at
          the
        * camera's focal point.  The renderer is free to modify the
          position and
        * focal point of the camera at any time.
        
        * A CameraLight is also attached to the camera, but is not
          necessarily
        * located at the camera's position.  CameraLights are defined in
          a
        * coordinate space where the camera is located at (0, 0, 1),
          looking
        * towards (0, 0, 0) at a distance of 1, with up being (0, 1, 0).
        * CameraLight uses the transform matrix to establish this space.
        
        * Note: All SetLightType(), and SetLightTypeTo*() calls clear the
        * light's transform matrix.
        """
        ...
    
    def SetPosition(self, p_float, p_float_1, p_float_2):
        """
        V.SetPosition(float, float, float)
        C++: virtual void SetPosition(double _arg1, double _arg2,
            double _arg3)
        V.SetPosition((float, float, float))
        C++: virtual void SetPosition(const double _arg[3])
        
        Set/Get the position of the light. Note: The position of the
        light is defined in the coordinate space indicated by its
        transformation matrix (if it exists). Thus, to get the light's
        world space position, use vtkGetTransformedPosition() instead of
        vtkGetPosition().
        """
        ...
    
    def SetPositional(self, p_int):
        """
        V.SetPositional(int)
        C++: virtual void SetPositional(vtkTypeBool _arg)
        
        Turn positional lighting on or off.
        """
        ...
    
    def SetShadowAttenuation(self, p_float):
        """
        V.SetShadowAttenuation(float)
        C++: virtual void SetShadowAttenuation(float _arg)
        
        Set/Get the shadow intensity By default a light will be
        completely blocked when in shadow by setting this value to less
        than 1.0 you can control how much light is attenuated when in
        shadow
        """
        ...
    
    def SetSpecularColor(self, p_float, p_float_1, p_float_2):
        """
        V.SetSpecularColor(float, float, float)
        C++: virtual void SetSpecularColor(double _arg1, double _arg2,
            double _arg3)
        V.SetSpecularColor((float, float, float))
        C++: virtual void SetSpecularColor(const double _arg[3])
        
        Set/Get the color of the light. It is possible to set the
        ambient, diffuse and specular colors separately. The SetColor()
        method sets the diffuse and specular colors to the same color
        (this is a feature to preserve backward compatibility.)
        """
        ...
    
    def SetSwitch(self, p_int):
        """
        V.SetSwitch(int)
        C++: virtual void SetSwitch(vtkTypeBool _arg)
        
        Turn the light on or off.
        """
        ...
    
    def SetTransformMatrix(self, vtkMatrix4x4):
        """
        V.SetTransformMatrix(vtkMatrix4x4)
        C++: virtual void SetTransformMatrix(vtkMatrix4x4 *)
        
        Set/Get the light's transformation matrix.  If a matrix is set
        for a light, the light's parameters (position and focal point)
        are transformed by the matrix before being rendered.
        """
        ...
    
    def ShallowClone(self):
        """
        V.ShallowClone() -> vtkLight
        C++: virtual vtkLight *ShallowClone()
        
        Create a new light object with the same light parameters than the
        current object (any ivar from the superclasses (vtkObject and
        vtkObjectBase), like reference counting, timestamp and observers
        are not copied). This is a shallow clone (TransformMatrix is
        referenced)
        """
        ...
    
    def SwitchOff(self):
        """
        V.SwitchOff()
        C++: virtual void SwitchOff()
        
        Turn the light on or off.
        """
        ...
    
    def SwitchOn(self):
        """
        V.SwitchOn()
        C++: virtual void SwitchOn()
        
        Turn the light on or off.
        """
        ...
    
    def TransformPoint(self, p_float=..., p_float=..., p_float=..., *args, **kwargs):
        """
        V.TransformPoint([float, float, float], [float, float, float])
        C++: void TransformPoint(double a[3], double b[3])
        
        Use transform matrix to transform point (if it exists).
        """
        ...
    
    def TransformVector(self, p_float=..., p_float=..., p_float=..., *args, **kwargs):
        """
        V.TransformVector([float, float, float], [float, float, float])
        C++: void TransformVector(double a[3], double b[3])
        
        Use transform matrix to transform vector (if it exists).
        """
        ...
    
    def __delattr__(self, *args, **kwargs):
        """ Implement delattr(self, name). """
        ...
    
    def __getattribute__(self, *args, **kwargs):
        """ Return getattr(self, name). """
        ...
    
    def __init__(self, *args, **kwargs) -> None:
        ...
    
    @staticmethod
    def __new__(*args, **kwargs):
        """ Create and return a new object.  See help(type) for accurate signature. """
        ...
    
    def __repr__(self, *args, **kwargs):
        """ Return repr(self). """
        ...
    
    def __setattr__(self, *args, **kwargs):
        """ Implement setattr(self, name, value). """
        ...
    
    def __str__(self, *args, **kwargs) -> str:
        """ Return str(self). """
        ...
    
    __this__ = ...
    __dict__ = ...
    __vtkname__ = ...


