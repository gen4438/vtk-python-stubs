"""
This type stub file was generated by pyright.
"""

import vtkmodules.vtkCommonCore as __vtkmodules_vtkCommonCore

class vtkVolumeProperty(__vtkmodules_vtkCommonCore.vtkObject):
    """
    vtkVolumeProperty - represents the common properties for rendering a
    volume.
    
    Superclass: vtkObject
    
    vtkVolumeProperty is used to represent common properties associated
    with volume rendering. This includes properties for determining the
    type of interpolation to use when sampling a volume, the color of a
    volume, the scalar opacity of a volume, the gradient opacity of a
    volume, and the shading parameters of a volume.
    
    Color, scalar opacity and gradient magnitude opacity transfer
    functions can be set as either 3 separate 1D functions or as a single
    2D transfer function.
    
    - 1D Transfer functions (vtkVolumeProperty::TF_1D) Color, scalar
      opacity and gradient magnitude opacity are defined by 1
      vtkColorTransferFunction and 2 vtkPiecewiseFunctions respectively.
      When the scalar opacity or the gradient opacity of a volume is not
      set, then the function is defined to be a constant value of 1.0.
      When a scalar and gradient opacity are both set simultaneously,
      then the opacity is defined to be the product of the scalar opacity
    and gradient opacity transfer functions. 1D transfer functions is the
    legacy and default behavior.
    
    - 2D Transfer functions (vtkVolumeProperty::TF_2D) Color and
      scalar/gradient magnitude opacity are defined by a 4-component
      vtkImageData instance mapping scalar value vs. gradient magnitude
      on its x and y axis respectively. This mode is only available if a
      2D TF has been explicitly set (see SetTransferFunction2D).
    
    Most properties can be set per "component" for volume mappers that
    support multiple independent components. If you are using 2 component
    data as LV or 4 component data as RGBV (as specified in the mapper)
    only the first scalar opacity and gradient opacity transfer functions
    will be used (and all color functions will be ignored). Omitting the
    index parameter on the Set/Get methods will access index = 0.
    
    @sa vtkPiecewiseFunction vtkColorTransferFunction
    """
    def DeepCopy(self, vtkVolumeProperty):
        """
        V.DeepCopy(vtkVolumeProperty)
        C++: void DeepCopy(vtkVolumeProperty *p)
        """
        ...
    
    def DisableGradientOpacityOff(self, p_int):
        """
        V.DisableGradientOpacityOff(int)
        C++: virtual void DisableGradientOpacityOff(int index)
        V.DisableGradientOpacityOff()
        C++: virtual void DisableGradientOpacityOff()
        
        Enable/Disable the gradient opacity function for the given
        component. If set to true, any call to GetGradientOpacity() will
        return a default function for this component. Note that the
        gradient opacity function is still stored, it is not set or reset
        and can be retrieved using GetStoredGradientOpacity().
        """
        ...
    
    def DisableGradientOpacityOn(self, p_int):
        """
        V.DisableGradientOpacityOn(int)
        C++: virtual void DisableGradientOpacityOn(int index)
        V.DisableGradientOpacityOn()
        C++: virtual void DisableGradientOpacityOn()
        
        Enable/Disable the gradient opacity function for the given
        component. If set to true, any call to GetGradientOpacity() will
        return a default function for this component. Note that the
        gradient opacity function is still stored, it is not set or reset
        and can be retrieved using GetStoredGradientOpacity().
        """
        ...
    
    def GetAmbient(self, p_int):
        """
        V.GetAmbient(int) -> float
        C++: double GetAmbient(int index)
        V.GetAmbient() -> float
        C++: double GetAmbient()
        
        Set/Get the ambient lighting coefficient.
        """
        ...
    
    def GetClippedVoxelIntensity(self):
        """
        V.GetClippedVoxelIntensity() -> float
        C++: virtual double GetClippedVoxelIntensity()
        
        Set/Get the intensity value for voxels in the clipped space for
        gradient computations (for shading and gradient based opacity
        modulation). By default, this is set to VTK_DOUBLE_MIN.
        
        ote This value is only used when UseClippedVoxelIntensity is
        true.
        
        ote This property is only used by the vtkGPUVolumeRayCastMapper
        for now.
        \sa SetUseClippedVoxelIntensity
        """
        ...
    
    def GetColorChannels(self, p_int):
        """
        V.GetColorChannels(int) -> int
        C++: int GetColorChannels(int index)
        V.GetColorChannels() -> int
        C++: int GetColorChannels()
        
        Get the number of color channels in the transfer function for the
        given component.
        """
        ...
    
    def GetComponentWeight(self, p_int):
        """
        V.GetComponentWeight(int) -> float
        C++: virtual double GetComponentWeight(int index)
        
        Set/Get the scalar component weights. Clamped between the range
        of (0.0, 1.0)
        """
        ...
    
    def GetDiffuse(self, p_int):
        """
        V.GetDiffuse(int) -> float
        C++: double GetDiffuse(int index)
        V.GetDiffuse() -> float
        C++: double GetDiffuse()
        
        Set/Get the diffuse lighting coefficient.
        """
        ...
    
    def GetDisableGradientOpacity(self, p_int):
        """
        V.GetDisableGradientOpacity(int) -> int
        C++: virtual int GetDisableGradientOpacity(int index)
        V.GetDisableGradientOpacity() -> int
        C++: virtual int GetDisableGradientOpacity()
        
        Enable/Disable the gradient opacity function for the given
        component. If set to true, any call to GetGradientOpacity() will
        return a default function for this component. Note that the
        gradient opacity function is still stored, it is not set or reset
        and can be retrieved using GetStoredGradientOpacity().
        """
        ...
    
    def GetGradientOpacity(self, p_int):
        """
        V.GetGradientOpacity(int) -> vtkPiecewiseFunction
        C++: vtkPiecewiseFunction *GetGradientOpacity(int index)
        V.GetGradientOpacity() -> vtkPiecewiseFunction
        C++: vtkPiecewiseFunction *GetGradientOpacity()
        
        Get the gradient magnitude opacity transfer function for the
        given component. If no transfer function has been set for this
        component, a default one is created and returned. This default
        function is always returned if DisableGradientOpacity is On for
        that component.
        """
        ...
    
    def GetGradientOpacityMTime(self, p_int):
        """
        V.GetGradientOpacityMTime(int) -> vtkTimeStamp
        C++: vtkTimeStamp GetGradientOpacityMTime(int index)
        V.GetGradientOpacityMTime() -> vtkTimeStamp
        C++: vtkTimeStamp GetGradientOpacityMTime()
        
        WARNING: INTERNAL METHOD - NOT INTENDED FOR GENERAL USE Get the
        time that the gradient opacity transfer function was set
        """
        ...
    
    def GetGrayTransferFunction(self, p_int):
        """
        V.GetGrayTransferFunction(int) -> vtkPiecewiseFunction
        C++: vtkPiecewiseFunction *GetGrayTransferFunction(int index)
        V.GetGrayTransferFunction() -> vtkPiecewiseFunction
        C++: vtkPiecewiseFunction *GetGrayTransferFunction()
        
        Get the gray transfer function. If no transfer function has been
        set for this component, a default one is created and returned.
        """
        ...
    
    def GetGrayTransferFunctionMTime(self, p_int):
        """
        V.GetGrayTransferFunctionMTime(int) -> vtkTimeStamp
        C++: vtkTimeStamp GetGrayTransferFunctionMTime(int index)
        V.GetGrayTransferFunctionMTime() -> vtkTimeStamp
        C++: vtkTimeStamp GetGrayTransferFunctionMTime()
        
        WARNING: INTERNAL METHOD - NOT INTENDED FOR GENERAL USE Get the
        time that the GrayTransferFunction was set
        """
        ...
    
    def GetIndependentComponents(self):
        """
        V.GetIndependentComponents() -> int
        C++: virtual vtkTypeBool GetIndependentComponents()
        
        Does the data have independent components, or do some define
        color only? If IndependentComponents is On (the default) then
        each component will be independently passed through a lookup
        table to determine RGBA, shaded. Some volume Mappers can handle 1
        to 4 component unsigned char or unsigned short data (see each
        mapper header file to determine functionality). If
        IndependentComponents is Off, then you must have either 2 or 4
        component data. For 2 component data, the first is passed through
        the first color transfer function and the second component is
        passed through the first scalar opacity (and gradient opacity)
        transfer function. Normals will be generated off of the second
        component. When using gradient based opacity modulation, the
        gradients are computed off of the second component. For 4
        component data, the first three will directly represent RGB (no
        lookup table). The fourth component will be passed through the
        first scalar opacity transfer function for opacity and first
        gradient opacity transfer function for gradient based opacity
        modulation. Normals will be generated from the fourth component.
        When using gradient based opacity modulation, the gradients are
        computed off of the fourth component.
        """
        ...
    
    def GetIndependentComponentsMaxValue(self):
        """
        V.GetIndependentComponentsMaxValue() -> int
        C++: virtual vtkTypeBool GetIndependentComponentsMaxValue()
        
        Does the data have independent components, or do some define
        color only? If IndependentComponents is On (the default) then
        each component will be independently passed through a lookup
        table to determine RGBA, shaded. Some volume Mappers can handle 1
        to 4 component unsigned char or unsigned short data (see each
        mapper header file to determine functionality). If
        IndependentComponents is Off, then you must have either 2 or 4
        component data. For 2 component data, the first is passed through
        the first color transfer function and the second component is
        passed through the first scalar opacity (and gradient opacity)
        transfer function. Normals will be generated off of the second
        component. When using gradient based opacity modulation, the
        gradients are computed off of the second component. For 4
        component data, the first three will directly represent RGB (no
        lookup table). The fourth component will be passed through the
        first scalar opacity transfer function for opacity and first
        gradient opacity transfer function for gradient based opacity
        modulation. Normals will be generated from the fourth component.
        When using gradient based opacity modulation, the gradients are
        computed off of the fourth component.
        """
        ...
    
    def GetIndependentComponentsMinValue(self):
        """
        V.GetIndependentComponentsMinValue() -> int
        C++: virtual vtkTypeBool GetIndependentComponentsMinValue()
        
        Does the data have independent components, or do some define
        color only? If IndependentComponents is On (the default) then
        each component will be independently passed through a lookup
        table to determine RGBA, shaded. Some volume Mappers can handle 1
        to 4 component unsigned char or unsigned short data (see each
        mapper header file to determine functionality). If
        IndependentComponents is Off, then you must have either 2 or 4
        component data. For 2 component data, the first is passed through
        the first color transfer function and the second component is
        passed through the first scalar opacity (and gradient opacity)
        transfer function. Normals will be generated off of the second
        component. When using gradient based opacity modulation, the
        gradients are computed off of the second component. For 4
        component data, the first three will directly represent RGB (no
        lookup table). The fourth component will be passed through the
        first scalar opacity transfer function for opacity and first
        gradient opacity transfer function for gradient based opacity
        modulation. Normals will be generated from the fourth component.
        When using gradient based opacity modulation, the gradients are
        computed off of the fourth component.
        """
        ...
    
    def GetInterpolationType(self):
        """
        V.GetInterpolationType() -> int
        C++: virtual int GetInterpolationType()
        
        Set the interpolation type for sampling a volume. Initial value
        is VTK_NEAREST_INTERPOLATION.
        """
        ...
    
    def GetInterpolationTypeAsString(self):
        """
        V.GetInterpolationTypeAsString() -> string
        C++: const char *GetInterpolationTypeAsString(void)
        
        Set the interpolation type for sampling a volume. Initial value
        is VTK_NEAREST_INTERPOLATION.
        """
        ...
    
    def GetInterpolationTypeMaxValue(self):
        """
        V.GetInterpolationTypeMaxValue() -> int
        C++: virtual int GetInterpolationTypeMaxValue()
        
        Set the interpolation type for sampling a volume. Initial value
        is VTK_NEAREST_INTERPOLATION.
        """
        ...
    
    def GetInterpolationTypeMinValue(self):
        """
        V.GetInterpolationTypeMinValue() -> int
        C++: virtual int GetInterpolationTypeMinValue()
        
        Set the interpolation type for sampling a volume. Initial value
        is VTK_NEAREST_INTERPOLATION.
        """
        ...
    
    def GetIsoSurfaceValues(self):
        """
        V.GetIsoSurfaceValues() -> vtkContourValues
        C++: vtkContourValues *GetIsoSurfaceValues()
        
        Get contour values for isosurface blending mode. Do not affect
        other blending modes.
        """
        ...
    
    def GetLabelColor(self, p_int):
        """
        V.GetLabelColor(int) -> vtkColorTransferFunction
        C++: vtkColorTransferFunction *GetLabelColor(int label)
        
        Set/Get the color transfer function for a label in the label map.
        """
        ...
    
    def GetLabelColorMTime(self):
        """
        V.GetLabelColorMTime() -> vtkTimeStamp
        C++: virtual vtkTimeStamp GetLabelColorMTime()
        
        WARNING: INTERNAL METHOD - NOT INTENDED FOR GENERAL USE Get the
        time that label color transfer functions were set
        """
        ...
    
    def GetLabelGradientOpacity(self, p_int):
        """
        V.GetLabelGradientOpacity(int) -> vtkPiecewiseFunction
        C++: vtkPiecewiseFunction *GetLabelGradientOpacity(int label)
        
        Set/Get the gradient opacity function for a label in the label
        map.
        """
        ...
    
    def GetLabelGradientOpacityMTime(self):
        """
        V.GetLabelGradientOpacityMTime() -> vtkTimeStamp
        C++: virtual vtkTimeStamp GetLabelGradientOpacityMTime()
        
        WARNING: INTERNAL METHOD - NOT INTENDED FOR GENERAL USE Get the
        time that label gradient opacity transfer functions were set
        """
        ...
    
    def GetLabelScalarOpacity(self, p_int):
        """
        V.GetLabelScalarOpacity(int) -> vtkPiecewiseFunction
        C++: vtkPiecewiseFunction *GetLabelScalarOpacity(int label)
        
        Set/Get the opacity transfer function for a label in the label
        map.
        """
        ...
    
    def GetLabelScalarOpacityMTime(self):
        """
        V.GetLabelScalarOpacityMTime() -> vtkTimeStamp
        C++: virtual vtkTimeStamp GetLabelScalarOpacityMTime()
        
        WARNING: INTERNAL METHOD - NOT INTENDED FOR GENERAL USE Get the
        time that label scalar opacity transfer functions were set
        """
        ...
    
    def GetMTime(self):
        """
        V.GetMTime() -> int
        C++: vtkMTimeType GetMTime() override;
        
        Get the modified time for this object (or the properties
        registered with this object).
        """
        ...
    
    def GetNumberOfGenerationsFromBase(self, string):
        """
        V.GetNumberOfGenerationsFromBase(string) -> int
        C++: vtkIdType GetNumberOfGenerationsFromBase(const char *type)
            override;
        
        Given a the name of a base class of this class type, return the
        distance of inheritance between this class type and the named
        class (how many generations of inheritance are there between this
        class and the named class). If the named class is not in this
        class's inheritance tree, return a negative value. Valid
        responses will always be nonnegative. This method works in
        combination with vtkTypeMacro found in vtkSetGet.h.
        """
        ...
    
    def GetNumberOfGenerationsFromBaseType(self, string):
        """
        V.GetNumberOfGenerationsFromBaseType(string) -> int
        C++: static vtkIdType GetNumberOfGenerationsFromBaseType(
            const char *type)
        
        Given a the name of a base class of this class type, return the
        distance of inheritance between this class type and the named
        class (how many generations of inheritance are there between this
        class and the named class). If the named class is not in this
        class's inheritance tree, return a negative value. Valid
        responses will always be nonnegative. This method works in
        combination with vtkTypeMacro found in vtkSetGet.h.
        """
        ...
    
    def GetNumberOfLabels(self):
        """
        V.GetNumberOfLabels() -> int
        C++: std::size_t GetNumberOfLabels()
        
        Get the number of labels that are provided with transfer
        functions using either SetLabelColor, SetLabelScalarOpacity or
        SetLabelGradientOpacity.
        """
        ...
    
    def GetRGBTransferFunction(self, p_int):
        """
        V.GetRGBTransferFunction(int) -> vtkColorTransferFunction
        C++: vtkColorTransferFunction *GetRGBTransferFunction(int index)
        V.GetRGBTransferFunction() -> vtkColorTransferFunction
        C++: vtkColorTransferFunction *GetRGBTransferFunction()
        
        Get the RGB transfer function for the given component. If no
        transfer function has been set for this component, a default one
        is created and returned.
        """
        ...
    
    def GetRGBTransferFunctionMTime(self, p_int):
        """
        V.GetRGBTransferFunctionMTime(int) -> vtkTimeStamp
        C++: vtkTimeStamp GetRGBTransferFunctionMTime(int index)
        V.GetRGBTransferFunctionMTime() -> vtkTimeStamp
        C++: vtkTimeStamp GetRGBTransferFunctionMTime()
        
        WARNING: INTERNAL METHOD - NOT INTENDED FOR GENERAL USE Get the
        time that the RGBTransferFunction was set
        """
        ...
    
    def GetScalarOpacity(self, p_int):
        """
        V.GetScalarOpacity(int) -> vtkPiecewiseFunction
        C++: vtkPiecewiseFunction *GetScalarOpacity(int index)
        V.GetScalarOpacity() -> vtkPiecewiseFunction
        C++: vtkPiecewiseFunction *GetScalarOpacity()
        
        Get the scalar opacity transfer function for the given component.
        If no transfer function has been set for this component, a
        default one is created and returned.
        """
        ...
    
    def GetScalarOpacityMTime(self, p_int):
        """
        V.GetScalarOpacityMTime(int) -> vtkTimeStamp
        C++: vtkTimeStamp GetScalarOpacityMTime(int index)
        V.GetScalarOpacityMTime() -> vtkTimeStamp
        C++: vtkTimeStamp GetScalarOpacityMTime()
        
        WARNING: INTERNAL METHOD - NOT INTENDED FOR GENERAL USE Get the
        time that the scalar opacity transfer function was set.
        """
        ...
    
    def GetScalarOpacityUnitDistance(self, p_int):
        """
        V.GetScalarOpacityUnitDistance(int) -> float
        C++: double GetScalarOpacityUnitDistance(int index)
        V.GetScalarOpacityUnitDistance() -> float
        C++: double GetScalarOpacityUnitDistance()
        
        Set/Get the unit distance on which the scalar opacity transfer
        function is defined. By default this is 1.0, meaning that over a
        distance of 1.0 units, a given opacity (from the transfer
        function) is accumulated. This is adjusted for the actual
        sampling distance during rendering.
        """
        ...
    
    def GetShade(self, p_int):
        """
        V.GetShade(int) -> int
        C++: int GetShade(int index)
        V.GetShade() -> int
        C++: int GetShade()
        
        Set/Get the shading of a volume. If shading is turned off, then
        the mapper for the volume will not perform shading calculations.
        If shading is turned on, the mapper may perform shading
        calculations - in some cases shading does not apply (for example,
        in a maximum intensity projection) and therefore shading will not
        be performed even if this flag is on. For a compositing type of
        mapper, turning shading off is generally the same as setting
        ambient=1, diffuse=0, specular=0. Shading can be independently
        turned on/off per component.
        
        ote Shading is only supported for
        vtkVolumeMapper::COMPOSITE_BLEND. For minimum and maximum
        intensity blend modes, there is not necessarily one unique
        location along the ray through the volume where that minimum or
        maximum occurs. For average and additive blend modes, the value
        being visualized does not represent a location in the volume but
        rather a statistical measurement along the ray traversing through
        the volume, and hence shading is not applicable.
        \sa vtkVolumeMapper::BlendModes
        """
        ...
    
    def GetSliceFunction(self):
        """
        V.GetSliceFunction() -> vtkImplicitFunction
        C++: virtual vtkImplicitFunction *GetSliceFunction()
        
        Get/Set the function used for slicing. Currently, only vtkPlane
        is supported.
        """
        ...
    
    def GetSpecular(self, p_int):
        """
        V.GetSpecular(int) -> float
        C++: double GetSpecular(int index)
        V.GetSpecular() -> float
        C++: double GetSpecular()
        
        Set/Get the specular lighting coefficient.
        """
        ...
    
    def GetSpecularPower(self, p_int):
        """
        V.GetSpecularPower(int) -> float
        C++: double GetSpecularPower(int index)
        V.GetSpecularPower() -> float
        C++: double GetSpecularPower()
        
        Set/Get the specular power.
        """
        ...
    
    def GetStoredGradientOpacity(self, p_int):
        """
        V.GetStoredGradientOpacity(int) -> vtkPiecewiseFunction
        C++: vtkPiecewiseFunction *GetStoredGradientOpacity(int index)
        V.GetStoredGradientOpacity() -> vtkPiecewiseFunction
        C++: vtkPiecewiseFunction *GetStoredGradientOpacity()
        
        Enable/Disable the gradient opacity function for the given
        component. If set to true, any call to GetGradientOpacity() will
        return a default function for this component. Note that the
        gradient opacity function is still stored, it is not set or reset
        and can be retrieved using GetStoredGradientOpacity().
        """
        ...
    
    def GetTransferFunction2D(self, p_int):
        """
        V.GetTransferFunction2D(int) -> vtkImageData
        C++: vtkImageData *GetTransferFunction2D(int index)
        V.GetTransferFunction2D() -> vtkImageData
        C++: vtkImageData *GetTransferFunction2D()
        
        Set/Get a 2D transfer function. Volume mappers interpret the
        x-axis of of this transfer function as scalar value and the
        y-axis as gradient magnitude. The value at (X, Y) corresponds to
        the color and opacity for a salar value of X and a gradient
        magnitude of Y.
        """
        ...
    
    def GetTransferFunctionMode(self):
        """
        V.GetTransferFunctionMode() -> int
        C++: virtual int GetTransferFunctionMode()
        
        Color-opacity transfer function mode. TF_1D is its default value.
        - TF_1D Mappers will use 3 separate 1D functions for color,
          scalar opacity and gradient mag. opacity.
        - TF_2D Mappers will use a single 2D function for color and
          scalar/gradient mag. opacity.
        """
        ...
    
    def GetTransferFunctionModeMaxValue(self):
        """
        V.GetTransferFunctionModeMaxValue() -> int
        C++: virtual int GetTransferFunctionModeMaxValue()
        
        Color-opacity transfer function mode. TF_1D is its default value.
        - TF_1D Mappers will use 3 separate 1D functions for color,
          scalar opacity and gradient mag. opacity.
        - TF_2D Mappers will use a single 2D function for color and
          scalar/gradient mag. opacity.
        """
        ...
    
    def GetTransferFunctionModeMinValue(self):
        """
        V.GetTransferFunctionModeMinValue() -> int
        C++: virtual int GetTransferFunctionModeMinValue()
        
        Color-opacity transfer function mode. TF_1D is its default value.
        - TF_1D Mappers will use 3 separate 1D functions for color,
          scalar opacity and gradient mag. opacity.
        - TF_2D Mappers will use a single 2D function for color and
          scalar/gradient mag. opacity.
        """
        ...
    
    def GetUseClippedVoxelIntensity(self):
        """
        V.GetUseClippedVoxelIntensity() -> int
        C++: virtual int GetUseClippedVoxelIntensity()
        
        Set/Get whether to use a fixed intensity value for voxels in the
        clipped space for gradient calculations. When
        UseClippedVoxelIntensity is enabled, the ClippedVoxelIntensity
        value will be used as intensity of clipped voxels. By default,
        this is false.
        
        ote This property is only used by the vtkGPUVolumeRayCastMapper
        for now.
        \sa SetClippedVoxelIntensity
        """
        ...
    
    def HasGradientOpacity(self, p_int):
        """
        V.HasGradientOpacity(int) -> bool
        C++: bool HasGradientOpacity(int index=0)
        
        Check whether or not we have the gradient opacity. Checking
        gradient opacity via GetDisableGradientOpacity or
        GetGradientOpacity will not work as in the former case, 
        GetDisableGradientOpacity returns false by default and in the
        later case, a default gradient opacity will be created.
        """
        ...
    
    def HasLabelGradientOpacity(self):
        """
        V.HasLabelGradientOpacity() -> bool
        C++: bool HasLabelGradientOpacity()
        """
        ...
    
    def IndependentComponentsOff(self):
        """
        V.IndependentComponentsOff()
        C++: virtual void IndependentComponentsOff()
        
        Does the data have independent components, or do some define
        color only? If IndependentComponents is On (the default) then
        each component will be independently passed through a lookup
        table to determine RGBA, shaded. Some volume Mappers can handle 1
        to 4 component unsigned char or unsigned short data (see each
        mapper header file to determine functionality). If
        IndependentComponents is Off, then you must have either 2 or 4
        component data. For 2 component data, the first is passed through
        the first color transfer function and the second component is
        passed through the first scalar opacity (and gradient opacity)
        transfer function. Normals will be generated off of the second
        component. When using gradient based opacity modulation, the
        gradients are computed off of the second component. For 4
        component data, the first three will directly represent RGB (no
        lookup table). The fourth component will be passed through the
        first scalar opacity transfer function for opacity and first
        gradient opacity transfer function for gradient based opacity
        modulation. Normals will be generated from the fourth component.
        When using gradient based opacity modulation, the gradients are
        computed off of the fourth component.
        """
        ...
    
    def IndependentComponentsOn(self):
        """
        V.IndependentComponentsOn()
        C++: virtual void IndependentComponentsOn()
        
        Does the data have independent components, or do some define
        color only? If IndependentComponents is On (the default) then
        each component will be independently passed through a lookup
        table to determine RGBA, shaded. Some volume Mappers can handle 1
        to 4 component unsigned char or unsigned short data (see each
        mapper header file to determine functionality). If
        IndependentComponents is Off, then you must have either 2 or 4
        component data. For 2 component data, the first is passed through
        the first color transfer function and the second component is
        passed through the first scalar opacity (and gradient opacity)
        transfer function. Normals will be generated off of the second
        component. When using gradient based opacity modulation, the
        gradients are computed off of the second component. For 4
        component data, the first three will directly represent RGB (no
        lookup table). The fourth component will be passed through the
        first scalar opacity transfer function for opacity and first
        gradient opacity transfer function for gradient based opacity
        modulation. Normals will be generated from the fourth component.
        When using gradient based opacity modulation, the gradients are
        computed off of the fourth component.
        """
        ...
    
    def IsA(self, string):
        """
        V.IsA(string) -> int
        C++: vtkTypeBool IsA(const char *type) override;
        
        Return 1 if this class is the same type of (or a subclass of) the
        named class. Returns 0 otherwise. This method works in
        combination with vtkTypeMacro found in vtkSetGet.h.
        """
        ...
    
    def IsTypeOf(self, string):
        """
        V.IsTypeOf(string) -> int
        C++: static vtkTypeBool IsTypeOf(const char *type)
        
        Return 1 if this class type is the same type of (or a subclass
        of) the named class. Returns 0 otherwise. This method works in
        combination with vtkTypeMacro found in vtkSetGet.h.
        """
        ...
    
    def NewInstance(self):
        """
        V.NewInstance() -> vtkVolumeProperty
        C++: vtkVolumeProperty *NewInstance()
        """
        ...
    
    def SafeDownCast(self, vtkObjectBase):
        """
        V.SafeDownCast(vtkObjectBase) -> vtkVolumeProperty
        C++: static vtkVolumeProperty *SafeDownCast(vtkObjectBase *o)
        """
        ...
    
    def SetAmbient(self, p_int, p_float):
        """
        V.SetAmbient(int, float)
        C++: void SetAmbient(int index, double value)
        V.SetAmbient(float)
        C++: void SetAmbient(double value)
        
        Set/Get the ambient lighting coefficient.
        """
        ...
    
    def SetClippedVoxelIntensity(self, p_float):
        """
        V.SetClippedVoxelIntensity(float)
        C++: virtual void SetClippedVoxelIntensity(double _arg)
        
        Set/Get the intensity value for voxels in the clipped space for
        gradient computations (for shading and gradient based opacity
        modulation). By default, this is set to VTK_DOUBLE_MIN.
        
        ote This value is only used when UseClippedVoxelIntensity is
        true.
        
        ote This property is only used by the vtkGPUVolumeRayCastMapper
        for now.
        \sa SetUseClippedVoxelIntensity
        """
        ...
    
    def SetColor(self, p_int, vtkPiecewiseFunction):
        """
        V.SetColor(int, vtkPiecewiseFunction)
        C++: void SetColor(int index, vtkPiecewiseFunction *function)
        V.SetColor(vtkPiecewiseFunction)
        C++: void SetColor(vtkPiecewiseFunction *function)
        V.SetColor(int, vtkColorTransferFunction)
        C++: void SetColor(int index, vtkColorTransferFunction *function)
        V.SetColor(vtkColorTransferFunction)
        C++: void SetColor(vtkColorTransferFunction *function)
        
        Set the color of a volume to a gray level transfer function for
        the component indicated by index. This will set the color
        channels for this component to 1.
        """
        ...
    
    def SetComponentWeight(self, p_int, p_float):
        """
        V.SetComponentWeight(int, float)
        C++: virtual void SetComponentWeight(int index, double value)
        
        Set/Get the scalar component weights. Clamped between the range
        of (0.0, 1.0)
        """
        ...
    
    def SetDiffuse(self, p_int, p_float):
        """
        V.SetDiffuse(int, float)
        C++: void SetDiffuse(int index, double value)
        V.SetDiffuse(float)
        C++: void SetDiffuse(double value)
        
        Set/Get the diffuse lighting coefficient.
        """
        ...
    
    def SetDisableGradientOpacity(self, p_int, p_int_1):
        """
        V.SetDisableGradientOpacity(int, int)
        C++: virtual void SetDisableGradientOpacity(int index, int value)
        V.SetDisableGradientOpacity(int)
        C++: virtual void SetDisableGradientOpacity(int value)
        
        Enable/Disable the gradient opacity function for the given
        component. If set to true, any call to GetGradientOpacity() will
        return a default function for this component. Note that the
        gradient opacity function is still stored, it is not set or reset
        and can be retrieved using GetStoredGradientOpacity().
        """
        ...
    
    def SetGradientOpacity(self, p_int, vtkPiecewiseFunction):
        """
        V.SetGradientOpacity(int, vtkPiecewiseFunction)
        C++: void SetGradientOpacity(int index,
            vtkPiecewiseFunction *function)
        V.SetGradientOpacity(vtkPiecewiseFunction)
        C++: void SetGradientOpacity(vtkPiecewiseFunction *function)
        
        Set the opacity of a volume to an opacity transfer function based
        on gradient magnitude for the given component.
        """
        ...
    
    def SetIndependentComponents(self, p_int):
        """
        V.SetIndependentComponents(int)
        C++: virtual void SetIndependentComponents(vtkTypeBool _arg)
        
        Does the data have independent components, or do some define
        color only? If IndependentComponents is On (the default) then
        each component will be independently passed through a lookup
        table to determine RGBA, shaded. Some volume Mappers can handle 1
        to 4 component unsigned char or unsigned short data (see each
        mapper header file to determine functionality). If
        IndependentComponents is Off, then you must have either 2 or 4
        component data. For 2 component data, the first is passed through
        the first color transfer function and the second component is
        passed through the first scalar opacity (and gradient opacity)
        transfer function. Normals will be generated off of the second
        component. When using gradient based opacity modulation, the
        gradients are computed off of the second component. For 4
        component data, the first three will directly represent RGB (no
        lookup table). The fourth component will be passed through the
        first scalar opacity transfer function for opacity and first
        gradient opacity transfer function for gradient based opacity
        modulation. Normals will be generated from the fourth component.
        When using gradient based opacity modulation, the gradients are
        computed off of the fourth component.
        """
        ...
    
    def SetInterpolationType(self, p_int):
        """
        V.SetInterpolationType(int)
        C++: virtual void SetInterpolationType(int _arg)
        
        Set the interpolation type for sampling a volume. Initial value
        is VTK_NEAREST_INTERPOLATION.
        """
        ...
    
    def SetInterpolationTypeToLinear(self):
        """
        V.SetInterpolationTypeToLinear()
        C++: void SetInterpolationTypeToLinear()
        
        Set the interpolation type for sampling a volume. Initial value
        is VTK_NEAREST_INTERPOLATION.
        """
        ...
    
    def SetInterpolationTypeToNearest(self):
        """
        V.SetInterpolationTypeToNearest()
        C++: void SetInterpolationTypeToNearest()
        
        Set the interpolation type for sampling a volume. Initial value
        is VTK_NEAREST_INTERPOLATION.
        """
        ...
    
    def SetLabelColor(self, p_int, vtkColorTransferFunction):
        """
        V.SetLabelColor(int, vtkColorTransferFunction)
        C++: void SetLabelColor(int label,
            vtkColorTransferFunction *function)
        
        Set/Get the color transfer function for a label in the label map.
        """
        ...
    
    def SetLabelGradientOpacity(self, p_int, vtkPiecewiseFunction):
        """
        V.SetLabelGradientOpacity(int, vtkPiecewiseFunction)
        C++: void SetLabelGradientOpacity(int label,
            vtkPiecewiseFunction *function)
        
        Set/Get the gradient opacity function for a label in the label
        map.
        """
        ...
    
    def SetLabelScalarOpacity(self, p_int, vtkPiecewiseFunction):
        """
        V.SetLabelScalarOpacity(int, vtkPiecewiseFunction)
        C++: void SetLabelScalarOpacity(int label,
            vtkPiecewiseFunction *function)
        
        Set/Get the opacity transfer function for a label in the label
        map.
        """
        ...
    
    def SetScalarOpacity(self, p_int, vtkPiecewiseFunction):
        """
        V.SetScalarOpacity(int, vtkPiecewiseFunction)
        C++: void SetScalarOpacity(int index,
            vtkPiecewiseFunction *function)
        V.SetScalarOpacity(vtkPiecewiseFunction)
        C++: void SetScalarOpacity(vtkPiecewiseFunction *function)
        
        Set the opacity of a volume to an opacity transfer function based
        on scalar value for the component indicated by index.
        """
        ...
    
    def SetScalarOpacityUnitDistance(self, p_int, p_float):
        """
        V.SetScalarOpacityUnitDistance(int, float)
        C++: void SetScalarOpacityUnitDistance(int index, double distance)
        V.SetScalarOpacityUnitDistance(float)
        C++: void SetScalarOpacityUnitDistance(double distance)
        
        Set/Get the unit distance on which the scalar opacity transfer
        function is defined. By default this is 1.0, meaning that over a
        distance of 1.0 units, a given opacity (from the transfer
        function) is accumulated. This is adjusted for the actual
        sampling distance during rendering.
        """
        ...
    
    def SetShade(self, p_int, p_int_1):
        """
        V.SetShade(int, int)
        C++: void SetShade(int index, int value)
        V.SetShade(int)
        C++: void SetShade(int value)
        
        Set/Get the shading of a volume. If shading is turned off, then
        the mapper for the volume will not perform shading calculations.
        If shading is turned on, the mapper may perform shading
        calculations - in some cases shading does not apply (for example,
        in a maximum intensity projection) and therefore shading will not
        be performed even if this flag is on. For a compositing type of
        mapper, turning shading off is generally the same as setting
        ambient=1, diffuse=0, specular=0. Shading can be independently
        turned on/off per component.
        
        ote Shading is only supported for
        vtkVolumeMapper::COMPOSITE_BLEND. For minimum and maximum
        intensity blend modes, there is not necessarily one unique
        location along the ray through the volume where that minimum or
        maximum occurs. For average and additive blend modes, the value
        being visualized does not represent a location in the volume but
        rather a statistical measurement along the ray traversing through
        the volume, and hence shading is not applicable.
        \sa vtkVolumeMapper::BlendModes
        """
        ...
    
    def SetSliceFunction(self, vtkImplicitFunction):
        """
        V.SetSliceFunction(vtkImplicitFunction)
        C++: virtual void SetSliceFunction(vtkImplicitFunction *_arg)
        
        Get/Set the function used for slicing. Currently, only vtkPlane
        is supported.
        """
        ...
    
    def SetSpecular(self, p_int, p_float):
        """
        V.SetSpecular(int, float)
        C++: void SetSpecular(int index, double value)
        V.SetSpecular(float)
        C++: void SetSpecular(double value)
        
        Set/Get the specular lighting coefficient.
        """
        ...
    
    def SetSpecularPower(self, p_int, p_float):
        """
        V.SetSpecularPower(int, float)
        C++: void SetSpecularPower(int index, double value)
        V.SetSpecularPower(float)
        C++: void SetSpecularPower(double value)
        
        Set/Get the specular power.
        """
        ...
    
    def SetTransferFunction2D(self, p_int, vtkImageData):
        """
        V.SetTransferFunction2D(int, vtkImageData)
        C++: void SetTransferFunction2D(int index, vtkImageData *function)
        V.SetTransferFunction2D(vtkImageData)
        C++: void SetTransferFunction2D(vtkImageData *function)
        
        Set/Get a 2D transfer function. Volume mappers interpret the
        x-axis of of this transfer function as scalar value and the
        y-axis as gradient magnitude. The value at (X, Y) corresponds to
        the color and opacity for a salar value of X and a gradient
        magnitude of Y.
        """
        ...
    
    def SetTransferFunctionMode(self, p_int):
        """
        V.SetTransferFunctionMode(int)
        C++: virtual void SetTransferFunctionMode(int _arg)
        
        Color-opacity transfer function mode. TF_1D is its default value.
        - TF_1D Mappers will use 3 separate 1D functions for color,
          scalar opacity and gradient mag. opacity.
        - TF_2D Mappers will use a single 2D function for color and
          scalar/gradient mag. opacity.
        """
        ...
    
    def SetUseClippedVoxelIntensity(self, p_int):
        """
        V.SetUseClippedVoxelIntensity(int)
        C++: virtual void SetUseClippedVoxelIntensity(int _arg)
        
        Set/Get whether to use a fixed intensity value for voxels in the
        clipped space for gradient calculations. When
        UseClippedVoxelIntensity is enabled, the ClippedVoxelIntensity
        value will be used as intensity of clipped voxels. By default,
        this is false.
        
        ote This property is only used by the vtkGPUVolumeRayCastMapper
        for now.
        \sa SetClippedVoxelIntensity
        """
        ...
    
    def ShadeOff(self, p_int):
        """
        V.ShadeOff(int)
        C++: void ShadeOff(int index)
        V.ShadeOff()
        C++: void ShadeOff()
        
        Set/Get the shading of a volume. If shading is turned off, then
        the mapper for the volume will not perform shading calculations.
        If shading is turned on, the mapper may perform shading
        calculations - in some cases shading does not apply (for example,
        in a maximum intensity projection) and therefore shading will not
        be performed even if this flag is on. For a compositing type of
        mapper, turning shading off is generally the same as setting
        ambient=1, diffuse=0, specular=0. Shading can be independently
        turned on/off per component.
        
        ote Shading is only supported for
        vtkVolumeMapper::COMPOSITE_BLEND. For minimum and maximum
        intensity blend modes, there is not necessarily one unique
        location along the ray through the volume where that minimum or
        maximum occurs. For average and additive blend modes, the value
        being visualized does not represent a location in the volume but
        rather a statistical measurement along the ray traversing through
        the volume, and hence shading is not applicable.
        \sa vtkVolumeMapper::BlendModes
        """
        ...
    
    def ShadeOn(self, p_int):
        """
        V.ShadeOn(int)
        C++: void ShadeOn(int index)
        V.ShadeOn()
        C++: void ShadeOn()
        
        Set/Get the shading of a volume. If shading is turned off, then
        the mapper for the volume will not perform shading calculations.
        If shading is turned on, the mapper may perform shading
        calculations - in some cases shading does not apply (for example,
        in a maximum intensity projection) and therefore shading will not
        be performed even if this flag is on. For a compositing type of
        mapper, turning shading off is generally the same as setting
        ambient=1, diffuse=0, specular=0. Shading can be independently
        turned on/off per component.
        
        ote Shading is only supported for
        vtkVolumeMapper::COMPOSITE_BLEND. For minimum and maximum
        intensity blend modes, there is not necessarily one unique
        location along the ray through the volume where that minimum or
        maximum occurs. For average and additive blend modes, the value
        being visualized does not represent a location in the volume but
        rather a statistical measurement along the ray traversing through
        the volume, and hence shading is not applicable.
        \sa vtkVolumeMapper::BlendModes
        """
        ...
    
    def UpdateMTimes(self):
        """
        V.UpdateMTimes()
        C++: void UpdateMTimes()
        
        WARNING: INTERNAL METHOD - NOT INTENDED FOR GENERAL USE
        UpdateMTimes performs a Modified() on all TimeStamps. This is
        used by vtkVolume when the property is set, so that any other
        object that might have been caching information for the property
        will rebuild.
        """
        ...
    
    def UseClippedVoxelIntensityOff(self):
        """
        V.UseClippedVoxelIntensityOff()
        C++: virtual void UseClippedVoxelIntensityOff()
        
        Set/Get whether to use a fixed intensity value for voxels in the
        clipped space for gradient calculations. When
        UseClippedVoxelIntensity is enabled, the ClippedVoxelIntensity
        value will be used as intensity of clipped voxels. By default,
        this is false.
        
        ote This property is only used by the vtkGPUVolumeRayCastMapper
        for now.
        \sa SetClippedVoxelIntensity
        """
        ...
    
    def UseClippedVoxelIntensityOn(self):
        """
        V.UseClippedVoxelIntensityOn()
        C++: virtual void UseClippedVoxelIntensityOn()
        
        Set/Get whether to use a fixed intensity value for voxels in the
        clipped space for gradient calculations. When
        UseClippedVoxelIntensity is enabled, the ClippedVoxelIntensity
        value will be used as intensity of clipped voxels. By default,
        this is false.
        
        ote This property is only used by the vtkGPUVolumeRayCastMapper
        for now.
        \sa SetClippedVoxelIntensity
        """
        ...
    
    def __delattr__(self, *args, **kwargs):
        """ Implement delattr(self, name). """
        ...
    
    def __getattribute__(self, *args, **kwargs):
        """ Return getattr(self, name). """
        ...
    
    def __init__(self, *args, **kwargs) -> None:
        ...
    
    @staticmethod
    def __new__(*args, **kwargs):
        """ Create and return a new object.  See help(type) for accurate signature. """
        ...
    
    def __repr__(self, *args, **kwargs):
        """ Return repr(self). """
        ...
    
    def __setattr__(self, *args, **kwargs):
        """ Implement setattr(self, name, value). """
        ...
    
    def __str__(self, *args, **kwargs) -> str:
        """ Return str(self). """
        ...
    
    __this__ = ...
    TF_1D = ...
    TF_2D = ...
    TransferMode = ...
    __dict__ = ...
    __vtkname__ = ...


