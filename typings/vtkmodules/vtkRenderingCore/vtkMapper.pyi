"""
This type stub file was generated by pyright.
"""

from .vtkAbstractMapper3D import vtkAbstractMapper3D

class vtkMapper(vtkAbstractMapper3D):
    """
    vtkMapper - abstract class specifies interface to map data to
    graphics primitives
    
    Superclass: vtkAbstractMapper3D
    
    vtkMapper is an abstract class to specify interface between data and
    graphics primitives. Subclasses of vtkMapper map data through a
    lookuptable and control the creation of rendering primitives that
    interface to the graphics library. The mapping can be controlled by
    supplying a lookup table and specifying a scalar range to map data
    through.
    
    There are several important control mechanisms affecting the behavior
    of this object. The ScalarVisibility flag controls whether scalar
    data (if any) controls the color of the associated actor(s) that
    refer to the mapper. The ScalarMode ivar is used to determine whether
    scalar point data or cell data is used to color the object. By
    default, point data scalars are used unless there are none, in which
    cell scalars are used. Or you can explicitly control whether to use
    point or cell scalar data. Finally, the mapping of scalars through
    the lookup table varies depending on the setting of the ColorMode
    flag. See the documentation for the appropriate methods for an
    explanation.
    
    Another important feature of the mapper is the ability to shift the
    z-buffer to resolve coincident topology. For example, if you'd like
    to draw a mesh with some edges a different color, and the edges lie
    on the mesh, this feature can be useful to get nice looking lines.
    (See the ResolveCoincidentTopology-related methods.)
    
    @sa
    vtkDataSetMapper vtkPolyDataMapper
    """
    def CanUseTextureMapForColoring(self, vtkDataObject):
        """
        V.CanUseTextureMapForColoring(vtkDataObject) -> int
        C++: virtual int CanUseTextureMapForColoring(vtkDataObject *input)
        
        Returns if we can use texture maps for scalar coloring. Note this
        doesn't say we "will" use scalar coloring. It says, if we do use
        scalar coloring, we will use a texture. When rendering multiblock
        datasets, if any 2 blocks provide different lookup tables for the
        scalars, then also we cannot use textures. This case can be
        handled if required.
        """
        ...
    
    def ClearColorArrays(self):
        """
        V.ClearColorArrays()
        C++: void ClearColorArrays()
        
        Call to force a rebuild of color result arrays on next
        MapScalars. Necessary when using arrays in the case of multiblock
        data.
        """
        ...
    
    def ColorByArrayComponent(self, p_int, p_int_1):
        """
        V.ColorByArrayComponent(int, int)
        C++: void ColorByArrayComponent(int arrayNum, int component)
        V.ColorByArrayComponent(string, int)
        C++: void ColorByArrayComponent(const char *arrayName,
            int component)
        
        Legacy: These methods used to be used to specify the array
        component. It is better to do this in the lookup table.
        """
        ...
    
    def CreateDefaultLookupTable(self):
        """
        V.CreateDefaultLookupTable()
        C++: virtual void CreateDefaultLookupTable()
        
        Create default lookup table. Generally used to create one when
        none is available with the scalar data.
        """
        ...
    
    def GetArrayAccessMode(self):
        """
        V.GetArrayAccessMode() -> int
        C++: virtual int GetArrayAccessMode()
        """
        ...
    
    def GetArrayComponent(self):
        """
        V.GetArrayComponent() -> int
        C++: virtual int GetArrayComponent()
        """
        ...
    
    def GetArrayId(self):
        """
        V.GetArrayId() -> int
        C++: virtual int GetArrayId()
        """
        ...
    
    def GetArrayName(self):
        """
        V.GetArrayName() -> string
        C++: virtual char *GetArrayName()
        
        Set/Get the array name or number and component to color by.
        """
        ...
    
    def GetBounds(self):
        """
        V.GetBounds() -> (float, float, float, float, float, float)
        C++: double *GetBounds() override;
        V.GetBounds([float, float, float, float, float, float])
        C++: void GetBounds(double bounds[6]) override;
        
        Return bounding box (array of six doubles) of data expressed as
        (xmin,xmax, ymin,ymax, zmin,zmax).
        """
        ...
    
    def GetCoincidentTopologyLineOffsetParameters(self, p_float, p_float_1):
        """
        V.GetCoincidentTopologyLineOffsetParameters(float, float)
        C++: void GetCoincidentTopologyLineOffsetParameters(
            double &factor, double &units)
        
        Get the net parameters for handling coincident topology obtained
        by summing the global values with the relative values.
        """
        ...
    
    def GetCoincidentTopologyPointOffsetParameter(self, p_float):
        """
        V.GetCoincidentTopologyPointOffsetParameter(float)
        C++: void GetCoincidentTopologyPointOffsetParameter(double &units)
        
        Get the net parameters for handling coincident topology obtained
        by summing the global values with the relative values.
        """
        ...
    
    def GetCoincidentTopologyPolygonOffsetParameters(self, p_float, p_float_1):
        """
        V.GetCoincidentTopologyPolygonOffsetParameters(float, float)
        C++: void GetCoincidentTopologyPolygonOffsetParameters(
            double &factor, double &units)
        
        Get the net parameters for handling coincident topology obtained
        by summing the global values with the relative values.
        """
        ...
    
    def GetColorCoordinates(self):
        """
        V.GetColorCoordinates() -> vtkFloatArray
        C++: vtkFloatArray *GetColorCoordinates()
        
        Provide read access to the color texture coordinate array
        """
        ...
    
    def GetColorMapColors(self):
        """
        V.GetColorMapColors() -> vtkUnsignedCharArray
        C++: vtkUnsignedCharArray *GetColorMapColors()
        
        Provide read access to the color array
        """
        ...
    
    def GetColorMode(self):
        """
        V.GetColorMode() -> int
        C++: virtual int GetColorMode()
        
        default (ColorModeToDefault), unsigned char scalars are treated
        as colors, and NOT mapped through the lookup table, while
        everything else is.  ColorModeToDirectScalar extends
        ColorModeToDefault such that all integer types are treated as
        colors with values in the range 0-255 and floating types are
        treated as colors with values in the range 0.0-1.0.  Setting
        ColorModeToMapScalars means that all scalar data will be mapped
        through the lookup table.  (Note that for multi-component
        scalars, the particular component to use for mapping can be
        specified using the SelectColorArray() method.)
        """
        ...
    
    def GetColorModeAsString(self):
        """
        V.GetColorModeAsString() -> string
        C++: const char *GetColorModeAsString()
        
        Return the method of coloring scalar data.
        """
        ...
    
    def GetColorTextureMap(self):
        """
        V.GetColorTextureMap() -> vtkImageData
        C++: vtkImageData *GetColorTextureMap()
        
        Provide read access to the color texture array
        """
        ...
    
    def GetFieldDataTupleId(self):
        """
        V.GetFieldDataTupleId() -> int
        C++: virtual vtkIdType GetFieldDataTupleId()
        """
        ...
    
    def GetInput(self):
        """
        V.GetInput() -> vtkDataSet
        C++: vtkDataSet *GetInput()
        
        Get the input as a vtkDataSet.  This method is overridden in the
        specialized mapper classes to return more specific data types.
        """
        ...
    
    def GetInputAsDataSet(self):
        """
        V.GetInputAsDataSet() -> vtkDataSet
        C++: vtkDataSet *GetInputAsDataSet()
        
        Get the input to this mapper as a vtkDataSet, instead of as a
        more specialized data type that the subclass may return from
        GetInput().  This method is provided for use in the wrapper
        languages, C++ programmers should use GetInput() instead.
        """
        ...
    
    def GetInterpolateScalarsBeforeMapping(self):
        """
        V.GetInterpolateScalarsBeforeMapping() -> int
        C++: virtual vtkTypeBool GetInterpolateScalarsBeforeMapping()
        
        By default, vertex color is used to map colors to a surface.
        Colors are interpolated after being mapped. This option avoids
        color interpolation by using a one dimensional texture map for
        the colors.
        """
        ...
    
    def GetLookupTable(self):
        """
        V.GetLookupTable() -> vtkScalarsToColors
        C++: vtkScalarsToColors *GetLookupTable()
        
        Specify a lookup table for the mapper to use.
        """
        ...
    
    def GetMTime(self):
        """
        V.GetMTime() -> int
        C++: vtkMTimeType GetMTime() override;
        
        Overload standard modified time function. If lookup table is
        modified, then this object is modified as well.
        """
        ...
    
    def GetNumberOfGenerationsFromBase(self, string):
        """
        V.GetNumberOfGenerationsFromBase(string) -> int
        C++: vtkIdType GetNumberOfGenerationsFromBase(const char *type)
            override;
        
        Given a the name of a base class of this class type, return the
        distance of inheritance between this class type and the named
        class (how many generations of inheritance are there between this
        class and the named class). If the named class is not in this
        class's inheritance tree, return a negative value. Valid
        responses will always be nonnegative. This method works in
        combination with vtkTypeMacro found in vtkSetGet.h.
        """
        ...
    
    def GetNumberOfGenerationsFromBaseType(self, string):
        """
        V.GetNumberOfGenerationsFromBaseType(string) -> int
        C++: static vtkIdType GetNumberOfGenerationsFromBaseType(
            const char *type)
        
        Given a the name of a base class of this class type, return the
        distance of inheritance between this class type and the named
        class (how many generations of inheritance are there between this
        class and the named class). If the named class is not in this
        class's inheritance tree, return a negative value. Valid
        responses will always be nonnegative. This method works in
        combination with vtkTypeMacro found in vtkSetGet.h.
        """
        ...
    
    def GetRelativeCoincidentTopologyLineOffsetParameters(self, p_float, p_float_1):
        """
        V.GetRelativeCoincidentTopologyLineOffsetParameters(float, float)
        C++: void GetRelativeCoincidentTopologyLineOffsetParameters(
            double &factor, double &units)
        
        Used to set the line offset values relative to the global Used
        when ResolveCoincidentTopology is set to PolygonOffset.
        """
        ...
    
    def GetRelativeCoincidentTopologyPointOffsetParameter(self, p_float):
        """
        V.GetRelativeCoincidentTopologyPointOffsetParameter(float)
        C++: void GetRelativeCoincidentTopologyPointOffsetParameter(
            double &units)
        
        Used to set the point offset value relative to the global Used
        when ResolveCoincidentTopology is set to PolygonOffset.
        """
        ...
    
    def GetRelativeCoincidentTopologyPolygonOffsetParameters(self, p_float, p_float_1):
        """
        V.GetRelativeCoincidentTopologyPolygonOffsetParameters(float,
            float)
        C++: void GetRelativeCoincidentTopologyPolygonOffsetParameters(
            double &factor, double &units)
        
        Used to set the polygon offset values relative to the global Used
        when ResolveCoincidentTopology is set to PolygonOffset.
        """
        ...
    
    def GetRenderTime(self):
        """
        V.GetRenderTime() -> float
        C++: virtual double GetRenderTime()
        """
        ...
    
    def GetResolveCoincidentTopology(self):
        """
        V.GetResolveCoincidentTopology() -> int
        C++: static int GetResolveCoincidentTopology()
        
        Set/Get a global flag that controls whether coincident topology
        (e.g., a line on top of a polygon) is shifted to avoid z-buffer
        resolution (and hence rendering problems). If not off, there are
        two methods to choose from. PolygonOffset uses graphics systems
        calls to shift polygons, lines and points from each other.
        ShiftZBuffer is a legacy method that used to remap the z-buffer
        to distinguish vertices, lines, and polygons, but does not always
        produce acceptable results. You should only use the PolygonOffset
        method (or none) at this point.
        """
        ...
    
    def GetResolveCoincidentTopologyLineOffsetParameters(self, p_float, p_float_1):
        """
        V.GetResolveCoincidentTopologyLineOffsetParameters(float, float)
        C++: static void GetResolveCoincidentTopologyLineOffsetParameters(
            double &factor, double &units)
        
        Used to set the line offset scale factor and units. Used when
        ResolveCoincidentTopology is set to PolygonOffset. These are
        global variables.
        """
        ...
    
    def GetResolveCoincidentTopologyPointOffsetParameter(self, p_float):
        """
        V.GetResolveCoincidentTopologyPointOffsetParameter(float)
        C++: static void GetResolveCoincidentTopologyPointOffsetParameter(
            double &units)
        
        Used to set the point offset value Used when
        ResolveCoincidentTopology is set to PolygonOffset. These are
        global variables.
        """
        ...
    
    def GetResolveCoincidentTopologyPolygonOffsetFaces(self):
        """
        V.GetResolveCoincidentTopologyPolygonOffsetFaces() -> int
        C++: static int GetResolveCoincidentTopologyPolygonOffsetFaces()
        
        Used when ResolveCoincidentTopology is set to PolygonOffset. The
        polygon offset can be applied either to the solid polygonal faces
        or the lines/vertices. When set (default), the offset is applied
        to the faces otherwise it is applied to lines and vertices. This
        is a global variable.
        """
        ...
    
    def GetResolveCoincidentTopologyPolygonOffsetParameters(self, p_float, p_float_1):
        """
        V.GetResolveCoincidentTopologyPolygonOffsetParameters(float,
            float)
        C++: static void GetResolveCoincidentTopologyPolygonOffsetParameters(
            double &factor, double &units)
        
        Used to set the polygon offset scale factor and units. Used when
        ResolveCoincidentTopology is set to PolygonOffset. These are
        global variables.
        """
        ...
    
    def GetResolveCoincidentTopologyZShift(self):
        """
        V.GetResolveCoincidentTopologyZShift() -> float
        C++: static double GetResolveCoincidentTopologyZShift()
        
        Used to set the z-shift if ResolveCoincidentTopology is set to
        ShiftZBuffer. This is a global variable.
        """
        ...
    
    def GetScalarMode(self):
        """
        V.GetScalarMode() -> int
        C++: virtual int GetScalarMode()
        """
        ...
    
    def GetScalarModeAsString(self):
        """
        V.GetScalarModeAsString() -> string
        C++: const char *GetScalarModeAsString()
        
        Return the method for obtaining scalar data.
        """
        ...
    
    def GetScalarRange(self):
        """
        V.GetScalarRange() -> (float, float)
        C++: virtual double *GetScalarRange()
        
        Specify range in terms of scalar minimum and maximum (smin,smax).
        These values are used to map scalars into lookup table. Has no
        effect when UseLookupTableScalarRange is true.
        """
        ...
    
    def GetScalarVisibility(self):
        """
        V.GetScalarVisibility() -> int
        C++: virtual vtkTypeBool GetScalarVisibility()
        
        Turn on/off flag to control whether scalar data is used to color
        objects.
        """
        ...
    
    def GetStatic(self):
        """
        V.GetStatic() -> int
        C++: virtual vtkTypeBool GetStatic()
        
        Turn on/off flag to control whether the mapper's data is static.
        Static data means that the mapper does not propagate updates down
        the pipeline, greatly decreasing the time it takes to update many
        mappers. This should only be used if the data never changes.
        """
        ...
    
    def GetSupportsSelection(self):
        """
        V.GetSupportsSelection() -> bool
        C++: virtual bool GetSupportsSelection()
        
        WARNING: INTERNAL METHOD - NOT INTENDED FOR GENERAL USE DO NOT
        USE THIS METHOD OUTSIDE OF THE RENDERING PROCESS Used by
        vtkHardwareSelector to determine if the prop supports hardware
        selection.
        """
        ...
    
    def GetUseLookupTableScalarRange(self):
        """
        V.GetUseLookupTableScalarRange() -> int
        C++: virtual vtkTypeBool GetUseLookupTableScalarRange()
        
        Control whether the mapper sets the lookuptable range based on
        its own ScalarRange, or whether it will use the LookupTable
        ScalarRange regardless of it's own setting. By default the Mapper
        is allowed to set the LookupTable range, but users who are
        sharing LookupTables between mappers/actors will probably wish to
        force the mapper to use the LookupTable unchanged.
        """
        ...
    
    def HasOpaqueGeometry(self):
        """
        V.HasOpaqueGeometry() -> bool
        C++: virtual bool HasOpaqueGeometry()
        
        Some introspection on the type of data the mapper will render
        used by props to determine if they should invoke the mapper on a
        specific rendering pass.
        """
        ...
    
    def HasTranslucentPolygonalGeometry(self):
        """
        V.HasTranslucentPolygonalGeometry() -> bool
        C++: virtual bool HasTranslucentPolygonalGeometry()
        
        Some introspection on the type of data the mapper will render
        used by props to determine if they should invoke the mapper on a
        specific rendering pass.
        """
        ...
    
    def InterpolateScalarsBeforeMappingOff(self):
        """
        V.InterpolateScalarsBeforeMappingOff()
        C++: virtual void InterpolateScalarsBeforeMappingOff()
        
        By default, vertex color is used to map colors to a surface.
        Colors are interpolated after being mapped. This option avoids
        color interpolation by using a one dimensional texture map for
        the colors.
        """
        ...
    
    def InterpolateScalarsBeforeMappingOn(self):
        """
        V.InterpolateScalarsBeforeMappingOn()
        C++: virtual void InterpolateScalarsBeforeMappingOn()
        
        By default, vertex color is used to map colors to a surface.
        Colors are interpolated after being mapped. This option avoids
        color interpolation by using a one dimensional texture map for
        the colors.
        """
        ...
    
    def IsA(self, string):
        """
        V.IsA(string) -> int
        C++: vtkTypeBool IsA(const char *type) override;
        
        Return 1 if this class is the same type of (or a subclass of) the
        named class. Returns 0 otherwise. This method works in
        combination with vtkTypeMacro found in vtkSetGet.h.
        """
        ...
    
    def IsTypeOf(self, string):
        """
        V.IsTypeOf(string) -> int
        C++: static vtkTypeBool IsTypeOf(const char *type)
        
        Return 1 if this class type is the same type of (or a subclass
        of) the named class. Returns 0 otherwise. This method works in
        combination with vtkTypeMacro found in vtkSetGet.h.
        """
        ...
    
    def MapScalars(self, p_float):
        """
        V.MapScalars(float) -> vtkUnsignedCharArray
        C++: virtual vtkUnsignedCharArray *MapScalars(double alpha)
        V.MapScalars(float, int) -> vtkUnsignedCharArray
        C++: virtual vtkUnsignedCharArray *MapScalars(double alpha,
            int &cellFlag)
        V.MapScalars(vtkDataSet, float) -> vtkUnsignedCharArray
        C++: virtual vtkUnsignedCharArray *MapScalars(vtkDataSet *input,
            double alpha)
        V.MapScalars(vtkDataSet, float, int) -> vtkUnsignedCharArray
        C++: virtual vtkUnsignedCharArray *MapScalars(vtkDataSet *input,
            double alpha, int &cellFlag)
        
        Map the scalars (if there are any scalars and ScalarVisibility is
        on) through the lookup table, returning an unsigned char RGBA
        array. This is typically done as part of the rendering process.
        The alpha parameter allows the blending of the scalars with an
        additional alpha (typically which comes from a vtkActor, etc.)
        """
        ...
    
    def NewInstance(self):
        """
        V.NewInstance() -> vtkMapper
        C++: vtkMapper *NewInstance()
        """
        ...
    
    def ProcessSelectorPixelBuffers(self, vtkHardwareSelector, Stvector_IjE, vtkProp):
        """
        V.ProcessSelectorPixelBuffers(vtkHardwareSelector, Stvector_IjE,
            vtkProp)
        C++: virtual void ProcessSelectorPixelBuffers(
            vtkHardwareSelector *, std::vector<unsigned int> &, vtkProp *)
        
        allows a mapper to update a selections color buffers Called from
        a prop which in turn is called from the selector
        """
        ...
    
    def ReleaseGraphicsResources(self, vtkWindow):
        """
        V.ReleaseGraphicsResources(vtkWindow)
        C++: void ReleaseGraphicsResources(vtkWindow *) override;
        
        Release any graphics resources that are being consumed by this
        mapper. The parameter window could be used to determine which
        graphic resources to release.
        """
        ...
    
    def Render(self, vtkRenderer, vtkActor):
        """
        V.Render(vtkRenderer, vtkActor)
        C++: virtual void Render(vtkRenderer *ren, vtkActor *a)
        
        Method initiates the mapping process. Generally sent by the actor
        as each frame is rendered.
        """
        ...
    
    def SafeDownCast(self, vtkObjectBase):
        """
        V.SafeDownCast(vtkObjectBase) -> vtkMapper
        C++: static vtkMapper *SafeDownCast(vtkObjectBase *o)
        """
        ...
    
    def ScalarVisibilityOff(self):
        """
        V.ScalarVisibilityOff()
        C++: virtual void ScalarVisibilityOff()
        
        Turn on/off flag to control whether scalar data is used to color
        objects.
        """
        ...
    
    def ScalarVisibilityOn(self):
        """
        V.ScalarVisibilityOn()
        C++: virtual void ScalarVisibilityOn()
        
        Turn on/off flag to control whether scalar data is used to color
        objects.
        """
        ...
    
    def SelectColorArray(self, p_int):
        """
        V.SelectColorArray(int)
        C++: void SelectColorArray(int arrayNum)
        V.SelectColorArray(string)
        C++: void SelectColorArray(const char *arrayName)
        
        When ScalarMode is set to UsePointFieldData or UseCellFieldData,
        you can specify which array to use for coloring using these
        methods. The lookup table will decide how to convert vectors to
        colors.
        """
        ...
    
    def SetArrayAccessMode(self, p_int):
        """
        V.SetArrayAccessMode(int)
        C++: virtual void SetArrayAccessMode(int _arg)
        """
        ...
    
    def SetArrayComponent(self, p_int):
        """
        V.SetArrayComponent(int)
        C++: virtual void SetArrayComponent(int _arg)
        """
        ...
    
    def SetArrayId(self, p_int):
        """
        V.SetArrayId(int)
        C++: virtual void SetArrayId(int _arg)
        """
        ...
    
    def SetArrayName(self, string):
        """
        V.SetArrayName(string)
        C++: virtual void SetArrayName(const char *_arg)
        """
        ...
    
    def SetColorMode(self, p_int):
        """
        V.SetColorMode(int)
        C++: virtual void SetColorMode(int _arg)
        
        default (ColorModeToDefault), unsigned char scalars are treated
        as colors, and NOT mapped through the lookup table, while
        everything else is.  ColorModeToDirectScalar extends
        ColorModeToDefault such that all integer types are treated as
        colors with values in the range 0-255 and floating types are
        treated as colors with values in the range 0.0-1.0.  Setting
        ColorModeToMapScalars means that all scalar data will be mapped
        through the lookup table.  (Note that for multi-component
        scalars, the particular component to use for mapping can be
        specified using the SelectColorArray() method.)
        """
        ...
    
    def SetColorModeToDefault(self):
        """
        V.SetColorModeToDefault()
        C++: void SetColorModeToDefault()
        
        default (ColorModeToDefault), unsigned char scalars are treated
        as colors, and NOT mapped through the lookup table, while
        everything else is.  ColorModeToDirectScalar extends
        ColorModeToDefault such that all integer types are treated as
        colors with values in the range 0-255 and floating types are
        treated as colors with values in the range 0.0-1.0.  Setting
        ColorModeToMapScalars means that all scalar data will be mapped
        through the lookup table.  (Note that for multi-component
        scalars, the particular component to use for mapping can be
        specified using the SelectColorArray() method.)
        """
        ...
    
    def SetColorModeToDirectScalars(self):
        """
        V.SetColorModeToDirectScalars()
        C++: void SetColorModeToDirectScalars()
        
        default (ColorModeToDefault), unsigned char scalars are treated
        as colors, and NOT mapped through the lookup table, while
        everything else is.  ColorModeToDirectScalar extends
        ColorModeToDefault such that all integer types are treated as
        colors with values in the range 0-255 and floating types are
        treated as colors with values in the range 0.0-1.0.  Setting
        ColorModeToMapScalars means that all scalar data will be mapped
        through the lookup table.  (Note that for multi-component
        scalars, the particular component to use for mapping can be
        specified using the SelectColorArray() method.)
        """
        ...
    
    def SetColorModeToMapScalars(self):
        """
        V.SetColorModeToMapScalars()
        C++: void SetColorModeToMapScalars()
        
        default (ColorModeToDefault), unsigned char scalars are treated
        as colors, and NOT mapped through the lookup table, while
        everything else is.  ColorModeToDirectScalar extends
        ColorModeToDefault such that all integer types are treated as
        colors with values in the range 0-255 and floating types are
        treated as colors with values in the range 0.0-1.0.  Setting
        ColorModeToMapScalars means that all scalar data will be mapped
        through the lookup table.  (Note that for multi-component
        scalars, the particular component to use for mapping can be
        specified using the SelectColorArray() method.)
        """
        ...
    
    def SetFieldDataTupleId(self, p_int):
        """
        V.SetFieldDataTupleId(int)
        C++: virtual void SetFieldDataTupleId(vtkIdType _arg)
        """
        ...
    
    def SetInterpolateScalarsBeforeMapping(self, p_int):
        """
        V.SetInterpolateScalarsBeforeMapping(int)
        C++: virtual void SetInterpolateScalarsBeforeMapping(
            vtkTypeBool _arg)
        
        By default, vertex color is used to map colors to a surface.
        Colors are interpolated after being mapped. This option avoids
        color interpolation by using a one dimensional texture map for
        the colors.
        """
        ...
    
    def SetLookupTable(self, vtkScalarsToColors):
        """
        V.SetLookupTable(vtkScalarsToColors)
        C++: void SetLookupTable(vtkScalarsToColors *lut)
        
        Specify a lookup table for the mapper to use.
        """
        ...
    
    def SetRelativeCoincidentTopologyLineOffsetParameters(self, p_float, p_float_1):
        """
        V.SetRelativeCoincidentTopologyLineOffsetParameters(float, float)
        C++: void SetRelativeCoincidentTopologyLineOffsetParameters(
            double factor, double units)
        
        Used to set the line offset values relative to the global Used
        when ResolveCoincidentTopology is set to PolygonOffset.
        """
        ...
    
    def SetRelativeCoincidentTopologyPointOffsetParameter(self, p_float):
        """
        V.SetRelativeCoincidentTopologyPointOffsetParameter(float)
        C++: void SetRelativeCoincidentTopologyPointOffsetParameter(
            double units)
        
        Used to set the point offset value relative to the global Used
        when ResolveCoincidentTopology is set to PolygonOffset.
        """
        ...
    
    def SetRelativeCoincidentTopologyPolygonOffsetParameters(self, p_float, p_float_1):
        """
        V.SetRelativeCoincidentTopologyPolygonOffsetParameters(float,
            float)
        C++: void SetRelativeCoincidentTopologyPolygonOffsetParameters(
            double factor, double units)
        
        Used to set the polygon offset values relative to the global Used
        when ResolveCoincidentTopology is set to PolygonOffset.
        """
        ...
    
    def SetRenderTime(self, p_float):
        """
        V.SetRenderTime(float)
        C++: void SetRenderTime(double time)
        
        This instance variable is used by vtkLODActor to determine which
        mapper to use.  It is an estimate of the time necessary to
        render. Setting the render time does not modify the mapper.
        """
        ...
    
    def SetResolveCoincidentTopology(self, p_int):
        """
        V.SetResolveCoincidentTopology(int)
        C++: static void SetResolveCoincidentTopology(int val)
        
        Set/Get a global flag that controls whether coincident topology
        (e.g., a line on top of a polygon) is shifted to avoid z-buffer
        resolution (and hence rendering problems). If not off, there are
        two methods to choose from. PolygonOffset uses graphics systems
        calls to shift polygons, lines and points from each other.
        ShiftZBuffer is a legacy method that used to remap the z-buffer
        to distinguish vertices, lines, and polygons, but does not always
        produce acceptable results. You should only use the PolygonOffset
        method (or none) at this point.
        """
        ...
    
    def SetResolveCoincidentTopologyLineOffsetParameters(self, p_float, p_float_1):
        """
        V.SetResolveCoincidentTopologyLineOffsetParameters(float, float)
        C++: static void SetResolveCoincidentTopologyLineOffsetParameters(
            double factor, double units)
        
        Used to set the line offset scale factor and units. Used when
        ResolveCoincidentTopology is set to PolygonOffset. These are
        global variables.
        """
        ...
    
    def SetResolveCoincidentTopologyPointOffsetParameter(self, p_float):
        """
        V.SetResolveCoincidentTopologyPointOffsetParameter(float)
        C++: static void SetResolveCoincidentTopologyPointOffsetParameter(
            double units)
        
        Used to set the point offset value Used when
        ResolveCoincidentTopology is set to PolygonOffset. These are
        global variables.
        """
        ...
    
    def SetResolveCoincidentTopologyPolygonOffsetFaces(self, p_int):
        """
        V.SetResolveCoincidentTopologyPolygonOffsetFaces(int)
        C++: static void SetResolveCoincidentTopologyPolygonOffsetFaces(
            int faces)
        
        Used when ResolveCoincidentTopology is set to PolygonOffset. The
        polygon offset can be applied either to the solid polygonal faces
        or the lines/vertices. When set (default), the offset is applied
        to the faces otherwise it is applied to lines and vertices. This
        is a global variable.
        """
        ...
    
    def SetResolveCoincidentTopologyPolygonOffsetParameters(self, p_float, p_float_1):
        """
        V.SetResolveCoincidentTopologyPolygonOffsetParameters(float,
            float)
        C++: static void SetResolveCoincidentTopologyPolygonOffsetParameters(
            double factor, double units)
        
        Used to set the polygon offset scale factor and units. Used when
        ResolveCoincidentTopology is set to PolygonOffset. These are
        global variables.
        """
        ...
    
    def SetResolveCoincidentTopologyToDefault(self):
        """
        V.SetResolveCoincidentTopologyToDefault()
        C++: static void SetResolveCoincidentTopologyToDefault()
        
        Set/Get a global flag that controls whether coincident topology
        (e.g., a line on top of a polygon) is shifted to avoid z-buffer
        resolution (and hence rendering problems). If not off, there are
        two methods to choose from. PolygonOffset uses graphics systems
        calls to shift polygons, lines and points from each other.
        ShiftZBuffer is a legacy method that used to remap the z-buffer
        to distinguish vertices, lines, and polygons, but does not always
        produce acceptable results. You should only use the PolygonOffset
        method (or none) at this point.
        """
        ...
    
    def SetResolveCoincidentTopologyToOff(self):
        """
        V.SetResolveCoincidentTopologyToOff()
        C++: static void SetResolveCoincidentTopologyToOff()
        
        Set/Get a global flag that controls whether coincident topology
        (e.g., a line on top of a polygon) is shifted to avoid z-buffer
        resolution (and hence rendering problems). If not off, there are
        two methods to choose from. PolygonOffset uses graphics systems
        calls to shift polygons, lines and points from each other.
        ShiftZBuffer is a legacy method that used to remap the z-buffer
        to distinguish vertices, lines, and polygons, but does not always
        produce acceptable results. You should only use the PolygonOffset
        method (or none) at this point.
        """
        ...
    
    def SetResolveCoincidentTopologyToPolygonOffset(self):
        """
        V.SetResolveCoincidentTopologyToPolygonOffset()
        C++: static void SetResolveCoincidentTopologyToPolygonOffset()
        
        Set/Get a global flag that controls whether coincident topology
        (e.g., a line on top of a polygon) is shifted to avoid z-buffer
        resolution (and hence rendering problems). If not off, there are
        two methods to choose from. PolygonOffset uses graphics systems
        calls to shift polygons, lines and points from each other.
        ShiftZBuffer is a legacy method that used to remap the z-buffer
        to distinguish vertices, lines, and polygons, but does not always
        produce acceptable results. You should only use the PolygonOffset
        method (or none) at this point.
        """
        ...
    
    def SetResolveCoincidentTopologyToShiftZBuffer(self):
        """
        V.SetResolveCoincidentTopologyToShiftZBuffer()
        C++: static void SetResolveCoincidentTopologyToShiftZBuffer()
        
        Set/Get a global flag that controls whether coincident topology
        (e.g., a line on top of a polygon) is shifted to avoid z-buffer
        resolution (and hence rendering problems). If not off, there are
        two methods to choose from. PolygonOffset uses graphics systems
        calls to shift polygons, lines and points from each other.
        ShiftZBuffer is a legacy method that used to remap the z-buffer
        to distinguish vertices, lines, and polygons, but does not always
        produce acceptable results. You should only use the PolygonOffset
        method (or none) at this point.
        """
        ...
    
    def SetResolveCoincidentTopologyZShift(self, p_float):
        """
        V.SetResolveCoincidentTopologyZShift(float)
        C++: static void SetResolveCoincidentTopologyZShift(double val)
        
        Used to set the z-shift if ResolveCoincidentTopology is set to
        ShiftZBuffer. This is a global variable.
        """
        ...
    
    def SetScalarMode(self, p_int):
        """
        V.SetScalarMode(int)
        C++: virtual void SetScalarMode(int _arg)
        
        Control how the filter works with scalar point data and cell
        attribute data.  By default (ScalarModeToDefault), the filter
        will use point data, and if no point data is available, then cell
        data is used. Alternatively you can explicitly set the filter to
        use point data (ScalarModeToUsePointData) or cell data
        (ScalarModeToUseCellData). You can also choose to get the scalars
        from an array in point field data (ScalarModeToUsePointFieldData)
        or cell field data (ScalarModeToUseCellFieldData).  If scalars
        are coming from a field data array, you must call
        SelectColorArray before you call GetColors.
        """
        ...
    
    def SetScalarModeToDefault(self):
        """
        V.SetScalarModeToDefault()
        C++: void SetScalarModeToDefault()
        """
        ...
    
    def SetScalarModeToUseCellData(self):
        """
        V.SetScalarModeToUseCellData()
        C++: void SetScalarModeToUseCellData()
        """
        ...
    
    def SetScalarModeToUseCellFieldData(self):
        """
        V.SetScalarModeToUseCellFieldData()
        C++: void SetScalarModeToUseCellFieldData()
        """
        ...
    
    def SetScalarModeToUseFieldData(self):
        """
        V.SetScalarModeToUseFieldData()
        C++: void SetScalarModeToUseFieldData()
        """
        ...
    
    def SetScalarModeToUsePointData(self):
        """
        V.SetScalarModeToUsePointData()
        C++: void SetScalarModeToUsePointData()
        """
        ...
    
    def SetScalarModeToUsePointFieldData(self):
        """
        V.SetScalarModeToUsePointFieldData()
        C++: void SetScalarModeToUsePointFieldData()
        """
        ...
    
    def SetScalarRange(self, p_float, p_float_1):
        """
        V.SetScalarRange(float, float)
        C++: virtual void SetScalarRange(double _arg1, double _arg2)
        V.SetScalarRange((float, float))
        C++: void SetScalarRange(const double _arg[2])
        
        Specify range in terms of scalar minimum and maximum (smin,smax).
        These values are used to map scalars into lookup table. Has no
        effect when UseLookupTableScalarRange is true.
        """
        ...
    
    def SetScalarVisibility(self, p_int):
        """
        V.SetScalarVisibility(int)
        C++: virtual void SetScalarVisibility(vtkTypeBool _arg)
        
        Turn on/off flag to control whether scalar data is used to color
        objects.
        """
        ...
    
    def SetStatic(self, p_int):
        """
        V.SetStatic(int)
        C++: virtual void SetStatic(vtkTypeBool _arg)
        
        Turn on/off flag to control whether the mapper's data is static.
        Static data means that the mapper does not propagate updates down
        the pipeline, greatly decreasing the time it takes to update many
        mappers. This should only be used if the data never changes.
        """
        ...
    
    def SetUseLookupTableScalarRange(self, p_int):
        """
        V.SetUseLookupTableScalarRange(int)
        C++: virtual void SetUseLookupTableScalarRange(vtkTypeBool _arg)
        
        Control whether the mapper sets the lookuptable range based on
        its own ScalarRange, or whether it will use the LookupTable
        ScalarRange regardless of it's own setting. By default the Mapper
        is allowed to set the LookupTable range, but users who are
        sharing LookupTables between mappers/actors will probably wish to
        force the mapper to use the LookupTable unchanged.
        """
        ...
    
    def ShallowCopy(self, vtkAbstractMapper):
        """
        V.ShallowCopy(vtkAbstractMapper)
        C++: void ShallowCopy(vtkAbstractMapper *m) override;
        
        Make a shallow copy of this mapper.
        """
        ...
    
    def StaticOff(self):
        """
        V.StaticOff()
        C++: virtual void StaticOff()
        
        Turn on/off flag to control whether the mapper's data is static.
        Static data means that the mapper does not propagate updates down
        the pipeline, greatly decreasing the time it takes to update many
        mappers. This should only be used if the data never changes.
        """
        ...
    
    def StaticOn(self):
        """
        V.StaticOn()
        C++: virtual void StaticOn()
        
        Turn on/off flag to control whether the mapper's data is static.
        Static data means that the mapper does not propagate updates down
        the pipeline, greatly decreasing the time it takes to update many
        mappers. This should only be used if the data never changes.
        """
        ...
    
    def UseLookupTableScalarRangeOff(self):
        """
        V.UseLookupTableScalarRangeOff()
        C++: virtual void UseLookupTableScalarRangeOff()
        
        Control whether the mapper sets the lookuptable range based on
        its own ScalarRange, or whether it will use the LookupTable
        ScalarRange regardless of it's own setting. By default the Mapper
        is allowed to set the LookupTable range, but users who are
        sharing LookupTables between mappers/actors will probably wish to
        force the mapper to use the LookupTable unchanged.
        """
        ...
    
    def UseLookupTableScalarRangeOn(self):
        """
        V.UseLookupTableScalarRangeOn()
        C++: virtual void UseLookupTableScalarRangeOn()
        
        Control whether the mapper sets the lookuptable range based on
        its own ScalarRange, or whether it will use the LookupTable
        ScalarRange regardless of it's own setting. By default the Mapper
        is allowed to set the LookupTable range, but users who are
        sharing LookupTables between mappers/actors will probably wish to
        force the mapper to use the LookupTable unchanged.
        """
        ...
    
    def __delattr__(self, *args, **kwargs):
        """ Implement delattr(self, name). """
        ...
    
    def __getattribute__(self, *args, **kwargs):
        """ Return getattr(self, name). """
        ...
    
    def __init__(self, *args, **kwargs) -> None:
        ...
    
    @staticmethod
    def __new__(*args, **kwargs):
        """ Create and return a new object.  See help(type) for accurate signature. """
        ...
    
    def __repr__(self, *args, **kwargs):
        """ Return repr(self). """
        ...
    
    def __setattr__(self, *args, **kwargs):
        """ Implement setattr(self, name, value). """
        ...
    
    def __str__(self, *args, **kwargs) -> str:
        """ Return str(self). """
        ...
    
    __this__ = ...
    __dict__ = ...
    __vtkname__ = ...


