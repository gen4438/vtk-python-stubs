"""
This type stub file was generated by pyright.
"""

import vtkmodules.vtkCommonCore as __vtkmodules_vtkCommonCore

class vtkRenderWindow(__vtkmodules_vtkCommonCore.vtkWindow):
    """
    vtkRenderWindow - create a window for renderers to draw into
    
    Superclass: vtkWindow
    
    vtkRenderWindow is an abstract object to specify the behavior of a
    rendering window. A rendering window is a window in a graphical user
    interface where renderers draw their images. Methods are provided to
    synchronize the rendering process, set window size, and control
    double buffering.  The window also allows rendering in stereo.  The
    interlaced render stereo type is for output to a VRex stereo
    projector.  All of the odd horizontal lines are from the left eye,
    and the even lines are from the right eye.  The user has to make the
    render window aligned with the VRex projector, or the eye will be
    swapped.
    
    @warning
    In VTK versions 4 and later, the vtkWindowToImageFilter class is part
    of the canonical way to output an image of a window to a file
    (replacing the obsolete SaveImageAsPPM method for vtkRenderWindows
    that existed in 3.2 and earlier).  Connect one of these filters to
    the output of the window, and filter's output to a writer such as
    vtkPNGWriter.
    
    @sa
    vtkRenderer vtkRenderWindowInteractor vtkWindowToImageFilter
    """
    def AddRenderer(self, vtkRenderer):
        """
        V.AddRenderer(vtkRenderer)
        C++: virtual void AddRenderer(vtkRenderer *)
        
        Add a renderer to the list of renderers.
        """
        ...
    
    def AlphaBitPlanesOff(self):
        """
        V.AlphaBitPlanesOff()
        C++: virtual void AlphaBitPlanesOff()
        
        Turn on/off the use of alpha bitplanes.
        """
        ...
    
    def AlphaBitPlanesOn(self):
        """
        V.AlphaBitPlanesOn()
        C++: virtual void AlphaBitPlanesOn()
        
        Turn on/off the use of alpha bitplanes.
        """
        ...
    
    def BordersOff(self):
        """
        V.BordersOff()
        C++: virtual void BordersOff()
        
        Turn on/off window manager borders. Typically, you shouldn't turn
        the borders off, because that bypasses the window manager and can
        cause undesirable behavior.
        """
        ...
    
    def BordersOn(self):
        """
        V.BordersOn()
        C++: virtual void BordersOn()
        
        Turn on/off window manager borders. Typically, you shouldn't turn
        the borders off, because that bypasses the window manager and can
        cause undesirable behavior.
        """
        ...
    
    def CaptureGL2PSSpecialProps(self, vtkCollection):
        """
        V.CaptureGL2PSSpecialProps(vtkCollection)
        C++: void CaptureGL2PSSpecialProps(vtkCollection *specialProps)
        
        The GL2PS exporter must handle certain props in a special way
        (e.g. text). This method performs a render and captures all
        "GL2PS-special" props in the specified collection. The collection
        will contain a vtkPropCollection for each vtkRenderer in
        this->GetRenderers(), each containing the special props rendered
        by the corresponding renderer.
        """
        ...
    
    def CheckAbortStatus(self):
        """
        V.CheckAbortStatus() -> int
        C++: virtual int CheckAbortStatus()
        
        This is a flag that can be set to interrupt a rendering that is
        in progress.
        """
        ...
    
    def CheckInRenderStatus(self):
        """
        V.CheckInRenderStatus() -> int
        C++: virtual int CheckInRenderStatus()
        
        Are we rendering at the moment
        """
        ...
    
    def ClearInRenderStatus(self):
        """
        V.ClearInRenderStatus()
        C++: virtual void ClearInRenderStatus()
        
        Clear status (after an exception was thrown for example)
        """
        ...
    
    def CopyResultFrame(self):
        """
        V.CopyResultFrame()
        C++: virtual void CopyResultFrame()
        
        Performed at the end of the rendering process to generate image.
        This is typically done right before swapping buffers.
        """
        ...
    
    def End(self):
        """
        V.End()
        C++: virtual void End()
        
        Update the system, if needed, at end of render process
        """
        ...
    
    def Finalize(self):
        """
        V.Finalize()
        C++: virtual void Finalize()
        
        Finalize the rendering process.
        """
        ...
    
    def Frame(self):
        """
        V.Frame()
        C++: virtual void Frame()
        
        A termination method performed at the end of the rendering
        process to do things like swapping buffers (if necessary) or
        similar actions.
        """
        ...
    
    def FullScreenOff(self):
        """
        V.FullScreenOff()
        C++: virtual void FullScreenOff()
        
        Turn on/off rendering full screen window size.
        """
        ...
    
    def FullScreenOn(self):
        """
        V.FullScreenOn()
        C++: virtual void FullScreenOn()
        
        Turn on/off rendering full screen window size.
        """
        ...
    
    def GetAbortRender(self):
        """
        V.GetAbortRender() -> int
        C++: virtual int GetAbortRender()
        
        This is a flag that can be set to interrupt a rendering that is
        in progress.
        """
        ...
    
    def GetAlphaBitPlanes(self):
        """
        V.GetAlphaBitPlanes() -> int
        C++: virtual vtkTypeBool GetAlphaBitPlanes()
        
        Turn on/off the use of alpha bitplanes.
        """
        ...
    
    def GetAnaglyphColorMask(self):
        """
        V.GetAnaglyphColorMask() -> (int, int)
        C++: virtual int *GetAnaglyphColorMask()
        
        Set/get the anaglyph color mask values.  These two numbers are
        bits mask that control which color channels of the original
        stereo images are used to produce the final anaglyph image.  The
        first value is the color mask for the left view, the second the
        mask for the right view.  If a bit in the mask is on for a
        particular color for a view, that color is passed on to the final
        view; if it is not set, that channel for that view is ignored.
        The bits are arranged as r, g, and b, so r = 4, g = 2, and b = 1.
        By default, the first value (the left view) is set to 4, and the
        second value is set to 3.  That means that the red output channel
        comes from the left view, and the green and blue values come from
        the right view.
        """
        ...
    
    def GetAnaglyphColorSaturation(self):
        """
        V.GetAnaglyphColorSaturation() -> float
        C++: virtual float GetAnaglyphColorSaturation()
        
        Set/get the anaglyph color saturation factor.  This number ranges
        from 0.0 to 1.0:  0.0 means that no color from the original
        object is maintained, 1.0 means all of the color is maintained. 
        The default value is 0.65.  Too much saturation can produce
        uncomfortable 3D viewing because anaglyphs also use color to
        encode 3D.
        """
        ...
    
    def GetAnaglyphColorSaturationMaxValue(self):
        """
        V.GetAnaglyphColorSaturationMaxValue() -> float
        C++: virtual float GetAnaglyphColorSaturationMaxValue()
        
        Set/get the anaglyph color saturation factor.  This number ranges
        from 0.0 to 1.0:  0.0 means that no color from the original
        object is maintained, 1.0 means all of the color is maintained. 
        The default value is 0.65.  Too much saturation can produce
        uncomfortable 3D viewing because anaglyphs also use color to
        encode 3D.
        """
        ...
    
    def GetAnaglyphColorSaturationMinValue(self):
        """
        V.GetAnaglyphColorSaturationMinValue() -> float
        C++: virtual float GetAnaglyphColorSaturationMinValue()
        
        Set/get the anaglyph color saturation factor.  This number ranges
        from 0.0 to 1.0:  0.0 means that no color from the original
        object is maintained, 1.0 means all of the color is maintained. 
        The default value is 0.65.  Too much saturation can produce
        uncomfortable 3D viewing because anaglyphs also use color to
        encode 3D.
        """
        ...
    
    def GetBorders(self):
        """
        V.GetBorders() -> int
        C++: virtual vtkTypeBool GetBorders()
        
        Turn on/off window manager borders. Typically, you shouldn't turn
        the borders off, because that bypasses the window manager and can
        cause undesirable behavior.
        """
        ...
    
    def GetCapturingGL2PSSpecialProps(self):
        """
        V.GetCapturingGL2PSSpecialProps() -> int
        C++: virtual int GetCapturingGL2PSSpecialProps()
        
        Returns true if the render process is capturing text actors.
        """
        ...
    
    def GetColorBufferSizes(self, *int):
        """
        V.GetColorBufferSizes([int, ...]) -> int
        C++: virtual int GetColorBufferSizes(int *)
        
        Get the size of the color buffer. Returns 0 if not able to
        determine otherwise sets R G B and A into buffer.
        """
        ...
    
    def GetCurrentCursor(self):
        """
        V.GetCurrentCursor() -> int
        C++: virtual int GetCurrentCursor()
        
        Change the shape of the cursor.
        """
        ...
    
    def GetDepthBufferSize(self):
        """
        V.GetDepthBufferSize() -> int
        C++: virtual int GetDepthBufferSize()
        
        This method should be defined by the subclass. How many bits of
        precision are there in the zbuffer?
        """
        ...
    
    def GetDesiredUpdateRate(self):
        """
        V.GetDesiredUpdateRate() -> float
        C++: virtual double GetDesiredUpdateRate()
        
        Set/Get the desired update rate. This is used with the
        vtkLODActor class. When using level of detail actors you need to
        specify what update rate you require. The LODActors then will
        pick the correct resolution to meet your desired update rate in
        frames per second. A value of zero indicates that they can use
        all the time they want to.
        """
        ...
    
    def GetDeviceIndex(self):
        """
        V.GetDeviceIndex() -> int
        C++: virtual int GetDeviceIndex()
        
        If there are several graphics card installed on a system, this
        index can be used to specify which card you want to render to.
        the default is 0. This may not work on all derived render window
        and it may need to be set before the first render.
        """
        ...
    
    def GetEventPending(self):
        """
        V.GetEventPending() -> int
        C++: virtual vtkTypeBool GetEventPending()
        
        Check to see if a mouse button has been pressed.  All other
        events are ignored by this method.  Ideally, you want to abort
        the render on any event which causes the DesiredUpdateRate to
        switch from a high-quality rate to a more interactive rate.
        """
        ...
    
    def GetFullScreen(self):
        """
        V.GetFullScreen() -> int
        C++: virtual vtkTypeBool GetFullScreen()
        
        Turn on/off rendering full screen window size.
        """
        ...
    
    def GetGenericContext(self):
        """
        V.GetGenericContext() -> void
        C++: void *GetGenericContext() override;
        
        Dummy stubs for vtkWindow API.
        """
        ...
    
    def GetGenericDisplayId(self):
        """
        V.GetGenericDisplayId() -> void
        C++: void *GetGenericDisplayId() override;
        
        Dummy stubs for vtkWindow API.
        """
        ...
    
    def GetGenericDrawable(self):
        """
        V.GetGenericDrawable() -> void
        C++: void *GetGenericDrawable() override;
        
        Dummy stubs for vtkWindow API.
        """
        ...
    
    def GetGenericParentId(self):
        """
        V.GetGenericParentId() -> void
        C++: void *GetGenericParentId() override;
        
        Dummy stubs for vtkWindow API.
        """
        ...
    
    def GetGenericWindowId(self):
        """
        V.GetGenericWindowId() -> void
        C++: void *GetGenericWindowId() override;
        
        Dummy stubs for vtkWindow API.
        """
        ...
    
    def GetInAbortCheck(self):
        """
        V.GetInAbortCheck() -> int
        C++: virtual int GetInAbortCheck()
        
        This is a flag that can be set to interrupt a rendering that is
        in progress.
        """
        ...
    
    def GetInteractor(self):
        """
        V.GetInteractor() -> vtkRenderWindowInteractor
        C++: virtual vtkRenderWindowInteractor *GetInteractor()
        
        Get the interactor associated with this render window
        """
        ...
    
    def GetIsPicking(self):
        """
        V.GetIsPicking() -> int
        C++: vtkTypeBool GetIsPicking()
        
        @deprecated in VTK 9.0
        """
        ...
    
    def GetLineSmoothing(self):
        """
        V.GetLineSmoothing() -> int
        C++: virtual vtkTypeBool GetLineSmoothing()
        
        Turn on/off line smoothing. Default is off. This must be applied
        before the first Render.
        """
        ...
    
    def GetMultiSamples(self):
        """
        V.GetMultiSamples() -> int
        C++: virtual int GetMultiSamples()
        
        Set / Get the number of multisamples to use for hardware
        antialiasing. A value of 1 will be set to 0.
        """
        ...
    
    def GetNeverRendered(self):
        """
        V.GetNeverRendered() -> int
        C++: virtual int GetNeverRendered()
        
        This flag is set if the window hasn't rendered since it was
        created
        """
        ...
    
    def GetNumberOfDevices(self):
        """
        V.GetNumberOfDevices() -> int
        C++: virtual int GetNumberOfDevices()
        
        Returns the number of devices (graphics cards) on a system. This
        may not work on all derived render windows.
        """
        ...
    
    def GetNumberOfGenerationsFromBase(self, string):
        """
        V.GetNumberOfGenerationsFromBase(string) -> int
        C++: vtkIdType GetNumberOfGenerationsFromBase(const char *type)
            override;
        
        Given a the name of a base class of this class type, return the
        distance of inheritance between this class type and the named
        class (how many generations of inheritance are there between this
        class and the named class). If the named class is not in this
        class's inheritance tree, return a negative value. Valid
        responses will always be nonnegative. This method works in
        combination with vtkTypeMacro found in vtkSetGet.h.
        """
        ...
    
    def GetNumberOfGenerationsFromBaseType(self, string):
        """
        V.GetNumberOfGenerationsFromBaseType(string) -> int
        C++: static vtkIdType GetNumberOfGenerationsFromBaseType(
            const char *type)
        
        Given a the name of a base class of this class type, return the
        distance of inheritance between this class type and the named
        class (how many generations of inheritance are there between this
        class and the named class). If the named class is not in this
        class's inheritance tree, return a negative value. Valid
        responses will always be nonnegative. This method works in
        combination with vtkTypeMacro found in vtkSetGet.h.
        """
        ...
    
    def GetNumberOfLayers(self):
        """
        V.GetNumberOfLayers() -> int
        C++: virtual int GetNumberOfLayers()
        
        Get the number of layers for renderers.  Each renderer should
        have its layer set individually.  Some algorithms iterate through
        all layers, so it is not wise to set the number of layers to be
        exorbitantly large (say bigger than 100).
        """
        ...
    
    def GetNumberOfLayersMaxValue(self):
        """
        V.GetNumberOfLayersMaxValue() -> int
        C++: virtual int GetNumberOfLayersMaxValue()
        
        Get the number of layers for renderers.  Each renderer should
        have its layer set individually.  Some algorithms iterate through
        all layers, so it is not wise to set the number of layers to be
        exorbitantly large (say bigger than 100).
        """
        ...
    
    def GetNumberOfLayersMinValue(self):
        """
        V.GetNumberOfLayersMinValue() -> int
        C++: virtual int GetNumberOfLayersMinValue()
        
        Get the number of layers for renderers.  Each renderer should
        have its layer set individually.  Some algorithms iterate through
        all layers, so it is not wise to set the number of layers to be
        exorbitantly large (say bigger than 100).
        """
        ...
    
    def GetPlatformSupportsRenderWindowSharing(self):
        """
        V.GetPlatformSupportsRenderWindowSharing() -> bool
        C++: virtual bool GetPlatformSupportsRenderWindowSharing()
        
        Set/Get an already existing window that this window should share
        data with if possible. This must be set after the shared render
        window has been created and initialized but before this window
        has been initialized. Not all platforms support data sharing.
        """
        ...
    
    def GetPointSmoothing(self):
        """
        V.GetPointSmoothing() -> int
        C++: virtual vtkTypeBool GetPointSmoothing()
        
        Turn on/off point smoothing. Default is off. This must be applied
        before the first Render.
        """
        ...
    
    def GetPolygonSmoothing(self):
        """
        V.GetPolygonSmoothing() -> int
        C++: virtual vtkTypeBool GetPolygonSmoothing()
        
        Turn on/off polygon smoothing. Default is off. This must be
        applied before the first Render.
        """
        ...
    
    def GetRenderers(self):
        """
        V.GetRenderers() -> vtkRendererCollection
        C++: vtkRendererCollection *GetRenderers()
        
        Return the collection of renderers in the render window.
        """
        ...
    
    def GetRenderingBackend(self):
        """
        V.GetRenderingBackend() -> string
        C++: virtual const char *GetRenderingBackend()
        
        What rendering backend has the user requested
        """
        ...
    
    def GetRenderLibrary(self):
        """
        V.GetRenderLibrary() -> string
        C++: static const char *GetRenderLibrary()
        
        What rendering library has the user requested
        """
        ...
    
    def GetRenderTimer(self):
        """
        V.GetRenderTimer() -> vtkRenderTimerLog
        C++: virtual vtkRenderTimerLog *GetRenderTimer()
        
        Get the render timer log for this window.
        """
        ...
    
    def GetRGBACharPixelData(self, p_int, p_int_1, p_int_2, p_int_3, p_int_4, p_int_5):
        """
        V.GetRGBACharPixelData(int, int, int, int, int, int) -> (int, ...)
        C++: virtual unsigned char *GetRGBACharPixelData(int, int, int,
            int, int, int=0)
        V.GetRGBACharPixelData(int, int, int, int, int,
            vtkUnsignedCharArray, int) -> int
        C++: virtual int GetRGBACharPixelData(int, int, int, int, int,
            vtkUnsignedCharArray *, int=0)
        
        Same as Get/SetPixelData except that the image also contains an
        alpha component. The image is transmitted as RGBARGBARGBA... each
        of which is a float value. The "blend" parameter controls whether
        the SetRGBAPixelData method blends the data with the previous
        contents of the frame buffer or completely replaces the frame
        buffer data.
        """
        ...
    
    def GetRGBAPixelData(self, p_int, p_int_1, p_int_2, p_int_3, p_int_4, p_int_5):
        """
        V.GetRGBAPixelData(int, int, int, int, int, int) -> (float, ...)
        C++: virtual float *GetRGBAPixelData(int, int, int, int, int,
            int=0)
        V.GetRGBAPixelData(int, int, int, int, int, vtkFloatArray, int)
            -> int
        C++: virtual int GetRGBAPixelData(int, int, int, int, int,
            vtkFloatArray *, int=0)
        
        Same as Get/SetPixelData except that the image also contains an
        alpha component. The image is transmitted as RGBARGBARGBA... each
        of which is a float value. The "blend" parameter controls whether
        the SetRGBAPixelData method blends the data with the previous
        contents of the frame buffer or completely replaces the frame
        buffer data.
        """
        ...
    
    def GetSharedRenderWindow(self):
        """
        V.GetSharedRenderWindow() -> vtkRenderWindow
        C++: virtual vtkRenderWindow *GetSharedRenderWindow()
        
        Set/Get an already existing window that this window should share
        data with if possible. This must be set after the shared render
        window has been created and initialized but before this window
        has been initialized. Not all platforms support data sharing.
        """
        ...
    
    def GetStencilCapable(self):
        """
        V.GetStencilCapable() -> int
        C++: virtual vtkTypeBool GetStencilCapable()
        
        Set / Get the availability of the stencil buffer.
        """
        ...
    
    def GetStereoCapableWindow(self):
        """
        V.GetStereoCapableWindow() -> int
        C++: virtual vtkTypeBool GetStereoCapableWindow()
        
        Prescribe that the window be created in a stereo-capable mode.
        This method must be called before the window is realized. Default
        is off.
        """
        ...
    
    def GetStereoRender(self):
        """
        V.GetStereoRender() -> int
        C++: virtual vtkTypeBool GetStereoRender()
        
        Turn on/off stereo rendering.
        """
        ...
    
    def GetStereoType(self):
        """
        V.GetStereoType() -> int
        C++: virtual int GetStereoType()
        
        Set/Get what type of stereo rendering to use.  CrystalEyes mode
        uses frame-sequential capabilities available in OpenGL to drive
        LCD shutter glasses and stereo projectors.  RedBlue mode is a
        simple type of stereo for use with red-blue glasses. Anaglyph
        mode is a superset of RedBlue mode, but the color output channels
        can be configured using the AnaglyphColorMask and the color of
        the original image can be (somewhat) maintained using
        AnaglyphColorSaturation;  the default colors for Anaglyph mode is
        red-cyan.  Interlaced stereo mode produces a composite image
        where horizontal lines alternate between left and right views. 
        StereoLeft and StereoRight modes choose one or the other stereo
        view.  Dresden mode is yet another stereoscopic interleaving.
        Fake simply causes the window to render twice without actually
        swapping the camera from left eye to right eye. This is useful in
        certain applications that want to emulate the rendering passes
        without actually rendering in stereo mode. Emulate is similar to
        Fake, except that it does render left and right eye. There is no
        compositing of the resulting images from the two eyes at the end
        of each render in this mode, hence the result onscreen will be
        the right eye.
        """
        ...
    
    def GetStereoTypeAsString(self):
        """
        V.GetStereoTypeAsString() -> string
        C++: const char *GetStereoTypeAsString()
        V.GetStereoTypeAsString(int) -> string
        C++: static const char *GetStereoTypeAsString(int type)
        
        Returns the stereo type as a string.
        """
        ...
    
    def GetSwapBuffers(self):
        """
        V.GetSwapBuffers() -> int
        C++: virtual vtkTypeBool GetSwapBuffers()
        
        Turn on/off buffer swapping between images.
        """
        ...
    
    def GetUseSRGBColorSpace(self):
        """
        V.GetUseSRGBColorSpace() -> bool
        C++: virtual bool GetUseSRGBColorSpace()
        
        Set/Get if we want this window to use the sRGB color space. Some
        hardware/drivers do not fully support this.
        """
        ...
    
    def GetZbufferData(self, p_int, p_int_1, p_int_2, p_int_3):
        """
        V.GetZbufferData(int, int, int, int) -> (float, ...)
        C++: virtual float *GetZbufferData(int, int, int, int)
        V.GetZbufferData(int, int, int, int, [float, ...]) -> int
        C++: virtual int GetZbufferData(int, int, int, int, float *)
        V.GetZbufferData(int, int, int, int, vtkFloatArray) -> int
        C++: virtual int GetZbufferData(int, int, int, int,
            vtkFloatArray *)
        
        Set/Get the zbuffer data from the frame buffer. (x,y) is any
        corner of the rectangle. (x2,y2) is its opposite corner on the
        diagonal.
        """
        ...
    
    def GetZbufferDataAtPoint(self, p_int, p_int_1):
        """
        V.GetZbufferDataAtPoint(int, int) -> float
        C++: float GetZbufferDataAtPoint(int x, int y)
        
        Set/Get the zbuffer data from the frame buffer. (x,y) is any
        corner of the rectangle. (x2,y2) is its opposite corner on the
        diagonal.
        """
        ...
    
    def HasRenderer(self, vtkRenderer):
        """
        V.HasRenderer(vtkRenderer) -> int
        C++: int HasRenderer(vtkRenderer *)
        
        Query if a renderer is in the list of renderers.
        """
        ...
    
    def HideCursor(self):
        """
        V.HideCursor()
        C++: virtual void HideCursor()
        
        Hide or Show the mouse cursor, it is nice to be able to hide the
        default cursor if you want VTK to display a 3D cursor instead.
        Set cursor position in window (note that (0,0) is the lower left
        corner).
        """
        ...
    
    def InitializeFromCurrentContext(self):
        """
        V.InitializeFromCurrentContext() -> bool
        C++: virtual bool InitializeFromCurrentContext()
        
        Initialize the render window from the information associated with
        the currently activated OpenGL context.
        """
        ...
    
    def IsA(self, string):
        """
        V.IsA(string) -> int
        C++: vtkTypeBool IsA(const char *type) override;
        
        Return 1 if this class is the same type of (or a subclass of) the
        named class. Returns 0 otherwise. This method works in
        combination with vtkTypeMacro found in vtkSetGet.h.
        """
        ...
    
    def IsCurrent(self):
        """
        V.IsCurrent() -> bool
        C++: virtual bool IsCurrent()
        
        Tells if this window is the current graphics context for the
        calling thread.
        """
        ...
    
    def IsDirect(self):
        """
        V.IsDirect() -> int
        C++: virtual vtkTypeBool IsDirect()
        
        Is this render window using hardware acceleration? 0-false,
        1-true
        """
        ...
    
    def IsDrawable(self):
        """
        V.IsDrawable() -> bool
        C++: virtual bool IsDrawable()
        
        Test if the window has a valid drawable. This is currently only
        an issue on Mac OS X Cocoa where rendering to an invalid drawable
        results in all OpenGL calls to fail with "invalid framebuffer
        operation".
        """
        ...
    
    def IsPickingOff(self):
        """
        V.IsPickingOff()
        C++: void IsPickingOff()
        
        @deprecated in VTK 9.0
        """
        ...
    
    def IsPickingOn(self):
        """
        V.IsPickingOn()
        C++: void IsPickingOn()
        
        @deprecated in VTK 9.0
        """
        ...
    
    def IsTypeOf(self, string):
        """
        V.IsTypeOf(string) -> int
        C++: static vtkTypeBool IsTypeOf(const char *type)
        
        Return 1 if this class type is the same type of (or a subclass
        of) the named class. Returns 0 otherwise. This method works in
        combination with vtkTypeMacro found in vtkSetGet.h.
        """
        ...
    
    def LineSmoothingOff(self):
        """
        V.LineSmoothingOff()
        C++: virtual void LineSmoothingOff()
        
        Turn on/off line smoothing. Default is off. This must be applied
        before the first Render.
        """
        ...
    
    def LineSmoothingOn(self):
        """
        V.LineSmoothingOn()
        C++: virtual void LineSmoothingOn()
        
        Turn on/off line smoothing. Default is off. This must be applied
        before the first Render.
        """
        ...
    
    def MakeCurrent(self):
        """
        V.MakeCurrent()
        C++: void MakeCurrent() override;
        
        Attempt to make this window the current graphics context for the
        calling thread.
        """
        ...
    
    def MakeRenderWindowInteractor(self):
        """
        V.MakeRenderWindowInteractor() -> vtkRenderWindowInteractor
        C++: virtual vtkRenderWindowInteractor *MakeRenderWindowInteractor(
            )
        
        Create an interactor to control renderers in this window. We need
        to know what type of interactor to create, because we might be in
        X Windows or MS Windows.
        """
        ...
    
    def NewInstance(self):
        """
        V.NewInstance() -> vtkRenderWindow
        C++: vtkRenderWindow *NewInstance()
        """
        ...
    
    def PointSmoothingOff(self):
        """
        V.PointSmoothingOff()
        C++: virtual void PointSmoothingOff()
        
        Turn on/off point smoothing. Default is off. This must be applied
        before the first Render.
        """
        ...
    
    def PointSmoothingOn(self):
        """
        V.PointSmoothingOn()
        C++: virtual void PointSmoothingOn()
        
        Turn on/off point smoothing. Default is off. This must be applied
        before the first Render.
        """
        ...
    
    def PolygonSmoothingOff(self):
        """
        V.PolygonSmoothingOff()
        C++: virtual void PolygonSmoothingOff()
        
        Turn on/off polygon smoothing. Default is off. This must be
        applied before the first Render.
        """
        ...
    
    def PolygonSmoothingOn(self):
        """
        V.PolygonSmoothingOn()
        C++: virtual void PolygonSmoothingOn()
        
        Turn on/off polygon smoothing. Default is off. This must be
        applied before the first Render.
        """
        ...
    
    def ReleaseRGBAPixelData(self, *float):
        """
        V.ReleaseRGBAPixelData([float, ...])
        C++: virtual void ReleaseRGBAPixelData(float *)
        
        Same as Get/SetPixelData except that the image also contains an
        alpha component. The image is transmitted as RGBARGBARGBA... each
        of which is a float value. The "blend" parameter controls whether
        the SetRGBAPixelData method blends the data with the previous
        contents of the frame buffer or completely replaces the frame
        buffer data.
        """
        ...
    
    def RemoveRenderer(self, vtkRenderer):
        """
        V.RemoveRenderer(vtkRenderer)
        C++: void RemoveRenderer(vtkRenderer *)
        
        Remove a renderer from the list of renderers.
        """
        ...
    
    def Render(self):
        """
        V.Render()
        C++: void Render() override;
        
        Ask each renderer owned by this RenderWindow to render its image
        and synchronize this process.
        """
        ...
    
    def ReportCapabilities(self):
        """
        V.ReportCapabilities() -> string
        C++: virtual const char *ReportCapabilities()
        
        Get report of capabilities for the render window
        """
        ...
    
    def SafeDownCast(self, vtkObjectBase):
        """
        V.SafeDownCast(vtkObjectBase) -> vtkRenderWindow
        C++: static vtkRenderWindow *SafeDownCast(vtkObjectBase *o)
        """
        ...
    
    def SetAbortRender(self, p_int):
        """
        V.SetAbortRender(int)
        C++: virtual void SetAbortRender(int _arg)
        
        This is a flag that can be set to interrupt a rendering that is
        in progress.
        """
        ...
    
    def SetAlphaBitPlanes(self, p_int):
        """
        V.SetAlphaBitPlanes(int)
        C++: virtual void SetAlphaBitPlanes(vtkTypeBool _arg)
        
        Turn on/off the use of alpha bitplanes.
        """
        ...
    
    def SetAnaglyphColorMask(self, p_int, p_int_1):
        """
        V.SetAnaglyphColorMask(int, int)
        C++: virtual void SetAnaglyphColorMask(int _arg1, int _arg2)
        V.SetAnaglyphColorMask((int, int))
        C++: void SetAnaglyphColorMask(const int _arg[2])
        
        Set/get the anaglyph color mask values.  These two numbers are
        bits mask that control which color channels of the original
        stereo images are used to produce the final anaglyph image.  The
        first value is the color mask for the left view, the second the
        mask for the right view.  If a bit in the mask is on for a
        particular color for a view, that color is passed on to the final
        view; if it is not set, that channel for that view is ignored.
        The bits are arranged as r, g, and b, so r = 4, g = 2, and b = 1.
        By default, the first value (the left view) is set to 4, and the
        second value is set to 3.  That means that the red output channel
        comes from the left view, and the green and blue values come from
        the right view.
        """
        ...
    
    def SetAnaglyphColorSaturation(self, p_float):
        """
        V.SetAnaglyphColorSaturation(float)
        C++: virtual void SetAnaglyphColorSaturation(float _arg)
        
        Set/get the anaglyph color saturation factor.  This number ranges
        from 0.0 to 1.0:  0.0 means that no color from the original
        object is maintained, 1.0 means all of the color is maintained. 
        The default value is 0.65.  Too much saturation can produce
        uncomfortable 3D viewing because anaglyphs also use color to
        encode 3D.
        """
        ...
    
    def SetBorders(self, p_int):
        """
        V.SetBorders(int)
        C++: virtual void SetBorders(vtkTypeBool _arg)
        
        Turn on/off window manager borders. Typically, you shouldn't turn
        the borders off, because that bypasses the window manager and can
        cause undesirable behavior.
        """
        ...
    
    def SetCurrentCursor(self, p_int):
        """
        V.SetCurrentCursor(int)
        C++: virtual void SetCurrentCursor(int _arg)
        
        Change the shape of the cursor.
        """
        ...
    
    def SetCursorPosition(self, p_int, p_int_1):
        """
        V.SetCursorPosition(int, int)
        C++: virtual void SetCursorPosition(int, int)
        
        Hide or Show the mouse cursor, it is nice to be able to hide the
        default cursor if you want VTK to display a 3D cursor instead.
        Set cursor position in window (note that (0,0) is the lower left
        corner).
        """
        ...
    
    def SetDesiredUpdateRate(self, p_float):
        """
        V.SetDesiredUpdateRate(float)
        C++: virtual void SetDesiredUpdateRate(double)
        
        Set/Get the desired update rate. This is used with the
        vtkLODActor class. When using level of detail actors you need to
        specify what update rate you require. The LODActors then will
        pick the correct resolution to meet your desired update rate in
        frames per second. A value of zero indicates that they can use
        all the time they want to.
        """
        ...
    
    def SetDeviceIndex(self, p_int):
        """
        V.SetDeviceIndex(int)
        C++: virtual void SetDeviceIndex(int _arg)
        
        If there are several graphics card installed on a system, this
        index can be used to specify which card you want to render to.
        the default is 0. This may not work on all derived render window
        and it may need to be set before the first render.
        """
        ...
    
    def SetDisplayId(self, void):
        """
        V.SetDisplayId(void)
        C++: void SetDisplayId(void *) override;
        
        Dummy stubs for vtkWindow API.
        """
        ...
    
    def SetForceMakeCurrent(self):
        """
        V.SetForceMakeCurrent()
        C++: virtual void SetForceMakeCurrent()
        
        If called, allow MakeCurrent() to skip cache-check when called.
        MakeCurrent() reverts to original behavior of cache-checking on
        the next render.
        """
        ...
    
    def SetFullScreen(self, p_int):
        """
        V.SetFullScreen(int)
        C++: virtual void SetFullScreen(vtkTypeBool)
        
        Turn on/off rendering full screen window size.
        """
        ...
    
    def SetInAbortCheck(self, p_int):
        """
        V.SetInAbortCheck(int)
        C++: virtual void SetInAbortCheck(int _arg)
        
        This is a flag that can be set to interrupt a rendering that is
        in progress.
        """
        ...
    
    def SetInteractor(self, vtkRenderWindowInteractor):
        """
        V.SetInteractor(vtkRenderWindowInteractor)
        C++: void SetInteractor(vtkRenderWindowInteractor *)
        
        Set the interactor to the render window
        """
        ...
    
    def SetIsPicking(self, p_int):
        """
        V.SetIsPicking(int)
        C++: void SetIsPicking(vtkTypeBool)
        
        @deprecated in VTK 9.0
        """
        ...
    
    def SetLineSmoothing(self, p_int):
        """
        V.SetLineSmoothing(int)
        C++: virtual void SetLineSmoothing(vtkTypeBool _arg)
        
        Turn on/off line smoothing. Default is off. This must be applied
        before the first Render.
        """
        ...
    
    def SetMultiSamples(self, p_int):
        """
        V.SetMultiSamples(int)
        C++: virtual void SetMultiSamples(int)
        
        Set / Get the number of multisamples to use for hardware
        antialiasing. A value of 1 will be set to 0.
        """
        ...
    
    def SetNextWindowId(self, void):
        """
        V.SetNextWindowId(void)
        C++: virtual void SetNextWindowId(void *)
        
        Dummy stubs for vtkWindow API.
        """
        ...
    
    def SetNextWindowInfo(self, string):
        """
        V.SetNextWindowInfo(string)
        C++: virtual void SetNextWindowInfo(const char *)
        
        Dummy stubs for vtkWindow API.
        """
        ...
    
    def SetNumberOfLayers(self, p_int):
        """
        V.SetNumberOfLayers(int)
        C++: virtual void SetNumberOfLayers(int _arg)
        
        Get the number of layers for renderers.  Each renderer should
        have its layer set individually.  Some algorithms iterate through
        all layers, so it is not wise to set the number of layers to be
        exorbitantly large (say bigger than 100).
        """
        ...
    
    def SetParentId(self, void):
        """
        V.SetParentId(void)
        C++: void SetParentId(void *) override;
        
        Dummy stubs for vtkWindow API.
        """
        ...
    
    def SetParentInfo(self, string):
        """
        V.SetParentInfo(string)
        C++: void SetParentInfo(const char *) override;
        
        Dummy stubs for vtkWindow API.
        """
        ...
    
    def SetPixelData(self, p_int, p_int_1, p_int_2, p_int_3, *int, **kwargs):
        """
        V.SetPixelData(int, int, int, int, [int, ...], int, int) -> int
        C++: virtual int SetPixelData(int, int, int, int, unsigned char *,
             int, int=0)
        V.SetPixelData(int, int, int, int, vtkUnsignedCharArray, int, int)
             -> int
        C++: virtual int SetPixelData(int, int, int, int,
            vtkUnsignedCharArray *, int, int=0)
        
        Set/Get the pixel data of an image, transmitted as RGBRGBRGB. The
        front argument indicates if the front buffer should be used or
        the back buffer. It is the caller's responsibility to delete the
        resulting array. It is very important to realize that the memory
        in this array is organized from the bottom of the window to the
        top. The origin of the screen is in the lower left corner. The y
        axis increases as you go up the screen. So the storage of pixels
        is from left to right and from bottom to top. (x,y) is any corner
        of the rectangle. (x2,y2) is its opposite corner on the diagonal.
        """
        ...
    
    def SetPointSmoothing(self, p_int):
        """
        V.SetPointSmoothing(int)
        C++: virtual void SetPointSmoothing(vtkTypeBool _arg)
        
        Turn on/off point smoothing. Default is off. This must be applied
        before the first Render.
        """
        ...
    
    def SetPolygonSmoothing(self, p_int):
        """
        V.SetPolygonSmoothing(int)
        C++: virtual void SetPolygonSmoothing(vtkTypeBool _arg)
        
        Turn on/off polygon smoothing. Default is off. This must be
        applied before the first Render.
        """
        ...
    
    def SetRGBACharPixelData(self, p_int, p_int_1, p_int_2, p_int_3, *int, **kwargs):
        """
        V.SetRGBACharPixelData(int, int, int, int, [int, ...], int, int,
            int) -> int
        C++: virtual int SetRGBACharPixelData(int, int, int, int,
            unsigned char *, int, int=0, int=0)
        V.SetRGBACharPixelData(int, int, int, int, vtkUnsignedCharArray,
            int, int, int) -> int
        C++: virtual int SetRGBACharPixelData(int, int, int, int,
            vtkUnsignedCharArray *, int, int=0, int=0)
        
        Same as Get/SetPixelData except that the image also contains an
        alpha component. The image is transmitted as RGBARGBARGBA... each
        of which is a float value. The "blend" parameter controls whether
        the SetRGBAPixelData method blends the data with the previous
        contents of the frame buffer or completely replaces the frame
        buffer data.
        """
        ...
    
    def SetRGBAPixelData(self, p_int, p_int_1, p_int_2, p_int_3, *float, **kwargs):
        """
        V.SetRGBAPixelData(int, int, int, int, [float, ...], int, int,
            int) -> int
        C++: virtual int SetRGBAPixelData(int, int, int, int, float *,
            int, int=0, int=0)
        V.SetRGBAPixelData(int, int, int, int, vtkFloatArray, int, int,
            int) -> int
        C++: virtual int SetRGBAPixelData(int, int, int, int,
            vtkFloatArray *, int, int=0, int=0)
        
        Same as Get/SetPixelData except that the image also contains an
        alpha component. The image is transmitted as RGBARGBARGBA... each
        of which is a float value. The "blend" parameter controls whether
        the SetRGBAPixelData method blends the data with the previous
        contents of the frame buffer or completely replaces the frame
        buffer data.
        """
        ...
    
    def SetSharedRenderWindow(self, vtkRenderWindow):
        """
        V.SetSharedRenderWindow(vtkRenderWindow)
        C++: virtual void SetSharedRenderWindow(vtkRenderWindow *)
        
        Set/Get an already existing window that this window should share
        data with if possible. This must be set after the shared render
        window has been created and initialized but before this window
        has been initialized. Not all platforms support data sharing.
        """
        ...
    
    def SetStencilCapable(self, p_int):
        """
        V.SetStencilCapable(int)
        C++: virtual void SetStencilCapable(vtkTypeBool _arg)
        
        Set / Get the availability of the stencil buffer.
        """
        ...
    
    def SetStereoCapableWindow(self, p_int):
        """
        V.SetStereoCapableWindow(int)
        C++: virtual void SetStereoCapableWindow(vtkTypeBool capable)
        
        Prescribe that the window be created in a stereo-capable mode.
        This method must be called before the window is realized. Default
        is off.
        """
        ...
    
    def SetStereoRender(self, p_int):
        """
        V.SetStereoRender(int)
        C++: void SetStereoRender(vtkTypeBool stereo)
        
        Turn on/off stereo rendering.
        """
        ...
    
    def SetStereoType(self, p_int):
        """
        V.SetStereoType(int)
        C++: void SetStereoType(int)
        
        Set/Get what type of stereo rendering to use.  CrystalEyes mode
        uses frame-sequential capabilities available in OpenGL to drive
        LCD shutter glasses and stereo projectors.  RedBlue mode is a
        simple type of stereo for use with red-blue glasses. Anaglyph
        mode is a superset of RedBlue mode, but the color output channels
        can be configured using the AnaglyphColorMask and the color of
        the original image can be (somewhat) maintained using
        AnaglyphColorSaturation;  the default colors for Anaglyph mode is
        red-cyan.  Interlaced stereo mode produces a composite image
        where horizontal lines alternate between left and right views. 
        StereoLeft and StereoRight modes choose one or the other stereo
        view.  Dresden mode is yet another stereoscopic interleaving.
        Fake simply causes the window to render twice without actually
        swapping the camera from left eye to right eye. This is useful in
        certain applications that want to emulate the rendering passes
        without actually rendering in stereo mode. Emulate is similar to
        Fake, except that it does render left and right eye. There is no
        compositing of the resulting images from the two eyes at the end
        of each render in this mode, hence the result onscreen will be
        the right eye.
        """
        ...
    
    def SetStereoTypeToAnaglyph(self):
        """
        V.SetStereoTypeToAnaglyph()
        C++: void SetStereoTypeToAnaglyph()
        
        Set/Get what type of stereo rendering to use.  CrystalEyes mode
        uses frame-sequential capabilities available in OpenGL to drive
        LCD shutter glasses and stereo projectors.  RedBlue mode is a
        simple type of stereo for use with red-blue glasses. Anaglyph
        mode is a superset of RedBlue mode, but the color output channels
        can be configured using the AnaglyphColorMask and the color of
        the original image can be (somewhat) maintained using
        AnaglyphColorSaturation;  the default colors for Anaglyph mode is
        red-cyan.  Interlaced stereo mode produces a composite image
        where horizontal lines alternate between left and right views. 
        StereoLeft and StereoRight modes choose one or the other stereo
        view.  Dresden mode is yet another stereoscopic interleaving.
        Fake simply causes the window to render twice without actually
        swapping the camera from left eye to right eye. This is useful in
        certain applications that want to emulate the rendering passes
        without actually rendering in stereo mode. Emulate is similar to
        Fake, except that it does render left and right eye. There is no
        compositing of the resulting images from the two eyes at the end
        of each render in this mode, hence the result onscreen will be
        the right eye.
        """
        ...
    
    def SetStereoTypeToCheckerboard(self):
        """
        V.SetStereoTypeToCheckerboard()
        C++: void SetStereoTypeToCheckerboard()
        
        Set/Get what type of stereo rendering to use.  CrystalEyes mode
        uses frame-sequential capabilities available in OpenGL to drive
        LCD shutter glasses and stereo projectors.  RedBlue mode is a
        simple type of stereo for use with red-blue glasses. Anaglyph
        mode is a superset of RedBlue mode, but the color output channels
        can be configured using the AnaglyphColorMask and the color of
        the original image can be (somewhat) maintained using
        AnaglyphColorSaturation;  the default colors for Anaglyph mode is
        red-cyan.  Interlaced stereo mode produces a composite image
        where horizontal lines alternate between left and right views. 
        StereoLeft and StereoRight modes choose one or the other stereo
        view.  Dresden mode is yet another stereoscopic interleaving.
        Fake simply causes the window to render twice without actually
        swapping the camera from left eye to right eye. This is useful in
        certain applications that want to emulate the rendering passes
        without actually rendering in stereo mode. Emulate is similar to
        Fake, except that it does render left and right eye. There is no
        compositing of the resulting images from the two eyes at the end
        of each render in this mode, hence the result onscreen will be
        the right eye.
        """
        ...
    
    def SetStereoTypeToCrystalEyes(self):
        """
        V.SetStereoTypeToCrystalEyes()
        C++: void SetStereoTypeToCrystalEyes()
        
        Set/Get what type of stereo rendering to use.  CrystalEyes mode
        uses frame-sequential capabilities available in OpenGL to drive
        LCD shutter glasses and stereo projectors.  RedBlue mode is a
        simple type of stereo for use with red-blue glasses. Anaglyph
        mode is a superset of RedBlue mode, but the color output channels
        can be configured using the AnaglyphColorMask and the color of
        the original image can be (somewhat) maintained using
        AnaglyphColorSaturation;  the default colors for Anaglyph mode is
        red-cyan.  Interlaced stereo mode produces a composite image
        where horizontal lines alternate between left and right views. 
        StereoLeft and StereoRight modes choose one or the other stereo
        view.  Dresden mode is yet another stereoscopic interleaving.
        Fake simply causes the window to render twice without actually
        swapping the camera from left eye to right eye. This is useful in
        certain applications that want to emulate the rendering passes
        without actually rendering in stereo mode. Emulate is similar to
        Fake, except that it does render left and right eye. There is no
        compositing of the resulting images from the two eyes at the end
        of each render in this mode, hence the result onscreen will be
        the right eye.
        """
        ...
    
    def SetStereoTypeToDresden(self):
        """
        V.SetStereoTypeToDresden()
        C++: void SetStereoTypeToDresden()
        
        Set/Get what type of stereo rendering to use.  CrystalEyes mode
        uses frame-sequential capabilities available in OpenGL to drive
        LCD shutter glasses and stereo projectors.  RedBlue mode is a
        simple type of stereo for use with red-blue glasses. Anaglyph
        mode is a superset of RedBlue mode, but the color output channels
        can be configured using the AnaglyphColorMask and the color of
        the original image can be (somewhat) maintained using
        AnaglyphColorSaturation;  the default colors for Anaglyph mode is
        red-cyan.  Interlaced stereo mode produces a composite image
        where horizontal lines alternate between left and right views. 
        StereoLeft and StereoRight modes choose one or the other stereo
        view.  Dresden mode is yet another stereoscopic interleaving.
        Fake simply causes the window to render twice without actually
        swapping the camera from left eye to right eye. This is useful in
        certain applications that want to emulate the rendering passes
        without actually rendering in stereo mode. Emulate is similar to
        Fake, except that it does render left and right eye. There is no
        compositing of the resulting images from the two eyes at the end
        of each render in this mode, hence the result onscreen will be
        the right eye.
        """
        ...
    
    def SetStereoTypeToEmulate(self):
        """
        V.SetStereoTypeToEmulate()
        C++: void SetStereoTypeToEmulate()
        
        Set/Get what type of stereo rendering to use.  CrystalEyes mode
        uses frame-sequential capabilities available in OpenGL to drive
        LCD shutter glasses and stereo projectors.  RedBlue mode is a
        simple type of stereo for use with red-blue glasses. Anaglyph
        mode is a superset of RedBlue mode, but the color output channels
        can be configured using the AnaglyphColorMask and the color of
        the original image can be (somewhat) maintained using
        AnaglyphColorSaturation;  the default colors for Anaglyph mode is
        red-cyan.  Interlaced stereo mode produces a composite image
        where horizontal lines alternate between left and right views. 
        StereoLeft and StereoRight modes choose one or the other stereo
        view.  Dresden mode is yet another stereoscopic interleaving.
        Fake simply causes the window to render twice without actually
        swapping the camera from left eye to right eye. This is useful in
        certain applications that want to emulate the rendering passes
        without actually rendering in stereo mode. Emulate is similar to
        Fake, except that it does render left and right eye. There is no
        compositing of the resulting images from the two eyes at the end
        of each render in this mode, hence the result onscreen will be
        the right eye.
        """
        ...
    
    def SetStereoTypeToFake(self):
        """
        V.SetStereoTypeToFake()
        C++: void SetStereoTypeToFake()
        
        Set/Get what type of stereo rendering to use.  CrystalEyes mode
        uses frame-sequential capabilities available in OpenGL to drive
        LCD shutter glasses and stereo projectors.  RedBlue mode is a
        simple type of stereo for use with red-blue glasses. Anaglyph
        mode is a superset of RedBlue mode, but the color output channels
        can be configured using the AnaglyphColorMask and the color of
        the original image can be (somewhat) maintained using
        AnaglyphColorSaturation;  the default colors for Anaglyph mode is
        red-cyan.  Interlaced stereo mode produces a composite image
        where horizontal lines alternate between left and right views. 
        StereoLeft and StereoRight modes choose one or the other stereo
        view.  Dresden mode is yet another stereoscopic interleaving.
        Fake simply causes the window to render twice without actually
        swapping the camera from left eye to right eye. This is useful in
        certain applications that want to emulate the rendering passes
        without actually rendering in stereo mode. Emulate is similar to
        Fake, except that it does render left and right eye. There is no
        compositing of the resulting images from the two eyes at the end
        of each render in this mode, hence the result onscreen will be
        the right eye.
        """
        ...
    
    def SetStereoTypeToInterlaced(self):
        """
        V.SetStereoTypeToInterlaced()
        C++: void SetStereoTypeToInterlaced()
        
        Set/Get what type of stereo rendering to use.  CrystalEyes mode
        uses frame-sequential capabilities available in OpenGL to drive
        LCD shutter glasses and stereo projectors.  RedBlue mode is a
        simple type of stereo for use with red-blue glasses. Anaglyph
        mode is a superset of RedBlue mode, but the color output channels
        can be configured using the AnaglyphColorMask and the color of
        the original image can be (somewhat) maintained using
        AnaglyphColorSaturation;  the default colors for Anaglyph mode is
        red-cyan.  Interlaced stereo mode produces a composite image
        where horizontal lines alternate between left and right views. 
        StereoLeft and StereoRight modes choose one or the other stereo
        view.  Dresden mode is yet another stereoscopic interleaving.
        Fake simply causes the window to render twice without actually
        swapping the camera from left eye to right eye. This is useful in
        certain applications that want to emulate the rendering passes
        without actually rendering in stereo mode. Emulate is similar to
        Fake, except that it does render left and right eye. There is no
        compositing of the resulting images from the two eyes at the end
        of each render in this mode, hence the result onscreen will be
        the right eye.
        """
        ...
    
    def SetStereoTypeToLeft(self):
        """
        V.SetStereoTypeToLeft()
        C++: void SetStereoTypeToLeft()
        
        Set/Get what type of stereo rendering to use.  CrystalEyes mode
        uses frame-sequential capabilities available in OpenGL to drive
        LCD shutter glasses and stereo projectors.  RedBlue mode is a
        simple type of stereo for use with red-blue glasses. Anaglyph
        mode is a superset of RedBlue mode, but the color output channels
        can be configured using the AnaglyphColorMask and the color of
        the original image can be (somewhat) maintained using
        AnaglyphColorSaturation;  the default colors for Anaglyph mode is
        red-cyan.  Interlaced stereo mode produces a composite image
        where horizontal lines alternate between left and right views. 
        StereoLeft and StereoRight modes choose one or the other stereo
        view.  Dresden mode is yet another stereoscopic interleaving.
        Fake simply causes the window to render twice without actually
        swapping the camera from left eye to right eye. This is useful in
        certain applications that want to emulate the rendering passes
        without actually rendering in stereo mode. Emulate is similar to
        Fake, except that it does render left and right eye. There is no
        compositing of the resulting images from the two eyes at the end
        of each render in this mode, hence the result onscreen will be
        the right eye.
        """
        ...
    
    def SetStereoTypeToRedBlue(self):
        """
        V.SetStereoTypeToRedBlue()
        C++: void SetStereoTypeToRedBlue()
        
        Set/Get what type of stereo rendering to use.  CrystalEyes mode
        uses frame-sequential capabilities available in OpenGL to drive
        LCD shutter glasses and stereo projectors.  RedBlue mode is a
        simple type of stereo for use with red-blue glasses. Anaglyph
        mode is a superset of RedBlue mode, but the color output channels
        can be configured using the AnaglyphColorMask and the color of
        the original image can be (somewhat) maintained using
        AnaglyphColorSaturation;  the default colors for Anaglyph mode is
        red-cyan.  Interlaced stereo mode produces a composite image
        where horizontal lines alternate between left and right views. 
        StereoLeft and StereoRight modes choose one or the other stereo
        view.  Dresden mode is yet another stereoscopic interleaving.
        Fake simply causes the window to render twice without actually
        swapping the camera from left eye to right eye. This is useful in
        certain applications that want to emulate the rendering passes
        without actually rendering in stereo mode. Emulate is similar to
        Fake, except that it does render left and right eye. There is no
        compositing of the resulting images from the two eyes at the end
        of each render in this mode, hence the result onscreen will be
        the right eye.
        """
        ...
    
    def SetStereoTypeToRight(self):
        """
        V.SetStereoTypeToRight()
        C++: void SetStereoTypeToRight()
        
        Set/Get what type of stereo rendering to use.  CrystalEyes mode
        uses frame-sequential capabilities available in OpenGL to drive
        LCD shutter glasses and stereo projectors.  RedBlue mode is a
        simple type of stereo for use with red-blue glasses. Anaglyph
        mode is a superset of RedBlue mode, but the color output channels
        can be configured using the AnaglyphColorMask and the color of
        the original image can be (somewhat) maintained using
        AnaglyphColorSaturation;  the default colors for Anaglyph mode is
        red-cyan.  Interlaced stereo mode produces a composite image
        where horizontal lines alternate between left and right views. 
        StereoLeft and StereoRight modes choose one or the other stereo
        view.  Dresden mode is yet another stereoscopic interleaving.
        Fake simply causes the window to render twice without actually
        swapping the camera from left eye to right eye. This is useful in
        certain applications that want to emulate the rendering passes
        without actually rendering in stereo mode. Emulate is similar to
        Fake, except that it does render left and right eye. There is no
        compositing of the resulting images from the two eyes at the end
        of each render in this mode, hence the result onscreen will be
        the right eye.
        """
        ...
    
    def SetStereoTypeToSplitViewportHorizontal(self):
        """
        V.SetStereoTypeToSplitViewportHorizontal()
        C++: void SetStereoTypeToSplitViewportHorizontal()
        
        Set/Get what type of stereo rendering to use.  CrystalEyes mode
        uses frame-sequential capabilities available in OpenGL to drive
        LCD shutter glasses and stereo projectors.  RedBlue mode is a
        simple type of stereo for use with red-blue glasses. Anaglyph
        mode is a superset of RedBlue mode, but the color output channels
        can be configured using the AnaglyphColorMask and the color of
        the original image can be (somewhat) maintained using
        AnaglyphColorSaturation;  the default colors for Anaglyph mode is
        red-cyan.  Interlaced stereo mode produces a composite image
        where horizontal lines alternate between left and right views. 
        StereoLeft and StereoRight modes choose one or the other stereo
        view.  Dresden mode is yet another stereoscopic interleaving.
        Fake simply causes the window to render twice without actually
        swapping the camera from left eye to right eye. This is useful in
        certain applications that want to emulate the rendering passes
        without actually rendering in stereo mode. Emulate is similar to
        Fake, except that it does render left and right eye. There is no
        compositing of the resulting images from the two eyes at the end
        of each render in this mode, hence the result onscreen will be
        the right eye.
        """
        ...
    
    def SetSwapBuffers(self, p_int):
        """
        V.SetSwapBuffers(int)
        C++: virtual void SetSwapBuffers(vtkTypeBool _arg)
        
        Turn on/off buffer swapping between images.
        """
        ...
    
    def SetUseSRGBColorSpace(self, bool):
        """
        V.SetUseSRGBColorSpace(bool)
        C++: virtual void SetUseSRGBColorSpace(bool _arg)
        
        Set/Get if we want this window to use the sRGB color space. Some
        hardware/drivers do not fully support this.
        """
        ...
    
    def SetWindowId(self, void):
        """
        V.SetWindowId(void)
        C++: void SetWindowId(void *) override;
        
        Dummy stubs for vtkWindow API.
        """
        ...
    
    def SetWindowInfo(self, string):
        """
        V.SetWindowInfo(string)
        C++: void SetWindowInfo(const char *) override;
        
        Dummy stubs for vtkWindow API.
        """
        ...
    
    def SetZbufferData(self, p_int, p_int_1, p_int_2, p_int_3, *float):
        """
        V.SetZbufferData(int, int, int, int, [float, ...]) -> int
        C++: virtual int SetZbufferData(int, int, int, int, float *)
        V.SetZbufferData(int, int, int, int, vtkFloatArray) -> int
        C++: virtual int SetZbufferData(int, int, int, int,
            vtkFloatArray *)
        
        Set/Get the zbuffer data from the frame buffer. (x,y) is any
        corner of the rectangle. (x2,y2) is its opposite corner on the
        diagonal.
        """
        ...
    
    def ShowCursor(self):
        """
        V.ShowCursor()
        C++: virtual void ShowCursor()
        
        Hide or Show the mouse cursor, it is nice to be able to hide the
        default cursor if you want VTK to display a 3D cursor instead.
        Set cursor position in window (note that (0,0) is the lower left
        corner).
        """
        ...
    
    def Start(self):
        """
        V.Start()
        C++: virtual void Start()
        
        Start the rendering process for a frame
        """
        ...
    
    def StencilCapableOff(self):
        """
        V.StencilCapableOff()
        C++: virtual void StencilCapableOff()
        
        Set / Get the availability of the stencil buffer.
        """
        ...
    
    def StencilCapableOn(self):
        """
        V.StencilCapableOn()
        C++: virtual void StencilCapableOn()
        
        Set / Get the availability of the stencil buffer.
        """
        ...
    
    def StereoCapableWindowOff(self):
        """
        V.StereoCapableWindowOff()
        C++: virtual void StereoCapableWindowOff()
        
        Prescribe that the window be created in a stereo-capable mode.
        This method must be called before the window is realized. Default
        is off.
        """
        ...
    
    def StereoCapableWindowOn(self):
        """
        V.StereoCapableWindowOn()
        C++: virtual void StereoCapableWindowOn()
        
        Prescribe that the window be created in a stereo-capable mode.
        This method must be called before the window is realized. Default
        is off.
        """
        ...
    
    def StereoMidpoint(self):
        """
        V.StereoMidpoint()
        C++: virtual void StereoMidpoint()
        
        Intermediate method performs operations required between the
        rendering of the left and right eye.
        """
        ...
    
    def StereoRenderComplete(self):
        """
        V.StereoRenderComplete()
        C++: virtual void StereoRenderComplete()
        
        Handles work required once both views have been rendered when
        using stereo rendering.
        """
        ...
    
    def StereoRenderOff(self):
        """
        V.StereoRenderOff()
        C++: virtual void StereoRenderOff()
        
        Turn on/off stereo rendering.
        """
        ...
    
    def StereoRenderOn(self):
        """
        V.StereoRenderOn()
        C++: virtual void StereoRenderOn()
        
        Turn on/off stereo rendering.
        """
        ...
    
    def StereoUpdate(self):
        """
        V.StereoUpdate()
        C++: virtual void StereoUpdate()
        
        Update the system, if needed, due to stereo rendering. For some
        stereo methods, subclasses might need to switch some hardware
        settings here.
        """
        ...
    
    def SupportsOpenGL(self):
        """
        V.SupportsOpenGL() -> int
        C++: virtual int SupportsOpenGL()
        
        Does this render window support OpenGL? 0-false, 1-true
        """
        ...
    
    def SwapBuffersOff(self):
        """
        V.SwapBuffersOff()
        C++: virtual void SwapBuffersOff()
        
        Turn on/off buffer swapping between images.
        """
        ...
    
    def SwapBuffersOn(self):
        """
        V.SwapBuffersOn()
        C++: virtual void SwapBuffersOn()
        
        Turn on/off buffer swapping between images.
        """
        ...
    
    def UseSRGBColorSpaceOff(self):
        """
        V.UseSRGBColorSpaceOff()
        C++: virtual void UseSRGBColorSpaceOff()
        
        Set/Get if we want this window to use the sRGB color space. Some
        hardware/drivers do not fully support this.
        """
        ...
    
    def UseSRGBColorSpaceOn(self):
        """
        V.UseSRGBColorSpaceOn()
        C++: virtual void UseSRGBColorSpaceOn()
        
        Set/Get if we want this window to use the sRGB color space. Some
        hardware/drivers do not fully support this.
        """
        ...
    
    def WaitForCompletion(self):
        """
        V.WaitForCompletion()
        C++: virtual void WaitForCompletion()
        
        Block the thread until the actual rendering is finished(). Useful
        for measurement only.
        """
        ...
    
    def WindowRemap(self):
        """
        V.WindowRemap()
        C++: virtual void WindowRemap()
        
        Remap the rendering window. This probably only works on UNIX
        right now. It is useful for changing properties that can't
        normally be changed once the window is up.
        """
        ...
    
    def __delattr__(self, *args, **kwargs):
        """ Implement delattr(self, name). """
        ...
    
    def __getattribute__(self, *args, **kwargs):
        """ Return getattr(self, name). """
        ...
    
    def __init__(self, *args, **kwargs) -> None:
        ...
    
    @staticmethod
    def __new__(*args, **kwargs):
        """ Create and return a new object.  See help(type) for accurate signature. """
        ...
    
    def __repr__(self, *args, **kwargs):
        """ Return repr(self). """
        ...
    
    def __setattr__(self, *args, **kwargs):
        """ Implement setattr(self, name, value). """
        ...
    
    def __str__(self, *args, **kwargs) -> str:
        """ Return str(self). """
        ...
    
    __this__ = ...
    __dict__ = ...
    __vtkname__ = ...


