"""
This type stub file was generated by pyright.
"""

import vtkmodules.vtkCommonCore as __vtkmodules_vtkCommonCore

class vtkFXAAOptions(__vtkmodules_vtkCommonCore.vtkObject):
    """
    vtkFXAAOptions - Configuration for FXAA implementations.
    
    Superclass: vtkObject
    
    This class encapsulates the settings for vtkOpenGLFXAAFilter.
    """
    def GetDebugOptionValue(self):
        """
        V.GetDebugOptionValue() -> DebugOption
        C++: virtual DebugOption GetDebugOptionValue()
        
        Debugging options that affect the output color buffer. See
        vtkFXAAFilterFS.glsl for details. Only one may be active at a
        time.
        """
        ...
    
    def GetEndpointSearchIterations(self):
        """
        V.GetEndpointSearchIterations() -> int
        C++: virtual int GetEndpointSearchIterations()
        
        Set the number of iterations for the endpoint search algorithm.
        Increasing this value will increase runtime, but also properly
        detect longer edges. The current implementation steps one pixel
        in both the positive and negative directions per iteration. The
        default value is 12, which will resolve endpoints of edges < 25
        pixels long (2 * 12 + 1).
        """
        ...
    
    def GetEndpointSearchIterationsMaxValue(self):
        """
        V.GetEndpointSearchIterationsMaxValue() -> int
        C++: virtual int GetEndpointSearchIterationsMaxValue()
        
        Set the number of iterations for the endpoint search algorithm.
        Increasing this value will increase runtime, but also properly
        detect longer edges. The current implementation steps one pixel
        in both the positive and negative directions per iteration. The
        default value is 12, which will resolve endpoints of edges < 25
        pixels long (2 * 12 + 1).
        """
        ...
    
    def GetEndpointSearchIterationsMinValue(self):
        """
        V.GetEndpointSearchIterationsMinValue() -> int
        C++: virtual int GetEndpointSearchIterationsMinValue()
        
        Set the number of iterations for the endpoint search algorithm.
        Increasing this value will increase runtime, but also properly
        detect longer edges. The current implementation steps one pixel
        in both the positive and negative directions per iteration. The
        default value is 12, which will resolve endpoints of edges < 25
        pixels long (2 * 12 + 1).
        """
        ...
    
    def GetHardContrastThreshold(self):
        """
        V.GetHardContrastThreshold() -> float
        C++: virtual float GetHardContrastThreshold()
        
        Similar to RelativeContrastThreshold, but not scaled by the
        maximum luminosity.
        
        * If the contrast of the current pixel and it's 4 immediate NSWE
          neighbors is
        * less than HardContrastThreshold, the pixel is not considered
          aliased and
        * will not be affected by FXAA.
        
        * Suggested settings:
        * - 1/32: Visible limit
        * - 1/16: High quality (default)
        * - 1/12: Upper limit (start of visible unfiltered edges)
        """
        ...
    
    def GetHardContrastThresholdMaxValue(self):
        """
        V.GetHardContrastThresholdMaxValue() -> float
        C++: virtual float GetHardContrastThresholdMaxValue()
        
        Similar to RelativeContrastThreshold, but not scaled by the
        maximum luminosity.
        
        * If the contrast of the current pixel and it's 4 immediate NSWE
          neighbors is
        * less than HardContrastThreshold, the pixel is not considered
          aliased and
        * will not be affected by FXAA.
        
        * Suggested settings:
        * - 1/32: Visible limit
        * - 1/16: High quality (default)
        * - 1/12: Upper limit (start of visible unfiltered edges)
        """
        ...
    
    def GetHardContrastThresholdMinValue(self):
        """
        V.GetHardContrastThresholdMinValue() -> float
        C++: virtual float GetHardContrastThresholdMinValue()
        
        Similar to RelativeContrastThreshold, but not scaled by the
        maximum luminosity.
        
        * If the contrast of the current pixel and it's 4 immediate NSWE
          neighbors is
        * less than HardContrastThreshold, the pixel is not considered
          aliased and
        * will not be affected by FXAA.
        
        * Suggested settings:
        * - 1/32: Visible limit
        * - 1/16: High quality (default)
        * - 1/12: Upper limit (start of visible unfiltered edges)
        """
        ...
    
    def GetNumberOfGenerationsFromBase(self, string):
        """
        V.GetNumberOfGenerationsFromBase(string) -> int
        C++: vtkIdType GetNumberOfGenerationsFromBase(const char *type)
            override;
        
        Given a the name of a base class of this class type, return the
        distance of inheritance between this class type and the named
        class (how many generations of inheritance are there between this
        class and the named class). If the named class is not in this
        class's inheritance tree, return a negative value. Valid
        responses will always be nonnegative. This method works in
        combination with vtkTypeMacro found in vtkSetGet.h.
        """
        ...
    
    def GetNumberOfGenerationsFromBaseType(self, string):
        """
        V.GetNumberOfGenerationsFromBaseType(string) -> int
        C++: static vtkIdType GetNumberOfGenerationsFromBaseType(
            const char *type)
        
        Given a the name of a base class of this class type, return the
        distance of inheritance between this class type and the named
        class (how many generations of inheritance are there between this
        class and the named class). If the named class is not in this
        class's inheritance tree, return a negative value. Valid
        responses will always be nonnegative. This method works in
        combination with vtkTypeMacro found in vtkSetGet.h.
        """
        ...
    
    def GetRelativeContrastThreshold(self):
        """
        V.GetRelativeContrastThreshold() -> float
        C++: virtual float GetRelativeContrastThreshold()
        
        Threshold for applying FXAA to a pixel, relative to the maximum
        luminosity of its 4 immediate neighbors.
        
        * The luminosity of the current pixel and it's NSWE neighbors is
          computed.
        * The maximum luminosity and luminosity range (contrast) of all 5
        pixels is
        * found. If the contrast is less than RelativeContrastThreshold *
        maxLum,
        * the pixel is not considered aliased and will not be affected by
        FXAA.
        
        * Suggested settings:
        * - 1/3: Too little
        * - 1/4: Low quality
        * - 1/8: High quality (default)
        * - 1/16: Overkill
        """
        ...
    
    def GetRelativeContrastThresholdMaxValue(self):
        """
        V.GetRelativeContrastThresholdMaxValue() -> float
        C++: virtual float GetRelativeContrastThresholdMaxValue()
        
        Threshold for applying FXAA to a pixel, relative to the maximum
        luminosity of its 4 immediate neighbors.
        
        * The luminosity of the current pixel and it's NSWE neighbors is
          computed.
        * The maximum luminosity and luminosity range (contrast) of all 5
        pixels is
        * found. If the contrast is less than RelativeContrastThreshold *
        maxLum,
        * the pixel is not considered aliased and will not be affected by
        FXAA.
        
        * Suggested settings:
        * - 1/3: Too little
        * - 1/4: Low quality
        * - 1/8: High quality (default)
        * - 1/16: Overkill
        """
        ...
    
    def GetRelativeContrastThresholdMinValue(self):
        """
        V.GetRelativeContrastThresholdMinValue() -> float
        C++: virtual float GetRelativeContrastThresholdMinValue()
        
        Threshold for applying FXAA to a pixel, relative to the maximum
        luminosity of its 4 immediate neighbors.
        
        * The luminosity of the current pixel and it's NSWE neighbors is
          computed.
        * The maximum luminosity and luminosity range (contrast) of all 5
        pixels is
        * found. If the contrast is less than RelativeContrastThreshold *
        maxLum,
        * the pixel is not considered aliased and will not be affected by
        FXAA.
        
        * Suggested settings:
        * - 1/3: Too little
        * - 1/4: Low quality
        * - 1/8: High quality (default)
        * - 1/16: Overkill
        """
        ...
    
    def GetSubpixelBlendLimit(self):
        """
        V.GetSubpixelBlendLimit() -> float
        C++: virtual float GetSubpixelBlendLimit()
        
        Subpixel aliasing is corrected by applying a lowpass filter to
        the current pixel. This is implemented by blending an average of
        the 3x3 neighborhood around the pixel into the final result. The
        amount of blending is determined by comparing the detected amount
        of subpixel aliasing to the total contrasting of the CNSWE
        pixels:
        
        * SubpixelBlending = abs(lumC - lumAveNSWE) / (lumMaxCNSWE -
          lumMinCNSWE)
        
        * This parameter sets an upper limit to the amount of subpixel
          blending to
        * prevent the image from simply getting blurred.
        
        * Suggested settings:
        * - 1/2: Low amount of blending.
        * - 3/4: Medium amount of blending (default)
        * - 7/8: High amount of blending.
        * - 1: Maximum amount of blending.
        """
        ...
    
    def GetSubpixelBlendLimitMaxValue(self):
        """
        V.GetSubpixelBlendLimitMaxValue() -> float
        C++: virtual float GetSubpixelBlendLimitMaxValue()
        
        Subpixel aliasing is corrected by applying a lowpass filter to
        the current pixel. This is implemented by blending an average of
        the 3x3 neighborhood around the pixel into the final result. The
        amount of blending is determined by comparing the detected amount
        of subpixel aliasing to the total contrasting of the CNSWE
        pixels:
        
        * SubpixelBlending = abs(lumC - lumAveNSWE) / (lumMaxCNSWE -
          lumMinCNSWE)
        
        * This parameter sets an upper limit to the amount of subpixel
          blending to
        * prevent the image from simply getting blurred.
        
        * Suggested settings:
        * - 1/2: Low amount of blending.
        * - 3/4: Medium amount of blending (default)
        * - 7/8: High amount of blending.
        * - 1: Maximum amount of blending.
        """
        ...
    
    def GetSubpixelBlendLimitMinValue(self):
        """
        V.GetSubpixelBlendLimitMinValue() -> float
        C++: virtual float GetSubpixelBlendLimitMinValue()
        
        Subpixel aliasing is corrected by applying a lowpass filter to
        the current pixel. This is implemented by blending an average of
        the 3x3 neighborhood around the pixel into the final result. The
        amount of blending is determined by comparing the detected amount
        of subpixel aliasing to the total contrasting of the CNSWE
        pixels:
        
        * SubpixelBlending = abs(lumC - lumAveNSWE) / (lumMaxCNSWE -
          lumMinCNSWE)
        
        * This parameter sets an upper limit to the amount of subpixel
          blending to
        * prevent the image from simply getting blurred.
        
        * Suggested settings:
        * - 1/2: Low amount of blending.
        * - 3/4: Medium amount of blending (default)
        * - 7/8: High amount of blending.
        * - 1: Maximum amount of blending.
        """
        ...
    
    def GetSubpixelContrastThreshold(self):
        """
        V.GetSubpixelContrastThreshold() -> float
        C++: virtual float GetSubpixelContrastThreshold()
        
        Minimum amount of subpixel aliasing required for subpixel
        antialiasing to be applied.
        
        * Subpixel aliasing is corrected by applying a lowpass filter to
          the current
        * pixel. This is implemented by blending an average of the 3x3
          neighborhood
        * around the pixel into the final result. The amount of blending
          is
        * determined by comparing the detected amount of subpixel
          aliasing to the
        * total contrasting of the CNSWE pixels:
        
        * SubpixelBlending = abs(lumC - lumAveNSWE) / (lumMaxCNSWE -
          lumMinCNSWE)
        
        * If SubpixelBlending is less than this threshold, no lowpass
          blending will
        * occur.
        
        * Suggested settings:
        * - 1/2: Low subpixel aliasing removal
        * - 1/3: Medium subpixel aliasing removal
        * - 1/4: Default subpixel aliasing removal
        * - 1/8: High subpixel aliasing removal
        * - 0: Complete subpixel aliasing removal
        """
        ...
    
    def GetSubpixelContrastThresholdMaxValue(self):
        """
        V.GetSubpixelContrastThresholdMaxValue() -> float
        C++: virtual float GetSubpixelContrastThresholdMaxValue()
        
        Minimum amount of subpixel aliasing required for subpixel
        antialiasing to be applied.
        
        * Subpixel aliasing is corrected by applying a lowpass filter to
          the current
        * pixel. This is implemented by blending an average of the 3x3
          neighborhood
        * around the pixel into the final result. The amount of blending
          is
        * determined by comparing the detected amount of subpixel
          aliasing to the
        * total contrasting of the CNSWE pixels:
        
        * SubpixelBlending = abs(lumC - lumAveNSWE) / (lumMaxCNSWE -
          lumMinCNSWE)
        
        * If SubpixelBlending is less than this threshold, no lowpass
          blending will
        * occur.
        
        * Suggested settings:
        * - 1/2: Low subpixel aliasing removal
        * - 1/3: Medium subpixel aliasing removal
        * - 1/4: Default subpixel aliasing removal
        * - 1/8: High subpixel aliasing removal
        * - 0: Complete subpixel aliasing removal
        """
        ...
    
    def GetSubpixelContrastThresholdMinValue(self):
        """
        V.GetSubpixelContrastThresholdMinValue() -> float
        C++: virtual float GetSubpixelContrastThresholdMinValue()
        
        Minimum amount of subpixel aliasing required for subpixel
        antialiasing to be applied.
        
        * Subpixel aliasing is corrected by applying a lowpass filter to
          the current
        * pixel. This is implemented by blending an average of the 3x3
          neighborhood
        * around the pixel into the final result. The amount of blending
          is
        * determined by comparing the detected amount of subpixel
          aliasing to the
        * total contrasting of the CNSWE pixels:
        
        * SubpixelBlending = abs(lumC - lumAveNSWE) / (lumMaxCNSWE -
          lumMinCNSWE)
        
        * If SubpixelBlending is less than this threshold, no lowpass
          blending will
        * occur.
        
        * Suggested settings:
        * - 1/2: Low subpixel aliasing removal
        * - 1/3: Medium subpixel aliasing removal
        * - 1/4: Default subpixel aliasing removal
        * - 1/8: High subpixel aliasing removal
        * - 0: Complete subpixel aliasing removal
        """
        ...
    
    def GetUseHighQualityEndpoints(self):
        """
        V.GetUseHighQualityEndpoints() -> bool
        C++: virtual bool GetUseHighQualityEndpoints()
        
        Use an improved edge endpoint detection algorithm.
        
        * If true, a modified edge endpoint detection algorithm is used
          that requires
        * more texture lookups, but will properly detect aliased
          single-pixel lines.
        
        * If false, the edge endpoint algorithm proposed by NVIDIA will
          by used. This
        * algorithm is faster (fewer lookups), but will fail to detect
          endpoints of
        * single pixel edge steps.
        
        * Default setting is true.
        """
        ...
    
    def IsA(self, string):
        """
        V.IsA(string) -> int
        C++: vtkTypeBool IsA(const char *type) override;
        
        Return 1 if this class is the same type of (or a subclass of) the
        named class. Returns 0 otherwise. This method works in
        combination with vtkTypeMacro found in vtkSetGet.h.
        """
        ...
    
    def IsTypeOf(self, string):
        """
        V.IsTypeOf(string) -> int
        C++: static vtkTypeBool IsTypeOf(const char *type)
        
        Return 1 if this class type is the same type of (or a subclass
        of) the named class. Returns 0 otherwise. This method works in
        combination with vtkTypeMacro found in vtkSetGet.h.
        """
        ...
    
    def NewInstance(self):
        """
        V.NewInstance() -> vtkFXAAOptions
        C++: vtkFXAAOptions *NewInstance()
        """
        ...
    
    def SafeDownCast(self, vtkObjectBase):
        """
        V.SafeDownCast(vtkObjectBase) -> vtkFXAAOptions
        C++: static vtkFXAAOptions *SafeDownCast(vtkObjectBase *o)
        """
        ...
    
    def SetDebugOptionValue(self, DebugOption):
        """
        V.SetDebugOptionValue(DebugOption)
        C++: virtual void SetDebugOptionValue(DebugOption _arg)
        
        Debugging options that affect the output color buffer. See
        vtkFXAAFilterFS.glsl for details. Only one may be active at a
        time.
        """
        ...
    
    def SetEndpointSearchIterations(self, p_int):
        """
        V.SetEndpointSearchIterations(int)
        C++: virtual void SetEndpointSearchIterations(int _arg)
        
        Set the number of iterations for the endpoint search algorithm.
        Increasing this value will increase runtime, but also properly
        detect longer edges. The current implementation steps one pixel
        in both the positive and negative directions per iteration. The
        default value is 12, which will resolve endpoints of edges < 25
        pixels long (2 * 12 + 1).
        """
        ...
    
    def SetHardContrastThreshold(self, p_float):
        """
        V.SetHardContrastThreshold(float)
        C++: virtual void SetHardContrastThreshold(float _arg)
        
        Similar to RelativeContrastThreshold, but not scaled by the
        maximum luminosity.
        
        * If the contrast of the current pixel and it's 4 immediate NSWE
          neighbors is
        * less than HardContrastThreshold, the pixel is not considered
          aliased and
        * will not be affected by FXAA.
        
        * Suggested settings:
        * - 1/32: Visible limit
        * - 1/16: High quality (default)
        * - 1/12: Upper limit (start of visible unfiltered edges)
        """
        ...
    
    def SetRelativeContrastThreshold(self, p_float):
        """
        V.SetRelativeContrastThreshold(float)
        C++: virtual void SetRelativeContrastThreshold(float _arg)
        
        Threshold for applying FXAA to a pixel, relative to the maximum
        luminosity of its 4 immediate neighbors.
        
        * The luminosity of the current pixel and it's NSWE neighbors is
          computed.
        * The maximum luminosity and luminosity range (contrast) of all 5
        pixels is
        * found. If the contrast is less than RelativeContrastThreshold *
        maxLum,
        * the pixel is not considered aliased and will not be affected by
        FXAA.
        
        * Suggested settings:
        * - 1/3: Too little
        * - 1/4: Low quality
        * - 1/8: High quality (default)
        * - 1/16: Overkill
        """
        ...
    
    def SetSubpixelBlendLimit(self, p_float):
        """
        V.SetSubpixelBlendLimit(float)
        C++: virtual void SetSubpixelBlendLimit(float _arg)
        
        Subpixel aliasing is corrected by applying a lowpass filter to
        the current pixel. This is implemented by blending an average of
        the 3x3 neighborhood around the pixel into the final result. The
        amount of blending is determined by comparing the detected amount
        of subpixel aliasing to the total contrasting of the CNSWE
        pixels:
        
        * SubpixelBlending = abs(lumC - lumAveNSWE) / (lumMaxCNSWE -
          lumMinCNSWE)
        
        * This parameter sets an upper limit to the amount of subpixel
          blending to
        * prevent the image from simply getting blurred.
        
        * Suggested settings:
        * - 1/2: Low amount of blending.
        * - 3/4: Medium amount of blending (default)
        * - 7/8: High amount of blending.
        * - 1: Maximum amount of blending.
        """
        ...
    
    def SetSubpixelContrastThreshold(self, p_float):
        """
        V.SetSubpixelContrastThreshold(float)
        C++: virtual void SetSubpixelContrastThreshold(float _arg)
        
        Minimum amount of subpixel aliasing required for subpixel
        antialiasing to be applied.
        
        * Subpixel aliasing is corrected by applying a lowpass filter to
          the current
        * pixel. This is implemented by blending an average of the 3x3
          neighborhood
        * around the pixel into the final result. The amount of blending
          is
        * determined by comparing the detected amount of subpixel
          aliasing to the
        * total contrasting of the CNSWE pixels:
        
        * SubpixelBlending = abs(lumC - lumAveNSWE) / (lumMaxCNSWE -
          lumMinCNSWE)
        
        * If SubpixelBlending is less than this threshold, no lowpass
          blending will
        * occur.
        
        * Suggested settings:
        * - 1/2: Low subpixel aliasing removal
        * - 1/3: Medium subpixel aliasing removal
        * - 1/4: Default subpixel aliasing removal
        * - 1/8: High subpixel aliasing removal
        * - 0: Complete subpixel aliasing removal
        """
        ...
    
    def SetUseHighQualityEndpoints(self, bool):
        """
        V.SetUseHighQualityEndpoints(bool)
        C++: virtual void SetUseHighQualityEndpoints(bool _arg)
        
        Use an improved edge endpoint detection algorithm.
        
        * If true, a modified edge endpoint detection algorithm is used
          that requires
        * more texture lookups, but will properly detect aliased
          single-pixel lines.
        
        * If false, the edge endpoint algorithm proposed by NVIDIA will
          by used. This
        * algorithm is faster (fewer lookups), but will fail to detect
          endpoints of
        * single pixel edge steps.
        
        * Default setting is true.
        """
        ...
    
    def UseHighQualityEndpointsOff(self):
        """
        V.UseHighQualityEndpointsOff()
        C++: virtual void UseHighQualityEndpointsOff()
        
        Use an improved edge endpoint detection algorithm.
        
        * If true, a modified edge endpoint detection algorithm is used
          that requires
        * more texture lookups, but will properly detect aliased
          single-pixel lines.
        
        * If false, the edge endpoint algorithm proposed by NVIDIA will
          by used. This
        * algorithm is faster (fewer lookups), but will fail to detect
          endpoints of
        * single pixel edge steps.
        
        * Default setting is true.
        """
        ...
    
    def UseHighQualityEndpointsOn(self):
        """
        V.UseHighQualityEndpointsOn()
        C++: virtual void UseHighQualityEndpointsOn()
        
        Use an improved edge endpoint detection algorithm.
        
        * If true, a modified edge endpoint detection algorithm is used
          that requires
        * more texture lookups, but will properly detect aliased
          single-pixel lines.
        
        * If false, the edge endpoint algorithm proposed by NVIDIA will
          by used. This
        * algorithm is faster (fewer lookups), but will fail to detect
          endpoints of
        * single pixel edge steps.
        
        * Default setting is true.
        """
        ...
    
    def __delattr__(self, *args, **kwargs):
        """ Implement delattr(self, name). """
        ...
    
    def __getattribute__(self, *args, **kwargs):
        """ Return getattr(self, name). """
        ...
    
    def __init__(self, *args, **kwargs) -> None:
        ...
    
    @staticmethod
    def __new__(*args, **kwargs):
        """ Create and return a new object.  See help(type) for accurate signature. """
        ...
    
    def __repr__(self, *args, **kwargs):
        """ Return repr(self). """
        ...
    
    def __setattr__(self, *args, **kwargs):
        """ Implement setattr(self, name, value). """
        ...
    
    def __str__(self, *args, **kwargs) -> str:
        """ Return str(self). """
        ...
    
    __this__ = ...
    DebugOption = ...
    FXAA_DEBUG_EDGE_DIRECTION = ...
    FXAA_DEBUG_EDGE_DISTANCE = ...
    FXAA_DEBUG_EDGE_NUM_STEPS = ...
    FXAA_DEBUG_EDGE_SAMPLE_OFFSET = ...
    FXAA_DEBUG_ONLY_EDGE_AA = ...
    FXAA_DEBUG_ONLY_SUBPIX_AA = ...
    FXAA_DEBUG_SUBPIXEL_ALIASING = ...
    FXAA_NO_DEBUG = ...
    __dict__ = ...
    __vtkname__ = ...


