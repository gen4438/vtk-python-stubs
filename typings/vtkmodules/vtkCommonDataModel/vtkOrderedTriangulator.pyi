"""
This type stub file was generated by pyright.
"""

import vtkmodules.vtkCommonCore as __vtkmodules_vtkCommonCore

class vtkOrderedTriangulator(__vtkmodules_vtkCommonCore.vtkObject):
    """
    vtkOrderedTriangulator - helper class to generate triangulations
    
    Superclass: vtkObject
    
    This class is used to generate unique triangulations of points. The
    uniqueness of the triangulation is controlled by the id of the
    inserted points in combination with a Delaunay criterion. The class
    is designed to be as fast as possible (since the algorithm can be
    slow) and uses block memory allocations to support rapid
    triangulation generation. Also, the assumption behind the class is
    that a maximum of hundreds of points are to be triangulated. If you
    desire more robust triangulation methods use
    vtkPolygon::Triangulate(), vtkDelaunay2D, or vtkDelaunay3D.
    
    @par Background: This work is documented in the technical paper: W.J.
    Schroeder, B. Geveci, M. Malaterre. Compatible Triangulations of
    Spatial Decompositions. In Proceedings of Visualization 2004, IEEE
    Press October 2004.
    
    @par Background: Delaunay triangulations are unique assuming a random
    distribution of input points. The 3D Delaunay criterion is as
    follows: the circumsphere of each tetrahedron contains no other
    points of the triangulation except for the four points defining the
    tetrahedron.  In application this property is hard to satisfy because
    objects like cubes are defined by eight points all sharing the same
    circumsphere (center and radius); hence the Delaunay triangulation is
    not unique.  These so-called degenerate situations are typically
    resolved by arbitrary selecting a triangulation. This code does
    something different: it resolves degenerate triangulations by
    modifying the "InCircumsphere" method to use a slightly smaller
    radius. Hence, degenerate points are always considered "out" of the
    circumsphere. This, in combination with an ordering (based on id) of
    the input points, guarantees a unique triangulation.
    
    @par Background: There is another related characteristic of Delaunay
    triangulations. Given a N-dimensional Delaunay triangulation, points
    laying on a (N-1) dimensional plane also form a (N-1) Delaunay
    triangulation. This means for example, that if a 3D cell is defined
    by a set of (2D) planar faces, then the face triangulations are
    Delaunay. Combining this with the method to generate unique
    triangulations described previously, the triangulations on the face
    are guaranteed unique. This fact can be used to triangulate 3D
    objects in such a way to guarantee compatible face triangulations.
    This is a very useful fact for parallel processing, or performing
    operations like clipping that require compatible triangulations
    across 3D cell faces. (See vtkClipVolume for an example.)
    
    @par Background: A special feature of this class is that it can
    generate triangulation templates on the fly. If template
    triangulation is enabled, then the ordered triangulator will first
    triangulate the cell using the slower ordered Delaunay approach, and
    then store the result as a template. Later, if the same cell type and
    cell configuration is encountered, then the template is reused which
    greatly speeds the triangulation.
    
    @warning
    Duplicate vertices will be ignored, i.e., if two points have the same
    coordinates the second one is discarded. The implications are that
    the user of this class must prevent duplicate points. Because the
    precision of this algorithm is double, it's also a good idea to merge
    points that are within some epsilon of one another.
    
    @warning
    The triangulation is performed using the parametric coordinates of
    the inserted points. Therefore the bounds (see InitTriangulation())
    should represent the range of the parametric coordinates of the
    inserted points.
    
    @sa
    vtkDelaunay2D vtkDelaunay3D vtkPolygon
    """
    def AddTetras(self, p_int, vtkUnstructuredGrid):
        """
        V.AddTetras(int, vtkUnstructuredGrid) -> int
        C++: vtkIdType AddTetras(int classification,
            vtkUnstructuredGrid *ugrid)
        V.AddTetras(int, vtkCellArray) -> int
        C++: vtkIdType AddTetras(int classification,
            vtkCellArray *connectivity)
        V.AddTetras(int, vtkIncrementalPointLocator, vtkCellArray,
            vtkPointData, vtkPointData, vtkCellData, int, vtkCellData)
            -> int
        C++: vtkIdType AddTetras(int classification,
            vtkIncrementalPointLocator *locator,
            vtkCellArray *outConnectivity, vtkPointData *inPD,
            vtkPointData *outPD, vtkCellData *inCD, vtkIdType cellId,
            vtkCellData *outCD)
        V.AddTetras(int, vtkIdList, vtkPoints) -> int
        C++: vtkIdType AddTetras(int classification, vtkIdList *ptIds,
            vtkPoints *pts)
        
        Add the tetras to the unstructured grid provided. The
        unstructured grid is assumed to have been initialized (with
        Allocate()) and points set (with SetPoints()). The tetrahdera
        added are of the type specified (0=inside,1=outside,2=all).
        Inside tetrahedron are those whose points are classified "inside"
        or on the "boundary." Outside tetrahedron have at least one point
        classified "outside." The method returns the number of
        tetrahedrahedron of the type requested.
        """
        ...
    
    def AddTriangles(self, vtkCellArray):
        """
        V.AddTriangles(vtkCellArray) -> int
        C++: vtkIdType AddTriangles(vtkCellArray *connectivity)
        V.AddTriangles(int, vtkCellArray) -> int
        C++: vtkIdType AddTriangles(vtkIdType id,
            vtkCellArray *connectivity)
        
        Add the triangle faces classified (2=boundary) to the
        connectivity list provided. The method returns the number of
        triangles.
        """
        ...
    
    def GetNextTetra(self, p_int, vtkTetra, vtkDataArray, vtkDoubleArray):
        """
        V.GetNextTetra(int, vtkTetra, vtkDataArray, vtkDoubleArray) -> int
        C++: int GetNextTetra(int classification, vtkTetra *tet,
            vtkDataArray *cellScalars, vtkDoubleArray *tetScalars)
        
        Methods to get one tetra at a time. Start with
        InitTetraTraversal() and then invoke GetNextTetra() until the
        method returns 0. cellScalars are point-centered scalars on the
        original cell. tetScalars are point-centered scalars on the
        tetra: the values will be copied from cellScalars.
        \pre tet_exists: tet!=0
        \pre cellScalars_exists: cellScalars!=0
        \pre tetScalars_exists: tetScalars!=0
        \pre tetScalars_valid_size: tetScalars->GetNumberOfTuples()==4
        """
        ...
    
    def GetNumberOfGenerationsFromBase(self, string):
        """
        V.GetNumberOfGenerationsFromBase(string) -> int
        C++: vtkIdType GetNumberOfGenerationsFromBase(const char *type)
            override;
        
        Given a the name of a base class of this class type, return the
        distance of inheritance between this class type and the named
        class (how many generations of inheritance are there between this
        class and the named class). If the named class is not in this
        class's inheritance tree, return a negative value. Valid
        responses will always be nonnegative. This method works in
        combination with vtkTypeMacro found in vtkSetGet.h.
        """
        ...
    
    def GetNumberOfGenerationsFromBaseType(self, string):
        """
        V.GetNumberOfGenerationsFromBaseType(string) -> int
        C++: static vtkIdType GetNumberOfGenerationsFromBaseType(
            const char *type)
        
        Given a the name of a base class of this class type, return the
        distance of inheritance between this class type and the named
        class (how many generations of inheritance are there between this
        class and the named class). If the named class is not in this
        class's inheritance tree, return a negative value. Valid
        responses will always be nonnegative. This method works in
        combination with vtkTypeMacro found in vtkSetGet.h.
        """
        ...
    
    def GetNumberOfPoints(self):
        """
        V.GetNumberOfPoints() -> int
        C++: virtual int GetNumberOfPoints()
        
        Return the number of inserted points.
        """
        ...
    
    def GetPointId(self, p_int):
        """
        V.GetPointId(int) -> int
        C++: vtkIdType GetPointId(vtkIdType internalId)
        
        Return the Id of point `internalId'. This id is the one passed in
        argument of InsertPoint. It assumes that the point has already
        been inserted. The method should be invoked prior to the
        Triangulate method.
        \pre valid_range: internalId>=0 &&
            internalId<this->GetNumberOfPoints()
        """
        ...
    
    def GetPointLocation(self, p_int):
        """
        V.GetPointLocation(int) -> (float, ...)
        C++: double *GetPointLocation(vtkIdType internalId)
        
        Return the global coordinates of point `internalId'. It assumes
        that the point has already been inserted. The method should be
        invoked prior to the Triangulate method.
        \pre valid_range: internalId>=0 &&
            internalId<this->GetNumberOfPoints()
        """
        ...
    
    def GetPointPosition(self, p_int):
        """
        V.GetPointPosition(int) -> (float, ...)
        C++: double *GetPointPosition(vtkIdType internalId)
        
        Return the parametric coordinates of point `internalId'. It
        assumes that the point has already been inserted. The method
        should be invoked prior to the Triangulate method.
        \pre valid_range: internalId>=0 &&
            internalId<this->GetNumberOfPoints()
        """
        ...
    
    def GetPreSorted(self):
        """
        V.GetPreSorted() -> int
        C++: virtual vtkTypeBool GetPreSorted()
        
        Boolean indicates whether the points have been pre-sorted. If
        pre-sorted is enabled, the points are not sorted on point id. By
        default, presorted is off. (The point id is defined in
        InsertPoint().)
        """
        ...
    
    def GetTetras(self, p_int, vtkUnstructuredGrid):
        """
        V.GetTetras(int, vtkUnstructuredGrid) -> int
        C++: vtkIdType GetTetras(int classification,
            vtkUnstructuredGrid *ugrid)
        
        Initialize and add the tetras and points from the triangulation
        to the unstructured grid provided.  New points are created and
        the mesh is allocated. (This method differs from AddTetras() in
        that it inserts points and cells; AddTetras only adds the tetra
        cells.) The tetrahdera added are of the type specified
        (0=inside,1=outside,2=all). Inside tetrahedron are those whose
        points are classified "inside" or on the "boundary."  Outside
        tetrahedron have at least one point classified "outside."  The
        method returns the number of tetrahedrahedron of the type
        requested.
        """
        ...
    
    def GetUseTemplates(self):
        """
        V.GetUseTemplates() -> int
        C++: virtual vtkTypeBool GetUseTemplates()
        
        If this flag is set, then the ordered triangulator will create
        and use templates for the triangulation. To use templates, the
        TemplateTriangulate() method should be called when appropriate.
        (Note: the TemplateTriangulate() method works for complete
        (interior) cells without extra points due to intersection, etc.)
        """
        ...
    
    def GetUseTwoSortIds(self):
        """
        V.GetUseTwoSortIds() -> int
        C++: virtual vtkTypeBool GetUseTwoSortIds()
        
        Tells the triangulator that a second sort id is provided for each
        point and should also be considered when sorting.
        """
        ...
    
    def InitTetraTraversal(self):
        """
        V.InitTetraTraversal()
        C++: void InitTetraTraversal()
        
        Methods to get one tetra at a time. Start with
        InitTetraTraversal() and then invoke GetNextTetra() until the
        method returns 0.
        """
        ...
    
    def InitTriangulation(self, p_float, p_float_1, p_float_2, p_float_3, p_float_4, p_float_5, p_int):
        """
        V.InitTriangulation(float, float, float, float, float, float, int)
        C++: void InitTriangulation(double xmin, double xmax, double ymin,
             double ymax, double zmin, double zmax, int numPts)
        V.InitTriangulation([float, float, float, float, float, float],
            int)
        C++: void InitTriangulation(double bounds[6], int numPts)
        
        Initialize the triangulation process. Provide a bounding box and
        the maximum number of points to be inserted. Note that since the
        triangulation is performed using parametric coordinates (see
        InsertPoint()) the bounds should be represent the range of the
        parametric coordinates inserted.
        \post no_point_inserted: GetNumberOfPoints()==0
        """
        ...
    
    def InsertPoint(self, p_int, p_float=..., p_float=..., p_float=..., *args, **kwargs):
        """
        V.InsertPoint(int, [float, float, float], [float, float, float],
            int) -> int
        C++: vtkIdType InsertPoint(vtkIdType id, double x[3], double p[3],
             int type)
        V.InsertPoint(int, int, [float, float, float], [float, float,
            float], int) -> int
        C++: vtkIdType InsertPoint(vtkIdType id, vtkIdType sortid,
            double x[3], double p[3], int type)
        V.InsertPoint(int, int, int, [float, float, float], [float, float,
             float], int) -> int
        C++: vtkIdType InsertPoint(vtkIdType id, vtkIdType sortid,
            vtkIdType sortid2, double x[3], double p[3], int type)
        
        For each point to be inserted, provide an id, a position x,
        parametric coordinate p, and whether the point is inside
        (type=0), outside (type=1), or on the boundary (type=2). You must
        call InitTriangulation() prior to invoking this method. Make sure
        that the number of points inserted does not exceed the numPts
        specified in InitTriangulation(). Also note that the "id" can be
        any integer and can be greater than numPts. It is used to create
        tetras (in AddTetras()) with the appropriate connectivity ids.
        The method returns an internal id that can be used prior to the
        Triangulate() method to update the type of the point with
        UpdatePointType(). (Note: the algorithm triangulated with the
        parametric coordinate p[3] and creates tetras with the global
        coordinate x[3]. The parametric coordinates and global
        coordinates may be the same.)
        """
        ...
    
    def IsA(self, string):
        """
        V.IsA(string) -> int
        C++: vtkTypeBool IsA(const char *type) override;
        
        Return 1 if this class is the same type of (or a subclass of) the
        named class. Returns 0 otherwise. This method works in
        combination with vtkTypeMacro found in vtkSetGet.h.
        """
        ...
    
    def IsTypeOf(self, string):
        """
        V.IsTypeOf(string) -> int
        C++: static vtkTypeBool IsTypeOf(const char *type)
        
        Return 1 if this class type is the same type of (or a subclass
        of) the named class. Returns 0 otherwise. This method works in
        combination with vtkTypeMacro found in vtkSetGet.h.
        """
        ...
    
    def NewInstance(self):
        """
        V.NewInstance() -> vtkOrderedTriangulator
        C++: vtkOrderedTriangulator *NewInstance()
        """
        ...
    
    def PreSortedOff(self):
        """
        V.PreSortedOff()
        C++: virtual void PreSortedOff()
        
        Boolean indicates whether the points have been pre-sorted. If
        pre-sorted is enabled, the points are not sorted on point id. By
        default, presorted is off. (The point id is defined in
        InsertPoint().)
        """
        ...
    
    def PreSortedOn(self):
        """
        V.PreSortedOn()
        C++: virtual void PreSortedOn()
        
        Boolean indicates whether the points have been pre-sorted. If
        pre-sorted is enabled, the points are not sorted on point id. By
        default, presorted is off. (The point id is defined in
        InsertPoint().)
        """
        ...
    
    def SafeDownCast(self, vtkObjectBase):
        """
        V.SafeDownCast(vtkObjectBase) -> vtkOrderedTriangulator
        C++: static vtkOrderedTriangulator *SafeDownCast(vtkObjectBase *o)
        """
        ...
    
    def SetPreSorted(self, p_int):
        """
        V.SetPreSorted(int)
        C++: virtual void SetPreSorted(vtkTypeBool _arg)
        
        Boolean indicates whether the points have been pre-sorted. If
        pre-sorted is enabled, the points are not sorted on point id. By
        default, presorted is off. (The point id is defined in
        InsertPoint().)
        """
        ...
    
    def SetUseTemplates(self, p_int):
        """
        V.SetUseTemplates(int)
        C++: virtual void SetUseTemplates(vtkTypeBool _arg)
        
        If this flag is set, then the ordered triangulator will create
        and use templates for the triangulation. To use templates, the
        TemplateTriangulate() method should be called when appropriate.
        (Note: the TemplateTriangulate() method works for complete
        (interior) cells without extra points due to intersection, etc.)
        """
        ...
    
    def SetUseTwoSortIds(self, p_int):
        """
        V.SetUseTwoSortIds(int)
        C++: virtual void SetUseTwoSortIds(vtkTypeBool _arg)
        
        Tells the triangulator that a second sort id is provided for each
        point and should also be considered when sorting.
        """
        ...
    
    def TemplateTriangulate(self, p_int, p_int_1, p_int_2):
        """
        V.TemplateTriangulate(int, int, int)
        C++: void TemplateTriangulate(int cellType, int numPts,
            int numEdges)
        
        Perform the triangulation. (Complete all calls to InsertPoint()
        prior to invoking this method.) A special version is available
        when templates should be used.
        """
        ...
    
    def Triangulate(self):
        """
        V.Triangulate()
        C++: void Triangulate()
        
        Perform the triangulation. (Complete all calls to InsertPoint()
        prior to invoking this method.) A special version is available
        when templates should be used.
        """
        ...
    
    def UpdatePointType(self, p_int, p_int_1):
        """
        V.UpdatePointType(int, int)
        C++: void UpdatePointType(vtkIdType internalId, int type)
        
        Update the point type. This is useful when the merging of nearly
        coincident points is performed. The id is the internal id
        returned from InsertPoint(). The method should be invoked prior
        to the Triangulate method. The type is specified as inside
        (type=0), outside (type=1), or on the boundary (type=2).
        \pre valid_range: internalId>=0 &&
            internalId<this->GetNumberOfPoints()
        """
        ...
    
    def UseTemplatesOff(self):
        """
        V.UseTemplatesOff()
        C++: virtual void UseTemplatesOff()
        
        If this flag is set, then the ordered triangulator will create
        and use templates for the triangulation. To use templates, the
        TemplateTriangulate() method should be called when appropriate.
        (Note: the TemplateTriangulate() method works for complete
        (interior) cells without extra points due to intersection, etc.)
        """
        ...
    
    def UseTemplatesOn(self):
        """
        V.UseTemplatesOn()
        C++: virtual void UseTemplatesOn()
        
        If this flag is set, then the ordered triangulator will create
        and use templates for the triangulation. To use templates, the
        TemplateTriangulate() method should be called when appropriate.
        (Note: the TemplateTriangulate() method works for complete
        (interior) cells without extra points due to intersection, etc.)
        """
        ...
    
    def UseTwoSortIdsOff(self):
        """
        V.UseTwoSortIdsOff()
        C++: virtual void UseTwoSortIdsOff()
        
        Tells the triangulator that a second sort id is provided for each
        point and should also be considered when sorting.
        """
        ...
    
    def UseTwoSortIdsOn(self):
        """
        V.UseTwoSortIdsOn()
        C++: virtual void UseTwoSortIdsOn()
        
        Tells the triangulator that a second sort id is provided for each
        point and should also be considered when sorting.
        """
        ...
    
    def __delattr__(self, *args, **kwargs):
        """ Implement delattr(self, name). """
        ...
    
    def __getattribute__(self, *args, **kwargs):
        """ Return getattr(self, name). """
        ...
    
    def __init__(self, *args, **kwargs) -> None:
        ...
    
    @staticmethod
    def __new__(*args, **kwargs):
        """ Create and return a new object.  See help(type) for accurate signature. """
        ...
    
    def __repr__(self, *args, **kwargs):
        """ Return repr(self). """
        ...
    
    def __setattr__(self, *args, **kwargs):
        """ Implement setattr(self, name, value). """
        ...
    
    def __str__(self, *args, **kwargs) -> str:
        """ Return str(self). """
        ...
    
    __this__ = ...
    __dict__ = ...
    __vtkname__ = ...


