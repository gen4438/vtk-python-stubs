"""
This type stub file was generated by pyright.
"""

from .vtkNonLinearCell import vtkNonLinearCell

class vtkQuadraticPolygon(vtkNonLinearCell):
    """
    vtkQuadraticPolygon - a cell that represents a parabolic n-sided
    polygon
    
    Superclass: vtkNonLinearCell
    
    vtkQuadraticPolygon is a concrete implementation of vtkNonLinearCell
    to represent a 2D n-sided (2*n nodes) parabolic polygon. The polygon
    cannot have any internal holes, and cannot self-intersect. The cell
    includes a mid-edge node for each of the n edges of the cell. The
    ordering of the 2*n points defining the cell are point ids (0..n-1
    and n..2*n-1) where ids 0..n-1 define the corner vertices of the
    polygon; ids n..2*n-1 define the midedge nodes. Define the polygon
    with points ordered in the counter- clockwise direction; do not
    repeat the last point.
    
    @sa
    vtkQuadraticEdge vtkQuadraticTriangle vtkQuadraticTetra
    vtkQuadraticHexahedron vtkQuadraticWedge vtkQuadraticPyramid
    """
    def CellBoundary(self, p_int, , vtkIdList):
        """
        V.CellBoundary(int, (float, float, float), vtkIdList) -> int
        C++: int CellBoundary(int subId, const double pcoords[3],
            vtkIdList *pts) override;
        
        These methods are based on the vtkPolygon ones : the
        vtkQuadraticPolygon (with n edges and 2*n points) is transform
        into a vtkPolygon (with 2*n edges and 2*n points) and the
        vtkPolygon methods are called.
        """
        ...
    
    def Clip(self, p_float, vtkDataArray, vtkIncrementalPointLocator, vtkCellArray, vtkPointData, vtkPointData_1, vtkCellData, p_int, vtkCellData_1, p_int_1):
        """
        V.Clip(float, vtkDataArray, vtkIncrementalPointLocator,
            vtkCellArray, vtkPointData, vtkPointData, vtkCellData, int,
            vtkCellData, int)
        C++: void Clip(double value, vtkDataArray *cellScalars,
            vtkIncrementalPointLocator *locator, vtkCellArray *polys,
            vtkPointData *inPd, vtkPointData *outPd, vtkCellData *inCd,
            vtkIdType cellId, vtkCellData *outCd, int insideOut) override;
        
        These methods are based on the vtkPolygon ones : the
        vtkQuadraticPolygon (with n edges and 2*n points) is transform
        into a vtkPolygon (with 2*n edges and 2*n points) and the
        vtkPolygon methods are called.
        """
        ...
    
    def ComputeCentroid(self, vtkIdTypeArray, vtkPoints, p_float=..., p_float=..., p_float=...):
        """
        V.ComputeCentroid(vtkIdTypeArray, vtkPoints, [float, float,
            float])
        C++: static void ComputeCentroid(vtkIdTypeArray *ids,
            vtkPoints *pts, double centroid[3])
        
        These methods are based on the vtkPolygon ones : the
        vtkQuadraticPolygon (with n edges and 2*n points) is transform
        into a vtkPolygon (with 2*n edges and 2*n points) and the
        vtkPolygon methods are called.
        """
        ...
    
    def Contour(self, p_float, vtkDataArray, vtkIncrementalPointLocator, vtkCellArray, vtkCellArray_1, vtkCellArray_2, vtkPointData, vtkPointData_1, vtkCellData, p_int, vtkCellData_1):
        """
        V.Contour(float, vtkDataArray, vtkIncrementalPointLocator,
            vtkCellArray, vtkCellArray, vtkCellArray, vtkPointData,
            vtkPointData, vtkCellData, int, vtkCellData)
        C++: void Contour(double value, vtkDataArray *cellScalars,
            vtkIncrementalPointLocator *locator, vtkCellArray *verts,
            vtkCellArray *lines, vtkCellArray *polys, vtkPointData *inPd,
            vtkPointData *outPd, vtkCellData *inCd, vtkIdType cellId,
            vtkCellData *outCd) override;
        
        These methods are based on the vtkPolygon ones : the
        vtkQuadraticPolygon (with n edges and 2*n points) is transform
        into a vtkPolygon (with 2*n edges and 2*n points) and the
        vtkPolygon methods are called.
        """
        ...
    
    def Derivatives(self, p_int, , float_tuple, p_int_1, *float):
        """
        V.Derivatives(int, (float, float, float), (float, ...), int,
            [float, ...])
        C++: void Derivatives(int subId, const double pcoords[3],
            const double *values, int dim, double *derivs) override;
        
        Compute derivatives given cell subId and parametric coordinates.
        The values array is a series of data value(s) at the cell points.
        There is a one-to-one correspondence between cell point and data
        value(s). Dim is the number of data values per cell point. Derivs
        are derivatives in the x-y-z coordinate directions for each data
        value. Thus, if computing derivatives for a scalar function in a
        hexahedron, dim=1, 8 values are supplied, and 3 deriv values are
        returned (i.e., derivatives in x-y-z directions). On the other
        hand, if computing derivatives of velocity (vx,vy,vz) dim=3, 24
        values are supplied ((vx,vy,vz)1, (vx,vy,vz)2, ....()8), and 9
        deriv values are returned ((d(vx)/dx),(d(vx)/dy),(d(vx)/dz),
        (d(vy)/dx),(d(vy)/dy), (d(vy)/dz),
        (d(vz)/dx),(d(vz)/dy),(d(vz)/dz)).
        """
        ...
    
    def DistanceToPolygon(self, p_float=..., p_float=..., p_float=..., *args, **kwargs):
        """
        V.DistanceToPolygon([float, float, float], int, [float, ...],
            [float, float, float, float, float, float], [float, float,
            float]) -> float
        C++: static double DistanceToPolygon(double x[3], int numPts,
            double *pts, double bounds[6], double closest[3])
        
        These methods are based on the vtkPolygon ones : the
        vtkQuadraticPolygon (with n edges and 2*n points) is transform
        into a vtkPolygon (with 2*n edges and 2*n points) and the
        vtkPolygon methods are called.
        """
        ...
    
    def EvaluateLocation(self, p_int, , p_float=..., p_float=..., p_float=..., *args, **kwargs):
        """
        V.EvaluateLocation(int, (float, float, float), [float, float,
            float], [float, ...])
        C++: void EvaluateLocation(int &subId, const double pcoords[3],
            double x[3], double *weights) override;
        
        These methods are based on the vtkPolygon ones : the
        vtkQuadraticPolygon (with n edges and 2*n points) is transform
        into a vtkPolygon (with 2*n edges and 2*n points) and the
        vtkPolygon methods are called.
        """
        ...
    
    def EvaluatePosition(self, , p_float=..., p_float=..., p_float=..., *args, **kwargs):
        """
        V.EvaluatePosition((float, float, float), [float, float, float],
            int, [float, float, float], float, [float, ...]) -> int
        C++: int EvaluatePosition(const double x[3],
            double closestPoint[3], int &subId, double pcoords[3],
            double &dist2, double weights[]) override;
        
        These methods are based on the vtkPolygon ones : the
        vtkQuadraticPolygon (with n edges and 2*n points) is transform
        into a vtkPolygon (with 2*n edges and 2*n points) and the
        vtkPolygon methods are called.
        """
        ...
    
    def GetCellDimension(self):
        """
        V.GetCellDimension() -> int
        C++: int GetCellDimension() override;
        
        Return the topological dimensional of the cell (0,1,2, or 3).
        """
        ...
    
    def GetCellType(self):
        """
        V.GetCellType() -> int
        C++: int GetCellType() override;
        
        Implement the vtkCell API. See the vtkCell API for descriptions
        of these methods.
        """
        ...
    
    def GetEdge(self, p_int):
        """
        V.GetEdge(int) -> vtkCell
        C++: vtkCell *GetEdge(int) override;
        
        Return the edge cell from the edgeId of the cell.
        """
        ...
    
    def GetFace(self, p_int):
        """
        V.GetFace(int) -> vtkCell
        C++: vtkCell *GetFace(int) override;
        
        Return the face cell from the faceId of the cell.
        """
        ...
    
    def GetNumberOfEdges(self):
        """
        V.GetNumberOfEdges() -> int
        C++: int GetNumberOfEdges() override;
        
        Return the number of edges in the cell.
        """
        ...
    
    def GetNumberOfFaces(self):
        """
        V.GetNumberOfFaces() -> int
        C++: int GetNumberOfFaces() override;
        
        Return the number of faces in the cell.
        """
        ...
    
    def GetNumberOfGenerationsFromBase(self, string):
        """
        V.GetNumberOfGenerationsFromBase(string) -> int
        C++: vtkIdType GetNumberOfGenerationsFromBase(const char *type)
            override;
        
        Given a the name of a base class of this class type, return the
        distance of inheritance between this class type and the named
        class (how many generations of inheritance are there between this
        class and the named class). If the named class is not in this
        class's inheritance tree, return a negative value. Valid
        responses will always be nonnegative. This method works in
        combination with vtkTypeMacro found in vtkSetGet.h.
        """
        ...
    
    def GetNumberOfGenerationsFromBaseType(self, string):
        """
        V.GetNumberOfGenerationsFromBaseType(string) -> int
        C++: static vtkIdType GetNumberOfGenerationsFromBaseType(
            const char *type)
        
        Given a the name of a base class of this class type, return the
        distance of inheritance between this class type and the named
        class (how many generations of inheritance are there between this
        class and the named class). If the named class is not in this
        class's inheritance tree, return a negative value. Valid
        responses will always be nonnegative. This method works in
        combination with vtkTypeMacro found in vtkSetGet.h.
        """
        ...
    
    def GetUseMVCInterpolation(self):
        """
        V.GetUseMVCInterpolation() -> bool
        C++: virtual bool GetUseMVCInterpolation()
        
        Set/Get the flag indicating whether to use Mean Value Coordinate
        for the interpolation. If true, InterpolateFunctions() uses the
        Mean Value Coordinate to compute weights. Otherwise, the
        conventional 1/r^2 method is used. The UseMVCInterpolation
        parameter is set to true by default.
        """
        ...
    
    def InterpolateFunctions(self, , *float):
        """
        V.InterpolateFunctions((float, float, float), [float, ...])
        C++: void InterpolateFunctions(const double x[3], double *weights)
             override;
        
        These methods are based on the vtkPolygon ones : the
        vtkQuadraticPolygon (with n edges and 2*n points) is transform
        into a vtkPolygon (with 2*n edges and 2*n points) and the
        vtkPolygon methods are called.
        """
        ...
    
    def IntersectConvex2DCells(self, vtkCell, vtkCell_1, p_float, p_float=..., p_float=..., p_float=..., *args, **kwargs):
        """
        V.IntersectConvex2DCells(vtkCell, vtkCell, float, [float, float,
            float], [float, float, float]) -> int
        C++: static int IntersectConvex2DCells(vtkCell *cell1,
            vtkCell *cell2, double tol, double p0[3], double p1[3])
        
        These methods are based on the vtkPolygon ones : the
        vtkQuadraticPolygon (with n edges and 2*n points) is transform
        into a vtkPolygon (with 2*n edges and 2*n points) and the
        vtkPolygon methods are called.
        """
        ...
    
    def IntersectPolygonWithPolygon(self, p_int, *float, **kwargs):
        """
        V.IntersectPolygonWithPolygon(int, [float, ...], [float, float,
            float, float, float, float], int, [float, ...], [float, float,
             float, float, float, float], float, [float, float, float])
            -> int
        C++: static int IntersectPolygonWithPolygon(int npts, double *pts,
             double bounds[6], int npts2, double *pts2, double bounds2[6],
             double tol, double x[3])
        
        These methods are based on the vtkPolygon ones : the
        vtkQuadraticPolygon (with n edges and 2*n points) is transform
        into a vtkPolygon (with 2*n edges and 2*n points) and the
        vtkPolygon methods are called.
        """
        ...
    
    def IntersectWithLine(self, , , p_float_6, p_float_7, p_float=..., p_float=..., p_float=..., *args, **kwargs):
        """
        V.IntersectWithLine((float, float, float), (float, float, float),
            float, float, [float, float, float], [float, float, float],
            int) -> int
        C++: int IntersectWithLine(const double p1[3], const double p2[3],
             double tol, double &t, double x[3], double pcoords[3],
            int &subId) override;
        
        These methods are based on the vtkPolygon ones : the
        vtkQuadraticPolygon (with n edges and 2*n points) is transform
        into a vtkPolygon (with 2*n edges and 2*n points) and the
        vtkPolygon methods are called.
        """
        ...
    
    def IsA(self, string):
        """
        V.IsA(string) -> int
        C++: vtkTypeBool IsA(const char *type) override;
        
        Return 1 if this class is the same type of (or a subclass of) the
        named class. Returns 0 otherwise. This method works in
        combination with vtkTypeMacro found in vtkSetGet.h.
        """
        ...
    
    def IsPrimaryCell(self):
        """
        V.IsPrimaryCell() -> int
        C++: int IsPrimaryCell() override;
        
        Return whether this cell type has a fixed topology or whether the
        topology varies depending on the data (e.g., vtkConvexPointSet).
        This compares to composite cells that are typically composed of
        primary cells (e.g., a triangle strip composite cell is made up
        of triangle primary cells).
        """
        ...
    
    def IsTypeOf(self, string):
        """
        V.IsTypeOf(string) -> int
        C++: static vtkTypeBool IsTypeOf(const char *type)
        
        Return 1 if this class type is the same type of (or a subclass
        of) the named class. Returns 0 otherwise. This method works in
        combination with vtkTypeMacro found in vtkSetGet.h.
        """
        ...
    
    def NewInstance(self):
        """
        V.NewInstance() -> vtkQuadraticPolygon
        C++: vtkQuadraticPolygon *NewInstance()
        """
        ...
    
    def NonDegenerateTriangulate(self, vtkIdList):
        """
        V.NonDegenerateTriangulate(vtkIdList) -> int
        C++: int NonDegenerateTriangulate(vtkIdList *outTris)
        
        These methods are based on the vtkPolygon ones : the
        vtkQuadraticPolygon (with n edges and 2*n points) is transform
        into a vtkPolygon (with 2*n edges and 2*n points) and the
        vtkPolygon methods are called.
        """
        ...
    
    def ParameterizePolygon(self, p_float=..., p_float=..., p_float=..., *args, **kwargs):
        """
        V.ParameterizePolygon([float, float, float], [float, float,
            float], float, [float, float, float], float, [float, float,
            float]) -> int
        C++: int ParameterizePolygon(double p0[3], double p10[3],
            double &l10, double p20[3], double &l20, double n[3])
        
        These methods are based on the vtkPolygon ones : the
        vtkQuadraticPolygon (with n edges and 2*n points) is transform
        into a vtkPolygon (with 2*n edges and 2*n points) and the
        vtkPolygon methods are called.
        """
        ...
    
    def PointInPolygon(self, p_float=..., p_float=..., p_float=..., *args, **kwargs):
        """
        V.PointInPolygon([float, float, float], int, [float, ...], [float,
             float, float, float, float, float], [float, float, float])
            -> int
        C++: static int PointInPolygon(double x[3], int numPts,
            double *pts, double bounds[6], double n[3])
        
        These methods are based on the vtkPolygon ones : the
        vtkQuadraticPolygon (with n edges and 2*n points) is transform
        into a vtkPolygon (with 2*n edges and 2*n points) and the
        vtkPolygon methods are called.
        """
        ...
    
    def SafeDownCast(self, vtkObjectBase):
        """
        V.SafeDownCast(vtkObjectBase) -> vtkQuadraticPolygon
        C++: static vtkQuadraticPolygon *SafeDownCast(vtkObjectBase *o)
        """
        ...
    
    def SetUseMVCInterpolation(self, bool):
        """
        V.SetUseMVCInterpolation(bool)
        C++: virtual void SetUseMVCInterpolation(bool _arg)
        
        Set/Get the flag indicating whether to use Mean Value Coordinate
        for the interpolation. If true, InterpolateFunctions() uses the
        Mean Value Coordinate to compute weights. Otherwise, the
        conventional 1/r^2 method is used. The UseMVCInterpolation
        parameter is set to true by default.
        """
        ...
    
    def Triangulate(self, vtkIdList):
        """
        V.Triangulate(vtkIdList) -> int
        C++: int Triangulate(vtkIdList *outTris)
        V.Triangulate(int, vtkIdList, vtkPoints) -> int
        C++: int Triangulate(int index, vtkIdList *ptIds, vtkPoints *pts)
            override;
        
        These methods are based on the vtkPolygon ones : the
        vtkQuadraticPolygon (with n edges and 2*n points) is transform
        into a vtkPolygon (with 2*n edges and 2*n points) and the
        vtkPolygon methods are called.
        """
        ...
    
    def __delattr__(self, *args, **kwargs):
        """ Implement delattr(self, name). """
        ...
    
    def __getattribute__(self, *args, **kwargs):
        """ Return getattr(self, name). """
        ...
    
    def __init__(self, *args, **kwargs) -> None:
        ...
    
    @staticmethod
    def __new__(*args, **kwargs):
        """ Create and return a new object.  See help(type) for accurate signature. """
        ...
    
    def __repr__(self, *args, **kwargs):
        """ Return repr(self). """
        ...
    
    def __setattr__(self, *args, **kwargs):
        """ Implement setattr(self, name, value). """
        ...
    
    def __str__(self, *args, **kwargs) -> str:
        """ Return str(self). """
        ...
    
    __this__ = ...
    __dict__ = ...
    __vtkname__ = ...


