"""
This type stub file was generated by pyright.
"""

from .vtkCell import vtkCell

class vtkTriangle(vtkCell):
    """
    vtkTriangle - a cell that represents a triangle
    
    Superclass: vtkCell
    
    vtkTriangle is a concrete implementation of vtkCell to represent a
    triangle located in 3-space.
    """
    def BarycentricCoords(self, , , , , p_float=..., p_float=..., p_float=...):
        """
        V.BarycentricCoords((float, float), (float, float), (float, float)
            , (float, float), [float, float, float]) -> int
        C++: static int BarycentricCoords(const double x[2],
            const double x1[2], const double x2[2], const double x3[2],
            double bcoords[3])
        
        Given a 2D point x[2], determine the barycentric coordinates of
        the point. Barycentric coordinates are a natural coordinate
        system for simplices that express a position as a linear
        combination of the vertices. For a triangle, there are three
        barycentric coordinates (because there are three vertices), and
        the sum of the coordinates must equal 1. If a point x is inside a
        simplex, then all three coordinates will be strictly positive. 
        If two coordinates are zero (so the third =1), then the point x
        is on a vertex. If one coordinates are zero, the point x is on an
        edge. In this method, you must specify the vertex coordinates
        x1->x3. Returns 0 if triangle is degenerate.
        """
        ...
    
    def CellBoundary(self, p_int, , vtkIdList):
        """
        V.CellBoundary(int, (float, float, float), vtkIdList) -> int
        C++: int CellBoundary(int subId, const double pcoords[3],
            vtkIdList *pts) override;
        
        See the vtkCell API for descriptions of these methods.
        """
        ...
    
    def Circumcircle(self, , , , p_float=..., p_float=...):
        """
        V.Circumcircle((float, float), (float, float), (float, float),
            [float, float]) -> float
        C++: static double Circumcircle(const double p1[2],
            const double p2[2], const double p3[2], double center[2])
        
        Compute the circumcenter (center[3]) and radius squared (method
        return value) of a triangle defined by the three points x1, x2,
        and x3. (Note that the coordinates are 2D. 3D points can be used
        but the z-component will be ignored.)
        """
        ...
    
    def Clip(self, p_float, vtkDataArray, vtkIncrementalPointLocator, vtkCellArray, vtkPointData, vtkPointData_1, vtkCellData, p_int, vtkCellData_1, p_int_1):
        """
        V.Clip(float, vtkDataArray, vtkIncrementalPointLocator,
            vtkCellArray, vtkPointData, vtkPointData, vtkCellData, int,
            vtkCellData, int)
        C++: void Clip(double value, vtkDataArray *cellScalars,
            vtkIncrementalPointLocator *locator, vtkCellArray *polys,
            vtkPointData *inPd, vtkPointData *outPd, vtkCellData *inCd,
            vtkIdType cellId, vtkCellData *outCd, int insideOut) override;
        
        Clip this triangle using scalar value provided. Like contouring,
        except that it cuts the triangle to produce other triangles.
        """
        ...
    
    def ComputeArea(self):
        """
        V.ComputeArea() -> float
        C++: double ComputeArea()
        
        A convenience function to compute the area of a vtkTriangle.
        """
        ...
    
    def ComputeCentroid(self, vtkPoints, int_tuple, p_float=..., p_float=..., p_float=...):
        """
        V.ComputeCentroid(vtkPoints, (int, ...), [float, float, float])
            -> bool
        C++: static bool ComputeCentroid(vtkPoints *points,
            const vtkIdType *pointIds, double centroid[3])
        
        Get the centroid of the triangle. pointIds can be nullptr if ids
        are {0, 1, 2}
        """
        ...
    
    def ComputeNormal(self, vtkPoints, p_int, int_tuple, p_float=..., p_float=..., p_float=...):
        """
        V.ComputeNormal(vtkPoints, int, (int, ...), [float, float, float])
        C++: static void ComputeNormal(vtkPoints *p, int numPts,
            const vtkIdType *pts, double n[3])
        V.ComputeNormal((float, float, float), (float, float, float), (
            float, float, float), [float, float, float])
        C++: static void ComputeNormal(const double v1[3],
            const double v2[3], const double v3[3], double n[3])
        
        Compute the triangle normal from a points list, and a list of
        point ids that index into the points list.
        """
        ...
    
    def ComputeNormalDirection(self, , , , p_float=..., p_float=..., p_float=...):
        """
        V.ComputeNormalDirection((float, float, float), (float, float,
            float), (float, float, float), [float, float, float])
        C++: static void ComputeNormalDirection(const double v1[3],
            const double v2[3], const double v3[3], double n[3])
        
        Compute the (unnormalized) triangle normal direction from three
        points.
        """
        ...
    
    def ComputeQuadric(self, , , , *args, **kwargs):
        """
        V.ComputeQuadric((float, float, float), (float, float, float), (
            float, float, float), [[float, float, float, float], [float,
            float, float, float], [float, float, float, float], [float,
            float, float, float]])
        C++: static void ComputeQuadric(const double x1[3],
            const double x2[3], const double x3[3], double quadric[4][4])
        V.ComputeQuadric((float, float, float), (float, float, float), (
            float, float, float), vtkQuadric)
        C++: static void ComputeQuadric(const double x1[3],
            const double x2[3], const double x3[3], vtkQuadric *quadric)
        
        Calculate the error quadric for this triangle.  Return the
        quadric as a 4x4 matrix or a vtkQuadric.  (from Peter Lindstrom's
        Siggraph 2000 paper, "Out-of-Core Simplification of Large
        Polygonal Models")
        """
        ...
    
    def Contour(self, p_float, vtkDataArray, vtkIncrementalPointLocator, vtkCellArray, vtkCellArray_1, vtkCellArray_2, vtkPointData, vtkPointData_1, vtkCellData, p_int, vtkCellData_1):
        """
        V.Contour(float, vtkDataArray, vtkIncrementalPointLocator,
            vtkCellArray, vtkCellArray, vtkCellArray, vtkPointData,
            vtkPointData, vtkCellData, int, vtkCellData)
        C++: void Contour(double value, vtkDataArray *cellScalars,
            vtkIncrementalPointLocator *locator, vtkCellArray *verts,
            vtkCellArray *lines, vtkCellArray *polys, vtkPointData *inPd,
            vtkPointData *outPd, vtkCellData *inCd, vtkIdType cellId,
            vtkCellData *outCd) override;
        
        See the vtkCell API for descriptions of these methods.
        """
        ...
    
    def Derivatives(self, p_int, , float_tuple, p_int_1, *float):
        """
        V.Derivatives(int, (float, float, float), (float, ...), int,
            [float, ...])
        C++: void Derivatives(int subId, const double pcoords[3],
            const double *values, int dim, double *derivs) override;
        
        See the vtkCell API for descriptions of these methods.
        """
        ...
    
    def EvaluateLocation(self, p_int, , p_float=..., p_float=..., p_float=..., *args, **kwargs):
        """
        V.EvaluateLocation(int, (float, float, float), [float, float,
            float], [float, ...])
        C++: void EvaluateLocation(int &subId, const double pcoords[3],
            double x[3], double *weights) override;
        
        See the vtkCell API for descriptions of these methods.
        """
        ...
    
    def EvaluatePosition(self, , p_float=..., p_float=..., p_float=..., *args, **kwargs):
        """
        V.EvaluatePosition((float, float, float), [float, float, float],
            int, [float, float, float], float, [float, ...]) -> int
        C++: int EvaluatePosition(const double x[3],
            double closestPoint[3], int &subId, double pcoords[3],
            double &dist2, double weights[]) override;
        
        See the vtkCell API for descriptions of these methods.
        """
        ...
    
    def GetCellDimension(self):
        """
        V.GetCellDimension() -> int
        C++: int GetCellDimension() override;
        
        See the vtkCell API for descriptions of these methods.
        """
        ...
    
    def GetCellType(self):
        """
        V.GetCellType() -> int
        C++: int GetCellType() override;
        
        See the vtkCell API for descriptions of these methods.
        """
        ...
    
    def GetEdge(self, p_int):
        """
        V.GetEdge(int) -> vtkCell
        C++: vtkCell *GetEdge(int edgeId) override;
        
        Get the edge specified by edgeId (range 0 to 2) and return that
        edge's coordinates.
        """
        ...
    
    def GetEdgeArray(self, p_int):
        """
        V.GetEdgeArray(int) -> (int, ...)
        C++: const vtkIdType *GetEdgeArray(vtkIdType edgeId)
        
        Return the ids of the vertices defining edge (`edgeId`). Ids are
        related to the cell, not to the dataset.
        
        ote The return type changed. It used to be int*, it is now const
        vtkIdType*. This is so ids are unified between vtkCell and
        vtkPoints, and so vtkCell ids can be used as inputs in algorithms
        such as vtkPolygon::ComputeNormal.
        """
        ...
    
    def GetFace(self, p_int):
        """
        V.GetFace(int) -> vtkCell
        C++: vtkCell *GetFace(int) override;
        
        See the vtkCell API for descriptions of these methods.
        """
        ...
    
    def GetNumberOfEdges(self):
        """
        V.GetNumberOfEdges() -> int
        C++: int GetNumberOfEdges() override;
        
        See the vtkCell API for descriptions of these methods.
        """
        ...
    
    def GetNumberOfFaces(self):
        """
        V.GetNumberOfFaces() -> int
        C++: int GetNumberOfFaces() override;
        
        See the vtkCell API for descriptions of these methods.
        """
        ...
    
    def GetNumberOfGenerationsFromBase(self, string):
        """
        V.GetNumberOfGenerationsFromBase(string) -> int
        C++: vtkIdType GetNumberOfGenerationsFromBase(const char *type)
            override;
        
        Given a the name of a base class of this class type, return the
        distance of inheritance between this class type and the named
        class (how many generations of inheritance are there between this
        class and the named class). If the named class is not in this
        class's inheritance tree, return a negative value. Valid
        responses will always be nonnegative. This method works in
        combination with vtkTypeMacro found in vtkSetGet.h.
        """
        ...
    
    def GetNumberOfGenerationsFromBaseType(self, string):
        """
        V.GetNumberOfGenerationsFromBaseType(string) -> int
        C++: static vtkIdType GetNumberOfGenerationsFromBaseType(
            const char *type)
        
        Given a the name of a base class of this class type, return the
        distance of inheritance between this class type and the named
        class (how many generations of inheritance are there between this
        class and the named class). If the named class is not in this
        class's inheritance tree, return a negative value. Valid
        responses will always be nonnegative. This method works in
        combination with vtkTypeMacro found in vtkSetGet.h.
        """
        ...
    
    def GetParametricCenter(self, p_float=..., p_float=..., p_float=...):
        """
        V.GetParametricCenter([float, float, float]) -> int
        C++: int GetParametricCenter(double pcoords[3]) override;
        
        Return the center of the triangle in parametric coordinates.
        """
        ...
    
    def GetParametricCoords(self):
        """
        V.GetParametricCoords() -> (float, ...)
        C++: double *GetParametricCoords() override;
        
        See the vtkCell API for descriptions of these methods.
        """
        ...
    
    def GetParametricDistance(self, ):
        """
        V.GetParametricDistance((float, float, float)) -> float
        C++: double GetParametricDistance(const double pcoords[3])
            override;
        
        Return the distance of the parametric coordinate provided to the
        cell. If inside the cell, a distance of zero is returned.
        """
        ...
    
    def InterpolateDerivs(self, , p_float=..., p_float=..., p_float=..., p_float=..., p_float=..., p_float=...):
        """
        V.InterpolateDerivs((float, float, float), [float, float, float,
            float, float, float])
        C++: void InterpolateDerivs(const double pcoords[3],
            double derivs[6]) override;
        
        Compute the interpolation functions/derivatives (aka shape
        functions/derivatives)
        """
        ...
    
    def InterpolateFunctions(self, , p_float=..., p_float=..., p_float=...):
        """
        V.InterpolateFunctions((float, float, float), [float, float,
            float])
        C++: void InterpolateFunctions(const double pcoords[3],
            double sf[3]) override;
        
        Compute the interpolation functions/derivatives (aka shape
        functions/derivatives)
        """
        ...
    
    def InterpolationDerivs(self, , p_float=..., p_float=..., p_float=..., p_float=..., p_float=..., p_float=...):
        """
        V.InterpolationDerivs((float, float, float), [float, float, float,
             float, float, float])
        C++: static void InterpolationDerivs(const double pcoords[3],
            double derivs[6])
        """
        ...
    
    def InterpolationFunctions(self, , p_float=..., p_float=..., p_float=...):
        """
        V.InterpolationFunctions((float, float, float), [float, float,
            float])
        C++: static void InterpolationFunctions(const double pcoords[3],
            double sf[3])
        """
        ...
    
    def IntersectWithLine(self, , , p_float_6, p_float_7, p_float=..., p_float=..., p_float=..., *args, **kwargs):
        """
        V.IntersectWithLine((float, float, float), (float, float, float),
            float, float, [float, float, float], [float, float, float],
            int) -> int
        C++: int IntersectWithLine(const double p1[3], const double p2[3],
             double tol, double &t, double x[3], double pcoords[3],
            int &subId) override;
        
        Plane intersection plus in/out test on triangle. The in/out test
        is performed using tol as the tolerance.
        """
        ...
    
    def IsA(self, string):
        """
        V.IsA(string) -> int
        C++: vtkTypeBool IsA(const char *type) override;
        
        Return 1 if this class is the same type of (or a subclass of) the
        named class. Returns 0 otherwise. This method works in
        combination with vtkTypeMacro found in vtkSetGet.h.
        """
        ...
    
    def IsTypeOf(self, string):
        """
        V.IsTypeOf(string) -> int
        C++: static vtkTypeBool IsTypeOf(const char *type)
        
        Return 1 if this class type is the same type of (or a subclass
        of) the named class. Returns 0 otherwise. This method works in
        combination with vtkTypeMacro found in vtkSetGet.h.
        """
        ...
    
    def NewInstance(self):
        """
        V.NewInstance() -> vtkTriangle
        C++: vtkTriangle *NewInstance()
        """
        ...
    
    def PointInTriangle(self, , , , , p_float_12):
        """
        V.PointInTriangle((float, float, float), (float, float, float), (
            float, float, float), (float, float, float), float) -> int
        C++: static int PointInTriangle(const double x[3],
            const double x1[3], const double x2[3], const double x3[3],
            const double tol2)
        
        Given a point x, determine whether it is inside (within the
        tolerance squared, tol2) the triangle defined by the three
        coordinate values p1, p2, p3. Method is via comparing dot
        products. (Note: in current implementation the tolerance only
        works in the neighborhood of the three vertices of the triangle.
        """
        ...
    
    def ProjectTo2D(self, , , , p_float=..., p_float=..., *args, **kwargs):
        """
        V.ProjectTo2D((float, float, float), (float, float, float), (
            float, float, float), [float, float], [float, float], [float,
            float]) -> int
        C++: static int ProjectTo2D(const double x1[3],
            const double x2[3], const double x3[3], double v1[2],
            double v2[2], double v3[2])
        
        Project triangle defined in 3D to 2D coordinates. Returns 0 if
        degenerate triangle; non-zero value otherwise. Input points are
        x1->x3; output 2D points are v1->v3.
        """
        ...
    
    def SafeDownCast(self, vtkObjectBase):
        """
        V.SafeDownCast(vtkObjectBase) -> vtkTriangle
        C++: static vtkTriangle *SafeDownCast(vtkObjectBase *o)
        """
        ...
    
    def TriangleArea(self, , , ):
        """
        V.TriangleArea((float, float, float), (float, float, float), (
            float, float, float)) -> float
        C++: static double TriangleArea(const double p1[3],
            const double p2[3], const double p3[3])
        
        Compute the area of a triangle in 3D. See also
        vtkTriangle::ComputeArea()
        """
        ...
    
    def TriangleCenter(self, , , , p_float=..., p_float=..., p_float=...):
        """
        V.TriangleCenter((float, float, float), (float, float, float), (
            float, float, float), [float, float, float])
        C++: static void TriangleCenter(const double p1[3],
            const double p2[3], const double p3[3], double center[3])
        
        Compute the center of the triangle.
        """
        ...
    
    def TrianglesIntersect(self, , , , , , ):
        """
        V.TrianglesIntersect((float, float, float), (float, float, float),
             (float, float, float), (float, float, float), (float, float,
            float), (float, float, float)) -> int
        C++: static int TrianglesIntersect(const double p1[3],
            const double q1[3], const double r1[3], const double p2[3],
            const double q2[3], const double r2[3])
        
        Determine whether or not triangle (p1,q1,r1) intersects triangle
        (p2,q2,r2). This method is adapted from Olivier Devillers,
        Philippe Guigue. Faster Triangle-Triangle Intersection Tests.
        RR-4488, IN-RIA. 2002. <inria-00072100>.
        """
        ...
    
    def Triangulate(self, p_int, vtkIdList, vtkPoints):
        """
        V.Triangulate(int, vtkIdList, vtkPoints) -> int
        C++: int Triangulate(int index, vtkIdList *ptIds, vtkPoints *pts)
            override;
        
        See the vtkCell API for descriptions of these methods.
        """
        ...
    
    def __delattr__(self, *args, **kwargs):
        """ Implement delattr(self, name). """
        ...
    
    def __getattribute__(self, *args, **kwargs):
        """ Return getattr(self, name). """
        ...
    
    def __init__(self, *args, **kwargs) -> None:
        ...
    
    @staticmethod
    def __new__(*args, **kwargs):
        """ Create and return a new object.  See help(type) for accurate signature. """
        ...
    
    def __repr__(self, *args, **kwargs):
        """ Return repr(self). """
        ...
    
    def __setattr__(self, *args, **kwargs):
        """ Implement setattr(self, name, value). """
        ...
    
    def __str__(self, *args, **kwargs) -> str:
        """ Return str(self). """
        ...
    
    __this__ = ...
    __dict__ = ...
    __vtkname__ = ...


