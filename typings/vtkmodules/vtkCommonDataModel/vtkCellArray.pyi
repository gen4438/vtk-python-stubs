"""
This type stub file was generated by pyright.
"""

import vtkmodules.vtkCommonCore as __vtkmodules_vtkCommonCore

class vtkCellArray(__vtkmodules_vtkCommonCore.vtkObject):
    """
    vtkCellArray - object to represent cell connectivity
    
    Superclass: vtkObject
    
    vtkCellArray stores dataset topologies as an explicit connectivity
    table listing the point ids that make up each cell.
    
    Internally, the connectivity table is represented as two arrays:
    Offsets and Connectivity.
    
    Offsets is an array of [numCells+1] values indicating the index in
    the Connectivity array where each cell's points start. The last value
    is always the length of the Connectivity array.
    
    The Connectivity array stores the lists of point ids for each cell.
    
    Thus, for a dataset consisting of 2 triangles, a quad, and a line,
    the internal arrays will appear as follows:
    
    ``` Topology:
    --------- Cell 0: Triangle | point ids: {0, 1, 2} Cell 1: Triangle |
        point ids: {5, 7, 2} Cell 2: Quad     | point ids: {3, 4, 6, 7}
        Cell 4: Line     | point ids: {5, 8}
    
    vtkCellArray (current):
    ----------------------- Offsets:      {0, 3, 6, 10, 12} Connectivity:
    {0, 1, 2, 5, 7, 2, 3, 4, 6, 7, 5, 8} ```
    
    While this class provides traversal methods (the legacy
    InitTraversal(), GetNextCell() methods, and the newer method
    GetCellAtId()) these are in general not thread-safe. Whenever
    possible it is preferrable to use a local thread-safe,
    vtkCellArrayIterator object, which can be obtained via:
    
    ``` auto iter = vtk::TakeSmartPointer(cellArray->NewIterator()); for
    (iter->GoToFirstCell(); !iter->IsDoneWithTraversal();
    iter->GoToNextCell()) {
      // do work with iter } ``` (Note however that depending on the type
    and structure of internal storage, a cell array iterator may be
    significantly slower than direct traversal over the cell array due to
    extra data copying. Factors of 3-4X are not uncommon. See
    vtkCellArrayIterator for more information. Also note that an iterator
    may become invalid if the internal vtkCellArray storage is modified.)
    
    Other methods are also available for allocation and memory-related
    management; insertion of new cells into the vtkCellArray; and limited
    editing operations such as replacing one cell with a new cell of the
    same size.
    
    The internal arrays may store either 32- or 64-bit values, though
    most of the API will prefer to use vtkIdType to refer to items in
    these arrays. This enables significant memory savings when vtkIdType
    is 64-bit, but 32 bits are sufficient to store all of the values in
    the connectivity table. Using 64-bit storage with a 32-bit vtkIdType
    is permitted, but values too large to fit in a 32-bit signed integer
    will be truncated when accessed through the API. (The particular
    internal storage type has implications on performance depending on
    vtkIdType. If the internal storage is equivalent to vtkIdType, then
    methods that return pointers to arrays of point ids can share the
    internal storage; otherwise a copy of internal memory must be
    performed.)
    
    Methods for managing the storage type are:
    
    - `bool IsStorage64Bit()`
    - `bool IsStorageShareable() // Can pointers to internal storage be
      shared`
    - `void Use32BitStorage()`
    - `void Use64BitStorage()`
    - `void UseDefaultStorage() // Depends on vtkIdType`
    - `bool CanConvertTo32BitStorage()`
    - `bool CanConvertTo64BitStorage()`
    - `bool CanConvertToDefaultStorage() // Depends on vtkIdType`
    - `bool ConvertTo32BitStorage()`
    - `bool ConvertTo64BitStorage()`
    - `bool ConvertToDefaultStorage() // Depends on vtkIdType`
    - `bool ConvertToSmallestStorage() // Depends on current values in
      arrays`
    
    Note that some legacy methods are still available that reflect the
    previous storage format of this data, which embedded the cell sizes
    into the Connectivity array:
    
    ``` vtkCellArray (legacy):
    ---------------------- Connectivity: {3, 0, 1, 2, 3, 5, 7, 2, 4, 3,
        4, 6, 7, 2, 5, 8} |--Cell 0--||--Cell 1--||----Cell 2---||--C3-|
        ```
    
    The methods require an external lookup table to allow random access,
    which was historically stored in the vtkCellTypes object. The
    following methods in vtkCellArray still support this style of
    indexing for compatibility purposes, but these are slow as they must
    perform some complex computations to convert the old "location" into
    the new "offset" and should be avoided. These methods (and their
    modern equivalents) are:
    
    - GetCell (Prefer GetCellAtId)
    - GetInsertLocation (Prefer GetNumberOfCells)
    - GetTraversalLocation (Prefer GetTraversalCellId, or better,
      NewIterator)
    - SetTraversalLocation (Prefer SetTraversalLocation, or better,
      NewIterator)
    - ReverseCell (Prefer ReverseCellAtId)
    - ReplaceCell (Prefer ReplaceCellAtId)
    - SetCells (Use ImportLegacyFormat, or SetData)
    - GetData (Use ExportLegacyFormat, or
      Get[Offsets|Connectivity]Array[|32|64])
    
    Some other legacy methods were completely removed, such as
    GetPointer() / WritePointer(), since they are cannot be effectively
    emulated under the current design. If external code needs to support
    both the old and new version of the vtkCellArray API, the
    VTK_CELL_ARRAY_V2 preprocessor definition may be used to detect which
    API is being compiled against.
    
    @sa vtkCellTypes vtkCellLinks
    """
    def Allocate(self, p_int, p_int_1):
        """
        V.Allocate(int, int) -> int
        C++: vtkTypeBool Allocate(vtkIdType sz, vtkIdType ext=1000)
        
        Allocate memory.
        
        This currently allocates both the offsets and connectivity arrays
        to sz.
        
        ote It is preferrable to use AllocateEstimate(numCells,
        maxCellSize) or AllocateExact(numCells, connectivitySize)
        instead.
        """
        ...
    
    def AllocateCopy(self, vtkCellArray):
        """
        V.AllocateCopy(vtkCellArray) -> bool
        C++: bool AllocateCopy(vtkCellArray *other)
        
        Pre-allocate memory in internal data structures to match the used
        size of the input vtkCellArray. Does not change the number of
        cells, only the array capacities. Existing data is NOT preserved.
        @param other The vtkCellArray to use as a reference.
        @return True if allocation succeeds.
        @sa Squeeze AllocateEstimate AllocateExact
        """
        ...
    
    def AllocateEstimate(self, p_int, p_int_1):
        """
        V.AllocateEstimate(int, int) -> bool
        C++: bool AllocateEstimate(vtkIdType numCells,
            vtkIdType maxCellSize)
        
        Pre-allocate memory in internal data structures. Does not change
        the number of cells, only the array capacities. Existing data is
        NOT preserved.
        @param numCells The number of expected cells in the dataset.
        @param maxCellSize The number of points per cell to allocate
            memory for.
        @return True if allocation succeeds.
        @sa Squeeze AllocateExact AllocateCopy
        """
        ...
    
    def AllocateExact(self, p_int, p_int_1):
        """
        V.AllocateExact(int, int) -> bool
        C++: bool AllocateExact(vtkIdType numCells,
            vtkIdType connectivitySize)
        
        Pre-allocate memory in internal data structures. Does not change
        the number of cells, only the array capacities. Existing data is
        NOT preserved.
        @param numCells The number of expected cells in the dataset.
        @param connectivitySize The total number of pointIds stored for
            all cells.
        @return True if allocation succeeds.
        @sa Squeeze AllocateEstimate AllocateCopy
        """
        ...
    
    def Append(self, vtkCellArray, p_int):
        """
        V.Append(vtkCellArray, int)
        C++: void Append(vtkCellArray *src, vtkIdType pointOffset=0)
        
        Append cells from src into this. Point ids are offset by
        pointOffset.
        """
        ...
    
    def AppendLegacyFormat(self, vtkIdTypeArray, p_int):
        """
        V.AppendLegacyFormat(vtkIdTypeArray, int)
        C++: void AppendLegacyFormat(vtkIdTypeArray *data,
            vtkIdType ptOffset=0)
        V.AppendLegacyFormat((int, ...), int, int)
        C++: void AppendLegacyFormat(const vtkIdType *data, vtkIdType len,
             vtkIdType ptOffset=0)
        """
        ...
    
    def CanConvertTo32BitStorage(self):
        """
        V.CanConvertTo32BitStorage() -> bool
        C++: bool CanConvertTo32BitStorage()
        """
        ...
    
    def CanConvertTo64BitStorage(self):
        """
        V.CanConvertTo64BitStorage() -> bool
        C++: bool CanConvertTo64BitStorage()
        """
        ...
    
    def CanConvertToDefaultStorage(self):
        """
        V.CanConvertToDefaultStorage() -> bool
        C++: bool CanConvertToDefaultStorage()
        """
        ...
    
    def ConvertTo32BitStorage(self):
        """
        V.ConvertTo32BitStorage() -> bool
        C++: bool ConvertTo32BitStorage()
        """
        ...
    
    def ConvertTo64BitStorage(self):
        """
        V.ConvertTo64BitStorage() -> bool
        C++: bool ConvertTo64BitStorage()
        """
        ...
    
    def ConvertToDefaultStorage(self):
        """
        V.ConvertToDefaultStorage() -> bool
        C++: bool ConvertToDefaultStorage()
        """
        ...
    
    def ConvertToSmallestStorage(self):
        """
        V.ConvertToSmallestStorage() -> bool
        C++: bool ConvertToSmallestStorage()
        """
        ...
    
    def DeepCopy(self, vtkCellArray):
        """
        V.DeepCopy(vtkCellArray)
        C++: void DeepCopy(vtkCellArray *ca)
        
        Perform a deep copy (no reference counting) of the given cell
        array.
        """
        ...
    
    def EstimateSize(self, p_int, p_int_1):
        """
        V.EstimateSize(int, int) -> int
        C++: vtkIdType EstimateSize(vtkIdType numCells, int maxPtsPerCell)
        
        Utility routines help manage memory of cell array. EstimateSize()
        returns a value used to initialize and allocate memory for array
        based on number of cells and maximum number of points making up
        cell.  If every cell is the same size (in terms of number of
        points), then the memory estimate is guaranteed exact. (If not
        exact, use Squeeze() to reclaim any extra memory.)
        
        ote This method was often misused (e.g. called alone and then
        discarding the result). Use AllocateEstimate directly instead.
        """
        ...
    
    def ExportLegacyFormat(self, vtkIdTypeArray):
        """
        V.ExportLegacyFormat(vtkIdTypeArray)
        C++: void ExportLegacyFormat(vtkIdTypeArray *data)
        
        Fill data with the old-style vtkCellArray data layout, e.g.
        
        ``` { n0, p0_0, p0_1, ..., p0_n, n1, p1_0, p1_1, ..., p1_n, ... }
        ```
        
        where `n0` is the number of points in cell 0, and `pX_Y` is the
        Y'th point in cell X.
        """
        ...
    
    def GetActualMemorySize(self):
        """
        V.GetActualMemorySize() -> int
        C++: unsigned long GetActualMemorySize()
        
        Return the memory in kibibytes (1024 bytes) consumed by this cell
        array. Used to support streaming and reading/writing data. The
        value returned is guaranteed to be greater than or equal to the
        memory required to actually represent the data represented by
        this object. The information returned is valid only after the
        pipeline has been updated.
        """
        ...
    
    def GetCell(self, p_int, p_int_1, int_tuple):
        """
        V.GetCell(int, int, (int, ...))
        C++: void GetCell(vtkIdType loc, vtkIdType &npts,
            const vtkIdType *&pts)
        V.GetCell(int, vtkIdList)
        C++: void GetCell(vtkIdType loc, vtkIdList *pts)
        
        Internal method used to retrieve a cell given a legacy offset
        location.
        
        @warning Subsequent calls to this method may invalidate previous
            call
        results.
        
        ote The location-based API is now a super-slow compatibility
        layer. Prefer GetCellAtId.
        """
        ...
    
    def GetCellAtId(self, p_int, p_int_1, int_tuple):
        """
        V.GetCellAtId(int, int, (int, ...))
        C++: void GetCellAtId(vtkIdType cellId, vtkIdType &cellSize,
            vtkIdType const *&cellPoints)
        V.GetCellAtId(int, vtkIdList)
        C++: void GetCellAtId(vtkIdType cellId, vtkIdList *pts)
        
        Return the point ids for the cell at cellId.
        
        @warning Subsequent calls to this method may invalidate previous
            call
        results if the internal storage type is not the same as vtkIdType
        and cannot be shared through the cellPoints pointer. In other
        words, the method may not be thread safe. Check if shareable
        (using IsStorageShareable()), or use a vtkCellArrayIterator to
        guarantee thread safety.
        """
        ...
    
    def GetCellSize(self, p_int):
        """
        V.GetCellSize(int) -> int
        C++: vtkIdType GetCellSize(const vtkIdType cellId)
        
        Return the size of the cell at cellId.
        """
        ...
    
    def GetConnectivityArray(self):
        """
        V.GetConnectivityArray() -> vtkDataArray
        C++: vtkDataArray *GetConnectivityArray()
        """
        ...
    
    def GetConnectivityArray32(self):
        """
        V.GetConnectivityArray32() -> vtkTypeInt32Array
        C++: ArrayType32 *GetConnectivityArray32()
        """
        ...
    
    def GetConnectivityArray64(self):
        """
        V.GetConnectivityArray64() -> vtkTypeInt64Array
        C++: ArrayType64 *GetConnectivityArray64()
        """
        ...
    
    def GetData(self):
        """
        V.GetData() -> vtkIdTypeArray
        C++: vtkIdTypeArray *GetData()
        
        Return the underlying data as a data array.
        
        @warning The returned array is not the actual internal
            representation used
        by vtkCellArray. Modifications to the returned array will not
        change the vtkCellArray's topology.
        
        ote Use ExportLegacyFormat, or
        GetOffsetsArray/GetConnectivityArray instead.
        """
        ...
    
    def GetInsertLocation(self, p_int):
        """
        V.GetInsertLocation(int) -> int
        C++: vtkIdType GetInsertLocation(int npts)
        
        Computes the current legacy insertion location within the
        internal array. Used in conjunction with GetCell(int loc,...).
        
        ote The location-based API is now a super-slow compatibility
        layer.
        """
        ...
    
    def GetMaxCellSize(self):
        """
        V.GetMaxCellSize() -> int
        C++: int GetMaxCellSize()
        
        Returns the size of the largest cell. The size is the number of
        points defining the cell.
        """
        ...
    
    def GetNextCell(self, p_int, int_tuple):
        """
        V.GetNextCell(int, (int, ...)) -> int
        C++: int GetNextCell(vtkIdType &npts, vtkIdType const *&pts)
        V.GetNextCell(vtkIdList) -> int
        C++: int GetNextCell(vtkIdList *pts)
        
        @warning This method is not thread-safe. Consider using the
            NewIterator()
        iterator instead.
        
        GetNextCell() gets the next cell in the list. If end of list is
        encountered, 0 is returned. A value of 1 is returned whenever
        npts and pts have been updated without error.
        
        Do not modify the returned pts pointer, as it may point to shared
        memory.
        
        ote This method is not thread-safe and has tricky syntax to use
        correctly. Prefer the use of vtkCellArrayIterator (see
        NewIterator()).
        """
        ...
    
    def GetNumberOfCells(self):
        """
        V.GetNumberOfCells() -> int
        C++: vtkIdType GetNumberOfCells()
        
        Get the number of cells in the array.
        """
        ...
    
    def GetNumberOfConnectivityEntries(self):
        """
        V.GetNumberOfConnectivityEntries() -> int
        C++: vtkIdType GetNumberOfConnectivityEntries()
        
        Return the size of the array that would be returned from
        ExportLegacyFormat().
        
        ote Method incompatible with current internal storage.
        """
        ...
    
    def GetNumberOfConnectivityIds(self):
        """
        V.GetNumberOfConnectivityIds() -> int
        C++: vtkIdType GetNumberOfConnectivityIds()
        
        Get the size of the connectivity array that stores the point ids.
        
        ote Do not confuse this with the deprecated
        GetNumberOfConnectivityEntries(), which refers to the legacy
        memory layout.
        """
        ...
    
    def GetNumberOfGenerationsFromBase(self, string):
        """
        V.GetNumberOfGenerationsFromBase(string) -> int
        C++: vtkIdType GetNumberOfGenerationsFromBase(const char *type)
            override;
        
        Standard methods for instantiation, type information, and
        printing.
        """
        ...
    
    def GetNumberOfGenerationsFromBaseType(self, string):
        """
        V.GetNumberOfGenerationsFromBaseType(string) -> int
        C++: static vtkIdType GetNumberOfGenerationsFromBaseType(
            const char *type)
        
        Standard methods for instantiation, type information, and
        printing.
        """
        ...
    
    def GetNumberOfOffsets(self):
        """
        V.GetNumberOfOffsets() -> int
        C++: vtkIdType GetNumberOfOffsets()
        
        Get the number of elements in the offsets array. This will be the
        number of cells + 1.
        """
        ...
    
    def GetOffsetsArray(self):
        """
        V.GetOffsetsArray() -> vtkDataArray
        C++: vtkDataArray *GetOffsetsArray()
        """
        ...
    
    def GetOffsetsArray32(self):
        """
        V.GetOffsetsArray32() -> vtkTypeInt32Array
        C++: ArrayType32 *GetOffsetsArray32()
        """
        ...
    
    def GetOffsetsArray64(self):
        """
        V.GetOffsetsArray64() -> vtkTypeInt64Array
        C++: ArrayType64 *GetOffsetsArray64()
        """
        ...
    
    def GetSize(self):
        """
        V.GetSize() -> int
        C++: vtkIdType GetSize()
        
        Get the size of the allocated connectivity array.
        
        @warning This returns the allocated capacity of the internal
            arrays as a
        number of elements, NOT the number of elements in use.
        
        ote Method incompatible with current internal storage.
        """
        ...
    
    def GetTraversalCellId(self):
        """
        V.GetTraversalCellId() -> int
        C++: vtkIdType GetTraversalCellId()
        """
        ...
    
    def GetTraversalLocation(self):
        """
        V.GetTraversalLocation() -> int
        C++: vtkIdType GetTraversalLocation()
        V.GetTraversalLocation(int) -> int
        C++: vtkIdType GetTraversalLocation(vtkIdType npts)
        """
        ...
    
    def ImportLegacyFormat(self, vtkIdTypeArray):
        """
        V.ImportLegacyFormat(vtkIdTypeArray)
        C++: void ImportLegacyFormat(vtkIdTypeArray *data)
        V.ImportLegacyFormat((int, ...), int)
        C++: void ImportLegacyFormat(const vtkIdType *data, vtkIdType len)
        """
        ...
    
    def Initialize(self):
        """
        V.Initialize()
        C++: void Initialize()
        
        Free any memory and reset to an empty state.
        """
        ...
    
    def InitTraversal(self):
        """
        V.InitTraversal()
        C++: void InitTraversal()
        
        @warning This method is not thread-safe. Consider using the
            NewIterator()
        iterator instead.
        
        InitTraversal() initializes the traversal of the list of cells.
        
        ote This method is not thread-safe and has tricky syntax to use
        correctly. Prefer the use of vtkCellArrayIterator (see
        NewIterator()).
        """
        ...
    
    def InsertCellPoint(self, p_int):
        """
        V.InsertCellPoint(int)
        C++: void InsertCellPoint(vtkIdType id)
        
        Used in conjunction with InsertNextCell(npts) to add another
        point to the list of cells.
        """
        ...
    
    def InsertNextCell(self, vtkCell):
        """
        V.InsertNextCell(vtkCell) -> int
        C++: vtkIdType InsertNextCell(vtkCell *cell)
        V.InsertNextCell(int, (int, ...)) -> int
        C++: vtkIdType InsertNextCell(vtkIdType npts,
            const vtkIdType *pts)
        V.InsertNextCell(vtkIdList) -> int
        C++: vtkIdType InsertNextCell(vtkIdList *pts)
        V.InsertNextCell(int) -> int
        C++: vtkIdType InsertNextCell(int npts)
        
        Insert a cell object. Return the cell id of the cell.
        """
        ...
    
    def IsA(self, string):
        """
        V.IsA(string) -> int
        C++: vtkTypeBool IsA(const char *type) override;
        
        Standard methods for instantiation, type information, and
        printing.
        """
        ...
    
    def IsHomogeneous(self):
        """
        V.IsHomogeneous() -> int
        C++: vtkIdType IsHomogeneous()
        
        Check if all cells have the same number of vertices.
        
        The return value is coded as:
        * -1 = heterogeneous
        * 0 = Cell array empty
        * n (positive integer) = homogeneous array of cell size n
        """
        ...
    
    def IsStorage64Bit(self):
        """
        V.IsStorage64Bit() -> bool
        C++: bool IsStorage64Bit()
        
        @return True if the internal storage is using 64 bit arrays. If
            false,
        the storage is using 32 bit arrays.
        """
        ...
    
    def IsStorageShareable(self):
        """
        V.IsStorageShareable() -> bool
        C++: bool IsStorageShareable()
        
        @return True if the internal storage can be shared as a
        pointer to vtkIdType, i.e., the type and organization of internal
        storage is such that copying of data can be avoided, and instead
        a pointer to vtkIdType can be used.
        """
        ...
    
    def IsTypeOf(self, string):
        """
        V.IsTypeOf(string) -> int
        C++: static vtkTypeBool IsTypeOf(const char *type)
        
        Standard methods for instantiation, type information, and
        printing.
        """
        ...
    
    def IsValid(self):
        """
        V.IsValid() -> bool
        C++: bool IsValid()
        
        Check that internal storage is consistent and in a valid state.
        
        Specifically, this function returns true if and only if:
        - The offset and connectivity arrays have exactly one component.
        - The offset array has at least one value and starts at 0.
        - The offset array values never decrease.
        - The connectivity array has as many entries as the last value in
        the offset array.
        """
        ...
    
    def NewInstance(self):
        """
        V.NewInstance() -> vtkCellArray
        C++: vtkCellArray *NewInstance()
        
        Standard methods for instantiation, type information, and
        printing.
        """
        ...
    
    def NewIterator(self):
        """
        V.NewIterator() -> vtkCellArrayIterator
        C++: vtkCellArrayIterator *NewIterator()
        
        NewIterator returns a new instance of vtkCellArrayIterator that
        is initialized to point at the first cell's data. The caller is
        responsible for Delete()'ing the object.
        """
        ...
    
    def ReplaceCell(self, p_int, p_int_1, int_tuple):
        """
        V.ReplaceCell(int, int, (int, ...))
        C++: void ReplaceCell(vtkIdType loc, int npts,
            const vtkIdType pts[])
        
        Replace the point ids of the cell at the legacy location with a
        different list of point ids. Calling this method does not mark
        the vtkCellArray as modified. This is the responsibility of the
        caller and may be done after multiple calls to ReplaceCell. This
        call does not support changing the number of points in the cell
        -- the caller must ensure that the target cell has npts points.
        
        ote The location-based API is now a super-slow compatibility
        layer. Prefer ReplaceCellAtId.
        """
        ...
    
    def ReplaceCellAtId(self, p_int, vtkIdList):
        """
        V.ReplaceCellAtId(int, vtkIdList)
        C++: void ReplaceCellAtId(vtkIdType cellId, vtkIdList *list)
        V.ReplaceCellAtId(int, int, (int, ...))
        C++: void ReplaceCellAtId(vtkIdType cellId, vtkIdType cellSize,
            const vtkIdType *cellPoints)
        """
        ...
    
    def Reset(self):
        """
        V.Reset()
        C++: void Reset()
        
        Reuse list. Reset to initial state without freeing memory.
        """
        ...
    
    def ResizeExact(self, p_int, p_int_1):
        """
        V.ResizeExact(int, int) -> bool
        C++: bool ResizeExact(vtkIdType numCells,
            vtkIdType connectivitySize)
        
        ResizeExact() resizes the internal structures to hold numCells
        total cell offsets and connectivitySize total pointIds. Old data
        is preserved, and newly-available memory is not initialized.
        
        @warning For advanced use only. You probably want an Allocate
            method.
        
        @return True if allocation succeeds.
        """
        ...
    
    def ReverseCell(self, p_int):
        """
        V.ReverseCell(int)
        C++: void ReverseCell(vtkIdType loc)
        
        Special method inverts ordering of cell at the specified legacy
        location. Must be called carefully or the cell topology may be
        corrupted.
        
        ote The location-based API is now a super-slow compatibility
        layer. Prefer ReverseCellAtId;
        """
        ...
    
    def ReverseCellAtId(self, p_int):
        """
        V.ReverseCellAtId(int)
        C++: void ReverseCellAtId(vtkIdType cellId)
        
        Reverses the order of the point ids for the specified cell.
        """
        ...
    
    def SafeDownCast(self, vtkObjectBase):
        """
        V.SafeDownCast(vtkObjectBase) -> vtkCellArray
        C++: static vtkCellArray *SafeDownCast(vtkObjectBase *o)
        
        Standard methods for instantiation, type information, and
        printing.
        """
        ...
    
    def SetCells(self, p_int, vtkIdTypeArray):
        """
        V.SetCells(int, vtkIdTypeArray)
        C++: void SetCells(vtkIdType ncells, vtkIdTypeArray *cells)
        
        Define multiple cells by providing a connectivity list. The list
        is in the form (npts,p0,p1,...p(npts-1), repeated for each cell).
        Be careful using this method because it discards the old cells,
        and anything referring these cells becomes invalid (for example,
        if BuildCells() has been called see vtkPolyData).  The traversal
        location is reset to the beginning of the list; the insertion
        location is set to the end of the list.
        
        @warning The vtkCellArray will not hold a reference to `cells`.
            This
        function merely calls ImportLegacyFormat.
        
        ote Use ImportLegacyFormat or SetData instead.
        """
        ...
    
    def SetData(self, vtkDataArray, vtkDataArray_1):
        """
        V.SetData(vtkDataArray, vtkDataArray) -> bool
        C++: bool SetData(vtkDataArray *offsets,
            vtkDataArray *connectivity)
        
        Sets the internal arrays to the supplied offsets and connectivity
        arrays.
        
        This is a convenience method, and may fail if the following
        conditions are not met:
        
        - Both arrays must be of the same type.
        - The array type must be one of the types in InputArrayList.
        
        If invalid arrays are passed in, an error is logged and the
        function will return false.
        """
        ...
    
    def SetNumberOfCells(self, p_int):
        """
        V.SetNumberOfCells(int)
        C++: virtual void SetNumberOfCells(vtkIdType)
        
        Set the number of cells in the array. DO NOT do any kind of
        allocation, advanced use only.
        
        ote This call has no effect.
        """
        ...
    
    def SetTraversalCellId(self, p_int):
        """
        V.SetTraversalCellId(int)
        C++: void SetTraversalCellId(vtkIdType cellId)
        """
        ...
    
    def SetTraversalLocation(self, p_int):
        """
        V.SetTraversalLocation(int)
        C++: void SetTraversalLocation(vtkIdType loc)
        """
        ...
    
    def ShallowCopy(self, vtkCellArray):
        """
        V.ShallowCopy(vtkCellArray)
        C++: void ShallowCopy(vtkCellArray *ca)
        
        Shallow copy ca into this cell array.
        """
        ...
    
    def Squeeze(self):
        """
        V.Squeeze()
        C++: void Squeeze()
        
        Reclaim any extra memory while preserving data.
        
        @sa ConvertToSmallestStorage
        """
        ...
    
    def UpdateCellCount(self, p_int):
        """
        V.UpdateCellCount(int)
        C++: void UpdateCellCount(int npts)
        
        Used in conjunction with InsertNextCell(int npts) and
        InsertCellPoint() to update the number of points defining the
        cell.
        """
        ...
    
    def Use32BitStorage(self):
        """
        V.Use32BitStorage()
        C++: void Use32BitStorage()
        """
        ...
    
    def Use64BitStorage(self):
        """
        V.Use64BitStorage()
        C++: void Use64BitStorage()
        """
        ...
    
    def UseDefaultStorage(self):
        """
        V.UseDefaultStorage()
        C++: void UseDefaultStorage()
        """
        ...
    
    def __delattr__(self, *args, **kwargs):
        """ Implement delattr(self, name). """
        ...
    
    def __getattribute__(self, *args, **kwargs):
        """ Return getattr(self, name). """
        ...
    
    def __init__(self, current) -> None:
        ...
    
    @staticmethod
    def __new__(*args, **kwargs):
        """ Create and return a new object.  See help(type) for accurate signature. """
        ...
    
    def __repr__(self, *args, **kwargs):
        """ Return repr(self). """
        ...
    
    def __setattr__(self, *args, **kwargs):
        """ Implement setattr(self, name, value). """
        ...
    
    def __str__(self, *args, **kwargs) -> str:
        """ Return str(self). """
        ...
    
    __this__ = ...
    __dict__ = ...
    __vtkname__ = ...


