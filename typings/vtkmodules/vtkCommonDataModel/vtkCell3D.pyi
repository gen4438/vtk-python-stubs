"""
This type stub file was generated by pyright.
"""

from .vtkCell import vtkCell

class vtkCell3D(vtkCell):
    """
    vtkCell3D - abstract class to specify 3D cell interface
    
    Superclass: vtkCell
    
    vtkCell3D is an abstract class that extends the interfaces for 3D
    data cells, and implements methods needed to satisfy the vtkCell API.
    The 3D cells include hexehedra, tetrahedra, wedge, pyramid, and
    voxel.
    
    @sa
    vtkTetra vtkHexahedron vtkVoxel vtkWedge vtkPyramid
    """
    def Clip(self, p_float, vtkDataArray, vtkIncrementalPointLocator, vtkCellArray, vtkPointData, vtkPointData_1, vtkCellData, p_int, vtkCellData_1, p_int_1):
        """
        V.Clip(float, vtkDataArray, vtkIncrementalPointLocator,
            vtkCellArray, vtkPointData, vtkPointData, vtkCellData, int,
            vtkCellData, int)
        C++: void Clip(double value, vtkDataArray *cellScalars,
            vtkIncrementalPointLocator *locator,
            vtkCellArray *connectivity, vtkPointData *inPd,
            vtkPointData *outPd, vtkCellData *inCd, vtkIdType cellId,
            vtkCellData *outCd, int insideOut) override;
        
        Cut (or clip) the cell based on the input cellScalars and the
        specified value. The output of the clip operation will be one or
        more cells of the same topological dimension as the original
        cell.  The flag insideOut controls what part of the cell is
        considered inside - normally cell points whose scalar value is
        greater than "value" are considered inside. If insideOut is on,
        this is reversed. Also, if the output cell data is non-nullptr,
        the cell data from the clipped cell is passed to the generated
        contouring primitives. (Note: the CopyAllocate() method must be
        invoked on both the output cell and point data. The cellId refers
        to the cell from which the cell data is copied.)  (Satisfies
        vtkCell API.)
        """
        ...
    
    def Contour(self, p_float, vtkDataArray, vtkIncrementalPointLocator, vtkCellArray, vtkCellArray_1, vtkCellArray_2, vtkPointData, vtkPointData_1, vtkCellData, p_int, vtkCellData_1):
        """
        V.Contour(float, vtkDataArray, vtkIncrementalPointLocator,
            vtkCellArray, vtkCellArray, vtkCellArray, vtkPointData,
            vtkPointData, vtkCellData, int, vtkCellData)
        C++: void Contour(double value, vtkDataArray *cellScalars,
            vtkIncrementalPointLocator *locator, vtkCellArray *verts,
            vtkCellArray *lines, vtkCellArray *polys, vtkPointData *inPd,
            vtkPointData *outPd, vtkCellData *inCd, vtkIdType cellId,
            vtkCellData *outCd) override;
        
        Generate contouring primitives. The scalar list cellScalars are
        scalar values at each cell point. The point locator is
        essentially a points list that merges points as they are inserted
        (i.e., prevents duplicates). Contouring primitives can be
        vertices, lines, or polygons. It is possible to interpolate point
        data along the edge by providing input and output point data - if
        outPd is nullptr, then no interpolation is performed. Also, if
        the output cell data is non-nullptr, the cell data from the
        contoured cell is passed to the generated contouring primitives.
        (Note: the CopyAllocate() method must be invoked on both the
        output cell and point data. The cellId refers to the cell from
        which the cell data is copied.)
        """
        ...
    
    def GetCellDimension(self):
        """
        V.GetCellDimension() -> int
        C++: int GetCellDimension() override;
        
        The topological dimension of the cell. (Satisfies vtkCell API.)
        """
        ...
    
    def GetCentroid(self, p_float=..., p_float=..., p_float=...):
        """
        V.GetCentroid([float, float, float]) -> bool
        C++: virtual bool GetCentroid(double centroid[3])
        
        Computes the centroid of the cell.
        """
        ...
    
    def GetEdgePoints(self, p_int, int_tuple):
        """
        V.GetEdgePoints(int, (int, ...))
        C++: virtual void GetEdgePoints(vtkIdType edgeId,
            const vtkIdType *&pts)
        V.GetEdgePoints(int, [int, ...])
        C++: virtual void GetEdgePoints(int edgeId, int *&pts)
        
        Get the pair of vertices that define an edge. The method returns
        the number of vertices, along with an array of vertices. Note
        that the vertices are 0-offset; that is, they refer to the ids of
        the cell, not the point ids of the mesh that the cell belongs to.
        The edgeId must range between 0<=edgeId<this->GetNumberOfEdges().
        """
        ...
    
    def GetEdgeToAdjacentFaces(self, p_int, int_tuple):
        """
        V.GetEdgeToAdjacentFaces(int, (int, ...))
        C++: virtual void GetEdgeToAdjacentFaces(vtkIdType edgeId,
            const vtkIdType *&faceIds)
        
        Get the ids of the two adjacent faces to edge of id edgeId. The
        output face ids are sorted from id of lowest rank to highest.
        Note that the faces are 0-offset; that is, they refer to the ids
        of the cells, not the face ids of the mesh that the cell belongs
        to. The edgeId must range between
        0<=edgeId<this->GetNumberOfEdges().
        """
        ...
    
    def GetFacePoints(self, p_int, int_tuple):
        """
        V.GetFacePoints(int, (int, ...)) -> int
        C++: virtual vtkIdType GetFacePoints(vtkIdType faceId,
            const vtkIdType *&pts)
        V.GetFacePoints(int, [int, ...])
        C++: virtual void GetFacePoints(int faceId, int *&pts)
        
        Get the list of vertices that define a face. The list is
        terminated with a negative number. Note that the vertices are
        0-offset; that is, they refer to the ids of the cell, not the
        point ids of the mesh that the cell belongs to. The faceId must
        range between 0<=faceId<this->GetNumberOfFaces().
        
        @return The number of points in face faceId
        """
        ...
    
    def GetFaceToAdjacentFaces(self, p_int, int_tuple):
        """
        V.GetFaceToAdjacentFaces(int, (int, ...)) -> int
        C++: virtual vtkIdType GetFaceToAdjacentFaces(vtkIdType faceId,
            const vtkIdType *&faceIds)
        
        Get the ids of the adjacent faces to face of id faceId. The order
        of faces is consistent. They are always ordered in counter
        clockwise w.r.t. normal orientation. The first id faces[0]
        corresponds to the face sharing point of id pts[0] where pts is
        obtained from this->GetFacePoints(faceId, pts), being the "most counter
        clockwise" oriented w.r.t. face faceId. Note that the faces are
        0-offset; that is, they refer to the ids of the cell, not the
        face ids of the mesh that the cell belongs to. The faceId must be
        between 0<=faceId<this->GetNumberOfFaces();
        
        @warning If the vtkCell3D is "inside out", i.e. normals point
            inside the cell, the order is
        inverted.
        @return The number of adjacent faces to faceId.
        """
        ...
    
    def GetMergeTolerance(self):
        """
        V.GetMergeTolerance() -> float
        C++: virtual double GetMergeTolerance()
        
        Set the tolerance for merging clip intersection points that are
        near the vertices of cells. This tolerance is used to prevent the
        generation of degenerate tetrahedra during clipping.
        """
        ...
    
    def GetMergeToleranceMaxValue(self):
        """
        V.GetMergeToleranceMaxValue() -> float
        C++: virtual double GetMergeToleranceMaxValue()
        
        Set the tolerance for merging clip intersection points that are
        near the vertices of cells. This tolerance is used to prevent the
        generation of degenerate tetrahedra during clipping.
        """
        ...
    
    def GetMergeToleranceMinValue(self):
        """
        V.GetMergeToleranceMinValue() -> float
        C++: virtual double GetMergeToleranceMinValue()
        
        Set the tolerance for merging clip intersection points that are
        near the vertices of cells. This tolerance is used to prevent the
        generation of degenerate tetrahedra during clipping.
        """
        ...
    
    def GetNumberOfGenerationsFromBase(self, string):
        """
        V.GetNumberOfGenerationsFromBase(string) -> int
        C++: vtkIdType GetNumberOfGenerationsFromBase(const char *type)
            override;
        
        Given a the name of a base class of this class type, return the
        distance of inheritance between this class type and the named
        class (how many generations of inheritance are there between this
        class and the named class). If the named class is not in this
        class's inheritance tree, return a negative value. Valid
        responses will always be nonnegative. This method works in
        combination with vtkTypeMacro found in vtkSetGet.h.
        """
        ...
    
    def GetNumberOfGenerationsFromBaseType(self, string):
        """
        V.GetNumberOfGenerationsFromBaseType(string) -> int
        C++: static vtkIdType GetNumberOfGenerationsFromBaseType(
            const char *type)
        
        Given a the name of a base class of this class type, return the
        distance of inheritance between this class type and the named
        class (how many generations of inheritance are there between this
        class and the named class). If the named class is not in this
        class's inheritance tree, return a negative value. Valid
        responses will always be nonnegative. This method works in
        combination with vtkTypeMacro found in vtkSetGet.h.
        """
        ...
    
    def GetPointToIncidentEdges(self, p_int, int_tuple):
        """
        V.GetPointToIncidentEdges(int, (int, ...)) -> int
        C++: virtual vtkIdType GetPointToIncidentEdges(vtkIdType pointId,
            const vtkIdType *&edgeIds)
        
        Get the ids of the incident edges to point of id pointId. Edges
        are sorted in counter clockwise order w.r.t. bisectrix pointing
        outside the cell at point of id pointId. The first edge
        corresponds to the edge containing point of id pts[0], where pts
        is obtained from this->GetPointToOnRingVertices(pointId, pts).
        Note that the edges are 0-offset; that is, they refer to the ids
        of the cell, not the edge ids of the mesh that the cell belongs
        to. The edgeId must be between
        0<=edgeId<this->GetNumberOfEdges();
        
        @warning If the vtkCell3D is "inside out", i.e. normals point
            inside the cell, the order is
        inverted.
        @return The valence of point pointId.
        """
        ...
    
    def GetPointToIncidentFaces(self, p_int, int_tuple):
        """
        V.GetPointToIncidentFaces(int, (int, ...)) -> int
        C++: virtual vtkIdType GetPointToIncidentFaces(vtkIdType pointId,
            const vtkIdType *&faceIds)
        
        Get the ids of the incident faces point of id pointId. Faces are
        sorted in counter clockwise order w.r.t. bisectrix pointing
        outside the cell at point of id pointId. The first face
        corresponds to the face containing edge of id edges[0], where
        edges is obtained from this->GetPointToIncidentEdges(pointId,
        edges), such that face faces[0] is the "most counterclockwise"
        face incident to point pointId containing edges[0]. Note that the
        faces are 0-offset; that is, they refer to the ids of the cell,
        not the face ids of the mesh that the cell belongs to. The
        pointId must be between 0<=pointId<this->GetNumberOfPoints().
        
        @warning If the vtkCell3D is "inside out", i.e. normals point
            inside the cell, the order is
        inverted.
        @return The valence of point pointId.
        """
        ...
    
    def GetPointToOneRingPoints(self, p_int, int_tuple):
        """
        V.GetPointToOneRingPoints(int, (int, ...)) -> int
        C++: virtual vtkIdType GetPointToOneRingPoints(vtkIdType pointId,
            const vtkIdType *&pts)
        
        Get the ids of a one-ring surrounding point of id pointId. Points
        are sorted in counter clockwise order w.r.t. bisectrix pointing
        outside the cell at point of id pointId. The first point
        corresponds to the point contained in edges[0], where edges is
        obtained from this->GetPointToIncidentEdges(pointId, edges). Note
        that the points are 0-offset; that is, they refer to the ids of
        the cell, not the point ids of the mesh that the cell belongs to.
        The pointId must be between 0<pointId<this->GetNumberOfPoints().
        @return The valence of point pointId.
        """
        ...
    
    def IsA(self, string):
        """
        V.IsA(string) -> int
        C++: vtkTypeBool IsA(const char *type) override;
        
        Return 1 if this class is the same type of (or a subclass of) the
        named class. Returns 0 otherwise. This method works in
        combination with vtkTypeMacro found in vtkSetGet.h.
        """
        ...
    
    def IsInsideOut(self):
        """
        V.IsInsideOut() -> bool
        C++: virtual bool IsInsideOut()
        
        Returns true if the normals of the vtkCell3D point inside the
        cell.
        
        @warning This flag is not precomputed. It is advised for the
            return result of
        this method to be stored in a local boolean by the user if needed
        multiple times.
        """
        ...
    
    def IsTypeOf(self, string):
        """
        V.IsTypeOf(string) -> int
        C++: static vtkTypeBool IsTypeOf(const char *type)
        
        Return 1 if this class type is the same type of (or a subclass
        of) the named class. Returns 0 otherwise. This method works in
        combination with vtkTypeMacro found in vtkSetGet.h.
        """
        ...
    
    def NewInstance(self):
        """
        V.NewInstance() -> vtkCell3D
        C++: vtkCell3D *NewInstance()
        """
        ...
    
    def SafeDownCast(self, vtkObjectBase):
        """
        V.SafeDownCast(vtkObjectBase) -> vtkCell3D
        C++: static vtkCell3D *SafeDownCast(vtkObjectBase *o)
        """
        ...
    
    def SetMergeTolerance(self, p_float):
        """
        V.SetMergeTolerance(float)
        C++: virtual void SetMergeTolerance(double _arg)
        
        Set the tolerance for merging clip intersection points that are
        near the vertices of cells. This tolerance is used to prevent the
        generation of degenerate tetrahedra during clipping.
        """
        ...
    
    def __delattr__(self, *args, **kwargs):
        """ Implement delattr(self, name). """
        ...
    
    def __getattribute__(self, *args, **kwargs):
        """ Return getattr(self, name). """
        ...
    
    def __init__(self, *args, **kwargs) -> None:
        ...
    
    @staticmethod
    def __new__(*args, **kwargs):
        """ Create and return a new object.  See help(type) for accurate signature. """
        ...
    
    def __repr__(self, *args, **kwargs):
        """ Return repr(self). """
        ...
    
    def __setattr__(self, *args, **kwargs):
        """ Implement setattr(self, name, value). """
        ...
    
    def __str__(self, *args, **kwargs) -> str:
        """ Return str(self). """
        ...
    
    __this__ = ...
    __dict__ = ...
    __vtkname__ = ...


