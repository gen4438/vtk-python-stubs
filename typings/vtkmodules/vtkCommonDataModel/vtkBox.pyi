"""
This type stub file was generated by pyright.
"""

from .vtkImplicitFunction import vtkImplicitFunction

class vtkBox(vtkImplicitFunction):
    """
    vtkBox - implicit function for a bounding box
    
    Superclass: vtkImplicitFunction
    
    vtkBox computes the implicit function and/or gradient for a
    axis-aligned bounding box. (The superclasses transform can be used to
    modify this orientation.) Each side of the box is orthogonal to all
    other sides meeting along shared edges and all faces are orthogonal
    to the x-y-z coordinate axes.  (If you wish to orient this box
    differently, recall that the superclass vtkImplicitFunction supports
    a transformation matrix.) vtkBox is a concrete implementation of
    vtkImplicitFunction.
    
    @sa
    vtkCubeSource vtkImplicitFunction
    """
    def AddBounds(self, ):
        """
        V.AddBounds((float, float, float, float, float, float))
        C++: void AddBounds(const double bounds[6])
        
        A special method that allows union set operation on bounding
        boxes. Start with a SetBounds(). Subsequent AddBounds() methods
        are union set operations on the original bounds. Retrieve the
        final bounds with a GetBounds() method.
        """
        ...
    
    def EvaluateFunction(self, p_float=..., p_float=..., p_float=...):
        """
        V.EvaluateFunction([float, float, float]) -> float
        C++: double EvaluateFunction(double x[3]) override;
        V.EvaluateFunction(vtkDataArray, vtkDataArray)
        C++: virtual void EvaluateFunction(vtkDataArray *input,
            vtkDataArray *output)
        V.EvaluateFunction(float, float, float) -> float
        C++: virtual double EvaluateFunction(double x, double y, double z)
        
        Evaluate function at position x-y-z and return value.  You should
        generally not call this method directly, you should use
        FunctionValue() instead.  This method must be implemented by any
        derived class.
        """
        ...
    
    def EvaluateGradient(self, p_float=..., p_float=..., p_float=..., *args, **kwargs):
        """
        V.EvaluateGradient([float, float, float], [float, float, float])
        C++: void EvaluateGradient(double x[3], double n[3]) override;
        
        Evaluate the gradient of the box.
        """
        ...
    
    def GetBounds(self, p_float, p_float_1, p_float_2, p_float_3, p_float_4, p_float_5):
        """
        V.GetBounds(float, float, float, float, float, float)
        C++: void GetBounds(double &xMin, double &xMax, double &yMin,
            double &yMax, double &zMin, double &zMax)
        V.GetBounds([float, float, float, float, float, float])
        C++: void GetBounds(double bounds[6])
        V.GetBounds() -> (float, float, float, float, float, float)
        C++: double *GetBounds()
        """
        ...
    
    def GetNumberOfGenerationsFromBase(self, string):
        """
        V.GetNumberOfGenerationsFromBase(string) -> int
        C++: vtkIdType GetNumberOfGenerationsFromBase(const char *type)
            override;
        
        Given a the name of a base class of this class type, return the
        distance of inheritance between this class type and the named
        class (how many generations of inheritance are there between this
        class and the named class). If the named class is not in this
        class's inheritance tree, return a negative value. Valid
        responses will always be nonnegative. This method works in
        combination with vtkTypeMacro found in vtkSetGet.h.
        """
        ...
    
    def GetNumberOfGenerationsFromBaseType(self, string):
        """
        V.GetNumberOfGenerationsFromBaseType(string) -> int
        C++: static vtkIdType GetNumberOfGenerationsFromBaseType(
            const char *type)
        
        Given a the name of a base class of this class type, return the
        distance of inheritance between this class type and the named
        class (how many generations of inheritance are there between this
        class and the named class). If the named class is not in this
        class's inheritance tree, return a negative value. Valid
        responses will always be nonnegative. This method works in
        combination with vtkTypeMacro found in vtkSetGet.h.
        """
        ...
    
    def GetXMax(self, p_float=..., p_float=..., p_float=...):
        """
        V.GetXMax([float, float, float])
        C++: void GetXMax(double p[3])
        V.GetXMax(float, float, float)
        C++: void GetXMax(double &x, double &y, double &z)
        """
        ...
    
    def GetXMin(self, p_float=..., p_float=..., p_float=...):
        """
        V.GetXMin([float, float, float])
        C++: void GetXMin(double p[3])
        V.GetXMin(float, float, float)
        C++: void GetXMin(double &x, double &y, double &z)
        
        Set / get the bounding box using various methods.
        """
        ...
    
    def IntersectBox(self, , , , p_float=..., p_float=..., p_float=..., *args, **kwargs):
        """
        V.IntersectBox((float, float, float, float, float, float), (float,
             float, float), (float, float, float), [float, float, float],
            float) -> char
        C++: static char IntersectBox(const double bounds[6],
            const double origin[3], const double dir[3], double coord[3],
            double &t)
        
        Bounding box intersection with line modified from Graphics Gems
        Vol I. The method returns a non-zero value if the bounding box is
        hit. Origin[3] starts the ray, dir[3] is the vector components of
        the ray in the x-y-z directions, coord[3] is the location of hit,
        and t is the parametric coordinate along line. (Notes: the
        intersection ray dir[3] is NOT normalized.  Valid intersections
        will only occur between 0<=t<=1.)
        """
        ...
    
    def IntersectWithInfiniteLine(self, , , , p_float_12, p_float_13, p_float=..., p_float=..., p_float=..., *args, **kwargs):
        """
        V.IntersectWithInfiniteLine((float, float, float, float, float,
            float), (float, float, float), (float, float, float), float,
            float, [float, float, float], [float, float, float], int, int)
             -> bool
        C++: static bool IntersectWithInfiniteLine(const double bounds[6],
             const double p1[3], const double p2[3], double &t1,
            double &t2, double x1[3], double x2[3], int &plane1,
            int &plane2)
        
        Same method as vtkBox::IntersectWithLine, except that t1 and t2
        can be outside of [0,1]. t1 is the distance of x1 to p1 in
        parametric coordinates, and t2 is the distance of x2 to p1 in
        parametric coordinates as well. In vtkBox::IntersectWithInLine,
        it is assumed that [p1,p2] is a segment, here, it is assumed that
        it is a line with no ends. t1 <= t2, which means that x1 is
        always "before" x2 on the line parameterized by [p1,p2]. x1 and
        x2 can be set to nullptr without crash.
        """
        ...
    
    def IntersectWithLine(self, , , , p_float_12, p_float_13, p_float=..., p_float=..., p_float=..., *args, **kwargs):
        """
        V.IntersectWithLine((float, float, float, float, float, float), (
            float, float, float), (float, float, float), float, float,
            [float, float, float], [float, float, float], int, int) -> int
        C++: static int IntersectWithLine(const double bounds[6],
            const double p1[3], const double p2[3], double &t1,
            double &t2, double x1[3], double x2[3], int &plane1,
            int &plane2)
        
        Intersect a line with the box.  Give the endpoints of the line in
        p1 and p2.  The parameteric distances from p1 to the entry and
        exit points are returned in t1 and t2, where t1 and t2 are
        clamped to the range [0,1].  The entry and exit planes are
        returned in plane1 and plane2 where integers (0, 1, 2, 3, 4, 5)
        stand for the (xmin, xmax, ymin, ymax, zmin, zmax) planes
        respectively, and a value of -1 means that no intersection
        occurred.  The actual intersection coordinates are stored in x1
        and x2, which can be set to nullptr of you do not need them to be
        returned.  The function return value will be zero if the line is
        wholly outside of the box.
        """
        ...
    
    def IntersectWithPlane(self, p_float=..., p_float=..., p_float=..., p_float=..., p_float=..., p_float=..., *args, **kwargs):
        """
        V.IntersectWithPlane([float, float, float, float, float, float],
            [float, float, float], [float, float, float]) -> int
        C++: static vtkTypeBool IntersectWithPlane(double bounds[6],
            double origin[3], double normal[3])
        V.IntersectWithPlane([float, float, float, float, float, float],
            [float, float, float], [float, float, float], [float, float,
            float, float, float, float, float, float, float, float, float,
             float, float, float, float, float, float, float]) -> int
        C++: static vtkTypeBool IntersectWithPlane(double bounds[6],
            double origin[3], double normal[3], double xints[18])
        
        Plane intersection with the box. The plane is infinite in extent
        and defined by an origin and normal. The function indicates
        whether the plane intersects, not the particulars of intersection
        points and such. The function returns non-zero if the plane and
        box intersect; zero otherwise.
        """
        ...
    
    def IsA(self, string):
        """
        V.IsA(string) -> int
        C++: vtkTypeBool IsA(const char *type) override;
        
        Return 1 if this class is the same type of (or a subclass of) the
        named class. Returns 0 otherwise. This method works in
        combination with vtkTypeMacro found in vtkSetGet.h.
        """
        ...
    
    def IsTypeOf(self, string):
        """
        V.IsTypeOf(string) -> int
        C++: static vtkTypeBool IsTypeOf(const char *type)
        
        Return 1 if this class type is the same type of (or a subclass
        of) the named class. Returns 0 otherwise. This method works in
        combination with vtkTypeMacro found in vtkSetGet.h.
        """
        ...
    
    def NewInstance(self):
        """
        V.NewInstance() -> vtkBox
        C++: vtkBox *NewInstance()
        """
        ...
    
    def SafeDownCast(self, vtkObjectBase):
        """
        V.SafeDownCast(vtkObjectBase) -> vtkBox
        C++: static vtkBox *SafeDownCast(vtkObjectBase *o)
        """
        ...
    
    def SetBounds(self, p_float, p_float_1, p_float_2, p_float_3, p_float_4, p_float_5):
        """
        V.SetBounds(float, float, float, float, float, float)
        C++: void SetBounds(double xMin, double xMax, double yMin,
            double yMax, double zMin, double zMax)
        V.SetBounds((float, float, float, float, float, float))
        C++: void SetBounds(const double bounds[6])
        """
        ...
    
    def SetXMax(self, p_float=..., p_float=..., p_float=...):
        """
        V.SetXMax([float, float, float])
        C++: void SetXMax(double p[3])
        V.SetXMax(float, float, float)
        C++: void SetXMax(double x, double y, double z)
        """
        ...
    
    def SetXMin(self, p_float=..., p_float=..., p_float=...):
        """
        V.SetXMin([float, float, float])
        C++: void SetXMin(double p[3])
        V.SetXMin(float, float, float)
        C++: void SetXMin(double x, double y, double z)
        
        Set / get the bounding box using various methods.
        """
        ...
    
    def __delattr__(self, *args, **kwargs):
        """ Implement delattr(self, name). """
        ...
    
    def __getattribute__(self, *args, **kwargs):
        """ Return getattr(self, name). """
        ...
    
    def __init__(self, *args, **kwargs) -> None:
        ...
    
    @staticmethod
    def __new__(*args, **kwargs):
        """ Create and return a new object.  See help(type) for accurate signature. """
        ...
    
    def __repr__(self, *args, **kwargs):
        """ Return repr(self). """
        ...
    
    def __setattr__(self, *args, **kwargs):
        """ Implement setattr(self, name, value). """
        ...
    
    def __str__(self, *args, **kwargs) -> str:
        """ Return str(self). """
        ...
    
    __this__ = ...
    __dict__ = ...
    __vtkname__ = ...


