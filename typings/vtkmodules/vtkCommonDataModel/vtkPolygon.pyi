"""
This type stub file was generated by pyright.
"""

from .vtkCell import vtkCell

class vtkPolygon(vtkCell):
    """
    vtkPolygon - a cell that represents an n-sided polygon
    
    Superclass: vtkCell
    
    vtkPolygon is a concrete implementation of vtkCell to represent a 2D
    n-sided polygon. The polygons cannot have any internal holes, and
    cannot self-intersect. Define the polygon with n-points ordered in
    the counter- clockwise direction; do not repeat the last point.
    """
    def BoundedTriangulate(self, vtkIdList, p_float):
        """
        V.BoundedTriangulate(vtkIdList, float) -> int
        C++: int BoundedTriangulate(vtkIdList *outTris, double tol)
        
        Triangulate polygon and enforce that the ratio of the smallest
        triangle area to the polygon area is greater than a user-defined
        tolerance. The user must provide the vtkIdList outTris. On
        output, the outTris list contains the ids of the points defining
        the triangulation. The ids are ordered into groups of three: each
        three-group defines one triangle.
        """
        ...
    
    def CellBoundary(self, p_int, , vtkIdList):
        """
        V.CellBoundary(int, (float, float, float), vtkIdList) -> int
        C++: int CellBoundary(int subId, const double pcoords[3],
            vtkIdList *pts) override;
        
        See the vtkCell API for descriptions of these methods.
        """
        ...
    
    def Clip(self, p_float, vtkDataArray, vtkIncrementalPointLocator, vtkCellArray, vtkPointData, vtkPointData_1, vtkCellData, p_int, vtkCellData_1, p_int_1):
        """
        V.Clip(float, vtkDataArray, vtkIncrementalPointLocator,
            vtkCellArray, vtkPointData, vtkPointData, vtkCellData, int,
            vtkCellData, int)
        C++: void Clip(double value, vtkDataArray *cellScalars,
            vtkIncrementalPointLocator *locator, vtkCellArray *tris,
            vtkPointData *inPd, vtkPointData *outPd, vtkCellData *inCd,
            vtkIdType cellId, vtkCellData *outCd, int insideOut) override;
        
        See the vtkCell API for descriptions of these methods.
        """
        ...
    
    def ComputeArea(self):
        """
        V.ComputeArea() -> float
        C++: double ComputeArea()
        V.ComputeArea(vtkPoints, int, (int, ...), [float, float, float])
            -> float
        C++: static double ComputeArea(vtkPoints *p, vtkIdType numPts,
            const vtkIdType *pts, double normal[3])
        
        Compute the area of a polygon. This is a convenience function
        which simply calls static double ComputeArea(vtkPoints *p,
        vtkIdType numPts, vtkIdType *pts, double normal[3]); with the
        appropriate parameters from the instantiated vtkPolygon.
        """
        ...
    
    def ComputeCentroid(self, vtkPoints, p_int, int_tuple, p_float=..., p_float=..., p_float=...):
        """
        V.ComputeCentroid(vtkPoints, int, (int, ...), [float, float,
            float]) -> bool
        C++: static bool ComputeCentroid(vtkPoints *p, int numPts,
            const vtkIdType *pts, double centroid[3])
        V.ComputeCentroid(vtkIdTypeArray, vtkPoints, [float, float,
            float]) -> bool
        C++: static bool ComputeCentroid(vtkIdTypeArray *ids,
            vtkPoints *pts, double centroid[3])
        
        Compute the centroid of a set of points. Returns false if the
        computation is invalid (this occurs when numPts=0 or when ids is
        empty).
        """
        ...
    
    def ComputeNormal(self, vtkPoints, p_int, int_tuple, p_float=..., p_float=..., p_float=...):
        """
        V.ComputeNormal(vtkPoints, int, (int, ...), [float, float, float])
        C++: static void ComputeNormal(vtkPoints *p, int numPts,
            const vtkIdType *pts, double n[3])
        V.ComputeNormal(vtkPoints, [float, float, float])
        C++: static void ComputeNormal(vtkPoints *p, double n[3])
        V.ComputeNormal(vtkIdTypeArray, vtkPoints, [float, float, float])
        C++: static void ComputeNormal(vtkIdTypeArray *ids,
            vtkPoints *pts, double n[3])
        V.ComputeNormal(int, [float, ...], [float, float, float])
        C++: static void ComputeNormal(int numPts, double *pts,
            double n[3])
        
        Computes the unit normal to the polygon. If pts=nullptr, point
        indexing is assumed to be {0, 1, ..., numPts-1}.
        """
        ...
    
    def Contour(self, p_float, vtkDataArray, vtkIncrementalPointLocator, vtkCellArray, vtkCellArray_1, vtkCellArray_2, vtkPointData, vtkPointData_1, vtkCellData, p_int, vtkCellData_1):
        """
        V.Contour(float, vtkDataArray, vtkIncrementalPointLocator,
            vtkCellArray, vtkCellArray, vtkCellArray, vtkPointData,
            vtkPointData, vtkCellData, int, vtkCellData)
        C++: void Contour(double value, vtkDataArray *cellScalars,
            vtkIncrementalPointLocator *locator, vtkCellArray *verts,
            vtkCellArray *lines, vtkCellArray *polys, vtkPointData *inPd,
            vtkPointData *outPd, vtkCellData *inCd, vtkIdType cellId,
            vtkCellData *outCd) override;
        
        See the vtkCell API for descriptions of these methods.
        """
        ...
    
    def Derivatives(self, p_int, , float_tuple, p_int_1, *float):
        """
        V.Derivatives(int, (float, float, float), (float, ...), int,
            [float, ...])
        C++: void Derivatives(int subId, const double pcoords[3],
            const double *values, int dim, double *derivs) override;
        
        See the vtkCell API for descriptions of these methods.
        """
        ...
    
    def DistanceToPolygon(self, p_float=..., p_float=..., p_float=..., *args, **kwargs):
        """
        V.DistanceToPolygon([float, float, float], int, [float, ...],
            [float, float, float, float, float, float], [float, float,
            float]) -> float
        C++: static double DistanceToPolygon(double x[3], int numPts,
            double *pts, double bounds[6], double closest[3])
        
        Compute the distance of a point to a polygon. The closest point
        on the polygon is also returned. The bounds should be provided to
        accelerate the computation.
        """
        ...
    
    def EvaluateLocation(self, p_int, , p_float=..., p_float=..., p_float=..., *args, **kwargs):
        """
        V.EvaluateLocation(int, (float, float, float), [float, float,
            float], [float, ...])
        C++: void EvaluateLocation(int &subId, const double pcoords[3],
            double x[3], double *weights) override;
        
        See the vtkCell API for descriptions of these methods.
        """
        ...
    
    def EvaluatePosition(self, , p_float=..., p_float=..., p_float=..., *args, **kwargs):
        """
        V.EvaluatePosition((float, float, float), [float, float, float],
            int, [float, float, float], float, [float, ...]) -> int
        C++: int EvaluatePosition(const double x[3],
            double closestPoint[3], int &subId, double pcoords[3],
            double &dist2, double weights[]) override;
        
        See the vtkCell API for descriptions of these methods.
        """
        ...
    
    def GetCellDimension(self):
        """
        V.GetCellDimension() -> int
        C++: int GetCellDimension() override;
        
        See the vtkCell API for descriptions of these methods.
        """
        ...
    
    def GetCellType(self):
        """
        V.GetCellType() -> int
        C++: int GetCellType() override;
        
        See the vtkCell API for descriptions of these methods.
        """
        ...
    
    def GetEdge(self, p_int):
        """
        V.GetEdge(int) -> vtkCell
        C++: vtkCell *GetEdge(int edgeId) override;
        
        See the vtkCell API for descriptions of these methods.
        """
        ...
    
    def GetFace(self, p_int):
        """
        V.GetFace(int) -> vtkCell
        C++: vtkCell *GetFace(int) override;
        
        See the vtkCell API for descriptions of these methods.
        """
        ...
    
    def GetNumberOfEdges(self):
        """
        V.GetNumberOfEdges() -> int
        C++: int GetNumberOfEdges() override;
        
        See the vtkCell API for descriptions of these methods.
        """
        ...
    
    def GetNumberOfFaces(self):
        """
        V.GetNumberOfFaces() -> int
        C++: int GetNumberOfFaces() override;
        
        See the vtkCell API for descriptions of these methods.
        """
        ...
    
    def GetNumberOfGenerationsFromBase(self, string):
        """
        V.GetNumberOfGenerationsFromBase(string) -> int
        C++: vtkIdType GetNumberOfGenerationsFromBase(const char *type)
            override;
        
        Given a the name of a base class of this class type, return the
        distance of inheritance between this class type and the named
        class (how many generations of inheritance are there between this
        class and the named class). If the named class is not in this
        class's inheritance tree, return a negative value. Valid
        responses will always be nonnegative. This method works in
        combination with vtkTypeMacro found in vtkSetGet.h.
        """
        ...
    
    def GetNumberOfGenerationsFromBaseType(self, string):
        """
        V.GetNumberOfGenerationsFromBaseType(string) -> int
        C++: static vtkIdType GetNumberOfGenerationsFromBaseType(
            const char *type)
        
        Given a the name of a base class of this class type, return the
        distance of inheritance between this class type and the named
        class (how many generations of inheritance are there between this
        class and the named class). If the named class is not in this
        class's inheritance tree, return a negative value. Valid
        responses will always be nonnegative. This method works in
        combination with vtkTypeMacro found in vtkSetGet.h.
        """
        ...
    
    def GetUseMVCInterpolation(self):
        """
        V.GetUseMVCInterpolation() -> bool
        C++: virtual bool GetUseMVCInterpolation()
        
        Set/Get the flag indicating whether to use Mean Value Coordinate
        for the interpolation. If true, InterpolateFunctions() uses the
        Mean Value Coordinate to compute weights. Otherwise, the
        conventional 1/r^2 method is used. The UseMVCInterpolation
        parameter is set to false by default.
        """
        ...
    
    def InterpolateFunctions(self, , *float):
        """
        V.InterpolateFunctions((float, float, float), [float, ...])
        C++: void InterpolateFunctions(const double x[3], double *sf)
            override;
        
        Compute the interpolation functions/derivatives. (aka shape
        functions/derivatives) Two interpolation algorithms are
        available: 1/r^2 and Mean Value Coordinate. The former is used by
        default. To use the second algorithm, set UseMVCInterpolation to
        be true. The function assumes the input point lies on the polygon
        plane without checking that.
        """
        ...
    
    def IntersectConvex2DCells(self, vtkCell, vtkCell_1, p_float, p_float=..., p_float=..., p_float=..., *args, **kwargs):
        """
        V.IntersectConvex2DCells(vtkCell, vtkCell, float, [float, float,
            float], [float, float, float]) -> int
        C++: static int IntersectConvex2DCells(vtkCell *cell1,
            vtkCell *cell2, double tol, double p0[3], double p1[3])
        
        Intersect two convex 2D polygons to produce a line segment as
        output. The return status of the methods indicated no
        intersection (returns 0); a single point of intersection (returns
        1); or a line segment (i.e., two points of intersection, returns
        2). The points of intersection are returned in the arrays p0 and
        p1.  If less than two points of intersection are generated then
        p1 and/or p0 may be indeterminiate. Finally, if the two convex
        polygons are parallel, then "0" is returned (i.e., no
        intersection) even if the triangles lie on one another.
        """
        ...
    
    def IntersectPolygonWithPolygon(self, p_int, *float, **kwargs):
        """
        V.IntersectPolygonWithPolygon(int, [float, ...], [float, float,
            float, float, float, float], int, [float, ...], [float, float,
             float], float, [float, float, float]) -> int
        C++: static int IntersectPolygonWithPolygon(int npts, double *pts,
             double bounds[6], int npts2, double *pts2, double bounds2[3],
             double tol, double x[3])
        
        Method intersects two polygons. You must supply the number of
        points and point coordinates (npts, *pts) and the bounding box
        (bounds) of the two polygons. Also supply a tolerance squared for
        controlling error. The method returns 1 if there is an
        intersection, and 0 if not. A single point of intersection x[3]
        is also returned if there is an intersection.
        """
        ...
    
    def IntersectWithLine(self, , , p_float_6, p_float_7, p_float=..., p_float=..., p_float=..., *args, **kwargs):
        """
        V.IntersectWithLine((float, float, float), (float, float, float),
            float, float, [float, float, float], [float, float, float],
            int) -> int
        C++: int IntersectWithLine(const double p1[3], const double p2[3],
             double tol, double &t, double x[3], double pcoords[3],
            int &subId) override;
        
        See the vtkCell API for descriptions of these methods.
        """
        ...
    
    def IsA(self, string):
        """
        V.IsA(string) -> int
        C++: vtkTypeBool IsA(const char *type) override;
        
        Return 1 if this class is the same type of (or a subclass of) the
        named class. Returns 0 otherwise. This method works in
        combination with vtkTypeMacro found in vtkSetGet.h.
        """
        ...
    
    def IsConvex(self):
        """
        V.IsConvex() -> bool
        C++: bool IsConvex()
        V.IsConvex(vtkPoints, int, [int, ...]) -> bool
        C++: static bool IsConvex(vtkPoints *p, int numPts,
            vtkIdType *pts)
        V.IsConvex(vtkIdTypeArray, vtkPoints) -> bool
        C++: static bool IsConvex(vtkIdTypeArray *ids, vtkPoints *p)
        V.IsConvex(vtkPoints) -> bool
        C++: static bool IsConvex(vtkPoints *p)
        
        Determine whether or not a polygon is convex. This is a
        convenience function that simply calls static bool IsConvex(int
        numPts, vtkIdType *pts, vtkPoints *p) with the appropriate
        parameters from the instantiated vtkPolygon.
        """
        ...
    
    def IsPrimaryCell(self):
        """
        V.IsPrimaryCell() -> int
        C++: int IsPrimaryCell() override;
        
        See the vtkCell API for descriptions of these methods.
        """
        ...
    
    def IsTypeOf(self, string):
        """
        V.IsTypeOf(string) -> int
        C++: static vtkTypeBool IsTypeOf(const char *type)
        
        Return 1 if this class type is the same type of (or a subclass
        of) the named class. Returns 0 otherwise. This method works in
        combination with vtkTypeMacro found in vtkSetGet.h.
        """
        ...
    
    def NewInstance(self):
        """
        V.NewInstance() -> vtkPolygon
        C++: vtkPolygon *NewInstance()
        """
        ...
    
    def NonDegenerateTriangulate(self, vtkIdList):
        """
        V.NonDegenerateTriangulate(vtkIdList) -> int
        C++: int NonDegenerateTriangulate(vtkIdList *outTris)
        
        Same as Triangulate(vtkIdList *outTris) but with a first pass to
        split the polygon into non-degenerate polygons.
        """
        ...
    
    def ParameterizePolygon(self, p_float=..., p_float=..., p_float=..., *args, **kwargs):
        """
        V.ParameterizePolygon([float, float, float], [float, float,
            float], float, [float, float, float], float, [float, float,
            float]) -> int
        C++: int ParameterizePolygon(double p0[3], double p10[3],
            double &l10, double p20[3], double &l20, double n[3])
        
        Create a local s-t coordinate system for a polygon. The point p0
        is the origin of the local system, p10 is s-axis vector, and p20
        is the t-axis vector. (These are expressed in the modeling
        coordinate system and are vectors of dimension [3].) The values
        l20 and l20 are the lengths of the vectors p10 and p20, and n is
        the polygon normal.
        """
        ...
    
    def PointInPolygon(self, p_float=..., p_float=..., p_float=..., *args, **kwargs):
        """
        V.PointInPolygon([float, float, float], int, [float, ...], [float,
             float, float, float, float, float], [float, float, float])
            -> int
        C++: static int PointInPolygon(double x[3], int numPts,
            double *pts, double bounds[6], double n[3])
        
        Determine whether point is inside polygon. Function uses
        ray-casting to determine if point is inside polygon. Works for
        arbitrary polygon shape (e.g., non-convex). Returns 0 if point is
        not in polygon; 1 if it is. Can also return -1 to indicate
        degenerate polygon.
        """
        ...
    
    def SafeDownCast(self, vtkObjectBase):
        """
        V.SafeDownCast(vtkObjectBase) -> vtkPolygon
        C++: static vtkPolygon *SafeDownCast(vtkObjectBase *o)
        """
        ...
    
    def SetUseMVCInterpolation(self, bool):
        """
        V.SetUseMVCInterpolation(bool)
        C++: virtual void SetUseMVCInterpolation(bool _arg)
        
        Set/Get the flag indicating whether to use Mean Value Coordinate
        for the interpolation. If true, InterpolateFunctions() uses the
        Mean Value Coordinate to compute weights. Otherwise, the
        conventional 1/r^2 method is used. The UseMVCInterpolation
        parameter is set to false by default.
        """
        ...
    
    def Triangulate(self, p_int, vtkIdList, vtkPoints):
        """
        V.Triangulate(int, vtkIdList, vtkPoints) -> int
        C++: int Triangulate(int index, vtkIdList *ptIds, vtkPoints *pts)
            override;
        V.Triangulate(vtkIdList) -> int
        C++: int Triangulate(vtkIdList *outTris)
        
        See the vtkCell API for descriptions of these methods.
        """
        ...
    
    def __delattr__(self, *args, **kwargs):
        """ Implement delattr(self, name). """
        ...
    
    def __getattribute__(self, *args, **kwargs):
        """ Return getattr(self, name). """
        ...
    
    def __init__(self, *args, **kwargs) -> None:
        ...
    
    @staticmethod
    def __new__(*args, **kwargs):
        """ Create and return a new object.  See help(type) for accurate signature. """
        ...
    
    def __repr__(self, *args, **kwargs):
        """ Return repr(self). """
        ...
    
    def __setattr__(self, *args, **kwargs):
        """ Implement setattr(self, name, value). """
        ...
    
    def __str__(self, *args, **kwargs) -> str:
        """ Return str(self). """
        ...
    
    __this__ = ...
    __dict__ = ...
    __vtkname__ = ...


