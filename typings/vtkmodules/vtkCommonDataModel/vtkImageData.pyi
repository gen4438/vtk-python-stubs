"""
This type stub file was generated by pyright.
"""

from .vtkDataSet import vtkDataSet

class vtkImageData(vtkDataSet):
    """
    vtkImageData - topologically and geometrically regular array of data
    
    Superclass: vtkDataSet
    
    vtkImageData is a data object that is a concrete implementation of
    vtkDataSet. vtkImageData represents a geometric structure that is a
    topological and geometrical regular array of points. Examples include
    volumes (voxel data) and pixmaps.
    """
    def AllocateScalars(self, p_int, p_int_1):
        """
        V.AllocateScalars(int, int)
        C++: virtual void AllocateScalars(int dataType, int numComponents)
        V.AllocateScalars(vtkInformation)
        C++: virtual void AllocateScalars(vtkInformation *pipeline_info)
        
        Allocate the point scalars for this dataset. The data type
        determines the type of the array (VTK_FLOAT, VTK_INT etc.) where
        as numComponents determines its number of components.
        """
        ...
    
    def ComputeBounds(self):
        """
        V.ComputeBounds()
        C++: void ComputeBounds() override;
        
        Standard vtkDataSet API methods. See vtkDataSet for more
        information.
        \warning If GetCell(int,int,int) gets overridden in a subclass,
            it is
        necessary to override GetCell(vtkIdType) in that class as well
        since vtkImageData::GetCell(vtkIdType) will always call
        vkImageData::GetCell(int,int,int)
        """
        ...
    
    def ComputeCellId(self, p_int=..., p_int=..., p_int=...):
        """
        V.ComputeCellId([int, int, int]) -> int
        C++: virtual vtkIdType ComputeCellId(int ijk[3])
        
        Given a location in structured coordinates (i-j-k), return the
        cell id.
        """
        ...
    
    def ComputeIndexToPhysicalMatrix(self, , , , p_float=..., p_float=..., p_float=..., p_float=..., p_float=..., p_float=..., p_float=..., p_float=..., p_float=..., p_float=..., p_float=..., p_float=..., p_float=..., p_float=..., p_float=..., p_float=...):
        """
        V.ComputeIndexToPhysicalMatrix((float, float, float), (float,
            float, float), (float, float, float, float, float, float,
            float, float, float), [float, float, float, float, float,
            float, float, float, float, float, float, float, float, float,
             float, float])
        C++: static void ComputeIndexToPhysicalMatrix(
            double const origin[3], double const spacing[3],
            double const direction[9], double result[16])
        """
        ...
    
    def ComputeInternalExtent(self, *int, **kwargs):
        """
        V.ComputeInternalExtent([int, ...], [int, ...], [int, ...])
        C++: void ComputeInternalExtent(int *intExt, int *tgtExt,
            int *bnds)
        
        Given how many pixel are required on a side for bounrary
        conditions (in bnds), the target extent to traverse, compute the
        internal extent (the extent for this ImageData that does not
        suffer from any boundary conditions) and place it in intExt
        """
        ...
    
    def ComputePointId(self, p_int=..., p_int=..., p_int=...):
        """
        V.ComputePointId([int, int, int]) -> int
        C++: virtual vtkIdType ComputePointId(int ijk[3])
        
        Given a location in structured coordinates (i-j-k), return the
        point id.
        """
        ...
    
    def ComputeStructuredCoordinates(self, , p_int=..., p_int=..., p_int=..., *args, **kwargs):
        """
        V.ComputeStructuredCoordinates((float, float, float), [int, int,
            int], [float, float, float]) -> int
        C++: virtual int ComputeStructuredCoordinates(const double x[3],
            int ijk[3], double pcoords[3])
        
        Convenience function computes the structured coordinates for a
        point x[3]. The voxel is specified by the array ijk[3], and the
        parametric coordinates in the cell are specified with pcoords[3].
        The function returns a 0 if the point x is outside of the volume,
        and a 1 if inside the volume.
        """
        ...
    
    def CopyAndCastFrom(self, vtkImageData, p_int=..., p_int=..., p_int=..., p_int=..., p_int=..., p_int=...):
        """
        V.CopyAndCastFrom(vtkImageData, [int, int, int, int, int, int])
        C++: virtual void CopyAndCastFrom(vtkImageData *inData,
            int extent[6])
        V.CopyAndCastFrom(vtkImageData, int, int, int, int, int, int)
        C++: virtual void CopyAndCastFrom(vtkImageData *inData, int x0,
            int x1, int y0, int y1, int z0, int z1)
        
        This method is passed a input and output region, and executes the
        filter algorithm to fill the output from the input. It just
        executes a switch statement to call the correct function for the
        regions data types.
        """
        ...
    
    def CopyInformationFromPipeline(self, vtkInformation):
        """
        V.CopyInformationFromPipeline(vtkInformation)
        C++: void CopyInformationFromPipeline(vtkInformation *information)
             override;
        
        Override these to handle origin, spacing, scalar type, and scalar
        number of components.  See vtkDataObject for details.
        """
        ...
    
    def CopyInformationToPipeline(self, vtkInformation):
        """
        V.CopyInformationToPipeline(vtkInformation)
        C++: void CopyInformationToPipeline(vtkInformation *information)
            override;
        
        Copy information from this data object to the pipeline
        information. This is used by the vtkTrivialProducer that is
        created when someone calls SetInputData() to connect the image to
        a pipeline.
        """
        ...
    
    def CopyStructure(self, vtkDataSet):
        """
        V.CopyStructure(vtkDataSet)
        C++: void CopyStructure(vtkDataSet *ds) override;
        
        Copy the geometric and topological structure of an input image
        data object.
        """
        ...
    
    def Crop(self, int_tuple):
        """
        V.Crop((int, ...))
        C++: void Crop(const int *updateExtent) override;
        
        Reallocates and copies to set the Extent to updateExtent. This is
        used internally when the exact extent is requested, and the
        source generated more than the update extent.
        """
        ...
    
    def DeepCopy(self, vtkDataObject):
        """
        V.DeepCopy(vtkDataObject)
        C++: void DeepCopy(vtkDataObject *src) override;
        
        Shallow and Deep copy.
        """
        ...
    
    def FindAndGetCell(self, p_float=..., p_float=..., p_float=..., *args, **kwargs):
        """
        V.FindAndGetCell([float, float, float], vtkCell, int, float, int,
            [float, float, float], [float, ...]) -> vtkCell
        C++: vtkCell *FindAndGetCell(double x[3], vtkCell *cell,
            vtkIdType cellId, double tol2, int &subId, double pcoords[3],
            double *weights) override;
        
        Standard vtkDataSet API methods. See vtkDataSet for more
        information.
        \warning If GetCell(int,int,int) gets overridden in a subclass,
            it is
        necessary to override GetCell(vtkIdType) in that class as well
        since vtkImageData::GetCell(vtkIdType) will always call
        vkImageData::GetCell(int,int,int)
        """
        ...
    
    def FindCell(self, p_float=..., p_float=..., p_float=..., *args, **kwargs):
        """
        V.FindCell([float, float, float], vtkCell, int, float, int,
            [float, float, float], [float, ...]) -> int
        C++: vtkIdType FindCell(double x[3], vtkCell *cell,
            vtkIdType cellId, double tol2, int &subId, double pcoords[3],
            double *weights) override;
        V.FindCell([float, float, float], vtkCell, vtkGenericCell, int,
            float, int, [float, float, float], [float, ...]) -> int
        C++: vtkIdType FindCell(double x[3], vtkCell *cell,
            vtkGenericCell *gencell, vtkIdType cellId, double tol2,
            int &subId, double pcoords[3], double *weights) override;
        
        Standard vtkDataSet API methods. See vtkDataSet for more
        information.
        \warning If GetCell(int,int,int) gets overridden in a subclass,
            it is
        necessary to override GetCell(vtkIdType) in that class as well
        since vtkImageData::GetCell(vtkIdType) will always call
        vkImageData::GetCell(int,int,int)
        """
        ...
    
    def FindPoint(self, p_float, p_float_1, p_float_2):
        """
        V.FindPoint(float, float, float) -> int
        C++: virtual vtkIdType FindPoint(double x, double y, double z)
        V.FindPoint([float, float, float]) -> int
        C++: vtkIdType FindPoint(double x[3]) override;
        
        Standard vtkDataSet API methods. See vtkDataSet for more
        information.
        \warning If GetCell(int,int,int) gets overridden in a subclass,
            it is
        necessary to override GetCell(vtkIdType) in that class as well
        since vtkImageData::GetCell(vtkIdType) will always call
        vkImageData::GetCell(int,int,int)
        """
        ...
    
    def GetActualMemorySize(self):
        """
        V.GetActualMemorySize() -> int
        C++: unsigned long GetActualMemorySize() override;
        
        Return the actual size of the data in kibibytes (1024 bytes).
        This number is valid only after the pipeline has updated. The
        memory size returned is guaranteed to be greater than or equal to
        the memory required to represent the data (e.g., extra space in
        arrays, etc. are not included in the return value). THIS METHOD
        IS THREAD SAFE.
        """
        ...
    
    def GetArrayIncrements(self, vtkDataArray, p_int=..., p_int=..., p_int=...):
        """
        V.GetArrayIncrements(vtkDataArray, [int, int, int])
        C++: void GetArrayIncrements(vtkDataArray *array,
            vtkIdType increments[3])
        
        Since various arrays have different number of components, the
        will have different increments.
        """
        ...
    
    def GetArrayPointer(self, vtkDataArray, p_int=..., p_int=..., p_int=...):
        """
        V.GetArrayPointer(vtkDataArray, [int, int, int]) -> void
        C++: void *GetArrayPointer(vtkDataArray *array,
            int coordinates[3])
        
        These are convenience methods for getting a pointer from any
        filed array.  It is a start at expanding image filters to process
        any array (not just scalars).
        """
        ...
    
    def GetArrayPointerForExtent(self, vtkDataArray, p_int=..., p_int=..., p_int=..., p_int=..., p_int=..., p_int=...):
        """
        V.GetArrayPointerForExtent(vtkDataArray, [int, int, int, int, int,
             int]) -> void
        C++: void *GetArrayPointerForExtent(vtkDataArray *array,
            int extent[6])
        
        These are convenience methods for getting a pointer from any
        filed array.  It is a start at expanding image filters to process
        any array (not just scalars).
        """
        ...
    
    def GetAxisUpdateExtent(self, p_int, p_int_1, p_int_2, int_tuple):
        """
        V.GetAxisUpdateExtent(int, int, int, (int, ...))
        C++: virtual void GetAxisUpdateExtent(int axis, int &min,
            int &max, const int *updateExtent)
        
        Set / Get the extent on just one axis
        """
        ...
    
    def GetCell(self, p_int):
        """
        V.GetCell(int) -> vtkCell
        C++: vtkCell *GetCell(vtkIdType cellId) override;
        V.GetCell(int, int, int) -> vtkCell
        C++: vtkCell *GetCell(int i, int j, int k) override;
        V.GetCell(int, vtkGenericCell)
        C++: void GetCell(vtkIdType cellId, vtkGenericCell *cell)
            override;
        
        Standard vtkDataSet API methods. See vtkDataSet for more
        information.
        \warning If GetCell(int,int,int) gets overridden in a subclass,
            it is
        necessary to override GetCell(vtkIdType) in that class as well
        since vtkImageData::GetCell(vtkIdType) will always call
        vkImageData::GetCell(int,int,int)
        """
        ...
    
    def GetCellBounds(self, p_int, p_float=..., p_float=..., p_float=..., p_float=..., p_float=..., p_float=...):
        """
        V.GetCellBounds(int, [float, float, float, float, float, float])
        C++: void GetCellBounds(vtkIdType cellId, double bounds[6])
            override;
        
        Standard vtkDataSet API methods. See vtkDataSet for more
        information.
        \warning If GetCell(int,int,int) gets overridden in a subclass,
            it is
        necessary to override GetCell(vtkIdType) in that class as well
        since vtkImageData::GetCell(vtkIdType) will always call
        vkImageData::GetCell(int,int,int)
        """
        ...
    
    def GetCellPoints(self, p_int, vtkIdList):
        """
        V.GetCellPoints(int, vtkIdList)
        C++: void GetCellPoints(vtkIdType cellId, vtkIdList *ptIds)
            override;
        
        Standard vtkDataSet API methods. See vtkDataSet for more
        information.
        \warning If GetCell(int,int,int) gets overridden in a subclass,
            it is
        necessary to override GetCell(vtkIdType) in that class as well
        since vtkImageData::GetCell(vtkIdType) will always call
        vkImageData::GetCell(int,int,int)
        """
        ...
    
    def GetCellType(self, p_int):
        """
        V.GetCellType(int) -> int
        C++: int GetCellType(vtkIdType cellId) override;
        
        Standard vtkDataSet API methods. See vtkDataSet for more
        information.
        \warning If GetCell(int,int,int) gets overridden in a subclass,
            it is
        necessary to override GetCell(vtkIdType) in that class as well
        since vtkImageData::GetCell(vtkIdType) will always call
        vkImageData::GetCell(int,int,int)
        """
        ...
    
    def GetContinuousIncrements(self, p_int=..., p_int=..., p_int=..., p_int=..., p_int=..., p_int=..., *args, **kwargs):
        """
        V.GetContinuousIncrements([int, int, int, int, int, int], int,
            int, int)
        C++: virtual void GetContinuousIncrements(int extent[6],
            vtkIdType &incX, vtkIdType &incY, vtkIdType &incZ)
        V.GetContinuousIncrements(vtkDataArray, [int, int, int, int, int,
            int], int, int, int)
        C++: virtual void GetContinuousIncrements(vtkDataArray *scalars,
            int extent[6], vtkIdType &incX, vtkIdType &incY,
            vtkIdType &incZ)
        
        Different ways to get the increments for moving around the data.
        incX is always returned with 0.  incY is returned with the
        increment needed to move from the end of one X scanline of data
        to the start of the next line.  incZ is filled in with the
        increment needed to move from the end of one image to the start
        of the next.  The proper way to use these values is to for a loop
        over Z, Y, X, C, incrementing the pointer by 1 after each
        component.  When the end of the component is reached, the pointer
        is set to the beginning of the next pixel, thus incX is properly
        set to 0. The first form of GetContinuousIncrements uses the
        active scalar field while the second form allows the scalar array
        to be passed in.
        """
        ...
    
    def GetData(self, vtkInformation):
        """
        V.GetData(vtkInformation) -> vtkImageData
        C++: static vtkImageData *GetData(vtkInformation *info)
        V.GetData(vtkInformationVector, int) -> vtkImageData
        C++: static vtkImageData *GetData(vtkInformationVector *v,
            int i=0)
        
        Retrieve an instance of this class from an information object.
        """
        ...
    
    def GetDataDimension(self):
        """
        V.GetDataDimension() -> int
        C++: virtual int GetDataDimension()
        
        Return the dimensionality of the data.
        """
        ...
    
    def GetDataObjectType(self):
        """
        V.GetDataObjectType() -> int
        C++: int GetDataObjectType() override;
        
        Return what type of dataset this is.
        """
        ...
    
    def GetDimensions(self):
        """
        V.GetDimensions() -> (int, int, int)
        C++: virtual int *GetDimensions()
        V.GetDimensions([int, int, int])
        C++: virtual void GetDimensions(int dims[3])
        V.GetDimensions([int, int, int])
        C++: virtual void GetDimensions(vtkIdType dims[3])
        
        Get dimensions of this structured points dataset. It is the
        number of points on each axis. Dimensions are computed from
        Extents during this call.
        \warning Non thread-safe, use second signature if you want it to
            be.
        """
        ...
    
    def GetDirectionMatrix(self):
        """
        V.GetDirectionMatrix() -> vtkMatrix3x3
        C++: virtual vtkMatrix3x3 *GetDirectionMatrix()
        
        Set/Get the direction transform of the dataset. The direction is
        a 3 by 3 matrix.
        """
        ...
    
    def GetExtent(self):
        """
        V.GetExtent() -> (int, int, int, int, int, int)
        C++: virtual int *GetExtent()
        
        Set/Get the extent. On each axis, the extent is defined by the
        index of the first point and the index of the last point.  The
        extent should be set before the "Scalars" are set or allocated. 
        The Extent is stored in the order (X, Y, Z). The dataset extent
        does not have to start at (0,0,0). (0,0,0) is just the extent of
        the origin. The first point (the one with Id=0) is at extent
        (Extent[0],Extent[2],Extent[4]). As for any dataset, a data array
        on point data starts at Id=0.
        """
        ...
    
    def GetExtentType(self):
        """
        V.GetExtentType() -> int
        C++: int GetExtentType() override;
        
        The extent type is a 3D extent
        """
        ...
    
    def GetIncrements(self):
        """
        V.GetIncrements() -> (int, int, int)
        C++: virtual vtkIdType *GetIncrements()
        V.GetIncrements(int, int, int)
        C++: virtual void GetIncrements(vtkIdType &incX, vtkIdType &incY,
            vtkIdType &incZ)
        V.GetIncrements([int, int, int])
        C++: virtual void GetIncrements(vtkIdType inc[3])
        V.GetIncrements(vtkDataArray) -> (int, int, int)
        C++: virtual vtkIdType *GetIncrements(vtkDataArray *scalars)
        V.GetIncrements(vtkDataArray, int, int, int)
        C++: virtual void GetIncrements(vtkDataArray *scalars,
            vtkIdType &incX, vtkIdType &incY, vtkIdType &incZ)
        V.GetIncrements(vtkDataArray, [int, int, int])
        C++: virtual void GetIncrements(vtkDataArray *scalars,
            vtkIdType inc[3])
        
        Different ways to get the increments for moving around the data.
        GetIncrements() calls ComputeIncrements() to ensure the
        increments are up to date.  The first three methods compute the
        increments based on the active scalar field while the next three,
        the scalar field is passed in.
        """
        ...
    
    def GetIndexToPhysicalMatrix(self):
        """
        V.GetIndexToPhysicalMatrix() -> vtkMatrix4x4
        C++: virtual vtkMatrix4x4 *GetIndexToPhysicalMatrix()
        
        Get the transformation matrix from the index space to the
        physical space coordinate system of the dataset. The transform is
        a 4 by 4 matrix.
        """
        ...
    
    def GetMaxCellSize(self):
        """
        V.GetMaxCellSize() -> int
        C++: int GetMaxCellSize() override;
        
        Standard vtkDataSet API methods. See vtkDataSet for more
        information.
        \warning If GetCell(int,int,int) gets overridden in a subclass,
            it is
        necessary to override GetCell(vtkIdType) in that class as well
        since vtkImageData::GetCell(vtkIdType) will always call
        vkImageData::GetCell(int,int,int)
        """
        ...
    
    def GetNumberOfCells(self):
        """
        V.GetNumberOfCells() -> int
        C++: vtkIdType GetNumberOfCells() override;
        
        Standard vtkDataSet API methods. See vtkDataSet for more
        information.
        \warning If GetCell(int,int,int) gets overridden in a subclass,
            it is
        necessary to override GetCell(vtkIdType) in that class as well
        since vtkImageData::GetCell(vtkIdType) will always call
        vkImageData::GetCell(int,int,int)
        """
        ...
    
    def GetNumberOfGenerationsFromBase(self, string):
        """
        V.GetNumberOfGenerationsFromBase(string) -> int
        C++: vtkIdType GetNumberOfGenerationsFromBase(const char *type)
            override;
        
        Given a the name of a base class of this class type, return the
        distance of inheritance between this class type and the named
        class (how many generations of inheritance are there between this
        class and the named class). If the named class is not in this
        class's inheritance tree, return a negative value. Valid
        responses will always be nonnegative. This method works in
        combination with vtkTypeMacro found in vtkSetGet.h.
        """
        ...
    
    def GetNumberOfGenerationsFromBaseType(self, string):
        """
        V.GetNumberOfGenerationsFromBaseType(string) -> int
        C++: static vtkIdType GetNumberOfGenerationsFromBaseType(
            const char *type)
        
        Given a the name of a base class of this class type, return the
        distance of inheritance between this class type and the named
        class (how many generations of inheritance are there between this
        class and the named class). If the named class is not in this
        class's inheritance tree, return a negative value. Valid
        responses will always be nonnegative. This method works in
        combination with vtkTypeMacro found in vtkSetGet.h.
        """
        ...
    
    def GetNumberOfPoints(self):
        """
        V.GetNumberOfPoints() -> int
        C++: vtkIdType GetNumberOfPoints() override;
        
        Standard vtkDataSet API methods. See vtkDataSet for more
        information.
        \warning If GetCell(int,int,int) gets overridden in a subclass,
            it is
        necessary to override GetCell(vtkIdType) in that class as well
        since vtkImageData::GetCell(vtkIdType) will always call
        vkImageData::GetCell(int,int,int)
        """
        ...
    
    def GetNumberOfScalarComponents(self, vtkInformation):
        """
        V.GetNumberOfScalarComponents(vtkInformation) -> int
        C++: static int GetNumberOfScalarComponents(
            vtkInformation *meta_data)
        V.GetNumberOfScalarComponents() -> int
        C++: int GetNumberOfScalarComponents()
        
        Set/Get the number of scalar components for points. As with the
        SetScalarType method this is setting pipeline info.
        """
        ...
    
    def GetOrigin(self):
        """
        V.GetOrigin() -> (float, float, float)
        C++: virtual double *GetOrigin()
        
        Set/Get the origin of the dataset. The origin is the position in
        world coordinates of the point of extent (0,0,0). This point does
        not have to be part of the dataset, in other words, the dataset
        extent does not have to start at (0,0,0) and the origin can be
        outside of the dataset bounding box. The origin plus spacing
        determine the position in space of the points.
        """
        ...
    
    def GetPhysicalToIndexMatrix(self):
        """
        V.GetPhysicalToIndexMatrix() -> vtkMatrix4x4
        C++: virtual vtkMatrix4x4 *GetPhysicalToIndexMatrix()
        
        Get the transformation matrix from the physical space to the
        index space coordinate system of the dataset. The transform is a
        4 by 4 matrix.
        """
        ...
    
    def GetPoint(self, p_int):
        """
        V.GetPoint(int) -> (float, float, float)
        C++: double *GetPoint(vtkIdType ptId) override;
        V.GetPoint(int, [float, float, float])
        C++: void GetPoint(vtkIdType id, double x[3]) override;
        
        Standard vtkDataSet API methods. See vtkDataSet for more
        information.
        \warning If GetCell(int,int,int) gets overridden in a subclass,
            it is
        necessary to override GetCell(vtkIdType) in that class as well
        since vtkImageData::GetCell(vtkIdType) will always call
        vkImageData::GetCell(int,int,int)
        """
        ...
    
    def GetPointCells(self, p_int, vtkIdList):
        """
        V.GetPointCells(int, vtkIdList)
        C++: void GetPointCells(vtkIdType ptId, vtkIdList *cellIds)
            override;
        
        Standard vtkDataSet API methods. See vtkDataSet for more
        information.
        \warning If GetCell(int,int,int) gets overridden in a subclass,
            it is
        necessary to override GetCell(vtkIdType) in that class as well
        since vtkImageData::GetCell(vtkIdType) will always call
        vkImageData::GetCell(int,int,int)
        """
        ...
    
    def GetPointGradient(self, p_int, p_int_1, p_int_2, vtkDataArray, p_float=..., p_float=..., p_float=...):
        """
        V.GetPointGradient(int, int, int, vtkDataArray, [float, float,
            float])
        C++: virtual void GetPointGradient(int i, int j, int k,
            vtkDataArray *s, double g[3])
        
        Given structured coordinates (i,j,k) for a point in a structured
        point dataset, compute the gradient vector from the scalar data
        at that point. The scalars s are the scalars from which the
        gradient is to be computed. This method will treat structured
        point datasets of any dimension.
        """
        ...
    
    def GetScalarComponentAsDouble(self, p_int, p_int_1, p_int_2, p_int_3):
        """
        V.GetScalarComponentAsDouble(int, int, int, int) -> float
        C++: virtual double GetScalarComponentAsDouble(int x, int y,
            int z, int component)
        
        For access to data from wrappers
        """
        ...
    
    def GetScalarComponentAsFloat(self, p_int, p_int_1, p_int_2, p_int_3):
        """
        V.GetScalarComponentAsFloat(int, int, int, int) -> float
        C++: virtual float GetScalarComponentAsFloat(int x, int y, int z,
            int component)
        
        For access to data from wrappers
        """
        ...
    
    def GetScalarPointer(self, p_int=..., p_int=..., p_int=...):
        """
        V.GetScalarPointer([int, int, int]) -> void
        C++: virtual void *GetScalarPointer(int coordinates[3])
        V.GetScalarPointer(int, int, int) -> void
        C++: virtual void *GetScalarPointer(int x, int y, int z)
        V.GetScalarPointer() -> void
        C++: virtual void *GetScalarPointer()
        
        Access the native pointer for the scalar data
        """
        ...
    
    def GetScalarPointerForExtent(self, p_int=..., p_int=..., p_int=..., p_int=..., p_int=..., p_int=...):
        """
        V.GetScalarPointerForExtent([int, int, int, int, int, int])
            -> void
        C++: virtual void *GetScalarPointerForExtent(int extent[6])
        
        Access the native pointer for the scalar data
        """
        ...
    
    def GetScalarSize(self, vtkInformation):
        """
        V.GetScalarSize(vtkInformation) -> int
        C++: virtual int GetScalarSize(vtkInformation *meta_data)
        V.GetScalarSize() -> int
        C++: virtual int GetScalarSize()
        
        Get the size of the scalar type in bytes.
        """
        ...
    
    def GetScalarType(self, vtkInformation):
        """
        V.GetScalarType(vtkInformation) -> int
        C++: static int GetScalarType(vtkInformation *meta_data)
        V.GetScalarType() -> int
        C++: int GetScalarType()
        """
        ...
    
    def GetScalarTypeAsString(self):
        """
        V.GetScalarTypeAsString() -> string
        C++: const char *GetScalarTypeAsString()
        """
        ...
    
    def GetScalarTypeMax(self, vtkInformation):
        """
        V.GetScalarTypeMax(vtkInformation) -> float
        C++: virtual double GetScalarTypeMax(vtkInformation *meta_data)
        V.GetScalarTypeMax() -> float
        C++: virtual double GetScalarTypeMax()
        
        These returns the minimum and maximum values the ScalarType can
        hold without overflowing.
        """
        ...
    
    def GetScalarTypeMin(self, vtkInformation):
        """
        V.GetScalarTypeMin(vtkInformation) -> float
        C++: virtual double GetScalarTypeMin(vtkInformation *meta_data)
        V.GetScalarTypeMin() -> float
        C++: virtual double GetScalarTypeMin()
        
        These returns the minimum and maximum values the ScalarType can
        hold without overflowing.
        """
        ...
    
    def GetSpacing(self):
        """
        V.GetSpacing() -> (float, float, float)
        C++: virtual double *GetSpacing()
        
        Set the spacing (width,height,length) of the cubical cells that
        compose the data set.
        """
        ...
    
    def GetVoxelGradient(self, p_int, p_int_1, p_int_2, vtkDataArray, vtkDataArray_1):
        """
        V.GetVoxelGradient(int, int, int, vtkDataArray, vtkDataArray)
        C++: virtual void GetVoxelGradient(int i, int j, int k,
            vtkDataArray *s, vtkDataArray *g)
        
        Given structured coordinates (i,j,k) for a voxel cell, compute
        the eight gradient values for the voxel corners. The order in
        which the gradient vectors are arranged corresponds to the
        ordering of the voxel points. Gradient vector is computed by
        central differences (except on edges of volume where forward
        difference is used). The scalars s are the scalars from which the
        gradient is to be computed. This method will treat only 3D
        structured point datasets (i.e., volumes).
        """
        ...
    
    def HasNumberOfScalarComponents(self, vtkInformation):
        """
        V.HasNumberOfScalarComponents(vtkInformation) -> bool
        C++: static bool HasNumberOfScalarComponents(
            vtkInformation *meta_data)
        
        Set/Get the number of scalar components for points. As with the
        SetScalarType method this is setting pipeline info.
        """
        ...
    
    def HasScalarType(self, vtkInformation):
        """
        V.HasScalarType(vtkInformation) -> bool
        C++: static bool HasScalarType(vtkInformation *meta_data)
        """
        ...
    
    def Initialize(self):
        """
        V.Initialize()
        C++: void Initialize() override;
        
        Restore data object to initial state.
        """
        ...
    
    def IsA(self, string):
        """
        V.IsA(string) -> int
        C++: vtkTypeBool IsA(const char *type) override;
        
        Return 1 if this class is the same type of (or a subclass of) the
        named class. Returns 0 otherwise. This method works in
        combination with vtkTypeMacro found in vtkSetGet.h.
        """
        ...
    
    def IsTypeOf(self, string):
        """
        V.IsTypeOf(string) -> int
        C++: static vtkTypeBool IsTypeOf(const char *type)
        
        Return 1 if this class type is the same type of (or a subclass
        of) the named class. Returns 0 otherwise. This method works in
        combination with vtkTypeMacro found in vtkSetGet.h.
        """
        ...
    
    def NewInstance(self):
        """
        V.NewInstance() -> vtkImageData
        C++: vtkImageData *NewInstance()
        """
        ...
    
    def PrepareForNewData(self):
        """
        V.PrepareForNewData()
        C++: void PrepareForNewData() override;
        
        make the output data ready for new data to be inserted. For most
        objects we just call Initialize. But for image data we leave the
        old data in case the memory can be reused.
        """
        ...
    
    def SafeDownCast(self, vtkObjectBase):
        """
        V.SafeDownCast(vtkObjectBase) -> vtkImageData
        C++: static vtkImageData *SafeDownCast(vtkObjectBase *o)
        """
        ...
    
    def SetAxisUpdateExtent(self, p_int, p_int_1, p_int_2, int_tuple, *int):
        """
        V.SetAxisUpdateExtent(int, int, int, (int, ...), [int, ...])
        C++: virtual void SetAxisUpdateExtent(int axis, int min, int max,
            const int *updateExtent, int *axisUpdateExtent)
        
        Set / Get the extent on just one axis
        """
        ...
    
    def SetDimensions(self, p_int, p_int_1, p_int_2):
        """
        V.SetDimensions(int, int, int)
        C++: virtual void SetDimensions(int i, int j, int k)
        V.SetDimensions((int, int, int))
        C++: virtual void SetDimensions(const int dims[3])
        
        Same as SetExtent(0, i-1, 0, j-1, 0, k-1)
        """
        ...
    
    def SetDirectionMatrix(self, vtkMatrix3x3):
        """
        V.SetDirectionMatrix(vtkMatrix3x3)
        C++: virtual void SetDirectionMatrix(vtkMatrix3x3 *m)
        V.SetDirectionMatrix((float, float, float, float, float, float,
            float, float, float))
        C++: virtual void SetDirectionMatrix(const double elements[9])
        V.SetDirectionMatrix(float, float, float, float, float, float,
            float, float, float)
        C++: virtual void SetDirectionMatrix(double e00, double e01,
            double e02, double e10, double e11, double e12, double e20,
            double e21, double e22)
        
        Set/Get the direction transform of the dataset. The direction is
        a 3 by 3 matrix.
        """
        ...
    
    def SetExtent(self, p_int=..., p_int=..., p_int=..., p_int=..., p_int=..., p_int=...):
        """
        V.SetExtent([int, int, int, int, int, int])
        C++: virtual void SetExtent(int extent[6])
        V.SetExtent(int, int, int, int, int, int)
        C++: virtual void SetExtent(int x1, int x2, int y1, int y2,
            int z1, int z2)
        
        Set/Get the extent. On each axis, the extent is defined by the
        index of the first point and the index of the last point.  The
        extent should be set before the "Scalars" are set or allocated. 
        The Extent is stored in the order (X, Y, Z). The dataset extent
        does not have to start at (0,0,0). (0,0,0) is just the extent of
        the origin. The first point (the one with Id=0) is at extent
        (Extent[0],Extent[2],Extent[4]). As for any dataset, a data array
        on point data starts at Id=0.
        """
        ...
    
    def SetNumberOfScalarComponents(self, p_int, vtkInformation):
        """
        V.SetNumberOfScalarComponents(int, vtkInformation)
        C++: static void SetNumberOfScalarComponents(int n,
            vtkInformation *meta_data)
        
        Set/Get the number of scalar components for points. As with the
        SetScalarType method this is setting pipeline info.
        """
        ...
    
    def SetOrigin(self, p_float, p_float_1, p_float_2):
        """
        V.SetOrigin(float, float, float)
        C++: virtual void SetOrigin(double i, double j, double k)
        V.SetOrigin((float, float, float))
        C++: virtual void SetOrigin(const double ijk[3])
        
        Set/Get the origin of the dataset. The origin is the position in
        world coordinates of the point of extent (0,0,0). This point does
        not have to be part of the dataset, in other words, the dataset
        extent does not have to start at (0,0,0) and the origin can be
        outside of the dataset bounding box. The origin plus spacing
        determine the position in space of the points.
        """
        ...
    
    def SetScalarComponentFromDouble(self, p_int, p_int_1, p_int_2, p_int_3, p_float):
        """
        V.SetScalarComponentFromDouble(int, int, int, int, float)
        C++: virtual void SetScalarComponentFromDouble(int x, int y,
            int z, int component, double v)
        
        For access to data from wrappers
        """
        ...
    
    def SetScalarComponentFromFloat(self, p_int, p_int_1, p_int_2, p_int_3, p_float):
        """
        V.SetScalarComponentFromFloat(int, int, int, int, float)
        C++: virtual void SetScalarComponentFromFloat(int x, int y, int z,
             int component, float v)
        
        For access to data from wrappers
        """
        ...
    
    def SetScalarType(self, p_int, vtkInformation):
        """
        V.SetScalarType(int, vtkInformation)
        C++: static void SetScalarType(int, vtkInformation *meta_data)
        """
        ...
    
    def SetSpacing(self, p_float, p_float_1, p_float_2):
        """
        V.SetSpacing(float, float, float)
        C++: virtual void SetSpacing(double i, double j, double k)
        V.SetSpacing((float, float, float))
        C++: virtual void SetSpacing(const double ijk[3])
        
        Set the spacing (width,height,length) of the cubical cells that
        compose the data set.
        """
        ...
    
    def ShallowCopy(self, vtkDataObject):
        """
        V.ShallowCopy(vtkDataObject)
        C++: void ShallowCopy(vtkDataObject *src) override;
        
        Shallow and Deep copy.
        """
        ...
    
    def TransformContinuousIndexToPhysicalPoint(self, p_float, p_float_1, p_float_2, p_float=..., p_float=..., p_float=...):
        """
        V.TransformContinuousIndexToPhysicalPoint(float, float, float,
            [float, float, float])
        C++: virtual void TransformContinuousIndexToPhysicalPoint(
            double i, double j, double k, double xyz[3])
        V.TransformContinuousIndexToPhysicalPoint((float, float, float),
            [float, float, float])
        C++: virtual void TransformContinuousIndexToPhysicalPoint(
            const double ijk[3], double xyz[3])
        V.TransformContinuousIndexToPhysicalPoint(float, float, float, (
            float, float, float), (float, float, float), (float, float,
            float, float, float, float, float, float, float), [float,
            float, float])
        C++: static void TransformContinuousIndexToPhysicalPoint(double i,
             double j, double k, double const origin[3],
            double const spacing[3], double const direction[9],
            double xyz[3])
        
        Convert coordinates from index space (ijk) to physical space
        (xyz)
        """
        ...
    
    def TransformIndexToPhysicalPoint(self, p_int, p_int_1, p_int_2, p_float=..., p_float=..., p_float=...):
        """
        V.TransformIndexToPhysicalPoint(int, int, int, [float, float,
            float])
        C++: virtual void TransformIndexToPhysicalPoint(int i, int j,
            int k, double xyz[3])
        V.TransformIndexToPhysicalPoint((int, int, int), [float, float,
            float])
        C++: virtual void TransformIndexToPhysicalPoint(const int ijk[3],
            double xyz[3])
        
        Convert coordinates from index space (ijk) to physical space
        (xyz)
        """
        ...
    
    def TransformPhysicalNormalToContinuousIndex(self, , p_float=..., p_float=..., p_float=...):
        """
        V.TransformPhysicalNormalToContinuousIndex((float, float, float),
            [float, float, float])
        C++: virtual void TransformPhysicalNormalToContinuousIndex(
            const double xyz[3], double ijk[3])
        
        Convert normal from physical space (xyz) to index space (ijk)
        """
        ...
    
    def TransformPhysicalPlaneToContinuousIndex(self, , p_float=..., p_float=..., p_float=..., p_float=...):
        """
        V.TransformPhysicalPlaneToContinuousIndex((float, float, float,
            float), [float, float, float, float])
        C++: virtual void TransformPhysicalPlaneToContinuousIndex(
            double const pplane[4], double iplane[4])
        
        Convert a plane form physical to continuous index
        """
        ...
    
    def TransformPhysicalPointToContinuousIndex(self, p_float, p_float_1, p_float_2, p_float=..., p_float=..., p_float=...):
        """
        V.TransformPhysicalPointToContinuousIndex(float, float, float,
            [float, float, float])
        C++: virtual void TransformPhysicalPointToContinuousIndex(
            double x, double y, double z, double ijk[3])
        V.TransformPhysicalPointToContinuousIndex((float, float, float),
            [float, float, float])
        C++: virtual void TransformPhysicalPointToContinuousIndex(
            const double xyz[3], double ijk[3])
        
        Convert coordinates from physical space (xyz) to index space
        (ijk)
        """
        ...
    
    def __delattr__(self, *args, **kwargs):
        """ Implement delattr(self, name). """
        ...
    
    def __getattribute__(self, *args, **kwargs):
        """ Return getattr(self, name). """
        ...
    
    def __init__(self, *args, **kwargs) -> None:
        ...
    
    @staticmethod
    def __new__(*args, **kwargs):
        """ Create and return a new object.  See help(type) for accurate signature. """
        ...
    
    def __repr__(self, *args, **kwargs):
        """ Return repr(self). """
        ...
    
    def __setattr__(self, *args, **kwargs):
        """ Implement setattr(self, name, value). """
        ...
    
    def __str__(self, *args, **kwargs) -> str:
        """ Return str(self). """
        ...
    
    __this__ = ...
    __dict__ = ...
    __vtkname__ = ...


