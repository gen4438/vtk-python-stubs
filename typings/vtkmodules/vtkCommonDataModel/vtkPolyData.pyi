"""
This type stub file was generated by pyright.
"""

from .vtkPointSet import vtkPointSet

class vtkPolyData(vtkPointSet):
    """
    vtkPolyData - concrete dataset represents vertices, lines, polygons,
    and triangle strips
    
    Superclass: vtkPointSet
    
    vtkPolyData is a data object that is a concrete implementation of
    vtkDataSet. vtkPolyData represents a geometric structure consisting
    of vertices, lines, polygons, and/or triangle strips. Point and cell
    attribute values (e.g., scalars, vectors, etc.) also are represented.
    
    The actual cell types (vtkCellType.h) supported by vtkPolyData are:
    vtkVertex, vtkPolyVertex, vtkLine, vtkPolyLine, vtkTriangle, vtkQuad,
    vtkPolygon, and vtkTriangleStrip.
    
    One important feature of vtkPolyData objects is that special
    traversal and data manipulation methods are available to process
    data. These methods are generally more efficient than vtkDataSet
    methods and should be used whenever possible. For example, traversing
    the cells in a dataset we would use GetCell(). To traverse cells with
    vtkPolyData we would retrieve the cell array object representing
    polygons (for example using GetPolys()) and then use vtkCellArray's
    InitTraversal() and GetNextCell() methods.
    
    @warning
    Because vtkPolyData is implemented with four separate instances of
    vtkCellArray to represent 0D vertices, 1D lines, 2D polygons, and 2D
    triangle strips, it is possible to create vtkPolyData instances that
    consist of a mixture of cell types. Because of the design of the
    class, there are certain limitations on how mixed cell types are
    inserted into the vtkPolyData, and in turn the order in which they
    are processed and rendered. To preserve the consistency of cell ids,
    and to insure that cells with cell data are rendered properly, users
    must insert mixed cells in the order of vertices (vtkVertex and
    vtkPolyVertex), lines (vtkLine and vtkPolyLine), polygons
    (vtkTriangle, vtkQuad, vtkPolygon), and triangle strips
    (vtkTriangleStrip).
    
    @warning
    Some filters when processing vtkPolyData with mixed cell types may
    process the cells in differing ways. Some will convert one type into
    another (e.g., vtkTriangleStrip into vtkTriangles) or expect a
    certain type (vtkDecimatePro expects triangles or triangle strips;
    vtkTubeFilter expects lines). Read the documentation for each filter
    carefully to understand how each part of vtkPolyData is processed.
    
    @warning
    Some of the methods specified here function properly only when the
    dataset has been specified as "Editable". They are documented as
    such.
    """
    def AddCellReference(self, p_int):
        """
        V.AddCellReference(int)
        C++: void AddCellReference(vtkIdType cellId)
        
        Add references to cell in cell structure. This means the links
        from the cell's points to the cell are modified. Memory is not
        extended. Use the method ResizeCellList() to resize the link list
        from a point to its using cells. (This operator assumes
        BuildLinks() has been called.) Use this method only when the
        dataset is set as Editable.
        """
        ...
    
    def AddReferenceToCell(self, p_int, p_int_1):
        """
        V.AddReferenceToCell(int, int)
        C++: void AddReferenceToCell(vtkIdType ptId, vtkIdType cellId)
        
        Add a reference to a cell in a particular point's link list. (You
        may also consider using AddCellReference() to add the references
        from all the cell's points to the cell.) This operator does not
        realloc memory; use the operator ResizeCellList() to do this if
        necessary. Use this method only when the dataset is set as
        Editable.
        """
        ...
    
    def Allocate(self, p_int, p_int_1):
        """
        V.Allocate(int, int)
        C++: void Allocate(vtkIdType numCells=1000, int extSize=1000)
        V.Allocate(vtkPolyData, int, int)
        C++: void Allocate(vtkPolyData *inPolyData,
            vtkIdType numCells=1000, int extSize=1000)
        
        Method allocates initial storage for vertex, line, polygon, and
        triangle strip arrays. Use this method before the method
        PolyData::InsertNextCell(). (Or, provide vertex, line, polygon,
        and triangle strip cell arrays). extSize is no longer used.
        """
        ...
    
    def AllocateCopy(self, vtkPolyData):
        """
        V.AllocateCopy(vtkPolyData) -> bool
        C++: bool AllocateCopy(vtkPolyData *pd)
        
        Preallocate memory for the internal cell arrays such that they
        are the same size as those in pd.
        
        Existing data is not preserved and the number of cells is set to
        zero.
        
        @return True if allocation succeeds.
        """
        ...
    
    def AllocateEstimate(self, p_int, p_int_1):
        """
        V.AllocateEstimate(int, int) -> bool
        C++: bool AllocateEstimate(vtkIdType numCells,
            vtkIdType maxCellSize)
        V.AllocateEstimate(int, int, int, int, int, int, int, int) -> bool
        C++: bool AllocateEstimate(vtkIdType numVerts,
            vtkIdType maxVertSize, vtkIdType numLines,
            vtkIdType maxLineSize, vtkIdType numPolys,
            vtkIdType maxPolySize, vtkIdType numStrips,
            vtkIdType maxStripSize)
        
        Preallocate memory for the internal cell arrays. Each of the
        internal cell arrays (verts, lines, polys, and strips) will be
        resized to holdnumCells cells of size maxCellSize.
        
        Existing data is not preserved and the number of cells is set to
        zero.
        
        @return True if allocation succeeds.
        """
        ...
    
    def AllocateExact(self, p_int, p_int_1):
        """
        V.AllocateExact(int, int) -> bool
        C++: bool AllocateExact(vtkIdType numCells,
            vtkIdType connectivitySize)
        V.AllocateExact(int, int, int, int, int, int, int, int) -> bool
        C++: bool AllocateExact(vtkIdType numVerts,
            vtkIdType vertConnSize, vtkIdType numLines,
            vtkIdType lineConnSize, vtkIdType numPolys,
            vtkIdType polyConnSize, vtkIdType numStrips,
            vtkIdType stripConnSize)
        
        Preallocate memory for the internal cell arrays. Each of the
        internal cell arrays (verts, lines, polys, and strips) will be
        resized to holdnumCells cells and connectivitySize pointIds.
        
        Existing data is not preserved and the number of cells is set to
        zero.
        
        @return True if allocation succeeds.
        """
        ...
    
    def AllocateProportional(self, vtkPolyData, p_float):
        """
        V.AllocateProportional(vtkPolyData, float) -> bool
        C++: bool AllocateProportional(vtkPolyData *pd, double ratio)
        
        Preallocate memory for the internal cell arrays such that they
        are proportional to those in pd by a factor of ratio (for
        instance,ratio = 2 allocates twice as many cells).
        
        Existing data is not preserved and the number of cells is set to
        zero.
        
        @return True if allocation succeeds.
        """
        ...
    
    def BuildCells(self):
        """
        V.BuildCells()
        C++: void BuildCells()
        
        Create data structure that allows random access of cells.
        BuildCells is expensive but necessary to make use of the faster
        non-virtual implementations of GetCell/GetCellPoints. One may
        check if cells need to be built via NeedToBuilds before invoking.
        Cells always need to be built/re-built after low level direct
        modifications to verts, lines, polys or strips cell arrays.
        """
        ...
    
    def BuildLinks(self, p_int):
        """
        V.BuildLinks(int)
        C++: void BuildLinks(int initialSize=0)
        
        Create upward links from points to cells that use each point.
        Enables topologically complex queries. Normally the links array
        is allocated based on the number of points in the vtkPolyData.
        The optional initialSize parameter can be used to allocate a
        larger size initially.
        """
        ...
    
    def ComputeBounds(self):
        """
        V.ComputeBounds()
        C++: void ComputeBounds() override;
        
        Compute the (X, Y, Z)  bounds of the data. Note that the method
        only considers points that are used by cells (unless there are no
        cells, in which case all points are considered). This is done for
        usability and historical reasons.
        """
        ...
    
    def CopyCells(self, vtkPolyData, vtkIdList, vtkIncrementalPointLocator):
        """
        V.CopyCells(vtkPolyData, vtkIdList, vtkIncrementalPointLocator)
        C++: void CopyCells(vtkPolyData *pd, vtkIdList *idList,
            vtkIncrementalPointLocator *locator=nullptr)
        
        Copy cells listed in idList from pd, including points, point
        data, and cell data.  This method assumes that point and cell
        data have been allocated.  If you pass in a point locator, then
        the points won't be duplicated in the output. This requires the
        use of an incremental point locator.
        """
        ...
    
    def CopyStructure(self, vtkDataSet):
        """
        V.CopyStructure(vtkDataSet)
        C++: void CopyStructure(vtkDataSet *ds) override;
        
        Copy the geometric and topological structure of an input poly
        data object.
        """
        ...
    
    def DeepCopy(self, vtkDataObject):
        """
        V.DeepCopy(vtkDataObject)
        C++: void DeepCopy(vtkDataObject *src) override;
        
        Shallow and Deep copy.
        """
        ...
    
    def DeleteCell(self, p_int):
        """
        V.DeleteCell(int)
        C++: void DeleteCell(vtkIdType cellId)
        
        Mark a point/cell as deleted from this vtkPolyData. Use this
        method only when the dataset is set as Editable.
        """
        ...
    
    def DeleteCells(self):
        """
        V.DeleteCells()
        C++: void DeleteCells()
        
        Release data structure that allows random access of the cells.
        This must be done before a 2nd call to BuildLinks(). DeleteCells
        implicitly deletes the links as well since they are no longer
        valid.
        """
        ...
    
    def DeleteLinks(self):
        """
        V.DeleteLinks()
        C++: void DeleteLinks()
        
        Release the upward links from point to cells that use each point.
        """
        ...
    
    def DeletePoint(self, p_int):
        """
        V.DeletePoint(int)
        C++: void DeletePoint(vtkIdType ptId)
        
        Mark a point/cell as deleted from this vtkPolyData. Use this
        method only when the dataset is set as Editable.
        """
        ...
    
    def GetActualMemorySize(self):
        """
        V.GetActualMemorySize() -> int
        C++: unsigned long GetActualMemorySize() override;
        
        Return the actual size of the data in kibibytes (1024 bytes).
        This number is valid only after the pipeline has updated. The
        memory size returned is guaranteed to be greater than or equal to
        the memory required to represent the data (e.g., extra space in
        arrays, etc. are not included in the return value). THIS METHOD
        IS THREAD SAFE.
        """
        ...
    
    def GetCell(self, p_int):
        """
        V.GetCell(int) -> vtkCell
        C++: vtkCell *GetCell(vtkIdType cellId) override;
        V.GetCell(int, vtkGenericCell)
        C++: void GetCell(vtkIdType cellId, vtkGenericCell *cell)
            override;
        V.GetCell(int, (int, ...)) -> int
        C++: unsigned char GetCell(vtkIdType cellId,
            const vtkIdType *&pts)
        V.GetCell(int, int, int) -> vtkCell
        C++: virtual vtkCell *GetCell(int i, int j, int k)
        
        Standard vtkDataSet interface.
        """
        ...
    
    def GetCellBounds(self, p_int, p_float=..., p_float=..., p_float=..., p_float=..., p_float=..., p_float=...):
        """
        V.GetCellBounds(int, [float, float, float, float, float, float])
        C++: void GetCellBounds(vtkIdType cellId, double bounds[6])
            override;
        
        Standard vtkDataSet interface.
        """
        ...
    
    def GetCellEdgeNeighbors(self, p_int, p_int_1, p_int_2, vtkIdList):
        """
        V.GetCellEdgeNeighbors(int, int, int, vtkIdList)
        C++: void GetCellEdgeNeighbors(vtkIdType cellId, vtkIdType p1,
            vtkIdType p2, vtkIdList *cellIds)
        
        Get the neighbors at an edge. More efficient than the general
        GetCellNeighbors(). Assumes links have been built (with
        BuildLinks()), and looks specifically for edge neighbors.
        """
        ...
    
    def GetCellNeighbors(self, p_int, vtkIdList, vtkIdList_1):
        """
        V.GetCellNeighbors(int, vtkIdList, vtkIdList)
        C++: void GetCellNeighbors(vtkIdType cellId, vtkIdList *ptIds,
            vtkIdList *cellIds) override;
        
        Standard vtkDataSet interface.
        """
        ...
    
    def GetCellPoints(self, p_int, vtkIdList):
        """
        V.GetCellPoints(int, vtkIdList)
        C++: void GetCellPoints(vtkIdType cellId, vtkIdList *ptIds)
            override;
        V.GetCellPoints(int, int, (int, ...)) -> int
        C++: unsigned char GetCellPoints(vtkIdType cellId,
            vtkIdType &npts, vtkIdType const *&pts)
        
        Copy a cells point ids into list provided. (Less efficient.)
        """
        ...
    
    def GetCellType(self, p_int):
        """
        V.GetCellType(int) -> int
        C++: int GetCellType(vtkIdType cellId) override;
        
        Standard vtkDataSet interface.
        """
        ...
    
    def GetData(self, vtkInformation):
        """
        V.GetData(vtkInformation) -> vtkPolyData
        C++: static vtkPolyData *GetData(vtkInformation *info)
        V.GetData(vtkInformationVector, int) -> vtkPolyData
        C++: static vtkPolyData *GetData(vtkInformationVector *v, int i=0)
        
        Retrieve an instance of this class from an information object.
        """
        ...
    
    def GetDataObjectType(self):
        """
        V.GetDataObjectType() -> int
        C++: int GetDataObjectType() override;
        
        Return what type of dataset this is.
        """
        ...
    
    def GetGhostLevel(self):
        """
        V.GetGhostLevel() -> int
        C++: virtual int GetGhostLevel()
        
        Get the ghost level.
        """
        ...
    
    def GetLines(self):
        """
        V.GetLines() -> vtkCellArray
        C++: vtkCellArray *GetLines()
        
        Get the cell array defining lines. If there are no lines, an
        empty array will be returned (convenience to simplify traversal).
        """
        ...
    
    def GetMaxCellSize(self):
        """
        V.GetMaxCellSize() -> int
        C++: int GetMaxCellSize() override;
        
        Return the maximum cell size in this poly data.
        """
        ...
    
    def GetMeshMTime(self):
        """
        V.GetMeshMTime() -> int
        C++: virtual vtkMTimeType GetMeshMTime()
        
        Return the mesh (geometry/topology) modification time. This time
        is different from the usual MTime which also takes into account
        the modification of data arrays. This function can be used to
        track the changes on the mesh separately from the data arrays
        (eg. static mesh over time with transient data).
        """
        ...
    
    def GetMTime(self):
        """
        V.GetMTime() -> int
        C++: vtkMTimeType GetMTime() override;
        
        Get MTime which also considers its cell array MTime.
        """
        ...
    
    def GetNumberOfCells(self):
        """
        V.GetNumberOfCells() -> int
        C++: vtkIdType GetNumberOfCells() override;
        
        Standard vtkDataSet interface.
        """
        ...
    
    def GetNumberOfGenerationsFromBase(self, string):
        """
        V.GetNumberOfGenerationsFromBase(string) -> int
        C++: vtkIdType GetNumberOfGenerationsFromBase(const char *type)
            override;
        
        Standard methdos for type information and printing.
        """
        ...
    
    def GetNumberOfGenerationsFromBaseType(self, string):
        """
        V.GetNumberOfGenerationsFromBaseType(string) -> int
        C++: static vtkIdType GetNumberOfGenerationsFromBaseType(
            const char *type)
        
        Standard methdos for type information and printing.
        """
        ...
    
    def GetNumberOfLines(self):
        """
        V.GetNumberOfLines() -> int
        C++: vtkIdType GetNumberOfLines()
        
        Return the number of primitives of a particular type held.
        """
        ...
    
    def GetNumberOfPieces(self):
        """
        V.GetNumberOfPieces() -> int
        C++: virtual int GetNumberOfPieces()
        
        Get the piece and the number of pieces. Similar to extent in 3D.
        """
        ...
    
    def GetNumberOfPolys(self):
        """
        V.GetNumberOfPolys() -> int
        C++: vtkIdType GetNumberOfPolys()
        
        Return the number of primitives of a particular type held.
        """
        ...
    
    def GetNumberOfStrips(self):
        """
        V.GetNumberOfStrips() -> int
        C++: vtkIdType GetNumberOfStrips()
        
        Return the number of primitives of a particular type held.
        """
        ...
    
    def GetNumberOfVerts(self):
        """
        V.GetNumberOfVerts() -> int
        C++: vtkIdType GetNumberOfVerts()
        
        Return the number of primitives of a particular type held.
        """
        ...
    
    def GetPiece(self):
        """
        V.GetPiece() -> int
        C++: virtual int GetPiece()
        
        Get the piece and the number of pieces. Similar to extent in 3D.
        """
        ...
    
    def GetPointCells(self, p_int, vtkIdList):
        """
        V.GetPointCells(int, vtkIdList)
        C++: void GetPointCells(vtkIdType ptId, vtkIdList *cellIds)
            override;
        V.GetPointCells(int, int, [int, ...])
        C++: void GetPointCells(vtkIdType ptId, vtkIdType &ncells,
            vtkIdType *&cells)
        V.GetPointCells(int, int, [int, ...])
        C++: void GetPointCells(vtkIdType ptId, unsigned short &ncells,
            vtkIdType *&cells)
        
        Efficient method to obtain cells using a particular point. Make
        sure that routine BuildLinks() has been called.
        """
        ...
    
    def GetPolys(self):
        """
        V.GetPolys() -> vtkCellArray
        C++: vtkCellArray *GetPolys()
        
        Get the cell array defining polygons. If there are no polygons,
        an empty array will be returned (convenience to simplify
        traversal).
        """
        ...
    
    def GetScalarFieldCriticalIndex(self, p_int, vtkDataArray):
        """
        V.GetScalarFieldCriticalIndex(int, vtkDataArray) -> int
        C++: int GetScalarFieldCriticalIndex(vtkIdType pointId,
            vtkDataArray *scalarField)
        V.GetScalarFieldCriticalIndex(int, int) -> int
        C++: int GetScalarFieldCriticalIndex(vtkIdType pointId,
            int fieldId)
        V.GetScalarFieldCriticalIndex(int, string) -> int
        C++: int GetScalarFieldCriticalIndex(vtkIdType pointId,
            const char *fieldName)
        """
        ...
    
    def GetStrips(self):
        """
        V.GetStrips() -> vtkCellArray
        C++: vtkCellArray *GetStrips()
        
        Get the cell array defining triangle strips. If there are no
        triangle strips, an empty array will be returned (convenience to
        simplify traversal).
        """
        ...
    
    def GetVerts(self):
        """
        V.GetVerts() -> vtkCellArray
        C++: vtkCellArray *GetVerts()
        
        Get the cell array defining vertices. If there are no vertices,
        an empty array will be returned (convenience to simplify
        traversal).
        """
        ...
    
    def Initialize(self):
        """
        V.Initialize()
        C++: void Initialize() override;
        
        Restore object to initial state. Release memory back to system.
        """
        ...
    
    def InsertNextCell(self, p_int, p_int_1, int_tuple):
        """
        V.InsertNextCell(int, int, (int, ...)) -> int
        C++: vtkIdType InsertNextCell(int type, int npts,
            const vtkIdType pts[])
        V.InsertNextCell(int, vtkIdList) -> int
        C++: vtkIdType InsertNextCell(int type, vtkIdList *pts)
        
        Insert a cell of type VTK_VERTEX, VTK_POLY_VERTEX, VTK_LINE,
        VTK_POLY_LINE, VTK_TRIANGLE, VTK_QUAD, VTK_POLYGON, or
        VTK_TRIANGLE_STRIP.  Make sure that the PolyData::Allocate()
        function has been called first or that vertex, line, polygon, and
        triangle strip arrays have been supplied. Note: will also insert
        VTK_PIXEL, but converts it to VTK_QUAD.
        """
        ...
    
    def InsertNextLinkedCell(self, p_int, p_int_1, int_tuple):
        """
        V.InsertNextLinkedCell(int, int, (int, ...)) -> int
        C++: vtkIdType InsertNextLinkedCell(int type, int npts,
            const vtkIdType pts[])
        
        Add a new cell to the cell data structure (after cell pointers
        have been built). This method adds the cell and then updates the
        links from the points to the cells. (Memory is allocated as
        necessary.) Use this method only when the dataset is set as
        Editable.
        """
        ...
    
    def InsertNextLinkedPoint(self, p_int):
        """
        V.InsertNextLinkedPoint(int) -> int
        C++: vtkIdType InsertNextLinkedPoint(int numLinks)
        V.InsertNextLinkedPoint([float, float, float], int) -> int
        C++: vtkIdType InsertNextLinkedPoint(double x[3], int numLinks)
        
        Add a point to the cell data structure (after cell pointers have
        been built). This method adds the point and then allocates memory
        for the links to the cells.  (To use this method, make sure
        points are available and BuildLinks() has been invoked.) Of the
        two methods below, one inserts a point coordinate and the other
        just makes room for cell links. Use this method only when the
        dataset is set as Editable.
        """
        ...
    
    def IsA(self, string):
        """
        V.IsA(string) -> int
        C++: vtkTypeBool IsA(const char *type) override;
        
        Standard methdos for type information and printing.
        """
        ...
    
    def IsEdge(self, p_int, p_int_1):
        """
        V.IsEdge(int, int) -> int
        C++: int IsEdge(vtkIdType p1, vtkIdType p2)
        
        Determine whether two points form an edge. If they do, return
        non-zero. By definition PolyVertex and PolyLine have no edges
        since 1-dimensional edges are only found on cells 2D and higher.
        Edges are defined as 1-D boundary entities to cells. Make sure
        BuildLinks() has been called first.
        """
        ...
    
    def IsPointUsedByCell(self, p_int, p_int_1):
        """
        V.IsPointUsedByCell(int, int) -> int
        C++: int IsPointUsedByCell(vtkIdType ptId, vtkIdType cellId)
        
        Determine whether a point is used by a particular cell. If it is,
        return non-zero. Make sure BuildCells() has been called first.
        """
        ...
    
    def IsTriangle(self, p_int, p_int_1, p_int_2):
        """
        V.IsTriangle(int, int, int) -> int
        C++: int IsTriangle(int v1, int v2, int v3)
        
        Given three vertices, determine whether it's a triangle. Make
        sure BuildLinks() has been called first.
        """
        ...
    
    def IsTypeOf(self, string):
        """
        V.IsTypeOf(string) -> int
        C++: static vtkTypeBool IsTypeOf(const char *type)
        
        Standard methdos for type information and printing.
        """
        ...
    
    def NeedToBuildCells(self):
        """
        V.NeedToBuildCells() -> bool
        C++: bool NeedToBuildCells()
        
        Check if BuildCells is needed.
        """
        ...
    
    def NewInstance(self):
        """
        V.NewInstance() -> vtkPolyData
        C++: vtkPolyData *NewInstance()
        
        Standard methdos for type information and printing.
        """
        ...
    
    def RemoveCellReference(self, p_int):
        """
        V.RemoveCellReference(int)
        C++: void RemoveCellReference(vtkIdType cellId)
        
        Remove all references to cell in cell structure. This means the
        links from the cell's points to the cell are deleted. Memory is
        not reclaimed. Use the method ResizeCellList() to resize the link
        list from a point to its using cells. (This operator assumes
        BuildLinks() has been called.) Use this method only when the
        dataset is set as Editable.
        """
        ...
    
    def RemoveDeletedCells(self):
        """
        V.RemoveDeletedCells()
        C++: void RemoveDeletedCells()
        
        The cells marked by calls to DeleteCell are stored in the Cell
        Array VTK_EMPTY_CELL, but they still exist in the cell arrays. 
        Calling RemoveDeletedCells will traverse the cell arrays and
        remove/compact the cell arrays as well as any cell data thus
        truly removing the cells from the polydata object. Use this
        method only when the dataset is set as Editable.
        """
        ...
    
    def RemoveGhostCells(self):
        """
        V.RemoveGhostCells()
        C++: void RemoveGhostCells()
        
        This method will remove any cell that is marked as ghost (has the
        vtkDataSetAttributes::DUPLICATECELL bit set). It does not remove
        unused points.
        """
        ...
    
    def RemoveReferenceToCell(self, p_int, p_int_1):
        """
        V.RemoveReferenceToCell(int, int)
        C++: void RemoveReferenceToCell(vtkIdType ptId, vtkIdType cellId)
        
        Remove a reference to a cell in a particular point's link list.
        You may also consider using RemoveCellReference() to remove the
        references from all the cell's points to the cell. This operator
        does not reallocate memory; use the operator ResizeCellList() to
        do this if necessary. Use this method only when the dataset is
        set as Editable.
        """
        ...
    
    def ReplaceCell(self, p_int, vtkIdList):
        """
        V.ReplaceCell(int, vtkIdList)
        C++: void ReplaceCell(vtkIdType cellId, vtkIdList *ids)
        V.ReplaceCell(int, int, (int, ...))
        C++: void ReplaceCell(vtkIdType cellId, int npts,
            const vtkIdType pts[])
        """
        ...
    
    def ReplaceCellPoint(self, p_int, p_int_1, p_int_2):
        """
        V.ReplaceCellPoint(int, int, int)
        C++: void ReplaceCellPoint(vtkIdType cellId, vtkIdType oldPtId,
            vtkIdType newPtId)
        
        Replace a point in the cell connectivity list with a different
        point. Use this method only when the dataset is set as Editable.
        """
        ...
    
    def ReplaceLinkedCell(self, p_int, p_int_1, int_tuple):
        """
        V.ReplaceLinkedCell(int, int, (int, ...))
        C++: void ReplaceLinkedCell(vtkIdType cellId, int npts,
            const vtkIdType pts[])
        
        Replace one cell with another in cell structure. This operator
        updates the connectivity list and the point's link list. It does
        not delete references to the old cell in the point's link list.
        Use the operator RemoveCellReference() to delete all references
        from points to (old) cell.  You may also want to consider using
        the operator ResizeCellList() if the link list is changing size.
        Use this method only when the dataset is set as Editable.
        """
        ...
    
    def Reset(self):
        """
        V.Reset()
        C++: void Reset()
        
        Begin inserting data all over again. Memory is not freed but
        otherwise objects are returned to their initial state.
        """
        ...
    
    def ResizeCellList(self, p_int, p_int_1):
        """
        V.ResizeCellList(int, int)
        C++: void ResizeCellList(vtkIdType ptId, int size)
        
        Resize the list of cells using a particular point. (This operator
        assumes that BuildLinks() has been called.) Use this method only
        when the dataset is set as Editable.
        """
        ...
    
    def ReverseCell(self, p_int):
        """
        V.ReverseCell(int)
        C++: void ReverseCell(vtkIdType cellId)
        
        Reverse the order of point ids defining the cell. Use this method
        only when the dataset is set as Editable.
        """
        ...
    
    def SafeDownCast(self, vtkObjectBase):
        """
        V.SafeDownCast(vtkObjectBase) -> vtkPolyData
        C++: static vtkPolyData *SafeDownCast(vtkObjectBase *o)
        
        Standard methdos for type information and printing.
        """
        ...
    
    def SetLines(self, vtkCellArray):
        """
        V.SetLines(vtkCellArray)
        C++: void SetLines(vtkCellArray *l)
        
        Set the cell array defining lines.
        """
        ...
    
    def SetPolys(self, vtkCellArray):
        """
        V.SetPolys(vtkCellArray)
        C++: void SetPolys(vtkCellArray *p)
        
        Set the cell array defining polygons.
        """
        ...
    
    def SetStrips(self, vtkCellArray):
        """
        V.SetStrips(vtkCellArray)
        C++: void SetStrips(vtkCellArray *s)
        
        Set the cell array defining triangle strips.
        """
        ...
    
    def SetVerts(self, vtkCellArray):
        """
        V.SetVerts(vtkCellArray)
        C++: void SetVerts(vtkCellArray *v)
        
        Set the cell array defining vertices.
        """
        ...
    
    def ShallowCopy(self, vtkDataObject):
        """
        V.ShallowCopy(vtkDataObject)
        C++: void ShallowCopy(vtkDataObject *src) override;
        
        Shallow and Deep copy.
        """
        ...
    
    def Squeeze(self):
        """
        V.Squeeze()
        C++: void Squeeze() override;
        
        Recover extra allocated memory when creating data whose initial
        size is unknown. Examples include using the InsertNextCell()
        method, or when using the CellArray::EstimateSize() method to
        create vertices, lines, polygons, or triangle strips.
        """
        ...
    
    def __delattr__(self, *args, **kwargs):
        """ Implement delattr(self, name). """
        ...
    
    def __getattribute__(self, *args, **kwargs):
        """ Return getattr(self, name). """
        ...
    
    def __init__(self, *args, **kwargs) -> None:
        ...
    
    @staticmethod
    def __new__(*args, **kwargs):
        """ Create and return a new object.  See help(type) for accurate signature. """
        ...
    
    def __repr__(self, *args, **kwargs):
        """ Return repr(self). """
        ...
    
    def __setattr__(self, *args, **kwargs):
        """ Implement setattr(self, name, value). """
        ...
    
    def __str__(self, *args, **kwargs) -> str:
        """ Return str(self). """
        ...
    
    __this__ = ...
    ERR_INCORRECT_FIELD = ...
    ERR_NON_MANIFOLD_STAR = ...
    ERR_NO_SUCH_FIELD = ...
    MAXIMUM = ...
    MINIMUM = ...
    REGULAR_POINT = ...
    SADDLE = ...
    __dict__ = ...
    __vtkname__ = ...


