"""
This type stub file was generated by pyright.
"""

from .vtkDirectedGraph import vtkDirectedGraph

class vtkMutableDirectedGraph(vtkDirectedGraph):
    """
    vtkMutableDirectedGraph - An editable directed graph.
    
    Superclass: vtkDirectedGraph
    
    vtkMutableDirectedGraph is a directed graph which has additional
    methods for adding edges and vertices. AddChild() is a convenience
    method for constructing trees. ShallowCopy(), DeepCopy(),
    CheckedShallowCopy() and CheckedDeepCopy() will succeed for instances
    of vtkDirectedGraph, vtkMutableDirectedGraph and vtkTree.
    
    @sa
    vtkDirectedGraph vtkGraph vtkTree
    """
    def AddChild(self, p_int, vtkVariantArray):
        """
        V.AddChild(int, vtkVariantArray) -> int
        C++: vtkIdType AddChild(vtkIdType parent,
            vtkVariantArray *propertyArr)
        V.AddChild(int) -> int
        C++: vtkIdType AddChild(vtkIdType parent)
        
        Convenience method for creating trees. Returns the newly created
        vertex id. Shortcut forvtkIdType v = g->AddVertex();
        g->AddEdge(parent, v);
        If non-null, propertyArr provides edge properties for the
        newly-created edge. The values in propertyArr must match up with
        the arrays in the edge data returned by GetEdgeData().
        """
        ...
    
    def AddEdge(self, p_int, p_int_1):
        """
        V.AddEdge(int, int) -> vtkEdgeType
        C++: vtkEdgeType AddEdge(vtkIdType u, vtkIdType v)
        V.AddEdge(int, int, vtkVariantArray) -> vtkEdgeType
        C++: vtkEdgeType AddEdge(vtkIdType u, vtkIdType v,
            vtkVariantArray *propertyArr)
        V.AddEdge(vtkVariant, int, vtkVariantArray) -> vtkEdgeType
        C++: vtkEdgeType AddEdge(const vtkVariant &u, vtkIdType v,
            vtkVariantArray *propertyArr=nullptr)
        V.AddEdge(int, vtkVariant, vtkVariantArray) -> vtkEdgeType
        C++: vtkEdgeType AddEdge(vtkIdType u, const vtkVariant &v,
            vtkVariantArray *propertyArr=nullptr)
        V.AddEdge(vtkVariant, vtkVariant, vtkVariantArray) -> vtkEdgeType
        C++: vtkEdgeType AddEdge(const vtkVariant &u, const vtkVariant &v,
             vtkVariantArray *propertyArr=nullptr)
        
        Adds a directed edge from u to v, where u and v are vertex
        indices, and returns a vtkEdgeType structure describing that
        edge.
        
        * vtkEdgeType contains fields for Source vertex index,
        * Target vertex index, and edge index Id.
        """
        ...
    
    def AddGraphEdge(self, p_int, p_int_1):
        """
        V.AddGraphEdge(int, int) -> vtkGraphEdge
        C++: vtkGraphEdge *AddGraphEdge(vtkIdType u, vtkIdType v)
        
        Variant of AddEdge() that returns a heavyweight vtkGraphEdge
        object. The graph owns the reference of the edge and will replace
        its contents on the next call to AddGraphEdge().
        
        *
        
        ote This is a less efficient method for use with wrappers.
        * In C++ you should use the faster AddEdge().
        """
        ...
    
    def AddVertex(self):
        """
        V.AddVertex() -> int
        C++: vtkIdType AddVertex()
        V.AddVertex(vtkVariantArray) -> int
        C++: vtkIdType AddVertex(vtkVariantArray *propertyArr)
        V.AddVertex(vtkVariant) -> int
        C++: vtkIdType AddVertex(const vtkVariant &pedigreeId)
        
        Adds a vertex to the graph and returns the index of the new
        vertex.
        
        *
        
        ote In a distributed graph (i.e. a graph whose DistributedHelper
        * is non-null), this routine cannot be used to add a vertex
        * if the vertices in the graph have pedigree IDs, because this
          routine
        * will always add the vertex locally, which may conflict with the
        * proper location of the vertex based on the distribution of the
        * pedigree IDs.
        """
        ...
    
    def GetNumberOfGenerationsFromBase(self, string):
        """
        V.GetNumberOfGenerationsFromBase(string) -> int
        C++: vtkIdType GetNumberOfGenerationsFromBase(const char *type)
            override;
        
        Given a the name of a base class of this class type, return the
        distance of inheritance between this class type and the named
        class (how many generations of inheritance are there between this
        class and the named class). If the named class is not in this
        class's inheritance tree, return a negative value. Valid
        responses will always be nonnegative. This method works in
        combination with vtkTypeMacro found in vtkSetGet.h.
        """
        ...
    
    def GetNumberOfGenerationsFromBaseType(self, string):
        """
        V.GetNumberOfGenerationsFromBaseType(string) -> int
        C++: static vtkIdType GetNumberOfGenerationsFromBaseType(
            const char *type)
        
        Given a the name of a base class of this class type, return the
        distance of inheritance between this class type and the named
        class (how many generations of inheritance are there between this
        class and the named class). If the named class is not in this
        class's inheritance tree, return a negative value. Valid
        responses will always be nonnegative. This method works in
        combination with vtkTypeMacro found in vtkSetGet.h.
        """
        ...
    
    def IsA(self, string):
        """
        V.IsA(string) -> int
        C++: vtkTypeBool IsA(const char *type) override;
        
        Return 1 if this class is the same type of (or a subclass of) the
        named class. Returns 0 otherwise. This method works in
        combination with vtkTypeMacro found in vtkSetGet.h.
        """
        ...
    
    def IsTypeOf(self, string):
        """
        V.IsTypeOf(string) -> int
        C++: static vtkTypeBool IsTypeOf(const char *type)
        
        Return 1 if this class type is the same type of (or a subclass
        of) the named class. Returns 0 otherwise. This method works in
        combination with vtkTypeMacro found in vtkSetGet.h.
        """
        ...
    
    def LazyAddEdge(self, p_int, p_int_1, vtkVariantArray):
        """
        V.LazyAddEdge(int, int, vtkVariantArray)
        C++: void LazyAddEdge(vtkIdType u, vtkIdType v,
            vtkVariantArray *propertyArr=nullptr)
        V.LazyAddEdge(vtkVariant, int, vtkVariantArray)
        C++: void LazyAddEdge(const vtkVariant &u, vtkIdType v,
            vtkVariantArray *propertyArr=nullptr)
        V.LazyAddEdge(int, vtkVariant, vtkVariantArray)
        C++: void LazyAddEdge(vtkIdType u, const vtkVariant &v,
            vtkVariantArray *propertyArr=nullptr)
        V.LazyAddEdge(vtkVariant, vtkVariant, vtkVariantArray)
        C++: void LazyAddEdge(const vtkVariant &u, const vtkVariant &v,
            vtkVariantArray *propertyArr=nullptr)
        
        Adds a directed edge from u to v, where u and v are vertex
        indices.
        
        * The number and order of values in the optional parameter
        * propertyArr must match up with the arrays in the edge data
        * retrieved by GetEdgeData().
        
        * This method is lazily evaluated for distributed graphs (i.e.
          graphs
        * whose DistributedHelper is non-null) the next time Synchronize
          is
        * called on the helper.
        """
        ...
    
    def LazyAddVertex(self):
        """
        V.LazyAddVertex()
        C++: void LazyAddVertex()
        V.LazyAddVertex(vtkVariantArray)
        C++: void LazyAddVertex(vtkVariantArray *propertyArr)
        V.LazyAddVertex(vtkVariant)
        C++: void LazyAddVertex(const vtkVariant &pedigreeId)
        
        Adds a vertex to the graph.
        
        * This method is lazily evaluated for distributed graphs (i.e.
          graphs
        * whose DistributedHelper is non-null) the next time Synchronize
          is
        * called on the helper.
        """
        ...
    
    def NewInstance(self):
        """
        V.NewInstance() -> vtkMutableDirectedGraph
        C++: vtkMutableDirectedGraph *NewInstance()
        """
        ...
    
    def RemoveEdge(self, p_int):
        """
        V.RemoveEdge(int)
        C++: void RemoveEdge(vtkIdType e)
        
        Removes the edge from the graph. Note: This invalidates the last
        edge index, which is reassigned to e.
        """
        ...
    
    def RemoveEdges(self, vtkIdTypeArray):
        """
        V.RemoveEdges(vtkIdTypeArray)
        C++: void RemoveEdges(vtkIdTypeArray *arr)
        
        Removes a collection of edges from the graph.
        """
        ...
    
    def RemoveVertex(self, p_int):
        """
        V.RemoveVertex(int)
        C++: void RemoveVertex(vtkIdType v)
        
        Removes the vertex from the graph along with any connected edges.
        Note: This invalidates the last vertex index, which is reassigned
        to v.
        """
        ...
    
    def RemoveVertices(self, vtkIdTypeArray):
        """
        V.RemoveVertices(vtkIdTypeArray)
        C++: void RemoveVertices(vtkIdTypeArray *arr)
        
        Removes a collection of vertices from the graph along with any
        connected edges.
        """
        ...
    
    def SafeDownCast(self, vtkObjectBase):
        """
        V.SafeDownCast(vtkObjectBase) -> vtkMutableDirectedGraph
        C++: static vtkMutableDirectedGraph *SafeDownCast(
            vtkObjectBase *o)
        """
        ...
    
    def SetNumberOfVertices(self, p_int):
        """
        V.SetNumberOfVertices(int) -> int
        C++: virtual vtkIdType SetNumberOfVertices(vtkIdType numVerts)
        
        Allocates space for the specified number of vertices in the
        graph's internal data structures.
        
        * This has no effect on the number of vertex coordinate tuples or
        * vertex attribute tuples allocated; you are responsible for
        * guaranteeing these match.
        * Also, this call is not implemented for distributed-memory
          graphs since
        * the semantics are unclear; calling this function on a graph
          with a
        * non-nullptr DistributedGraphHelper will generate an error
          message and
        * no allocation will be performed.
        """
        ...
    
    def __delattr__(self, *args, **kwargs):
        """ Implement delattr(self, name). """
        ...
    
    def __getattribute__(self, *args, **kwargs):
        """ Return getattr(self, name). """
        ...
    
    def __init__(self, *args, **kwargs) -> None:
        ...
    
    @staticmethod
    def __new__(*args, **kwargs):
        """ Create and return a new object.  See help(type) for accurate signature. """
        ...
    
    def __repr__(self, *args, **kwargs):
        """ Return repr(self). """
        ...
    
    def __setattr__(self, *args, **kwargs):
        """ Implement setattr(self, name, value). """
        ...
    
    def __str__(self, *args, **kwargs) -> str:
        """ Return str(self). """
        ...
    
    __this__ = ...
    __dict__ = ...
    __vtkname__ = ...


