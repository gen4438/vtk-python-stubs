"""
This type stub file was generated by pyright.
"""

from .vtkAbstractCellLocator import vtkAbstractCellLocator

class vtkStaticCellLocator(vtkAbstractCellLocator):
    """
    vtkStaticCellLocator - perform fast cell location operations
    
    Superclass: vtkAbstractCellLocator
    
    vtkStaticCellLocator is a type of vtkAbstractCellLocator that
    accelerates certain operations when performing spatial operations on
    cells. These operations include finding a point that contains a cell,
    and intersecting cells with a line.
    
    vtkStaticCellLocator is an accelerated version of vtkCellLocator. It
    is threaded (via vtkSMPTools), and supports one-time static
    construction (i.e., incremental cell insertion is not supported).
    
    @warning
    This class is templated. It may run slower than serial execution if
    the code is not optimized during compilation. Build in Release or
    ReleaseWithDebugInfo.
    
    @warning
    This class *always* caches cell bounds.
    
    @sa
    vtkLocator vakAbstractCellLocator vtkCellLocator vtkCellTreeLocator
    vtkModifiedBSPTree
    """
    def BuildLocator(self):
        """
        V.BuildLocator()
        C++: void BuildLocator() override;
        
        Satisfy vtkLocator abstract interface.
        """
        ...
    
    def FindCell(self, p_float=..., p_float=..., p_float=..., *args, **kwargs):
        """
        V.FindCell([float, float, float], float, vtkGenericCell, [float,
            float, float], [float, ...]) -> int
        C++: vtkIdType FindCell(double pos[3], double,
            vtkGenericCell *cell, double pcoords[3], double *weights)
            override;
        V.FindCell([float, float, float]) -> int
        C++: vtkIdType FindCell(double x[3]) override;
        
        Test a point to find if it is inside a cell. Returns the cellId
        if inside or -1 if not.
        """
        ...
    
    def FindCellsAlongLine(self, , , p_float_6, vtkIdList):
        """
        V.FindCellsAlongLine((float, float, float), (float, float, float),
             float, vtkIdList)
        C++: void FindCellsAlongLine(const double p1[3],
            const double p2[3], double tolerance, vtkIdList *cells)
            override;
        
        Given a finite line defined by the two points (p1,p2), return the
        list of unique cell ids in the buckets containing the line. It is
        possible that an empty cell list is returned. The user must
        provide the vtkIdList cell list to populate. This method returns
        data only after the locator has been built.
        """
        ...
    
    def FindCellsAlongPlane(self, , , p_float_6, vtkIdList):
        """
        V.FindCellsAlongPlane((float, float, float), (float, float, float)
            , float, vtkIdList)
        C++: void FindCellsAlongPlane(const double o[3],
            const double n[3], double tolerance, vtkIdList *cells)
        
        Given an unbounded plane defined by an origin o[3] and unit
        normal n[3], return the list of unique cell ids in the buckets
        containing the plane. It is possible that an empty cell list is
        returned. The user must provide the vtkIdList cell list to
        populate. This method returns data only after the locator has
        been built.
        """
        ...
    
    def FindCellsWithinBounds(self, *float, **kwargs):
        """
        V.FindCellsWithinBounds([float, ...], vtkIdList)
        C++: void FindCellsWithinBounds(double *bbox, vtkIdList *cells)
            override;
        
        Return a list of unique cell ids inside of a given bounding box.
        The user must provide the vtkIdList to populate. This method
        returns data only after the locator has been built.
        """
        ...
    
    def FindClosestPoint(self, , p_float=..., p_float=..., p_float=..., *args, **kwargs):
        """
        V.FindClosestPoint((float, float, float), [float, float, float],
            vtkGenericCell, int, int, float)
        C++: void FindClosestPoint(const double x[3],
            double closestPoint[3], vtkGenericCell *cell,
            vtkIdType &cellId, int &subId, double &dist2) override;
        V.FindClosestPoint((float, float, float), [float, float, float],
            int, int, float)
        C++: virtual void FindClosestPoint(const double x[3],
            double closestPoint[3], vtkIdType &cellId, int &subId,
            double &dist2)
        
        Return the closest point and the cell which is closest to the
        point x. The closest point is somewhere on a cell, it need not be
        one of the vertices of the cell.  This version takes in a
        vtkGenericCell to avoid allocating and deallocating the cell. 
        This is much faster than the version which does not take a *cell,
        especially when this function is called many times in a row such
        as by a for loop, where the allocation and deallocation can be
        done only once outside the for loop.  If a cell is found, "cell"
        contains the points and ptIds for the cell "cellId" upon exit.
        """
        ...
    
    def FindClosestPointWithinRadius(self, p_float=..., p_float=..., p_float=..., *args, **kwargs):
        """
        V.FindClosestPointWithinRadius([float, float, float], float,
            [float, float, float], vtkGenericCell, int, int, float, int)
            -> int
        C++: vtkIdType FindClosestPointWithinRadius(double x[3],
            double radius, double closestPoint[3], vtkGenericCell *cell,
            vtkIdType &cellId, int &subId, double &dist2, int &inside)
            override;
        V.FindClosestPointWithinRadius([float, float, float], float,
            [float, float, float], int, int, float) -> int
        C++: virtual vtkIdType FindClosestPointWithinRadius(double x[3],
            double radius, double closestPoint[3], vtkIdType &cellId,
            int &subId, double &dist2)
        V.FindClosestPointWithinRadius([float, float, float], float,
            [float, float, float], vtkGenericCell, int, int, float) -> int
        C++: virtual vtkIdType FindClosestPointWithinRadius(double x[3],
            double radius, double closestPoint[3], vtkGenericCell *cell,
            vtkIdType &cellId, int &subId, double &dist2)
        
        Return the closest point within a specified radius and the cell
        which is closest to the point x. The closest point is somewhere
        on a cell, it need not be one of the vertices of the cell. This
        method returns 1 if a point is found within the specified radius.
        If there are no cells within the specified radius, the method
        returns 0 and the values of closestPoint, cellId, subId, and
        dist2 are undefined. This version takes in a vtkGenericCell to
        avoid allocating and deallocating the cell.  This is much faster
        than the version which does not take a *cell, especially when
        this function is called many times in a row such as by a for
        loop, where the allocation and dealloction can be done only once
        outside the for loop.  If a closest point is found, "cell"
        contains the points and ptIds for the cell "cellId" upon exit. 
        If a closest point is found, inside returns the return value of
        the EvaluatePosition call to the closest cell; inside(=1) or
        outside(=0).
        """
        ...
    
    def FreeSearchStructure(self):
        """
        V.FreeSearchStructure()
        C++: void FreeSearchStructure() override;
        
        Satisfy vtkLocator abstract interface.
        """
        ...
    
    def GenerateRepresentation(self, p_int, vtkPolyData):
        """
        V.GenerateRepresentation(int, vtkPolyData)
        C++: void GenerateRepresentation(int level, vtkPolyData *pd)
            override;
        
        Satisfy vtkLocator abstract interface.
        """
        ...
    
    def GetDivisions(self):
        """
        V.GetDivisions() -> (int, int, int)
        C++: virtual int *GetDivisions()
        
        Set the number of divisions in x-y-z directions. If the Automatic
        data member is enabled, the Divisions are set according to the
        NumberOfCellsPerNode and MaxNumberOfBuckets data members. The
        number of divisions must be >= 1 in each direction.
        """
        ...
    
    def GetLargeIds(self):
        """
        V.GetLargeIds() -> bool
        C++: bool GetLargeIds()
        
        Inform the user as to whether large ids are being used. This flag
        only has meaning after the locator has been built. Large ids are
        used when the number of binned points, or the number of bins, is
        >= the maximum number of buckets (specified by the user). Note
        that LargeIds are only available on 64-bit architectures.
        """
        ...
    
    def GetMaxNumberOfBuckets(self):
        """
        V.GetMaxNumberOfBuckets() -> int
        C++: virtual vtkIdType GetMaxNumberOfBuckets()
        
        Set the maximum number of buckets in the locator. By default the
        value is set to VTK_INT_MAX. Note that there are significant
        performance implications at work here. If the number of buckets
        is set very large (meaning > VTK_INT_MAX) then internal sorting
        may be performed using 64-bit integers (which is much slower than
        using a 32-bit int). Of course, memory requirements may
        dramatically increase as well.  It is recommended that the
        default value be used; but for extremely large data it may be
        desired to create a locator with an exceptionally large number of
        buckets. Note also that during initialization of the locator if
        the MaxNumberOfBuckets threshold is exceeded, the Divisions are
        scaled down in such a way as not to exceed the MaxNumberOfBuckets
        proportionally to the size of the bounding box in the x-y-z
        directions.
        """
        ...
    
    def GetMaxNumberOfBucketsMaxValue(self):
        """
        V.GetMaxNumberOfBucketsMaxValue() -> int
        C++: virtual vtkIdType GetMaxNumberOfBucketsMaxValue()
        
        Set the maximum number of buckets in the locator. By default the
        value is set to VTK_INT_MAX. Note that there are significant
        performance implications at work here. If the number of buckets
        is set very large (meaning > VTK_INT_MAX) then internal sorting
        may be performed using 64-bit integers (which is much slower than
        using a 32-bit int). Of course, memory requirements may
        dramatically increase as well.  It is recommended that the
        default value be used; but for extremely large data it may be
        desired to create a locator with an exceptionally large number of
        buckets. Note also that during initialization of the locator if
        the MaxNumberOfBuckets threshold is exceeded, the Divisions are
        scaled down in such a way as not to exceed the MaxNumberOfBuckets
        proportionally to the size of the bounding box in the x-y-z
        directions.
        """
        ...
    
    def GetMaxNumberOfBucketsMinValue(self):
        """
        V.GetMaxNumberOfBucketsMinValue() -> int
        C++: virtual vtkIdType GetMaxNumberOfBucketsMinValue()
        
        Set the maximum number of buckets in the locator. By default the
        value is set to VTK_INT_MAX. Note that there are significant
        performance implications at work here. If the number of buckets
        is set very large (meaning > VTK_INT_MAX) then internal sorting
        may be performed using 64-bit integers (which is much slower than
        using a 32-bit int). Of course, memory requirements may
        dramatically increase as well.  It is recommended that the
        default value be used; but for extremely large data it may be
        desired to create a locator with an exceptionally large number of
        buckets. Note also that during initialization of the locator if
        the MaxNumberOfBuckets threshold is exceeded, the Divisions are
        scaled down in such a way as not to exceed the MaxNumberOfBuckets
        proportionally to the size of the bounding box in the x-y-z
        directions.
        """
        ...
    
    def GetNumberOfGenerationsFromBase(self, string):
        """
        V.GetNumberOfGenerationsFromBase(string) -> int
        C++: vtkIdType GetNumberOfGenerationsFromBase(const char *type)
            override;
        
        Standard methods to instantiate, print and obtain type-related
        information.
        """
        ...
    
    def GetNumberOfGenerationsFromBaseType(self, string):
        """
        V.GetNumberOfGenerationsFromBaseType(string) -> int
        C++: static vtkIdType GetNumberOfGenerationsFromBaseType(
            const char *type)
        
        Standard methods to instantiate, print and obtain type-related
        information.
        """
        ...
    
    def IntersectWithLine(self, , , p_float_6, p_float_7, p_float=..., p_float=..., p_float=..., *args, **kwargs):
        """
        V.IntersectWithLine((float, float, float), (float, float, float),
            float, float, [float, float, float], [float, float, float],
            int, int, vtkGenericCell) -> int
        C++: int IntersectWithLine(const double a0[3], const double a1[3],
             double tol, double &t, double x[3], double pcoords[3],
            int &subId, vtkIdType &cellId, vtkGenericCell *cell) override;
        V.IntersectWithLine((float, float, float), (float, float, float),
            float, float, [float, float, float], [float, float, float],
            int) -> int
        C++: int IntersectWithLine(const double p1[3], const double p2[3],
             double tol, double &t, double x[3], double pcoords[3],
            int &subId) override;
        V.IntersectWithLine((float, float, float), (float, float, float),
            float, float, [float, float, float], [float, float, float],
            int, int) -> int
        C++: int IntersectWithLine(const double p1[3], const double p2[3],
             double tol, double &t, double x[3], double pcoords[3],
            int &subId, vtkIdType &cellId) override;
        V.IntersectWithLine((float, float, float), (float, float, float),
            vtkPoints, vtkIdList) -> int
        C++: int IntersectWithLine(const double p1[3], const double p2[3],
             vtkPoints *points, vtkIdList *cellIds) override;
        
        Return intersection point (if any) AND the cell which was
        intersected by the finite line. The cell is returned as a cell id
        and as a generic cell.
        """
        ...
    
    def IsA(self, string):
        """
        V.IsA(string) -> int
        C++: vtkTypeBool IsA(const char *type) override;
        
        Standard methods to instantiate, print and obtain type-related
        information.
        """
        ...
    
    def IsTypeOf(self, string):
        """
        V.IsTypeOf(string) -> int
        C++: static vtkTypeBool IsTypeOf(const char *type)
        
        Standard methods to instantiate, print and obtain type-related
        information.
        """
        ...
    
    def NewInstance(self):
        """
        V.NewInstance() -> vtkStaticCellLocator
        C++: vtkStaticCellLocator *NewInstance()
        
        Standard methods to instantiate, print and obtain type-related
        information.
        """
        ...
    
    def SafeDownCast(self, vtkObjectBase):
        """
        V.SafeDownCast(vtkObjectBase) -> vtkStaticCellLocator
        C++: static vtkStaticCellLocator *SafeDownCast(vtkObjectBase *o)
        
        Standard methods to instantiate, print and obtain type-related
        information.
        """
        ...
    
    def SetDivisions(self, p_int, p_int_1, p_int_2):
        """
        V.SetDivisions(int, int, int)
        C++: virtual void SetDivisions(int _arg1, int _arg2, int _arg3)
        V.SetDivisions((int, int, int))
        C++: virtual void SetDivisions(const int _arg[3])
        
        Set the number of divisions in x-y-z directions. If the Automatic
        data member is enabled, the Divisions are set according to the
        NumberOfCellsPerNode and MaxNumberOfBuckets data members. The
        number of divisions must be >= 1 in each direction.
        """
        ...
    
    def SetMaxNumberOfBuckets(self, p_int):
        """
        V.SetMaxNumberOfBuckets(int)
        C++: virtual void SetMaxNumberOfBuckets(vtkIdType _arg)
        
        Set the maximum number of buckets in the locator. By default the
        value is set to VTK_INT_MAX. Note that there are significant
        performance implications at work here. If the number of buckets
        is set very large (meaning > VTK_INT_MAX) then internal sorting
        may be performed using 64-bit integers (which is much slower than
        using a 32-bit int). Of course, memory requirements may
        dramatically increase as well.  It is recommended that the
        default value be used; but for extremely large data it may be
        desired to create a locator with an exceptionally large number of
        buckets. Note also that during initialization of the locator if
        the MaxNumberOfBuckets threshold is exceeded, the Divisions are
        scaled down in such a way as not to exceed the MaxNumberOfBuckets
        proportionally to the size of the bounding box in the x-y-z
        directions.
        """
        ...
    
    def __delattr__(self, *args, **kwargs):
        """ Implement delattr(self, name). """
        ...
    
    def __getattribute__(self, *args, **kwargs):
        """ Return getattr(self, name). """
        ...
    
    def __init__(self, *args, **kwargs) -> None:
        ...
    
    @staticmethod
    def __new__(*args, **kwargs):
        """ Create and return a new object.  See help(type) for accurate signature. """
        ...
    
    def __repr__(self, *args, **kwargs):
        """ Return repr(self). """
        ...
    
    def __setattr__(self, *args, **kwargs):
        """ Implement setattr(self, name, value). """
        ...
    
    def __str__(self, *args, **kwargs) -> str:
        """ Return str(self). """
        ...
    
    __this__ = ...
    __dict__ = ...
    __vtkname__ = ...


