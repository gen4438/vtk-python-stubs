"""
This type stub file was generated by pyright.
"""

from .object import object

class vtkBoundingBox(object):
    """
    vtkBoundingBox - Fast, simple class for dealing with 3D bounds
    
    vtkBoundingBox maintains a 3D axis aligned bounding box.  It is very
    light weight and many of the member functions are in-lined so it is
    very fast. It is not derived from vtkObject so it can be allocated on
    the stack.
    
    @sa
    vtkBox
    
    vtkBoundingBox()
    vtkBoundingBox(const double bounds[6])
    vtkBoundingBox(double xMin, double xMax, double yMin, double yMax,
        double zMin, double zMax)
    vtkBoundingBox(const vtkBoundingBox &bbox)
    """
    def AddBounds(self, float_tuple):
        """
        V.AddBounds((float, ...))
        C++: void AddBounds(const double bounds[])
        
        Adjust the bounding box so it contains the specified bounds
        (defined by the VTK representation (xmin,xmax, ymin,ymax,
        zmin,zmax).
        """
        ...
    
    def AddBox(self, vtkBoundingBox):
        """
        V.AddBox(vtkBoundingBox)
        C++: void AddBox(const vtkBoundingBox &bbox)
        
        Change the bounding box to be the union of itself and the
        specified bbox.
        """
        ...
    
    def AddPoint(self, p_float=..., p_float=..., p_float=...):
        """
        V.AddPoint([float, float, float])
        C++: void AddPoint(double p[3])
        V.AddPoint(float, float, float)
        C++: void AddPoint(double px, double py, double pz)
        
        Change bounding box so it includes the point p.  Note that the
        bounding box may have 0 volume if its bounds were just
        initialized.
        """
        ...
    
    def ComputeBounds(self, vtkPoints, p_float=..., p_float=..., p_float=..., p_float=..., p_float=..., p_float=...):
        """
        V.ComputeBounds(vtkPoints, [float, float, float, float, float,
            float])
        C++: static void ComputeBounds(vtkPoints *pts, double bounds[6])
        V.ComputeBounds(vtkPoints, (int, ...), [float, float, float,
            float, float, float])
        C++: static void ComputeBounds(vtkPoints *pts,
            const unsigned char *ptUses, double bounds[6])
        
        Compute the bounding box from an array of vtkPoints. It uses a
        fast path when possible. The second signature (with point uses)
        only considers points with ptUses[i] != 0 in the bounds
        calculation.
        """
        ...
    
    def ComputeDivisions(self, p_int, p_float=..., p_float=..., p_float=..., p_float=..., p_float=..., p_float=..., *args, **kwargs):
        """
        V.ComputeDivisions(int, [float, float, float, float, float,
            float], [int, int, int]) -> int
        C++: vtkIdType ComputeDivisions(vtkIdType totalBins,
            double bounds[6], int divs[3])
        
        Compute the number of divisions in the z-y-z directions given a
        target number of total bins (i.e., product of divisions in the
        x-y-z directions). The computation is done in such a way as to
        create near cuboid bins. Also note that the returned bounds may
        be different than the bounds defined in this class, as the bounds
        in the z-y-z directions can never be <= 0. Note that the total
        number of divisions (divs[0]*divs[1]*divs[2]) should be less than
        or equal to the target number of bins, but it may be slightly
        larger in certain cases.
        """
        ...
    
    def Contains(self, vtkBoundingBox):
        """
        V.Contains(vtkBoundingBox) -> int
        C++: int Contains(const vtkBoundingBox &bbox)
        
        Returns 1 if the min and max points of bbox are contained within
        the bounds of the specified box, else returns 0.
        """
        ...
    
    def ContainsPoint(self, p_float=..., p_float=..., p_float=...):
        """
        V.ContainsPoint([float, float, float]) -> int
        C++: vtkTypeBool ContainsPoint(double p[3])
        V.ContainsPoint(float, float, float) -> int
        C++: vtkTypeBool ContainsPoint(double px, double py, double pz)
        
        Returns 1 if the point is contained in the box else 0.
        """
        ...
    
    def GetBound(self, p_int):
        """
        V.GetBound(int) -> float
        C++: double GetBound(int i)
        
        Return the ith bounds of the box (defined by VTK style).
        """
        ...
    
    def GetBounds(self, p_float=..., p_float=..., p_float=..., p_float=..., p_float=..., p_float=...):
        """
        V.GetBounds([float, float, float, float, float, float])
        C++: void GetBounds(double bounds[6])
        V.GetBounds(float, float, float, float, float, float)
        C++: void GetBounds(double &xMin, double &xMax, double &yMin,
            double &yMax, double &zMin, double &zMax)
        
        Get the bounds of the box (defined by VTK style).
        """
        ...
    
    def GetCenter(self, p_float=..., p_float=..., p_float=...):
        """
        V.GetCenter([float, float, float])
        C++: void GetCenter(double center[3])
        
        Get the center of the bounding box.
        """
        ...
    
    def GetCorner(self, p_int, p_float=..., p_float=..., p_float=...):
        """
        V.GetCorner(int, [float, float, float])
        C++: void GetCorner(int corner, double p[3])
        
        Get the ith corner of the bounding box. The points are ordered
        with i, then j, then k increasing.
        """
        ...
    
    def GetDiagonalLength(self):
        """
        V.GetDiagonalLength() -> float
        C++: double GetDiagonalLength()
        
        Return the length of the diagonal.
        \pre not_empty: this->IsValid()
        """
        ...
    
    def GetLength(self, p_int):
        """
        V.GetLength(int) -> float
        C++: double GetLength(int i)
        
        Return the length of the bounding box in the ith direction.
        """
        ...
    
    def GetLengths(self, p_float=..., p_float=..., p_float=...):
        """
        V.GetLengths([float, float, float])
        C++: void GetLengths(double lengths[3])
        
        Get the length of each sode of the box.
        """
        ...
    
    def GetMaxLength(self):
        """
        V.GetMaxLength() -> float
        C++: double GetMaxLength()
        
        Return the maximum length of the box.
        """
        ...
    
    def GetMaxPoint(self):
        """
        V.GetMaxPoint() -> (float, float, float)
        C++: const double *GetMaxPoint()
        V.GetMaxPoint(float, float, float)
        C++: void GetMaxPoint(double &x, double &y, double &z)
        V.GetMaxPoint([float, float, float])
        C++: void GetMaxPoint(double x[3])
        
        Get the maximum point of the bounding box.
        """
        ...
    
    def GetMinPoint(self):
        """
        V.GetMinPoint() -> (float, float, float)
        C++: const double *GetMinPoint()
        V.GetMinPoint(float, float, float)
        C++: void GetMinPoint(double &x, double &y, double &z)
        V.GetMinPoint([float, float, float])
        C++: void GetMinPoint(double x[3])
        
        Get the minimum point of the bounding box.
        """
        ...
    
    def Inflate(self, p_float):
        """
        V.Inflate(float)
        C++: void Inflate(double delta)
        V.Inflate(float, float, float)
        C++: void Inflate(double deltaX, double deltaY, double deltaZ)
        V.Inflate()
        C++: void Inflate()
        
        Expand the bounding box. Inflate(delta) expands by delta on each
        side, the box will grow by 2*delta in x, y, and z.
        Inflate(dx,dy,dz) expands by the given amounts in each of the x,
        y, z directions. Finally, Inflate() expands the bounds so that it
        has non-zero volume. Edges that are inflated are adjusted 1% of
        the longest edge. Or if an edge is zero length, the bounding box
        is inflated by 1 unit in that direction.
        """
        ...
    
    def IntersectBox(self, vtkBoundingBox):
        """
        V.IntersectBox(vtkBoundingBox) -> int
        C++: int IntersectBox(const vtkBoundingBox &bbox)
        
        Intersect this box with bbox. The method returns 1 if both boxes
        are valid and they do have overlap else it will return 0.  If 0
        is returned the box has not been modified.
        """
        ...
    
    def IntersectPlane(self, p_float=..., p_float=..., p_float=..., *args, **kwargs):
        """
        V.IntersectPlane([float, float, float], [float, float, float])
            -> bool
        C++: bool IntersectPlane(double origin[3], double normal[3])
        
        Intersect this box with the half space defined by plane.  Returns
        true if there is intersection---which implies that the box has
        been modified Returns false otherwise.
        """
        ...
    
    def Intersects(self, vtkBoundingBox):
        """
        V.Intersects(vtkBoundingBox) -> int
        C++: int Intersects(const vtkBoundingBox &bbox)
        
        Returns 1 if the boxes intersect else returns 0.
        """
        ...
    
    def IsValid(self):
        """
        V.IsValid() -> int
        C++: int IsValid()
        V.IsValid((float, float, float, float, float, float)) -> int
        C++: static int IsValid(const double bounds[6])
        
        Returns 1 if the bounds have been set and 0 if the box is in its
        initialized state which is an inverted state.
        """
        ...
    
    def Reset(self):
        """
        V.Reset()
        C++: void Reset()
        
        Returns the box to its initialized state.
        """
        ...
    
    def Scale(self, p_float=..., p_float=..., p_float=...):
        """
        V.Scale([float, float, float])
        C++: void Scale(double s[3])
        V.Scale(float, float, float)
        C++: void Scale(double sx, double sy, double sz)
        
        Scale each dimension of the box by some given factor. If the box
        is not valid, it stays unchanged. If the scalar factor is
        negative, bounds are flipped: for example, if (xMin,xMax)=(-2,4)
        and sx=-3, (xMin,xMax) becomes (-12,6).
        """
        ...
    
    def ScaleAboutCenter(self, p_float):
        """
        V.ScaleAboutCenter(float)
        C++: void ScaleAboutCenter(double s)
        V.ScaleAboutCenter([float, float, float])
        C++: void ScaleAboutCenter(double s[3])
        V.ScaleAboutCenter(float, float, float)
        C++: void ScaleAboutCenter(double sx, double sy, double sz)
        
        Scale each dimension of the box by some given factor, with the
        origin of the bounding box the center of the scaling. If the box
        is not valid, it is not changed.
        """
        ...
    
    def SetBounds(self, ):
        """
        V.SetBounds((float, float, float, float, float, float))
        C++: void SetBounds(const double bounds[6])
        V.SetBounds(float, float, float, float, float, float)
        C++: void SetBounds(double xMin, double xMax, double yMin,
            double yMax, double zMin, double zMax)
        
        Set the bounds explicitly of the box (using the VTK convention
        for representing a bounding box).  Returns 1 if the box was
        changed else 0.
        """
        ...
    
    def SetMaxPoint(self, p_float, p_float_1, p_float_2):
        """
        V.SetMaxPoint(float, float, float)
        C++: void SetMaxPoint(double x, double y, double z)
        V.SetMaxPoint([float, float, float])
        C++: void SetMaxPoint(double p[3])
        
        Set the maximum point of the bounding box - if the max point is
        less than the min point then the min point will also be changed.
        """
        ...
    
    def SetMinPoint(self, p_float, p_float_1, p_float_2):
        """
        V.SetMinPoint(float, float, float)
        C++: void SetMinPoint(double x, double y, double z)
        V.SetMinPoint([float, float, float])
        C++: void SetMinPoint(double p[3])
        
        Set the minimum point of the bounding box - if the min point is
        greater than the max point then the max point will also be
        changed.
        """
        ...
    
    def __eq__(self, *args, **kwargs) -> bool:
        """ Return self==value. """
        ...
    
    def __getattribute__(self, *args, **kwargs):
        """ Return getattr(self, name). """
        ...
    
    def __ge__(self, *args, **kwargs) -> bool:
        """ Return self>=value. """
        ...
    
    def __gt__(self, *args, **kwargs) -> bool:
        """ Return self>value. """
        ...
    
    def __hash__(self, *args, **kwargs) -> int:
        """ Return hash(self). """
        ...
    
    def __init__(self) -> None:
        ...
    
    def __le__(self, *args, **kwargs) -> bool:
        """ Return self<=value. """
        ...
    
    def __lt__(self, *args, **kwargs) -> bool:
        """ Return self<value. """
        ...
    
    @staticmethod
    def __new__(*args, **kwargs):
        """ Create and return a new object.  See help(type) for accurate signature. """
        ...
    
    def __ne__(self, *args, **kwargs) -> bool:
        """ Return self!=value. """
        ...
    
    def __repr__(self, *args, **kwargs):
        """ Return repr(self). """
        ...
    


