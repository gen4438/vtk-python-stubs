"""
This type stub file was generated by pyright.
"""

from .vtkLocator import vtkLocator

class vtkAbstractCellLocator(vtkLocator):
    """
    vtkAbstractCellLocator - an abstract base class for locators which
    find cells
    
    Superclass: vtkLocator
    
    vtkAbstractCellLocator is a spatial search object to quickly locate
    cells in 3D. vtkAbstractCellLocator supplies a basic interface which
    concrete subclasses should implement.
    
    @warning
    When deriving a class from vtkAbstractCellLocator, one should include
    the 'hidden' member functions by the following construct in the
    derived class
      using vtkAbstractCellLocator::IntersectWithLine;
      using vtkAbstractCellLocator::FindClosestPoint;
      using vtkAbstractCellLocator::FindClosestPointWithinRadius;
     
    
    @sa
    vtkLocator vtkPointLocator vtkOBBTree vtkCellLocator
    """
    def CacheCellBoundsOff(self):
        """
        V.CacheCellBoundsOff()
        C++: virtual void CacheCellBoundsOff()
        
        Boolean controls whether the bounds of each cell are computed
        only once and then saved.  Should be 10 to 20% faster if
        repeatedly calling any of the Intersect/Find routines and the
        extra memory won't cause disk caching (24 extra bytes per cell
        are required to save the bounds).
        """
        ...
    
    def CacheCellBoundsOn(self):
        """
        V.CacheCellBoundsOn()
        C++: virtual void CacheCellBoundsOn()
        
        Boolean controls whether the bounds of each cell are computed
        only once and then saved.  Should be 10 to 20% faster if
        repeatedly calling any of the Intersect/Find routines and the
        extra memory won't cause disk caching (24 extra bytes per cell
        are required to save the bounds).
        """
        ...
    
    def FindCell(self, p_float=..., p_float=..., p_float=...):
        """
        V.FindCell([float, float, float]) -> int
        C++: virtual vtkIdType FindCell(double x[3])
        V.FindCell([float, float, float], float, vtkGenericCell, [float,
            float, float], [float, ...]) -> int
        C++: virtual vtkIdType FindCell(double x[3], double tol2,
            vtkGenericCell *GenCell, double pcoords[3], double *weights)
        
        Returns the Id of the cell containing the point, returns -1 if no
        cell found. This interface uses a tolerance of zero
        """
        ...
    
    def FindCellsAlongLine(self, , , p_float_6, vtkIdList):
        """
        V.FindCellsAlongLine((float, float, float), (float, float, float),
             float, vtkIdList)
        C++: virtual void FindCellsAlongLine(const double p1[3],
            const double p2[3], double tolerance, vtkIdList *cells)
        
        Given a finite line defined by the two points (p1,p2), return the
        list of unique cell ids in the buckets containing the line. It is
        possible that an empty cell list is returned. The user must
        provide the vtkIdList to populate. This method returns data only
        after the locator has been built.
        """
        ...
    
    def FindCellsWithinBounds(self, *float, **kwargs):
        """
        V.FindCellsWithinBounds([float, ...], vtkIdList)
        C++: virtual void FindCellsWithinBounds(double *bbox,
            vtkIdList *cells)
        
        Return a list of unique cell ids inside of a given bounding box.
        The user must provide the vtkIdList to populate. This method
        returns data only after the locator has been built.
        """
        ...
    
    def FindClosestPoint(self, , p_float=..., p_float=..., p_float=..., *args, **kwargs):
        """
        V.FindClosestPoint((float, float, float), [float, float, float],
            int, int, float)
        C++: virtual void FindClosestPoint(const double x[3],
            double closestPoint[3], vtkIdType &cellId, int &subId,
            double &dist2)
        V.FindClosestPoint((float, float, float), [float, float, float],
            vtkGenericCell, int, int, float)
        C++: virtual void FindClosestPoint(const double x[3],
            double closestPoint[3], vtkGenericCell *cell,
            vtkIdType &cellId, int &subId, double &dist2)
        
        Return the closest point and the cell which is closest to the
        point x. The closest point is somewhere on a cell, it need not be
        one of the vertices of the cell.
        """
        ...
    
    def FindClosestPointWithinRadius(self, p_float=..., p_float=..., p_float=..., *args, **kwargs):
        """
        V.FindClosestPointWithinRadius([float, float, float], float,
            [float, float, float], int, int, float) -> int
        C++: virtual vtkIdType FindClosestPointWithinRadius(double x[3],
            double radius, double closestPoint[3], vtkIdType &cellId,
            int &subId, double &dist2)
        V.FindClosestPointWithinRadius([float, float, float], float,
            [float, float, float], vtkGenericCell, int, int, float) -> int
        C++: virtual vtkIdType FindClosestPointWithinRadius(double x[3],
            double radius, double closestPoint[3], vtkGenericCell *cell,
            vtkIdType &cellId, int &subId, double &dist2)
        V.FindClosestPointWithinRadius([float, float, float], float,
            [float, float, float], vtkGenericCell, int, int, float, int)
            -> int
        C++: virtual vtkIdType FindClosestPointWithinRadius(double x[3],
            double radius, double closestPoint[3], vtkGenericCell *cell,
            vtkIdType &cellId, int &subId, double &dist2, int &inside)
        
        Return the closest point within a specified radius and the cell
        which is closest to the point x. The closest point is somewhere
        on a cell, it need not be one of the vertices of the cell. This
        method returns 1 if a point is found within the specified radius.
        If there are no cells within the specified radius, the method
        returns 0 and the values of closestPoint, cellId, subId, and
        dist2 are undefined.
        """
        ...
    
    def GetCacheCellBounds(self):
        """
        V.GetCacheCellBounds() -> int
        C++: virtual vtkTypeBool GetCacheCellBounds()
        
        Boolean controls whether the bounds of each cell are computed
        only once and then saved.  Should be 10 to 20% faster if
        repeatedly calling any of the Intersect/Find routines and the
        extra memory won't cause disk caching (24 extra bytes per cell
        are required to save the bounds).
        """
        ...
    
    def GetLazyEvaluation(self):
        """
        V.GetLazyEvaluation() -> int
        C++: virtual vtkTypeBool GetLazyEvaluation()
        
        Most Locators build their search structures during BuildLocator
        but some may delay construction until it is actually needed. If
        LazyEvaluation is supported, this turns on/off the feature. if
        not supported, it is ignored.
        """
        ...
    
    def GetNumberOfCellsPerNode(self):
        """
        V.GetNumberOfCellsPerNode() -> int
        C++: virtual int GetNumberOfCellsPerNode()
        
        Specify the preferred/maximum number of cells in each
        node/bucket. Default 32. Locators generally operate by
        subdividing space into smaller regions until the number of cells
        in each region (or node) reaches the desired level.
        """
        ...
    
    def GetNumberOfCellsPerNodeMaxValue(self):
        """
        V.GetNumberOfCellsPerNodeMaxValue() -> int
        C++: virtual int GetNumberOfCellsPerNodeMaxValue()
        
        Specify the preferred/maximum number of cells in each
        node/bucket. Default 32. Locators generally operate by
        subdividing space into smaller regions until the number of cells
        in each region (or node) reaches the desired level.
        """
        ...
    
    def GetNumberOfCellsPerNodeMinValue(self):
        """
        V.GetNumberOfCellsPerNodeMinValue() -> int
        C++: virtual int GetNumberOfCellsPerNodeMinValue()
        
        Specify the preferred/maximum number of cells in each
        node/bucket. Default 32. Locators generally operate by
        subdividing space into smaller regions until the number of cells
        in each region (or node) reaches the desired level.
        """
        ...
    
    def GetNumberOfGenerationsFromBase(self, string):
        """
        V.GetNumberOfGenerationsFromBase(string) -> int
        C++: vtkIdType GetNumberOfGenerationsFromBase(const char *type)
            override;
        
        Standard type and print methods.
        """
        ...
    
    def GetNumberOfGenerationsFromBaseType(self, string):
        """
        V.GetNumberOfGenerationsFromBaseType(string) -> int
        C++: static vtkIdType GetNumberOfGenerationsFromBaseType(
            const char *type)
        
        Standard type and print methods.
        """
        ...
    
    def GetRetainCellLists(self):
        """
        V.GetRetainCellLists() -> int
        C++: virtual vtkTypeBool GetRetainCellLists()
        
        Boolean controls whether to maintain list of cells in each node.
        not applicable to all implementations, but if the locator is
        being used as a geometry simplification technique, there is no
        need to keep them.
        """
        ...
    
    def GetUseExistingSearchStructure(self):
        """
        V.GetUseExistingSearchStructure() -> int
        C++: virtual vtkTypeBool GetUseExistingSearchStructure()
        
        Some locators support querying a new dataset without rebuilding
        the search structure (typically this may occur when a dataset
        changes due to a time update, but is actually the same topology)
        Turning on this flag enables some locators to skip the rebuilding
        phase
        """
        ...
    
    def InsideCellBounds(self, p_float=..., p_float=..., p_float=..., *args, **kwargs):
        """
        V.InsideCellBounds([float, float, float], int) -> bool
        C++: virtual bool InsideCellBounds(double x[3], vtkIdType cell_ID)
        
        Quickly test if a point is inside the bounds of a particular
        cell. Some locators cache cell bounds and this function can make
        use of fast access to the data.
        """
        ...
    
    def IntersectWithLine(self, , , p_float_6, p_float_7, p_float=..., p_float=..., p_float=..., *args, **kwargs):
        """
        V.IntersectWithLine((float, float, float), (float, float, float),
            float, float, [float, float, float], [float, float, float],
            int) -> int
        C++: virtual int IntersectWithLine(const double p1[3],
            const double p2[3], double tol, double &t, double x[3],
            double pcoords[3], int &subId)
        V.IntersectWithLine((float, float, float), (float, float, float),
            float, float, [float, float, float], [float, float, float],
            int, int) -> int
        C++: virtual int IntersectWithLine(const double p1[3],
            const double p2[3], double tol, double &t, double x[3],
            double pcoords[3], int &subId, vtkIdType &cellId)
        V.IntersectWithLine((float, float, float), (float, float, float),
            float, float, [float, float, float], [float, float, float],
            int, int, vtkGenericCell) -> int
        C++: virtual int IntersectWithLine(const double p1[3],
            const double p2[3], double tol, double &t, double x[3],
            double pcoords[3], int &subId, vtkIdType &cellId,
            vtkGenericCell *cell)
        V.IntersectWithLine((float, float, float), (float, float, float),
            vtkPoints, vtkIdList) -> int
        C++: virtual int IntersectWithLine(const double p1[3],
            const double p2[3], vtkPoints *points, vtkIdList *cellIds)
        
        Return intersection point (if any) of finite line with cells
        contained in cell locator. See vtkCell.h parameters
        documentation.
        """
        ...
    
    def IsA(self, string):
        """
        V.IsA(string) -> int
        C++: vtkTypeBool IsA(const char *type) override;
        
        Standard type and print methods.
        """
        ...
    
    def IsTypeOf(self, string):
        """
        V.IsTypeOf(string) -> int
        C++: static vtkTypeBool IsTypeOf(const char *type)
        
        Standard type and print methods.
        """
        ...
    
    def LazyEvaluationOff(self):
        """
        V.LazyEvaluationOff()
        C++: virtual void LazyEvaluationOff()
        
        Most Locators build their search structures during BuildLocator
        but some may delay construction until it is actually needed. If
        LazyEvaluation is supported, this turns on/off the feature. if
        not supported, it is ignored.
        """
        ...
    
    def LazyEvaluationOn(self):
        """
        V.LazyEvaluationOn()
        C++: virtual void LazyEvaluationOn()
        
        Most Locators build their search structures during BuildLocator
        but some may delay construction until it is actually needed. If
        LazyEvaluation is supported, this turns on/off the feature. if
        not supported, it is ignored.
        """
        ...
    
    def NewInstance(self):
        """
        V.NewInstance() -> vtkAbstractCellLocator
        C++: vtkAbstractCellLocator *NewInstance()
        
        Standard type and print methods.
        """
        ...
    
    def RetainCellListsOff(self):
        """
        V.RetainCellListsOff()
        C++: virtual void RetainCellListsOff()
        
        Boolean controls whether to maintain list of cells in each node.
        not applicable to all implementations, but if the locator is
        being used as a geometry simplification technique, there is no
        need to keep them.
        """
        ...
    
    def RetainCellListsOn(self):
        """
        V.RetainCellListsOn()
        C++: virtual void RetainCellListsOn()
        
        Boolean controls whether to maintain list of cells in each node.
        not applicable to all implementations, but if the locator is
        being used as a geometry simplification technique, there is no
        need to keep them.
        """
        ...
    
    def SafeDownCast(self, vtkObjectBase):
        """
        V.SafeDownCast(vtkObjectBase) -> vtkAbstractCellLocator
        C++: static vtkAbstractCellLocator *SafeDownCast(vtkObjectBase *o)
        
        Standard type and print methods.
        """
        ...
    
    def SetCacheCellBounds(self, p_int):
        """
        V.SetCacheCellBounds(int)
        C++: virtual void SetCacheCellBounds(vtkTypeBool _arg)
        
        Boolean controls whether the bounds of each cell are computed
        only once and then saved.  Should be 10 to 20% faster if
        repeatedly calling any of the Intersect/Find routines and the
        extra memory won't cause disk caching (24 extra bytes per cell
        are required to save the bounds).
        """
        ...
    
    def SetLazyEvaluation(self, p_int):
        """
        V.SetLazyEvaluation(int)
        C++: virtual void SetLazyEvaluation(vtkTypeBool _arg)
        
        Most Locators build their search structures during BuildLocator
        but some may delay construction until it is actually needed. If
        LazyEvaluation is supported, this turns on/off the feature. if
        not supported, it is ignored.
        """
        ...
    
    def SetNumberOfCellsPerNode(self, p_int):
        """
        V.SetNumberOfCellsPerNode(int)
        C++: virtual void SetNumberOfCellsPerNode(int _arg)
        
        Specify the preferred/maximum number of cells in each
        node/bucket. Default 32. Locators generally operate by
        subdividing space into smaller regions until the number of cells
        in each region (or node) reaches the desired level.
        """
        ...
    
    def SetRetainCellLists(self, p_int):
        """
        V.SetRetainCellLists(int)
        C++: virtual void SetRetainCellLists(vtkTypeBool _arg)
        
        Boolean controls whether to maintain list of cells in each node.
        not applicable to all implementations, but if the locator is
        being used as a geometry simplification technique, there is no
        need to keep them.
        """
        ...
    
    def SetUseExistingSearchStructure(self, p_int):
        """
        V.SetUseExistingSearchStructure(int)
        C++: virtual void SetUseExistingSearchStructure(vtkTypeBool _arg)
        
        Some locators support querying a new dataset without rebuilding
        the search structure (typically this may occur when a dataset
        changes due to a time update, but is actually the same topology)
        Turning on this flag enables some locators to skip the rebuilding
        phase
        """
        ...
    
    def UseExistingSearchStructureOff(self):
        """
        V.UseExistingSearchStructureOff()
        C++: virtual void UseExistingSearchStructureOff()
        
        Some locators support querying a new dataset without rebuilding
        the search structure (typically this may occur when a dataset
        changes due to a time update, but is actually the same topology)
        Turning on this flag enables some locators to skip the rebuilding
        phase
        """
        ...
    
    def UseExistingSearchStructureOn(self):
        """
        V.UseExistingSearchStructureOn()
        C++: virtual void UseExistingSearchStructureOn()
        
        Some locators support querying a new dataset without rebuilding
        the search structure (typically this may occur when a dataset
        changes due to a time update, but is actually the same topology)
        Turning on this flag enables some locators to skip the rebuilding
        phase
        """
        ...
    
    def __delattr__(self, *args, **kwargs):
        """ Implement delattr(self, name). """
        ...
    
    def __getattribute__(self, *args, **kwargs):
        """ Return getattr(self, name). """
        ...
    
    def __init__(self, *args, **kwargs) -> None:
        ...
    
    @staticmethod
    def __new__(*args, **kwargs):
        """ Create and return a new object.  See help(type) for accurate signature. """
        ...
    
    def __repr__(self, *args, **kwargs):
        """ Return repr(self). """
        ...
    
    def __setattr__(self, *args, **kwargs):
        """ Implement setattr(self, name, value). """
        ...
    
    def __str__(self, *args, **kwargs) -> str:
        """ Return str(self). """
        ...
    
    __this__ = ...
    __dict__ = ...
    __vtkname__ = ...


