"""
This type stub file was generated by pyright.
"""

import vtkmodules.vtkCommonCore as __vtkmodules_vtkCommonCore

class vtkImplicitFunction(__vtkmodules_vtkCommonCore.vtkObject):
    """
    vtkImplicitFunction - abstract interface for implicit functions
    
    Superclass: vtkObject
    
    vtkImplicitFunction specifies an abstract interface for implicit
    functions. Implicit functions are real valued functions defined in 3D
    space, w = F(x,y,z). Two primitive operations are required: the
    ability to evaluate the function, and the function gradient at a
    given point. The implicit function divides space into three regions:
    on the surface (F(x,y,z)=w), outside of the surface (F(x,y,z)>c), and
    inside the surface (F(x,y,z)<c). (When c is zero, positive values are
    outside, negative values are inside, and zero is on the surface. Note
    also that the function gradient points from inside to outside.)
    
    Implicit functions are very powerful. It is possible to represent
    almost any type of geometry with the level sets w = const, especially
    if you use boolean combinations of implicit functions (see
    vtkImplicitBoolean).
    
    vtkImplicitFunction provides a mechanism to transform the implicit
    function(s) via a vtkAbstractTransform.  This capability can be used
    to translate, orient, scale, or warp implicit functions.  For
    example, a sphere implicit function can be transformed into an
    oriented ellipse.
    
    @warning
    The transformation transforms a point into the space of the implicit
    function (i.e., the model space). Typically we want to transform the
    implicit model into world coordinates. In this case the inverse of
    the transformation is required.
    
    @sa
    vtkAbstractTransform vtkSphere vtkCylinder vtkImplicitBoolean
    vtkPlane vtkPlanes vtkQuadric vtkImplicitVolume vtkSampleFunction
    vtkCutter vtkClipPolyData
    """
    def EvaluateFunction(self, p_float=..., p_float=..., p_float=...):
        """
        V.EvaluateFunction([float, float, float]) -> float
        C++: virtual double EvaluateFunction(double x[3])
        V.EvaluateFunction(vtkDataArray, vtkDataArray)
        C++: virtual void EvaluateFunction(vtkDataArray *input,
            vtkDataArray *output)
        V.EvaluateFunction(float, float, float) -> float
        C++: virtual double EvaluateFunction(double x, double y, double z)
        
        Evaluate function at position x-y-z and return value.  You should
        generally not call this method directly, you should use
        FunctionValue() instead.  This method must be implemented by any
        derived class.
        """
        ...
    
    def EvaluateGradient(self, p_float=..., p_float=..., p_float=..., *args, **kwargs):
        """
        V.EvaluateGradient([float, float, float], [float, float, float])
        C++: virtual void EvaluateGradient(double x[3], double g[3])
        
        Evaluate function gradient at position x-y-z and pass back
        vector. You should generally not call this method directly, you
        should use FunctionGradient() instead.  This method must be
        implemented by any derived class.
        """
        ...
    
    def FunctionGradient(self, , p_float=..., p_float=..., p_float=...):
        """
        V.FunctionGradient((float, float, float), [float, float, float])
        C++: void FunctionGradient(const double x[3], double g[3])
        V.FunctionGradient((float, float, float)) -> (float, float, float)
        C++: double *FunctionGradient(const double x[3])
        V.FunctionGradient(float, float, float) -> (float, float, float)
        C++: double *FunctionGradient(double x, double y, double z)
        
        Evaluate function gradient at position x-y-z and pass back
        vector. Point x[3] is transformed through transform (if
        provided).
        """
        ...
    
    def FunctionValue(self, vtkDataArray, vtkDataArray_1):
        """
        V.FunctionValue(vtkDataArray, vtkDataArray)
        C++: virtual void FunctionValue(vtkDataArray *input,
            vtkDataArray *output)
        V.FunctionValue((float, float, float)) -> float
        C++: double FunctionValue(const double x[3])
        V.FunctionValue(float, float, float) -> float
        C++: double FunctionValue(double x, double y, double z)
        
        Evaluate function at position x-y-z and return value. Point x[3]
        is transformed through transform (if provided).
        """
        ...
    
    def GetMTime(self):
        """
        V.GetMTime() -> int
        C++: vtkMTimeType GetMTime() override;
        
        Overload standard modified time function. If Transform is
        modified, then this object is modified as well.
        """
        ...
    
    def GetNumberOfGenerationsFromBase(self, string):
        """
        V.GetNumberOfGenerationsFromBase(string) -> int
        C++: vtkIdType GetNumberOfGenerationsFromBase(const char *type)
            override;
        
        Given a the name of a base class of this class type, return the
        distance of inheritance between this class type and the named
        class (how many generations of inheritance are there between this
        class and the named class). If the named class is not in this
        class's inheritance tree, return a negative value. Valid
        responses will always be nonnegative. This method works in
        combination with vtkTypeMacro found in vtkSetGet.h.
        """
        ...
    
    def GetNumberOfGenerationsFromBaseType(self, string):
        """
        V.GetNumberOfGenerationsFromBaseType(string) -> int
        C++: static vtkIdType GetNumberOfGenerationsFromBaseType(
            const char *type)
        
        Given a the name of a base class of this class type, return the
        distance of inheritance between this class type and the named
        class (how many generations of inheritance are there between this
        class and the named class). If the named class is not in this
        class's inheritance tree, return a negative value. Valid
        responses will always be nonnegative. This method works in
        combination with vtkTypeMacro found in vtkSetGet.h.
        """
        ...
    
    def GetTransform(self):
        """
        V.GetTransform() -> vtkAbstractTransform
        C++: virtual vtkAbstractTransform *GetTransform()
        
        Set/Get a transformation to apply to input points before
        executing the implicit function.
        """
        ...
    
    def IsA(self, string):
        """
        V.IsA(string) -> int
        C++: vtkTypeBool IsA(const char *type) override;
        
        Return 1 if this class is the same type of (or a subclass of) the
        named class. Returns 0 otherwise. This method works in
        combination with vtkTypeMacro found in vtkSetGet.h.
        """
        ...
    
    def IsTypeOf(self, string):
        """
        V.IsTypeOf(string) -> int
        C++: static vtkTypeBool IsTypeOf(const char *type)
        
        Return 1 if this class type is the same type of (or a subclass
        of) the named class. Returns 0 otherwise. This method works in
        combination with vtkTypeMacro found in vtkSetGet.h.
        """
        ...
    
    def NewInstance(self):
        """
        V.NewInstance() -> vtkImplicitFunction
        C++: vtkImplicitFunction *NewInstance()
        """
        ...
    
    def SafeDownCast(self, vtkObjectBase):
        """
        V.SafeDownCast(vtkObjectBase) -> vtkImplicitFunction
        C++: static vtkImplicitFunction *SafeDownCast(vtkObjectBase *o)
        """
        ...
    
    def SetTransform(self, vtkAbstractTransform):
        """
        V.SetTransform(vtkAbstractTransform)
        C++: virtual void SetTransform(vtkAbstractTransform *)
        V.SetTransform((float, float, float, float, float, float, float,
            float, float, float, float, float, float, float, float, float)
            )
        C++: virtual void SetTransform(const double elements[16])
        
        Set/Get a transformation to apply to input points before
        executing the implicit function.
        """
        ...
    
    def __delattr__(self, *args, **kwargs):
        """ Implement delattr(self, name). """
        ...
    
    def __getattribute__(self, *args, **kwargs):
        """ Return getattr(self, name). """
        ...
    
    def __init__(self, *args, **kwargs) -> None:
        ...
    
    @staticmethod
    def __new__(*args, **kwargs):
        """ Create and return a new object.  See help(type) for accurate signature. """
        ...
    
    def __repr__(self, *args, **kwargs):
        """ Return repr(self). """
        ...
    
    def __setattr__(self, *args, **kwargs):
        """ Implement setattr(self, name, value). """
        ...
    
    def __str__(self, *args, **kwargs) -> str:
        """ Return str(self). """
        ...
    
    __this__ = ...
    __dict__ = ...
    __vtkname__ = ...


