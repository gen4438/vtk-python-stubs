"""
This type stub file was generated by pyright.
"""

from .vtkCell3D import vtkCell3D

class vtkPolyhedron(vtkCell3D):
    """
    vtkPolyhedron - a 3D cell defined by a set of polygonal faces
    
    Superclass: vtkCell3D
    
    vtkPolyhedron is a concrete implementation that represents a 3D cell
    defined by a set of polygonal faces. The polyhedron should be
    watertight, non-self-intersecting and manifold (each edge is used
    twice).
    
    Interpolation functions and weights are defined / computed using the
    method of Mean Value Coordinates (MVC). See the VTK class
    vtkMeanValueCoordinatesInterpolator for more information.
    
    The class does not require the polyhedron to be convex. However, the
    polygonal faces must be planar. Non-planar polygonal faces will
    definitely cause problems, especially in severely warped situations.
    
    @sa
    vtkCell3D vtkConvecPointSet vtkMeanValueCoordinatesInterpolator
    """
    def CellBoundary(self, p_int, , vtkIdList):
        """
        V.CellBoundary(int, (float, float, float), vtkIdList) -> int
        C++: int CellBoundary(int subId, const double pcoords[3],
            vtkIdList *pts) override;
        
        Find the boundary face closest to the point defined by the
        pcoords[3] and subId of the cell (subId can be ignored).
        """
        ...
    
    def Clip(self, p_float, vtkDataArray, vtkIncrementalPointLocator, vtkCellArray, vtkPointData, vtkPointData_1, vtkCellData, p_int, vtkCellData_1, p_int_1):
        """
        V.Clip(float, vtkDataArray, vtkIncrementalPointLocator,
            vtkCellArray, vtkPointData, vtkPointData, vtkCellData, int,
            vtkCellData, int)
        C++: void Clip(double value, vtkDataArray *scalars,
            vtkIncrementalPointLocator *locator,
            vtkCellArray *connectivity, vtkPointData *inPd,
            vtkPointData *outPd, vtkCellData *inCd, vtkIdType cellId,
            vtkCellData *outCd, int insideOut) override;
        
        Satisfy the vtkCell API. This method clips the input polyhedron
        and outputs a new polyhedron. The face information of the output
        polyhedron is encoded in the output vtkCellArray using a special
        format: CellLength [nCellFaces, nFace0Pts, i, j, k, nFace1Pts, i,
        j, k, ...]. Use the static method
        vtkUnstructuredGrid::DecomposePolyhedronCellArray to convert it
        into a standard format. Note: the algorithm assumes water-tight
        polyhedron cells.
        """
        ...
    
    def Contour(self, p_float, vtkDataArray, vtkIncrementalPointLocator, vtkCellArray, vtkCellArray_1, vtkCellArray_2, vtkPointData, vtkPointData_1, vtkCellData, p_int, vtkCellData_1):
        """
        V.Contour(float, vtkDataArray, vtkIncrementalPointLocator,
            vtkCellArray, vtkCellArray, vtkCellArray, vtkPointData,
            vtkPointData, vtkCellData, int, vtkCellData)
        C++: void Contour(double value, vtkDataArray *scalars,
            vtkIncrementalPointLocator *locator, vtkCellArray *verts,
            vtkCellArray *lines, vtkCellArray *polys, vtkPointData *inPd,
            vtkPointData *outPd, vtkCellData *inCd, vtkIdType cellId,
            vtkCellData *outCd) override;
        
        Satisfy the vtkCell API. This method contours the input
        polyhedron and outputs a polygon. When the result polygon is not
        planar, it will be triangulated. The current implementation
        assumes water-tight polyhedron cells.
        """
        ...
    
    def Derivatives(self, p_int, , float_tuple, p_int_1, *float):
        """
        V.Derivatives(int, (float, float, float), (float, ...), int,
            [float, ...])
        C++: void Derivatives(int subId, const double pcoords[3],
            const double *values, int dim, double *derivs) override;
        
        Computes derivatives at the point specified by the parameter
        coordinate. Current implementation uses all vertices and subId is
        not used. To accelerate the speed, the future implementation can
        triangulate and extract the local tetrahedron from subId and
        pcoords, then evaluate derivatives on the local tetrahedron.
        """
        ...
    
    def EvaluateLocation(self, p_int, , p_float=..., p_float=..., p_float=..., *args, **kwargs):
        """
        V.EvaluateLocation(int, (float, float, float), [float, float,
            float], [float, ...])
        C++: void EvaluateLocation(int &subId, const double pcoords[3],
            double x[3], double *weights) override;
        
        The inverse of EvaluatePosition. Note the weights should be the
        MVC weights.
        """
        ...
    
    def EvaluatePosition(self, , p_float=..., p_float=..., p_float=..., *args, **kwargs):
        """
        V.EvaluatePosition((float, float, float), [float, float, float],
            int, [float, float, float], float, [float, ...]) -> int
        C++: int EvaluatePosition(const double x[3],
            double closestPoint[3], int &subId, double pcoords[3],
            double &dist2, double weights[]) override;
        
        Satisfy the vtkCell API. The subId is ignored and zero is always
        returned. The parametric coordinates pcoords are normalized
        values in the bounding box of the polyhedron. The weights are
        determined by evaluating the MVC coordinates. The dist is always
        zero if the point x[3] is inside the polyhedron; otherwise it's
        the distance to the surface.
        """
        ...
    
    def GetCellType(self):
        """
        V.GetCellType() -> int
        C++: int GetCellType() override;
        
        See the vtkCell API for descriptions of these methods.
        """
        ...
    
    def GetCentroid(self, p_float=..., p_float=..., p_float=...):
        """
        V.GetCentroid([float, float, float]) -> bool
        C++: bool GetCentroid(double centroid[3]) override;
        
        Computes the centroid of the cell.
        """
        ...
    
    def GetEdge(self, p_int):
        """
        V.GetEdge(int) -> vtkCell
        C++: vtkCell *GetEdge(int) override;
        
        A polyhedron is represented internally by a set of polygonal
        faces. These faces can be processed to explicitly determine
        edges.
        """
        ...
    
    def GetEdgePoints(self, p_int, int_tuple):
        """
        V.GetEdgePoints(int, (int, ...))
        C++: void GetEdgePoints(vtkIdType edgeId, const vtkIdType *&pts)
            override;
        V.GetEdgePoints(int, [int, ...])
        C++: void GetEdgePoints(int edgeId, int *&pts) override;
        
        See vtkCell3D API for description of these methods.
        @warning These method are unimplemented in vtkPolyhedron
        """
        ...
    
    def GetEdgeToAdjacentFaces(self, p_int, int_tuple):
        """
        V.GetEdgeToAdjacentFaces(int, (int, ...))
        C++: void GetEdgeToAdjacentFaces(vtkIdType edgeId,
            const vtkIdType *&pts) override;
        
        Get the ids of the two adjacent faces to edge of id edgeId. The
        output face ids are sorted from id of lowest rank to highest.
        Note that the faces are 0-offset; that is, they refer to the ids
        of the cells, not the face ids of the mesh that the cell belongs
        to. The edgeId must range between
        0<=edgeId<this->GetNumberOfEdges().
        """
        ...
    
    def GetFace(self, p_int):
        """
        V.GetFace(int) -> vtkCell
        C++: vtkCell *GetFace(int faceId) override;
        
        A polyhedron is represented internally by a set of polygonal
        faces. These faces can be processed to explicitly determine
        edges.
        """
        ...
    
    def GetFacePoints(self, p_int, int_tuple):
        """
        V.GetFacePoints(int, (int, ...)) -> int
        C++: vtkIdType GetFacePoints(vtkIdType faceId,
            const vtkIdType *&pts) override;
        V.GetFacePoints(int, [int, ...])
        C++: void GetFacePoints(int faceId, int *&pts) override;
        
        Get the list of vertices that define a face. The list is
        terminated with a negative number. Note that the vertices are
        0-offset; that is, they refer to the ids of the cell, not the
        point ids of the mesh that the cell belongs to. The faceId must
        range between 0<=faceId<this->GetNumberOfFaces().
        
        @return The number of points in face faceId
        """
        ...
    
    def GetFaces(self):
        """
        V.GetFaces() -> (int, ...)
        C++: vtkIdType *GetFaces() override;
        
        Methods supporting the definition of faces. Note that the
        GetFaces() returns a list of faces in vtkCellArray form; use the
        method GetNumberOfFaces() to determine the number of faces in the
        list. The SetFaces() method is also in vtkCellArray form, except
        that it begins with a leading count indicating the total number
        of faces in the list.
        """
        ...
    
    def GetFaceToAdjacentFaces(self, p_int, int_tuple):
        """
        V.GetFaceToAdjacentFaces(int, (int, ...)) -> int
        C++: vtkIdType GetFaceToAdjacentFaces(vtkIdType faceId,
            const vtkIdType *&faceIds) override;
        
        Get the ids of the adjacent faces to face of id faceId. The order
        of faces is consistent. They are always ordered in counter
        clockwise w.r.t. normal orientation. The first id faces[0]
        corresponds to the face sharing point of id pts[0] where pts is
        obtained from this->GetFacePoints(faceId, pts), being the "most counter
        clockwise" oriented w.r.t. face faceId. Note that the faces are
        0-offset; that is, they refer to the ids of the cell, not the
        face ids of the mesh that the cell belongs to. The faceId must be
        between 0<=faceId<this->GetNumberOfFaces();
        
        @warning If the vtkCell3D is "inside out", i.e. normals point
            inside the cell, the order is
        inverted.
        @return The number of adjacent faces to faceId.
        """
        ...
    
    def GetNumberOfEdges(self):
        """
        V.GetNumberOfEdges() -> int
        C++: int GetNumberOfEdges() override;
        
        A polyhedron is represented internally by a set of polygonal
        faces. These faces can be processed to explicitly determine
        edges.
        """
        ...
    
    def GetNumberOfFaces(self):
        """
        V.GetNumberOfFaces() -> int
        C++: int GetNumberOfFaces() override;
        
        A polyhedron is represented internally by a set of polygonal
        faces. These faces can be processed to explicitly determine
        edges.
        """
        ...
    
    def GetNumberOfGenerationsFromBase(self, string):
        """
        V.GetNumberOfGenerationsFromBase(string) -> int
        C++: vtkIdType GetNumberOfGenerationsFromBase(const char *type)
            override;
        
        Standard new methods.
        """
        ...
    
    def GetNumberOfGenerationsFromBaseType(self, string):
        """
        V.GetNumberOfGenerationsFromBaseType(string) -> int
        C++: static vtkIdType GetNumberOfGenerationsFromBaseType(
            const char *type)
        
        Standard new methods.
        """
        ...
    
    def GetParametricCenter(self, p_float=..., p_float=..., p_float=...):
        """
        V.GetParametricCenter([float, float, float]) -> int
        C++: int GetParametricCenter(double pcoords[3]) override;
        
        Return the center of the cell in parametric coordinates. In this
        cell, the center of the bounding box is returned.
        """
        ...
    
    def GetParametricCoords(self):
        """
        V.GetParametricCoords() -> (float, ...)
        C++: double *GetParametricCoords() override;
        
        See vtkCell3D API for description of this method.
        """
        ...
    
    def GetPointToIncidentEdges(self, p_int, int_tuple):
        """
        V.GetPointToIncidentEdges(int, (int, ...)) -> int
        C++: vtkIdType GetPointToIncidentEdges(vtkIdType pointId,
            const vtkIdType *&edgeIds) override;
        
        Get the ids of the incident edges to point of id pointId. Edges
        are sorted in counter clockwise order w.r.t. bisectrix pointing
        outside the cell at point of id pointId. The first edge
        corresponds to the edge containing point of id pts[0], where pts
        is obtained from this->GetPointToOnRingVertices(pointId, pts).
        Note that the edges are 0-offset; that is, they refer to the ids
        of the cell, not the edge ids of the mesh that the cell belongs
        to. The edgeId must be between
        0<=edgeId<this->GetNumberOfEdges();
        
        @warning If the vtkCell3D is "inside out", i.e. normals point
            inside the cell, the order is
        inverted.
        @return The valence of point pointId.
        """
        ...
    
    def GetPointToIncidentFaces(self, p_int, int_tuple):
        """
        V.GetPointToIncidentFaces(int, (int, ...)) -> int
        C++: vtkIdType GetPointToIncidentFaces(vtkIdType pointId,
            const vtkIdType *&faceIds) override;
        
        Get the ids of the incident faces point of id pointId. Faces are
        sorted in counter clockwise order w.r.t. bisectrix pointing
        outside the cell at point of id pointId. The first face
        corresponds to the face containing edge of id edges[0], where
        edges is obtained from this->GetPointToIncidentEdges(pointId,
        edges), such that face faces[0] is the "most counterclockwise"
        face incident to point pointId containing edges[0]. Note that the
        faces are 0-offset; that is, they refer to the ids of the cell,
        not the face ids of the mesh that the cell belongs to. The
        pointId must be between 0<=pointId<this->GetNumberOfPoints().
        
        @warning If the vtkCell3D is "inside out", i.e. normals point
            inside the cell, the order is
        inverted.
        @return The valence of point pointId.
        """
        ...
    
    def GetPointToOneRingPoints(self, p_int, int_tuple):
        """
        V.GetPointToOneRingPoints(int, (int, ...)) -> int
        C++: vtkIdType GetPointToOneRingPoints(vtkIdType pointId,
            const vtkIdType *&pts) override;
        
        Get the ids of a one-ring surrounding point of id pointId. Points
        are sorted in counter clockwise order w.r.t. bisectrix pointing
        outside the cell at point of id pointId. The first point
        corresponds to the point contained in edges[0], where edges is
        obtained from this->GetPointToIncidentEdges(pointId, edges). Note
        that the points are 0-offset; that is, they refer to the ids of
        the cell, not the point ids of the mesh that the cell belongs to.
        The pointId must be between 0<pointId<this->GetNumberOfPoints().
        @return The valence of point pointId.
        """
        ...
    
    def GetPolyData(self):
        """
        V.GetPolyData() -> vtkPolyData
        C++: vtkPolyData *GetPolyData()
        
        Construct polydata if no one exist, then return this->PolyData
        """
        ...
    
    def Initialize(self):
        """
        V.Initialize()
        C++: void Initialize() override;
        """
        ...
    
    def InterpolateDerivs(self, , *float):
        """
        V.InterpolateDerivs((float, float, float), [float, ...])
        C++: void InterpolateDerivs(const double x[3], double *derivs)
            override;
        
        Compute the interpolation functions/derivatives (aka shape
        functions/derivatives). Here we use the MVC calculation process
        to compute the interpolation functions.
        """
        ...
    
    def InterpolateFunctions(self, , *float):
        """
        V.InterpolateFunctions((float, float, float), [float, ...])
        C++: void InterpolateFunctions(const double x[3], double *sf)
            override;
        
        Compute the interpolation functions/derivatives (aka shape
        functions/derivatives). Here we use the MVC calculation process
        to compute the interpolation functions.
        """
        ...
    
    def IntersectWithLine(self, , , p_float_6, p_float_7, p_float=..., p_float=..., p_float=..., *args, **kwargs):
        """
        V.IntersectWithLine((float, float, float), (float, float, float),
            float, float, [float, float, float], [float, float, float],
            int) -> int
        C++: int IntersectWithLine(const double p1[3], const double p2[3],
             double tol, double &t, double x[3], double pcoords[3],
            int &subId) override;
        
        Intersect the line (p1,p2) with a given tolerance tol to
        determine a point of intersection x[3] with parametric coordinate
        t along the line. The parametric coordinates are returned as well
        (subId can be ignored). Returns true if the line intersects a
        face.
        """
        ...
    
    def IsA(self, string):
        """
        V.IsA(string) -> int
        C++: vtkTypeBool IsA(const char *type) override;
        
        Standard new methods.
        """
        ...
    
    def IsConvex(self):
        """
        V.IsConvex() -> bool
        C++: bool IsConvex()
        
        Determine whether or not a polyhedron is convex. This method is
        adapted from Devillers et al., "Checking the Convexity of
        Polytopes and the Planarity of Subdivisions", Computational
        Geometry, Volume 11, Issues 3 - 4, December 1998, Pages 187 -
        208.
        """
        ...
    
    def IsInside(self, , p_float_3):
        """
        V.IsInside((float, float, float), float) -> int
        C++: int IsInside(const double x[3], double tolerance)
        
        A method particular to vtkPolyhedron. It determines whether a
        point x[3] is inside the polyhedron or not (returns 1 is the
        point is inside, 0 otherwise). The tolerance is expressed in
        normalized space; i.e., a fraction of the size of the bounding
        box.
        """
        ...
    
    def IsPrimaryCell(self):
        """
        V.IsPrimaryCell() -> int
        C++: int IsPrimaryCell() override;
        
        A polyhedron is a full-fledged primary cell.
        """
        ...
    
    def IsTypeOf(self, string):
        """
        V.IsTypeOf(string) -> int
        C++: static vtkTypeBool IsTypeOf(const char *type)
        
        Standard new methods.
        """
        ...
    
    def NewInstance(self):
        """
        V.NewInstance() -> vtkPolyhedron
        C++: vtkPolyhedron *NewInstance()
        
        Standard new methods.
        """
        ...
    
    def RequiresExplicitFaceRepresentation(self):
        """
        V.RequiresExplicitFaceRepresentation() -> int
        C++: int RequiresExplicitFaceRepresentation() override;
        
        Methods supporting the definition of faces. Note that the
        GetFaces() returns a list of faces in vtkCellArray form; use the
        method GetNumberOfFaces() to determine the number of faces in the
        list. The SetFaces() method is also in vtkCellArray form, except
        that it begins with a leading count indicating the total number
        of faces in the list.
        """
        ...
    
    def RequiresInitialization(self):
        """
        V.RequiresInitialization() -> int
        C++: int RequiresInitialization() override;
        
        This cell requires that it be initialized prior to access.
        """
        ...
    
    def SafeDownCast(self, vtkObjectBase):
        """
        V.SafeDownCast(vtkObjectBase) -> vtkPolyhedron
        C++: static vtkPolyhedron *SafeDownCast(vtkObjectBase *o)
        
        Standard new methods.
        """
        ...
    
    def SetFaces(self, *int):
        """
        V.SetFaces([int, ...])
        C++: void SetFaces(vtkIdType *faces) override;
        
        Methods supporting the definition of faces. Note that the
        GetFaces() returns a list of faces in vtkCellArray form; use the
        method GetNumberOfFaces() to determine the number of faces in the
        list. The SetFaces() method is also in vtkCellArray form, except
        that it begins with a leading count indicating the total number
        of faces in the list.
        """
        ...
    
    def Triangulate(self, p_int, vtkIdList, vtkPoints):
        """
        V.Triangulate(int, vtkIdList, vtkPoints) -> int
        C++: int Triangulate(int index, vtkIdList *ptIds, vtkPoints *pts)
            override;
        
        Use vtkOrderedTriangulator to tetrahedralize the polyhedron mesh.
        This method works well for a convex polyhedron but may return
        wrong result in a concave case. Once triangulation has been
        performed, the results are saved in ptIds and pts. The ptIds is a
        vtkIdList with 4xn number of ids (n is the number of result
        tetrahedrons). The first 4 represent the point ids of the first
        tetrahedron, the second 4 represents the point ids of the second
        tetrahedron and so on. The point ids represent global dataset
        ids. The points of result tetrahedons are stored in pts. Note
        that there are 4xm output points (m is the number of points in
        the original polyhedron). A point may be stored multiple times
        when it is shared by more than one tetrahedrons. The points
        stored in pts are ordered the same as they are listed in ptIds.
        """
        ...
    
    def __delattr__(self, *args, **kwargs):
        """ Implement delattr(self, name). """
        ...
    
    def __getattribute__(self, *args, **kwargs):
        """ Return getattr(self, name). """
        ...
    
    def __init__(self, *args, **kwargs) -> None:
        ...
    
    @staticmethod
    def __new__(*args, **kwargs):
        """ Create and return a new object.  See help(type) for accurate signature. """
        ...
    
    def __repr__(self, *args, **kwargs):
        """ Return repr(self). """
        ...
    
    def __setattr__(self, *args, **kwargs):
        """ Implement setattr(self, name, value). """
        ...
    
    def __str__(self, *args, **kwargs) -> str:
        """ Return str(self). """
        ...
    
    __this__ = ...
    __dict__ = ...
    __vtkname__ = ...


