"""
This type stub file was generated by pyright.
"""

from .vtkDataObject import vtkDataObject

class vtkGraph(vtkDataObject):
    """
    vtkGraph - Base class for graph data types.
    
    Superclass: vtkDataObject
    
    vtkGraph is the abstract base class that provides all read-only API
    for graph data types. A graph consists of a collection of vertices
    and a collection of edges connecting pairs of vertices. The
    vtkDirectedGraph subclass represents a graph whose edges have
    inherent order from source vertex to target vertex, while
    vtkUndirectedGraph is a graph whose edges have no inherent ordering.
    
    Graph vertices may be traversed in two ways. In the current
    implementation, all vertices are assigned consecutive ids starting at
    zero, so they may be traversed in a simple for loop from 0 to
    graph->GetNumberOfVertices() - 1. You may alternately create a
    vtkVertexListIterator and call graph->GetVertices(it). it->Next()
    will return the id of the next vertex, while it->HasNext() indicates
    whether there are more vertices in the graph. This is the preferred
    method, since in the future graphs may support filtering or
    subsetting where the vertex ids may not be contiguous.
    
    Graph edges must be traversed through iterators. To traverse all
    edges in a graph, create an instance of vtkEdgeListIterator and call
    graph->GetEdges(it). it->Next() returns lightweight vtkEdgeType
    structures, which contain the public fields Id, Source and Target. Id
    is the identifier for the edge, which may be used to look up values
    in assiciated edge data arrays. Source and Target store the ids of
    the source and target vertices of the edge. Note that the edge list
    iterator DOES NOT necessarily iterate over edges in order of
    ascending id. To traverse edges from wrapper code (Python, Java), use
    it->NextGraphEdge() instead of it->Next().  This will return a
    heavyweight, wrappable vtkGraphEdge object, which has the same fields
    as vtkEdgeType accessible through getter methods.
    
    To traverse all edges outgoing from a vertex, create a
    vtkOutEdgeIterator and call graph->GetOutEdges(v, it). it->Next()
    returns a lightweight vtkOutEdgeType containing the fields Id and
    Target. The source of the edge is always the vertex that was passed
    as an argument to GetOutEdges(). Incoming edges may be similarly
    traversed with vtkInEdgeIterator, which returns vtkInEdgeType
    structures with Id and Source fields. Both vtkOutEdgeIterator and
    vtkInEdgeIterator also provide the wrapper functions NextGraphEdge()
    which return vtkGraphEdge objects.
    
    An additional iterator, vtkAdjacentVertexIterator can traverse
    outgoing vertices directly, instead needing to parse through edges.
    Initialize the iterator by calling graph->GetAdjacentVertices(v, it).
    
    vtkGraph has two instances of vtkDataSetAttributes for associated
    vertex and edge data. It also has a vtkPoints instance which may
    store x,y,z locations for each vertex. This is populated by filters
    such as vtkGraphLayout and vtkAssignCoordinates.
    
    All graph types share the same implementation, so the structure of
    one may be shared among multiple graphs, even graphs of different
    types. Structures from vtkUndirectedGraph and
    vtkMutableUndirectedGraph may be shared directly.  Structures from
    vtkDirectedGraph, vtkMutableDirectedGraph, and vtkTree may be shared
    directly with the exception that setting a structure to a tree
    requires that a "is a tree" test passes.
    
    For graph types that are known to be compatible, calling
    ShallowCopy() or DeepCopy() will work as expected.  When the outcome
    of a conversion is unknown (i.e. setting a graph to a tree),
    CheckedShallowCopy() and CheckedDeepCopy() exist which are identical
    to ShallowCopy() and DeepCopy(), except that instead of emitting an
    error for an incompatible structure, the function returns false. 
    This allows you to programmatically check structure compatibility
    without causing error messages.
    
    To construct a graph, use vtkMutableDirectedGraph or
    vtkMutableUndirectedGraph. You may then use CheckedShallowCopy to set
    the contents of a mutable graph type into one of the non-mutable
    types vtkDirectedGraph, vtkUndirectedGraph. To construct a tree, use
    vtkMutableDirectedGraph, with directed edges which point from the
    parent to the child, then use CheckedShallowCopy to set the structure
    to a vtkTree.
    
    @warning
    All copy operations implement copy-on-write. The structures are
    initially shared, but if one of the graphs is modified, the structure
    is copied so that to the user they function as if they were deep
    copied. This means that care must be taken if different threads are
    accessing different graph instances that share the same structure.
    Race conditions may develop if one thread is modifying the graph at
    the same time that another graph is copying the structure.
    
    @par Vertex pedigree IDs: The vertices in a vtkGraph can be
    associated with pedigree IDs through GetVertexData()->SetPedigreeIds.
    In this case, there is a 1-1 mapping between pedigree Ids and
    vertices. One can query the vertex ID based on the pedigree ID using
    FindVertex, add new vertices by pedigree ID with AddVertex, and add
    edges based on the pedigree IDs of the source and target vertices.
    For example, AddEdge("Here", "There") will find (or add) vertices
    with pedigree ID "Here" and "There" and then introduce an edge from
    "Here" to "There".
    
    @par Vertex pedigree IDs: To configure the vtkGraph with a pedigree
    ID mapping, create a vtkDataArray that will store the pedigree IDs
    and set that array as the pedigree ID array for the vertices via
    GetVertexData()->SetPedigreeIds().
    
    @par Distributed graphs: vtkGraph instances can be distributed across
    multiple machines, to allow the construction and manipulation of
    graphs larger than a single machine could handle. A distributed graph
    will typically be distributed across many different nodes within a
    cluster, using the Message Passing Interface (MPI) to allow those
    cluster nodes to communicate.
    
    @par Distributed graphs: An empty vtkGraph can be made into a
    distributed graph by attaching an instance of a
    vtkDistributedGraphHelper via the SetDistributedGraphHelper() method.
    To determine whether a graph is distributed or not, call
    GetDistributedGraphHelper() and check whether the result is
    non-nullptr. For a distributed graph, the number of processors across
    which the graph is distributed can be retrieved by extracting the
    value for the DATA_NUMBER_OF_PIECES key in the vtkInformation object
    (retrieved by GetInformation()) associated with the graph. Similarly,
    the value corresponding to the DATA_PIECE_NUMBER key of the
    vtkInformation object describes which piece of the data this graph
    instance provides.
    
    @par Distributed graphs: Distributed graphs behave somewhat
    differently from non-distributed graphs, and will require special
    care. In a distributed graph, each of the processors will contain a
    subset of the vertices in the graph. That subset of vertices can be
    accessed via the vtkVertexListIterator produced by GetVertices().
    GetNumberOfVertices(), therefore, returns the number of vertices
    stored locally: it does not account for vertices stored on other
    processors. A vertex (or edge) is identified by both the rank of its
    owning processor and by its index within that processor, both of
    which are encoded within the vtkIdType value that describes that
    vertex (or edge). The owning processor is a value between 0 and P-1,
    where P is the number of processors across which the vtkGraph has
    been distributed. The local index will be a value between 0 and
    GetNumberOfVertices(), for vertices, or GetNumberOfEdges(), for
    edges, and can be used to access the local parts of distributed data
    arrays. When given a vtkIdType identifying a vertex, one can
    determine the owner of the vertex with
    vtkDistributedGraphHelper::GetVertexOwner() and the local index with
    vtkDistributedGraphHelper::GetVertexIndex(). With edges, the
    appropriate methods are vtkDistributedGraphHelper::GetEdgeOwner() and
    vtkDistributedGraphHelper::GetEdgeIndex(), respectively. To construct
    a vtkIdType representing either a vertex or edge given only its owner
    and local index, use vtkDistributedGraphHelper::MakeDistributedId().
    
    @par Distributed graphs: The edges in a distributed graph are always
    stored on the processors that own the vertices named by the edge. For
    example, given a directed edge (u, v), the edge will be stored in the
    out-edges list for vertex u on the processor that owns u, and in the
    in-edges list for vertex v on the processor that owns v. This
    "row-wise" decomposition of the graph means that, for any vertex that
    is local to a processor, that processor can look at all of the
    incoming and outgoing edges of the graph. Processors cannot, however,
    access the incoming or outgoing edge lists of vertex owned by other
    processors. Vertices owned by other processors will not be
    encountered when traversing the vertex list via GetVertices(), but
    may be encountered by traversing the in- and out-edge lists of local
    vertices or the edge list.
    
    @par Distributed graphs: Distributed graphs can have pedigree IDs for
    the vertices in the same way that non-distributed graphs can. In this
    case, the distribution of the vertices in the graph is based on
    pedigree ID. For example, a vertex with the pedigree ID "Here" might
    land on processor 0 while a vertex pedigree ID "There" would end up
    on processor 3. By default, the pedigree IDs themselves are hashed to
    give a random (and, hopefully, even) distribution of the vertices.
    However, one can provide a different vertex distribution function by
    calling vtkDistributedGraphHelper::SetVertexPedigreeIdDistribution. 
    Once a distributed graph has pedigree IDs, the no-argument
    AddVertex() method can no longer be used. Additionally, once a vertex
    has a pedigree ID, that pedigree ID should not be changed unless the
    user can guarantee that the vertex distribution will still map that
    vertex to the same processor where it already resides.
    
    @sa
    vtkDirectedGraph vtkUndirectedGraph vtkMutableDirectedGraph
    vtkMutableUndirectedGraph vtkTree vtkDistributedGraphHelper
    
    @par Thanks: Thanks to Brian Wylie, Timothy Shead, Ken Moreland of
    Sandia National Laboratories and Douglas Gregor of Indiana University
    for designing these classes.
    """
    def AddEdgePoint(self, p_int, ):
        """
        V.AddEdgePoint(int, (float, float, float))
        C++: void AddEdgePoint(vtkIdType e, const double x[3])
        V.AddEdgePoint(int, float, float, float)
        C++: void AddEdgePoint(vtkIdType e, double x, double y, double z)
        
        Adds a point to the end of the list of edge points for a certain
        edge.
        """
        ...
    
    def CheckedDeepCopy(self, vtkGraph):
        """
        V.CheckedDeepCopy(vtkGraph) -> bool
        C++: virtual bool CheckedDeepCopy(vtkGraph *g)
        
        Performs the same operation as DeepCopy(), but instead of
        reporting an error for an incompatible graph, returns false.
        """
        ...
    
    def CheckedShallowCopy(self, vtkGraph):
        """
        V.CheckedShallowCopy(vtkGraph) -> bool
        C++: virtual bool CheckedShallowCopy(vtkGraph *g)
        
        Performs the same operation as ShallowCopy(), but instead of
        reporting an error for an incompatible graph, returns false.
        """
        ...
    
    def ClearEdgePoints(self, p_int):
        """
        V.ClearEdgePoints(int)
        C++: void ClearEdgePoints(vtkIdType e)
        
        Clear all points associated with an edge.
        """
        ...
    
    def ComputeBounds(self):
        """
        V.ComputeBounds()
        C++: void ComputeBounds()
        
        Compute the bounds of the graph. In a distributed graph, this
        computes the bounds around the local part of the graph.
        """
        ...
    
    def CopyStructure(self, vtkGraph):
        """
        V.CopyStructure(vtkGraph)
        C++: virtual void CopyStructure(vtkGraph *g)
        
        Does a shallow copy of the topological information, but not the
        associated attributes.
        """
        ...
    
    def DeepCopy(self, vtkDataObject):
        """
        V.DeepCopy(vtkDataObject)
        C++: void DeepCopy(vtkDataObject *obj) override;
        
        Deep copies the data object into this graph. If it is an
        incompatible graph, reports an error.
        """
        ...
    
    def DeepCopyEdgePoints(self, vtkGraph):
        """
        V.DeepCopyEdgePoints(vtkGraph)
        C++: void DeepCopyEdgePoints(vtkGraph *g)
        
        Copy the internal edge point data from another graph into this
        graph. Both graphs must have the same number of edges.
        """
        ...
    
    def Dump(self):
        """
        V.Dump()
        C++: void Dump()
        
        Dump the contents of the graph to standard output.
        """
        ...
    
    def FindVertex(self, vtkVariant):
        """
        V.FindVertex(vtkVariant) -> int
        C++: vtkIdType FindVertex(const vtkVariant &pedigreeID)
        
        Retrieve the vertex with the given pedigree ID. If successful,
        returns the ID of the vertex. Otherwise, either the vertex data
        does not have a pedigree ID array or there is no vertex with the
        given pedigree ID, so this function returns -1. If the graph is a
        distributed graph, this method will return the Distributed-ID of
        the vertex.
        """
        ...
    
    def GetActualMemorySize(self):
        """
        V.GetActualMemorySize() -> int
        C++: unsigned long GetActualMemorySize() override;
        
        Return the actual size of the data in kibibytes (1024 bytes).
        This number is valid only after the pipeline has updated. The
        memory size returned is guaranteed to be greater than or equal to
        the memory required to represent the data (e.g., extra space in
        arrays, etc. are not included in the return value).
        """
        ...
    
    def GetAdjacentVertices(self, p_int, vtkAdjacentVertexIterator):
        """
        V.GetAdjacentVertices(int, vtkAdjacentVertexIterator)
        C++: virtual void GetAdjacentVertices(vtkIdType v,
            vtkAdjacentVertexIterator *it)
        
        Initializes the adjacent vertex iterator to iterate over all
        outgoing vertices from vertex v.  For an undirected graph,
        returns all adjacent vertices. In a distributed graph, the vertex
        v must be local to this processor.
        """
        ...
    
    def GetAttributesAsFieldData(self, p_int):
        """
        V.GetAttributesAsFieldData(int) -> vtkFieldData
        C++: vtkFieldData *GetAttributesAsFieldData(int type) override;
        
        Returns the attributes of the data object as a vtkFieldData. This
        returns non-null values in all the same cases as GetAttributes,
        in addition to the case of FIELD, which will return the field
        data for any vtkDataObject subclass.
        """
        ...
    
    def GetBounds(self):
        """
        V.GetBounds() -> (float, ...)
        C++: double *GetBounds()
        V.GetBounds([float, float, float, float, float, float])
        C++: void GetBounds(double bounds[6])
        
        Return a pointer to the geometry bounding box in the form
        (xmin,xmax, ymin,ymax, zmin,zmax). In a distributed graph, this
        computes the bounds around the local part of the graph.
        """
        ...
    
    def GetData(self, vtkInformation):
        """
        V.GetData(vtkInformation) -> vtkGraph
        C++: static vtkGraph *GetData(vtkInformation *info)
        V.GetData(vtkInformationVector, int) -> vtkGraph
        C++: static vtkGraph *GetData(vtkInformationVector *v, int i=0)
        
        Retrieve a graph from an information vector.
        """
        ...
    
    def GetDataObjectType(self):
        """
        V.GetDataObjectType() -> int
        C++: int GetDataObjectType() override;
        
        Return what type of dataset this is.
        """
        ...
    
    def GetDegree(self, p_int):
        """
        V.GetDegree(int) -> int
        C++: virtual vtkIdType GetDegree(vtkIdType v)
        
        The total of all incoming and outgoing vertices for vertex v. For
        undirected graphs, this is simply the number of edges incident to
        v. In a distributed graph, the vertex v must be local to this
        processor.
        """
        ...
    
    def GetDistributedGraphHelper(self):
        """
        V.GetDistributedGraphHelper() -> vtkDistributedGraphHelper
        C++: vtkDistributedGraphHelper *GetDistributedGraphHelper()
        
        Retrieves the distributed graph helper for this graph
        """
        ...
    
    def GetEdgeData(self):
        """
        V.GetEdgeData() -> vtkDataSetAttributes
        C++: virtual vtkDataSetAttributes *GetEdgeData()
        
        Get the vertex or edge data.
        """
        ...
    
    def GetEdgeId(self, p_int, p_int_1):
        """
        V.GetEdgeId(int, int) -> int
        C++: vtkIdType GetEdgeId(vtkIdType a, vtkIdType b)
        
        Returns the Id of the edge between vertex a and vertex b. This is
        independent of directionality of the edge, that is, if edge A->B
        exists or if edge B->A exists, this function will return its Id.
        If multiple edges exist between a and b, here is no guarantee
        about which one will be returned. Returns -1 if no edge exists
        between a and b.
        """
        ...
    
    def GetEdgePoint(self, p_int, p_int_1):
        """
        V.GetEdgePoint(int, int) -> (float, float, float)
        C++: double *GetEdgePoint(vtkIdType e, vtkIdType i)
        
        Get the x,y,z location of a point along edge e.
        """
        ...
    
    def GetEdgePoints(self, p_int, p_int_1, *float):
        """
        V.GetEdgePoints(int, int, [float, ...])
        C++: void GetEdgePoints(vtkIdType e, vtkIdType &npts,
            double *&pts)
        
        Get/Set the internal edge control points associated with each
        edge. The size of the pts array is 3*npts, and holds the x,y,z
        location of each edge control point.
        """
        ...
    
    def GetEdges(self, vtkEdgeListIterator):
        """
        V.GetEdges(vtkEdgeListIterator)
        C++: virtual void GetEdges(vtkEdgeListIterator *it)
        
        Initializes the edge list iterator to iterate over all edges in
        the graph. Edges may not be traversed in order of increasing edge
        id. In a distributed graph, this returns edges that are stored
        locally.
        """
        ...
    
    def GetGraphInternals(self, bool):
        """
        V.GetGraphInternals(bool) -> vtkGraphInternals
        C++: vtkGraphInternals *GetGraphInternals(bool modifying)
        
        Returns the internal representation of the graph. If modifying is
        true, then the returned vtkGraphInternals object will be unique
        to this vtkGraph object.
        """
        ...
    
    def GetInDegree(self, p_int):
        """
        V.GetInDegree(int) -> int
        C++: virtual vtkIdType GetInDegree(vtkIdType v)
        
        The number of incoming edges to vertex v. For undirected graphs,
        returns the same as GetDegree(). In a distributed graph, the
        vertex v must be local to this processor.
        """
        ...
    
    def GetInducedEdges(self, vtkIdTypeArray, vtkIdTypeArray_1):
        """
        V.GetInducedEdges(vtkIdTypeArray, vtkIdTypeArray)
        C++: void GetInducedEdges(vtkIdTypeArray *verts,
            vtkIdTypeArray *edges)
        
        Fills a list of edge indices with the edges contained in the
        induced subgraph formed by the vertices in the vertex list.
        """
        ...
    
    def GetInEdge(self, p_int, p_int_1):
        """
        V.GetInEdge(int, int) -> vtkInEdgeType
        C++: virtual vtkInEdgeType GetInEdge(vtkIdType v, vtkIdType index)
        V.GetInEdge(int, int, vtkGraphEdge)
        C++: virtual void GetInEdge(vtkIdType v, vtkIdType index,
            vtkGraphEdge *e)
        
        Random-access method for retrieving incoming edges to vertex v.
        """
        ...
    
    def GetInEdges(self, p_int, vtkInEdgeIterator):
        """
        V.GetInEdges(int, vtkInEdgeIterator)
        C++: virtual void GetInEdges(vtkIdType v, vtkInEdgeIterator *it)
        
        Initializes the in edge iterator to iterate over all incoming
        edges to vertex v.  For an undirected graph, returns all incident
        edges. In a distributed graph, the vertex v must be local to this
        processor.
        """
        ...
    
    def GetMTime(self):
        """
        V.GetMTime() -> int
        C++: vtkMTimeType GetMTime() override;
        
        The modified time of the graph.
        """
        ...
    
    def GetNumberOfEdgePoints(self, p_int):
        """
        V.GetNumberOfEdgePoints(int) -> int
        C++: vtkIdType GetNumberOfEdgePoints(vtkIdType e)
        
        Get the number of edge points associated with an edge.
        """
        ...
    
    def GetNumberOfEdges(self):
        """
        V.GetNumberOfEdges() -> int
        C++: virtual vtkIdType GetNumberOfEdges()
        
        The number of edges in the graph. In a distributed graph, this
        returns the number of edges stored locally.
        """
        ...
    
    def GetNumberOfElements(self, p_int):
        """
        V.GetNumberOfElements(int) -> int
        C++: vtkIdType GetNumberOfElements(int type) override;
        
        Get the number of elements for a specific attribute type (VERTEX,
        EDGE, etc.).
        """
        ...
    
    def GetNumberOfGenerationsFromBase(self, string):
        """
        V.GetNumberOfGenerationsFromBase(string) -> int
        C++: vtkIdType GetNumberOfGenerationsFromBase(const char *type)
            override;
        
        Given a the name of a base class of this class type, return the
        distance of inheritance between this class type and the named
        class (how many generations of inheritance are there between this
        class and the named class). If the named class is not in this
        class's inheritance tree, return a negative value. Valid
        responses will always be nonnegative. This method works in
        combination with vtkTypeMacro found in vtkSetGet.h.
        """
        ...
    
    def GetNumberOfGenerationsFromBaseType(self, string):
        """
        V.GetNumberOfGenerationsFromBaseType(string) -> int
        C++: static vtkIdType GetNumberOfGenerationsFromBaseType(
            const char *type)
        
        Given a the name of a base class of this class type, return the
        distance of inheritance between this class type and the named
        class (how many generations of inheritance are there between this
        class and the named class). If the named class is not in this
        class's inheritance tree, return a negative value. Valid
        responses will always be nonnegative. This method works in
        combination with vtkTypeMacro found in vtkSetGet.h.
        """
        ...
    
    def GetNumberOfVertices(self):
        """
        V.GetNumberOfVertices() -> int
        C++: virtual vtkIdType GetNumberOfVertices()
        
        The number of vertices in the graph. In a distributed graph,
        returns the number of local vertices in the graph.
        """
        ...
    
    def GetOutDegree(self, p_int):
        """
        V.GetOutDegree(int) -> int
        C++: virtual vtkIdType GetOutDegree(vtkIdType v)
        
        The number of outgoing edges from vertex v. For undirected
        graphs, returns the same as GetDegree(). In a distributed graph,
        the vertex v must be local to this processor.
        """
        ...
    
    def GetOutEdge(self, p_int, p_int_1):
        """
        V.GetOutEdge(int, int) -> vtkOutEdgeType
        C++: virtual vtkOutEdgeType GetOutEdge(vtkIdType v,
            vtkIdType index)
        V.GetOutEdge(int, int, vtkGraphEdge)
        C++: virtual void GetOutEdge(vtkIdType v, vtkIdType index,
            vtkGraphEdge *e)
        
        Random-access method for retrieving outgoing edges from vertex v.
        """
        ...
    
    def GetOutEdges(self, p_int, vtkOutEdgeIterator):
        """
        V.GetOutEdges(int, vtkOutEdgeIterator)
        C++: virtual void GetOutEdges(vtkIdType v, vtkOutEdgeIterator *it)
        
        Initializes the out edge iterator to iterate over all outgoing
        edges of vertex v.  For an undirected graph, returns all incident
        edges. In a distributed graph, the vertex v must be local to this
        processor.
        """
        ...
    
    def GetPoint(self, p_int):
        """
        V.GetPoint(int) -> (float, ...)
        C++: double *GetPoint(vtkIdType ptId)
        V.GetPoint(int, [float, float, float])
        C++: void GetPoint(vtkIdType ptId, double x[3])
        
        These methods return the point (0,0,0) until the points structure
        is created, when it returns the actual point position. In a
        distributed graph, only the points for local vertices can be
        retrieved.
        """
        ...
    
    def GetPoints(self):
        """
        V.GetPoints() -> vtkPoints
        C++: vtkPoints *GetPoints()
        
        Returns the points array for this graph. If points is not yet
        constructed, generates and returns a new points array filled with
        (0,0,0) coordinates. In a distributed graph, only the points for
        local vertices can be retrieved or modified.
        """
        ...
    
    def GetSourceVertex(self, p_int):
        """
        V.GetSourceVertex(int) -> int
        C++: vtkIdType GetSourceVertex(vtkIdType e)
        
        Retrieve the source and target vertices for an edge id. NOTE: The
        first time this is called, the graph will build a mapping array
        from edge id to source/target that is the same size as the number
        of edges in the graph. If you have access to a vtkOutEdgeType,
        vtkInEdgeType, vtkEdgeType, or vtkGraphEdge, you should directly
        use these structures to look up the source or target instead of
        this method.
        """
        ...
    
    def GetTargetVertex(self, p_int):
        """
        V.GetTargetVertex(int) -> int
        C++: vtkIdType GetTargetVertex(vtkIdType e)
        
        Retrieve the source and target vertices for an edge id. NOTE: The
        first time this is called, the graph will build a mapping array
        from edge id to source/target that is the same size as the number
        of edges in the graph. If you have access to a vtkOutEdgeType,
        vtkInEdgeType, vtkEdgeType, or vtkGraphEdge, you should directly
        use these structures to look up the source or target instead of
        this method.
        """
        ...
    
    def GetVertexData(self):
        """
        V.GetVertexData() -> vtkDataSetAttributes
        C++: virtual vtkDataSetAttributes *GetVertexData()
        
        Get the vertex or edge data.
        """
        ...
    
    def GetVertices(self, vtkVertexListIterator):
        """
        V.GetVertices(vtkVertexListIterator)
        C++: virtual void GetVertices(vtkVertexListIterator *it)
        
        Initializes the vertex list iterator to iterate over all vertices
        in the graph. In a distributed graph, the iterator traverses all
        local vertices.
        """
        ...
    
    def Initialize(self):
        """
        V.Initialize()
        C++: void Initialize() override;
        
        Initialize to an empty graph.
        """
        ...
    
    def IsA(self, string):
        """
        V.IsA(string) -> int
        C++: vtkTypeBool IsA(const char *type) override;
        
        Return 1 if this class is the same type of (or a subclass of) the
        named class. Returns 0 otherwise. This method works in
        combination with vtkTypeMacro found in vtkSetGet.h.
        """
        ...
    
    def IsSameStructure(self, vtkGraph):
        """
        V.IsSameStructure(vtkGraph) -> bool
        C++: bool IsSameStructure(vtkGraph *other)
        
        Returns true if both graphs point to the same adjacency
        structure. Can be used to test the copy-on-write feature of the
        graph.
        """
        ...
    
    def IsTypeOf(self, string):
        """
        V.IsTypeOf(string) -> int
        C++: static vtkTypeBool IsTypeOf(const char *type)
        
        Return 1 if this class type is the same type of (or a subclass
        of) the named class. Returns 0 otherwise. This method works in
        combination with vtkTypeMacro found in vtkSetGet.h.
        """
        ...
    
    def NewInstance(self):
        """
        V.NewInstance() -> vtkGraph
        C++: vtkGraph *NewInstance()
        """
        ...
    
    def ReorderOutVertices(self, p_int, vtkIdTypeArray):
        """
        V.ReorderOutVertices(int, vtkIdTypeArray)
        C++: void ReorderOutVertices(vtkIdType v,
            vtkIdTypeArray *vertices)
        
        Reorder the outgoing vertices of a vertex. The vertex list must
        have the same elements as the current out edge list, just in a
        different order. This method does not change the topology of the
        graph. In a distributed graph, the vertex v must be local.
        """
        ...
    
    def SafeDownCast(self, vtkObjectBase):
        """
        V.SafeDownCast(vtkObjectBase) -> vtkGraph
        C++: static vtkGraph *SafeDownCast(vtkObjectBase *o)
        """
        ...
    
    def SetDistributedGraphHelper(self, vtkDistributedGraphHelper):
        """
        V.SetDistributedGraphHelper(vtkDistributedGraphHelper)
        C++: void SetDistributedGraphHelper(
            vtkDistributedGraphHelper *helper)
        
        Sets the distributed graph helper of this graph, turning it into
        a distributed graph. This operation can only be executed on an
        empty graph.
        """
        ...
    
    def SetEdgePoint(self, p_int, p_int_1, ):
        """
        V.SetEdgePoint(int, int, (float, float, float))
        C++: void SetEdgePoint(vtkIdType e, vtkIdType i,
            const double x[3])
        V.SetEdgePoint(int, int, float, float, float)
        C++: void SetEdgePoint(vtkIdType e, vtkIdType i, double x,
            double y, double z)
        
        Set an x,y,z location of a point along an edge. This assumes
        there is already a point at location i, and simply overwrites it.
        """
        ...
    
    def SetEdgePoints(self, p_int, p_int_1, float_tuple):
        """
        V.SetEdgePoints(int, int, (float, ...))
        C++: void SetEdgePoints(vtkIdType e, vtkIdType npts,
            const double pts[])
        
        Get/Set the internal edge control points associated with each
        edge. The size of the pts array is 3*npts, and holds the x,y,z
        location of each edge control point.
        """
        ...
    
    def SetPoints(self, vtkPoints):
        """
        V.SetPoints(vtkPoints)
        C++: virtual void SetPoints(vtkPoints *points)
        
        Returns the points array for this graph. If points is not yet
        constructed, generates and returns a new points array filled with
        (0,0,0) coordinates. In a distributed graph, only the points for
        local vertices can be retrieved or modified.
        """
        ...
    
    def ShallowCopy(self, vtkDataObject):
        """
        V.ShallowCopy(vtkDataObject)
        C++: void ShallowCopy(vtkDataObject *obj) override;
        
        Shallow copies the data object into this graph. If it is an
        incompatible graph, reports an error.
        """
        ...
    
    def ShallowCopyEdgePoints(self, vtkGraph):
        """
        V.ShallowCopyEdgePoints(vtkGraph)
        C++: void ShallowCopyEdgePoints(vtkGraph *g)
        
        Copy the internal edge point data from another graph into this
        graph. Both graphs must have the same number of edges.
        """
        ...
    
    def Squeeze(self):
        """
        V.Squeeze()
        C++: virtual void Squeeze()
        
        Reclaim unused memory.
        """
        ...
    
    def ToDirectedGraph(self, vtkDirectedGraph):
        """
        V.ToDirectedGraph(vtkDirectedGraph) -> bool
        C++: bool ToDirectedGraph(vtkDirectedGraph *g)
        
        Convert the graph to a directed graph.
        """
        ...
    
    def ToUndirectedGraph(self, vtkUndirectedGraph):
        """
        V.ToUndirectedGraph(vtkUndirectedGraph) -> bool
        C++: bool ToUndirectedGraph(vtkUndirectedGraph *g)
        
        Convert the graph to an undirected graph.
        """
        ...
    
    def __delattr__(self, *args, **kwargs):
        """ Implement delattr(self, name). """
        ...
    
    def __getattribute__(self, *args, **kwargs):
        """ Return getattr(self, name). """
        ...
    
    def __init__(self, *args, **kwargs) -> None:
        ...
    
    @staticmethod
    def __new__(*args, **kwargs):
        """ Create and return a new object.  See help(type) for accurate signature. """
        ...
    
    def __repr__(self, *args, **kwargs):
        """ Return repr(self). """
        ...
    
    def __setattr__(self, *args, **kwargs):
        """ Implement setattr(self, name, value). """
        ...
    
    def __str__(self, *args, **kwargs) -> str:
        """ Return str(self). """
        ...
    
    __this__ = ...
    __dict__ = ...
    __vtkname__ = ...


