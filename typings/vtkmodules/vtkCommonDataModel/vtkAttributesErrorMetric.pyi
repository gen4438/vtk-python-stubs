"""
This type stub file was generated by pyright.
"""

from .vtkGenericSubdivisionErrorMetric import vtkGenericSubdivisionErrorMetric

class vtkAttributesErrorMetric(vtkGenericSubdivisionErrorMetric):
    """
    vtkAttributesErrorMetric - Objects that compute attribute-based error
    during cell tessellation.
    
    Superclass: vtkGenericSubdivisionErrorMetric
    
    It is a concrete error metric, based on an attribute criterium: the
    variation of the active attribute/component value from a linear ramp
    
    @sa
    vtkGenericCellTessellator vtkGenericSubdivisionErrorMetric
    """
    def GetAbsoluteAttributeTolerance(self):
        """
        V.GetAbsoluteAttributeTolerance() -> float
        C++: virtual double GetAbsoluteAttributeTolerance()
        
        Absolute tolerance of the active scalar (attribute+component).
        Subdivision is required if the square distance between the real
        attribute at the mid point on the edge and the interpolated
        attribute is greater than AbsoluteAttributeTolerance. This is the
        attribute accuracy. 0.01 will give better result than 0.1.
        """
        ...
    
    def GetAttributeTolerance(self):
        """
        V.GetAttributeTolerance() -> float
        C++: virtual double GetAttributeTolerance()
        
        Relative tolerance of the active scalar (attribute+component).
        Subdivision is required if the square distance between the real
        attribute at the mid point on the edge and the interpolated
        attribute is greater than AttributeTolerance. This is the
        attribute accuracy. 0.01 will give better result than 0.1.
        """
        ...
    
    def GetError(self, *float, **kwargs):
        """
        V.GetError([float, ...], [float, ...], [float, ...], float)
            -> float
        C++: double GetError(double *leftPoint, double *midPoint,
            double *rightPoint, double alpha) override;
        
        Return the error at the mid-point. The type of error depends on
        the state of the concrete error metric. For instance, it can
        return an absolute or relative error metric. See
        RequiresEdgeSubdivision() for a description of the arguments.
        \pre leftPoint_exists: leftPoint!=0
        \pre midPoint_exists: midPoint!=0
        \pre rightPoint_exists: rightPoint!=0
        \pre clamped_alpha: alpha>0 && alpha<1
        \pre valid_size:
            sizeof(leftPoint)=sizeof(midPoint)=sizeof(rightPoint)
        =GetAttributeCollection()->GetNumberOfPointCenteredComponents()+6
        \post positive_result: result>=0
        """
        ...
    
    def GetNumberOfGenerationsFromBase(self, string):
        """
        V.GetNumberOfGenerationsFromBase(string) -> int
        C++: vtkIdType GetNumberOfGenerationsFromBase(const char *type)
            override;
        
        Standard VTK type and error macros.
        """
        ...
    
    def GetNumberOfGenerationsFromBaseType(self, string):
        """
        V.GetNumberOfGenerationsFromBaseType(string) -> int
        C++: static vtkIdType GetNumberOfGenerationsFromBaseType(
            const char *type)
        
        Standard VTK type and error macros.
        """
        ...
    
    def IsA(self, string):
        """
        V.IsA(string) -> int
        C++: vtkTypeBool IsA(const char *type) override;
        
        Standard VTK type and error macros.
        """
        ...
    
    def IsTypeOf(self, string):
        """
        V.IsTypeOf(string) -> int
        C++: static vtkTypeBool IsTypeOf(const char *type)
        
        Standard VTK type and error macros.
        """
        ...
    
    def NewInstance(self):
        """
        V.NewInstance() -> vtkAttributesErrorMetric
        C++: vtkAttributesErrorMetric *NewInstance()
        
        Standard VTK type and error macros.
        """
        ...
    
    def RequiresEdgeSubdivision(self, *float, **kwargs):
        """
        V.RequiresEdgeSubdivision([float, ...], [float, ...], [float,
            ...], float) -> int
        C++: int RequiresEdgeSubdivision(double *leftPoint,
            double *midPoint, double *rightPoint, double alpha) override;
        
        Does the edge need to be subdivided according to the distance
        between the value of the active attribute/component at the
        midpoint and the mean value between the endpoints? The edge is
        defined by its `leftPoint' and its `rightPoint'. `leftPoint',
        `midPoint' and `rightPoint' have to be initialized before calling
        RequiresEdgeSubdivision(). Their format is global coordinates,
        parametric coordinates and point centered attributes: xyx rst abc
        de... `alpha' is the normalized abscissa of the midpoint along
        the edge. (close to 0 means close to the left point, close to 1
        means close to the right point)
        \pre leftPoint_exists: leftPoint!=0
        \pre midPoint_exists: midPoint!=0
        \pre rightPoint_exists: rightPoint!=0
        \pre clamped_alpha: alpha>0 && alpha<1
        \pre valid_size:
            sizeof(leftPoint)=sizeof(midPoint)=sizeof(rightPoint)
        =GetAttributeCollection()->GetNumberOfPointCenteredComponents()+6
        """
        ...
    
    def SafeDownCast(self, vtkObjectBase):
        """
        V.SafeDownCast(vtkObjectBase) -> vtkAttributesErrorMetric
        C++: static vtkAttributesErrorMetric *SafeDownCast(
            vtkObjectBase *o)
        
        Standard VTK type and error macros.
        """
        ...
    
    def SetAbsoluteAttributeTolerance(self, p_float):
        """
        V.SetAbsoluteAttributeTolerance(float)
        C++: void SetAbsoluteAttributeTolerance(double value)
        
        Set the absolute attribute accuracy to `value'. See
        GetAbsoluteAttributeTolerance() for details. It is particularly
        useful when some concrete implementation of vtkGenericAttribute
        does not support GetRange() request, called internally in
        SetAttributeTolerance(). It may happen when the implementation
        support higher order attributes but cannot compute the range.
        \pre valid_range_value: value>0
        """
        ...
    
    def SetAttributeTolerance(self, p_float):
        """
        V.SetAttributeTolerance(float)
        C++: void SetAttributeTolerance(double value)
        
        Set the relative attribute accuracy to `value'. See
        GetAttributeTolerance() for details.
        \pre valid_range_value: value>0 && value<1
        """
        ...
    
    def __delattr__(self, *args, **kwargs):
        """ Implement delattr(self, name). """
        ...
    
    def __getattribute__(self, *args, **kwargs):
        """ Return getattr(self, name). """
        ...
    
    def __init__(self, *args, **kwargs) -> None:
        ...
    
    @staticmethod
    def __new__(*args, **kwargs):
        """ Create and return a new object.  See help(type) for accurate signature. """
        ...
    
    def __repr__(self, *args, **kwargs):
        """ Return repr(self). """
        ...
    
    def __setattr__(self, *args, **kwargs):
        """ Implement setattr(self, name, value). """
        ...
    
    def __str__(self, *args, **kwargs) -> str:
        """ Return str(self). """
        ...
    
    __this__ = ...
    __dict__ = ...
    __vtkname__ = ...


