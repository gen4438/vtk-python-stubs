"""
This type stub file was generated by pyright.
"""

import vtkmodules.vtkCommonCore as __vtkmodules_vtkCommonCore

class vtkCellIterator(__vtkmodules_vtkCommonCore.vtkObject):
    """
    vtkCellIterator - Efficient cell iterator for vtkDataSet topologies.
    
    Superclass: vtkObject
    
    vtkCellIterator provides a method for traversing cells in a data set.
    Call the vtkDataSet::NewCellIterator() method to use this class.
    
    The cell is represented as a set of three pieces of information: The
    cell type, the ids of the points constituting the cell, and the
    points themselves. This iterator fetches these as needed. If only the
    cell type is used, the type is not looked up until GetCellType is
    called, and the point information is left uninitialized. This allows
    efficient screening of cells, since expensive point lookups may be
    skipped depending on the cell type/etc.
    
    An example usage of this class: ~~~ void myWorkerFunction(vtkDataSet
    *ds) {
      vtkCellIterator *it = ds->NewCellIterator();
      for (it->InitTraversal(); !it->IsDoneWithTraversal();
    it->GoToNextCell())
        {
        if (it->GetCellType() != VTK_TETRA)
          {
          continue; // Skip non-tetrahedral cells
          }
    
    
        vtkIdList *pointIds = it->GetPointIds();
        // Do screening on the point ids, maybe figure out scalar range
    and skip
           cells that do not lie in a certain range?
    
    
        vtkPoints *points = it->GetPoints();
        // Do work using the cell points, or ...
    
    
        vtkGenericCell *cell = ...;
        it->GetCell(cell);
        // ... do work with a vtkCell.
        }
      it->Delete(); } ~~~
    
    The example above pulls in bits of information as needed to filter
    out cells that aren't relevant. The least expensive lookups are
    performed first (cell type, then point ids, then points/full cell) to
    prevent wasted cycles fetching unnecessary data. Also note that at
    the end of the loop, the iterator must be deleted as these iterators
    are vtkObject subclasses.
    """
    def GetCell(self, vtkGenericCell):
        """
        V.GetCell(vtkGenericCell)
        C++: void GetCell(vtkGenericCell *cell)
        
        Write the current full cell information into the argument. This
        is usually a very expensive call, and should be avoided when
        possible. This should only be called when IsDoneWithTraversal()
        returns false.
        """
        ...
    
    def GetCellDimension(self):
        """
        V.GetCellDimension() -> int
        C++: int GetCellDimension()
        
        Get the current cell dimension (0, 1, 2, or 3). This should only
        be called when IsDoneWithTraversal() returns false.
        """
        ...
    
    def GetCellId(self):
        """
        V.GetCellId() -> int
        C++: virtual vtkIdType GetCellId()
        
        Get the id of the current cell.
        """
        ...
    
    def GetCellType(self):
        """
        V.GetCellType() -> int
        C++: int GetCellType()
        
        Get the current cell type (e.g. VTK_LINE, VTK_VERTEX, VTK_TETRA,
        etc). This should only be called when IsDoneWithTraversal()
        returns false.
        """
        ...
    
    def GetFaces(self):
        """
        V.GetFaces() -> vtkIdList
        C++: vtkIdList *GetFaces()
        
        Get the faces for a polyhedral cell. This is only valid when
        CellType is VTK_POLYHEDRON.
        """
        ...
    
    def GetNumberOfFaces(self):
        """
        V.GetNumberOfFaces() -> int
        C++: vtkIdType GetNumberOfFaces()
        
        Return the number of faces in the current cell. This should only
        be called when IsDoneWithTraversal() returns false.
        """
        ...
    
    def GetNumberOfGenerationsFromBase(self, string):
        """
        V.GetNumberOfGenerationsFromBase(string) -> int
        C++: vtkIdType GetNumberOfGenerationsFromBase(const char *type)
            override;
        
        Given a the name of a base class of this class type, return the
        distance of inheritance between this class type and the named
        class (how many generations of inheritance are there between this
        class and the named class). If the named class is not in this
        class's inheritance tree, return a negative value. Valid
        responses will always be nonnegative. This method works in
        combination with vtkTypeMacro found in vtkSetGet.h.
        """
        ...
    
    def GetNumberOfGenerationsFromBaseType(self, string):
        """
        V.GetNumberOfGenerationsFromBaseType(string) -> int
        C++: static vtkIdType GetNumberOfGenerationsFromBaseType(
            const char *type)
        
        Given a the name of a base class of this class type, return the
        distance of inheritance between this class type and the named
        class (how many generations of inheritance are there between this
        class and the named class). If the named class is not in this
        class's inheritance tree, return a negative value. Valid
        responses will always be nonnegative. This method works in
        combination with vtkTypeMacro found in vtkSetGet.h.
        """
        ...
    
    def GetNumberOfPoints(self):
        """
        V.GetNumberOfPoints() -> int
        C++: vtkIdType GetNumberOfPoints()
        
        Return the number of points in the current cell. This should only
        be called when IsDoneWithTraversal() returns false.
        """
        ...
    
    def GetPointIds(self):
        """
        V.GetPointIds() -> vtkIdList
        C++: vtkIdList *GetPointIds()
        
        Get the ids of the points in the current cell. This should only
        be called when IsDoneWithTraversal() returns false.
        """
        ...
    
    def GetPoints(self):
        """
        V.GetPoints() -> vtkPoints
        C++: vtkPoints *GetPoints()
        
        Get the points in the current cell. This is usually a very
        expensive call, and should be avoided when possible. This should
        only be called when IsDoneWithTraversal() returns false.
        """
        ...
    
    def GoToNextCell(self):
        """
        V.GoToNextCell()
        C++: void GoToNextCell()
        
        Increment to next cell. Always safe to call.
        """
        ...
    
    def InitTraversal(self):
        """
        V.InitTraversal()
        C++: void InitTraversal()
        
        Reset to the first cell.
        """
        ...
    
    def IsA(self, string):
        """
        V.IsA(string) -> int
        C++: vtkTypeBool IsA(const char *type) override;
        
        Return 1 if this class is the same type of (or a subclass of) the
        named class. Returns 0 otherwise. This method works in
        combination with vtkTypeMacro found in vtkSetGet.h.
        """
        ...
    
    def IsDoneWithTraversal(self):
        """
        V.IsDoneWithTraversal() -> bool
        C++: virtual bool IsDoneWithTraversal()
        
        Returns false while the iterator is valid. Always safe to call.
        """
        ...
    
    def IsTypeOf(self, string):
        """
        V.IsTypeOf(string) -> int
        C++: static vtkTypeBool IsTypeOf(const char *type)
        
        Return 1 if this class type is the same type of (or a subclass
        of) the named class. Returns 0 otherwise. This method works in
        combination with vtkTypeMacro found in vtkSetGet.h.
        """
        ...
    
    def NewInstance(self):
        """
        V.NewInstance() -> vtkCellIterator
        C++: vtkCellIterator *NewInstance()
        """
        ...
    
    def SafeDownCast(self, vtkObjectBase):
        """
        V.SafeDownCast(vtkObjectBase) -> vtkCellIterator
        C++: static vtkCellIterator *SafeDownCast(vtkObjectBase *o)
        """
        ...
    
    def __delattr__(self, *args, **kwargs):
        """ Implement delattr(self, name). """
        ...
    
    def __getattribute__(self, *args, **kwargs):
        """ Return getattr(self, name). """
        ...
    
    def __init__(self, *args, **kwargs) -> None:
        ...
    
    @staticmethod
    def __new__(*args, **kwargs):
        """ Create and return a new object.  See help(type) for accurate signature. """
        ...
    
    def __repr__(self, *args, **kwargs):
        """ Return repr(self). """
        ...
    
    def __setattr__(self, *args, **kwargs):
        """ Implement setattr(self, name, value). """
        ...
    
    def __str__(self, *args, **kwargs) -> str:
        """ Return str(self). """
        ...
    
    __this__ = ...
    __dict__ = ...
    __vtkname__ = ...


