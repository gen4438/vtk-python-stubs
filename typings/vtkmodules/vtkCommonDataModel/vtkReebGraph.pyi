"""
This type stub file was generated by pyright.
"""

from .vtkMutableDirectedGraph import vtkMutableDirectedGraph

class vtkReebGraph(vtkMutableDirectedGraph):
    """
    vtkReebGraph - Reeb graph computation for PL scalar fields.
    
    Superclass: vtkMutableDirectedGraph
    
    vtkReebGraph is a class that computes a Reeb graph given a PL scalar
    field (vtkDataArray) defined on a simplicial mesh. A Reeb graph is a
    concise representation of the connectivity evolution of the level
    sets of a scalar function.
    
    It is particularly useful in visualization (optimal seed set
    computation, fast flexible isosurface extraction, automated transfer
    function design, feature-driven visualization, etc.) and computer
    graphics (shape deformation, shape matching, shape compression,
    etc.).
    
    Reference: "Sur les points singuliers d'une forme de Pfaff
    completement integrable ou d'une fonction numerique", G. Reeb,
    Comptes-rendus de l'Academie des Sciences, 222:847-849, 1946.
    
    vtkReebGraph implements one of the latest and most robust Reeb graph
    computation algorithms.
    
    Reference: "Robust on-line computation of Reeb graphs: simplicity and
    speed", V. Pascucci, G. Scorzelli, P.-T. Bremer, and A. Mascarenhas,
    ACM Transactions on Graphics, Proc. of SIGGRAPH 2007.
    
    vtkReebGraph provides methods for computing multi-resolution
    topological hierarchies through topological simplification.
    Topoligical simplification can be either driven by persistence
    homology concepts (default behavior) or by application specific
    metrics (see vtkReebGraphSimplificationMetric). In the latter case,
    designing customized simplification metric evaluation algorithms
    enables the user to control the definition of what should be
    considered as noise or signal in the topological filtering process.
    
    References: "Topological persistence and simplification", H.
    Edelsbrunner, D. Letscher, and A. Zomorodian, Discrete Computational
    Geometry, 28:511-533, 2002.
    
    "Extreme elevation on a 2-manifold", P.K. Agarwal, H. Edelsbrunner,
    J. Harer, and Y. Wang, ACM Symposium on Computational Geometry, pp.
    357-365, 2004.
    
    "Simplifying flexible isosurfaces using local geometric measures", H.
    Carr, J. Snoeyink, M van de Panne, IEEE Visualization, 497-504, 2004
    
    "Loop surgery for volumetric meshes: Reeb graphs reduced to contour
    trees", J. Tierny, A. Gyulassy, E. Simon, V. Pascucci, IEEE Trans. on
    Vis. and Comp. Graph. (Proc of IEEE VIS), 15:1177-1184, 2009.
    
    Reeb graphs can be computed from 2D data (vtkPolyData, with triangles
    only) or 3D data (vtkUnstructuredGrid, with tetrahedra only),
    sequentially (see the "Build" calls) or in streaming (see the
    "StreamTriangle" and "StreamTetrahedron" calls).
    
    vtkReebGraph inherits from vtkMutableDirectedGraph.
    
    Each vertex of a vtkReebGraph object represents a critical point of
    the scalar field where the connectivity of the related level set
    changes (creation, deletion, split or merge of connected components).
    A vtkIdTypeArray (called "Vertex Ids") is associated with the
    VertexData of a vtkReebGraph object, in order to retrieve if
    necessary the exact Ids of the corresponding vertices in the input
    mesh.
    
    The edges of a vtkReebGraph object represent the regions of the input
    mesh separated by the critical contours of the field, and where the
    connectivity of the input field does not change. A vtkVariantArray is
    associated with the EdgeDta of a vtkReebGraph object and each entry
    of this array is a vtkAbstractArray containing the Ids of the
    vertices of those regions, sorted by function value (useful for
    flexible isosurface extraction or level set signature computation,
    for instance).
    
    See Graphics/Testing/Cxx/TestReebGraph.cxx for examples of traversals
    and typical usages (customized simplification, skeletonization,
    contour spectra,
     etc.) of a vtkReebGraph object.
    
    @sa
         vtkReebGraphSimplificationMetric
         vtkPolyDataToReebGraphFilter
         vtkUnstructuredGridToReebGraphFilter
         vtkReebGraphSimplificationFilter
         vtkReebGraphSurfaceSkeletonFilter
         vtkReebGraphVolumeSkeletonFilter
         vtkAreaContourSpectrumFilter
         vtkVolumeContourSpectrumFilter
    
    @par Tests:
         Graphics/Testing/Cxx/TestReebGraph.cxx
    """
    def Build(self, vtkPolyData, vtkDataArray):
        """
        V.Build(vtkPolyData, vtkDataArray) -> int
        C++: int Build(vtkPolyData *mesh, vtkDataArray *scalarField)
        V.Build(vtkUnstructuredGrid, vtkDataArray) -> int
        C++: int Build(vtkUnstructuredGrid *mesh,
            vtkDataArray *scalarField)
        V.Build(vtkPolyData, int) -> int
        C++: int Build(vtkPolyData *mesh, vtkIdType scalarFieldId)
        V.Build(vtkUnstructuredGrid, int) -> int
        C++: int Build(vtkUnstructuredGrid *mesh, vtkIdType scalarFieldId)
        V.Build(vtkPolyData, string) -> int
        C++: int Build(vtkPolyData *mesh, const char *scalarFieldName)
        V.Build(vtkUnstructuredGrid, string) -> int
        C++: int Build(vtkUnstructuredGrid *mesh,
            const char *scalarFieldName)
        
        Build the Reeb graph of the field 'scalarField' defined on the
        surface mesh 'mesh'.
        
        * Returned values:
        
        * vtkReebGraph::ERR_INCORRECT_FIELD: 'scalarField' does not have
          as many
        * tuples as 'mesh' has vertices.
        
        * vtkReebGraph::ERR_NOT_A_SIMPLICIAL_MESH: the input mesh 'mesh'
          is not a
        * simplicial mesh (for example, the surface mesh contains quads
          instead of
        * triangles).
        """
        ...
    
    def CloseStream(self):
        """
        V.CloseStream()
        C++: void CloseStream()
        
        Finalize internal data structures, in the case of streaming
        computations (with StreamTriangle or StreamTetrahedron). After
        this call, no more triangle or tetrahedron can be inserted via
        StreamTriangle or StreamTetrahedron. IMPORTANT: This method
        _must_ be called when the input stream is finished. If you need
        to get a snapshot of the Reeb graph during the streaming process
        (to parse or simplify it), do a DeepCopy followed by a
        CloseStream on the copy.
        """
        ...
    
    def DeepCopy(self, vtkDataObject):
        """
        V.DeepCopy(vtkDataObject)
        C++: void DeepCopy(vtkDataObject *src) override;
        
        Implements deep copy
        """
        ...
    
    def GetDataObjectType(self):
        """
        V.GetDataObjectType() -> int
        C++: int GetDataObjectType() override;
        
        Return class name of data type. This is one of
        VTK_STRUCTURED_GRID, VTK_STRUCTURED_POINTS,
        VTK_UNSTRUCTURED_GRID, VTK_POLY_DATA, or VTK_RECTILINEAR_GRID
        (see vtkSetGet.h for definitions). THIS METHOD IS THREAD SAFE
        """
        ...
    
    def GetNumberOfGenerationsFromBase(self, string):
        """
        V.GetNumberOfGenerationsFromBase(string) -> int
        C++: vtkIdType GetNumberOfGenerationsFromBase(const char *type)
            override;
        
        Given a the name of a base class of this class type, return the
        distance of inheritance between this class type and the named
        class (how many generations of inheritance are there between this
        class and the named class). If the named class is not in this
        class's inheritance tree, return a negative value. Valid
        responses will always be nonnegative. This method works in
        combination with vtkTypeMacro found in vtkSetGet.h.
        """
        ...
    
    def GetNumberOfGenerationsFromBaseType(self, string):
        """
        V.GetNumberOfGenerationsFromBaseType(string) -> int
        C++: static vtkIdType GetNumberOfGenerationsFromBaseType(
            const char *type)
        
        Given a the name of a base class of this class type, return the
        distance of inheritance between this class type and the named
        class (how many generations of inheritance are there between this
        class and the named class). If the named class is not in this
        class's inheritance tree, return a negative value. Valid
        responses will always be nonnegative. This method works in
        combination with vtkTypeMacro found in vtkSetGet.h.
        """
        ...
    
    def IsA(self, string):
        """
        V.IsA(string) -> int
        C++: vtkTypeBool IsA(const char *type) override;
        
        Return 1 if this class is the same type of (or a subclass of) the
        named class. Returns 0 otherwise. This method works in
        combination with vtkTypeMacro found in vtkSetGet.h.
        """
        ...
    
    def IsTypeOf(self, string):
        """
        V.IsTypeOf(string) -> int
        C++: static vtkTypeBool IsTypeOf(const char *type)
        
        Return 1 if this class type is the same type of (or a subclass
        of) the named class. Returns 0 otherwise. This method works in
        combination with vtkTypeMacro found in vtkSetGet.h.
        """
        ...
    
    def NewInstance(self):
        """
        V.NewInstance() -> vtkReebGraph
        C++: vtkReebGraph *NewInstance()
        """
        ...
    
    def SafeDownCast(self, vtkObjectBase):
        """
        V.SafeDownCast(vtkObjectBase) -> vtkReebGraph
        C++: static vtkReebGraph *SafeDownCast(vtkObjectBase *o)
        """
        ...
    
    def Set(self, vtkMutableDirectedGraph):
        """
        V.Set(vtkMutableDirectedGraph)
        C++: void Set(vtkMutableDirectedGraph *g)
        
        Use a pre-defined Reeb graph (post-processing). Use with caution!
        """
        ...
    
    def Simplify(self, p_float, vtkReebGraphSimplificationMetric):
        """
        V.Simplify(float, vtkReebGraphSimplificationMetric) -> int
        C++: int Simplify(double simplificationThreshold,
            vtkReebGraphSimplificationMetric *simplificationMetric)
        
        Simplify the Reeb graph given a threshold
        'simplificationThreshold' (between 0 and 1).
        
        * This method is the core feature for Reeb graph multi-resolution
        hierarchy
        * construction.
        
        * Return the number of arcs that have been removed through the
          simplification
        * process.
        
        * 'simplificationThreshold' represents a "scale", under which
          each Reeb graph
        * feature is considered as noise. 'simplificationThreshold' is
          expressed as a
        * fraction of the scalar field overall span. It can vary from 0
        * (no simplification) to 1 (maximal simplification).
        
        * 'simplificationMetric' is an object in charge of evaluating the
        importance
        * of a Reeb graph arc at each step of the simplification process.
        * if 'simplificationMetric' is nullptr, the default strategy
          (persitence of the
        * scalar field) is used.
        * Customized simplification metric evaluation algorithm can be
          designed (see
        * vtkReebGraphSimplificationMetric), enabling the user to control
        the
        * definition of what should be considered as noise or signal.
        
        * References:
        
        * "Topological persistence and simplification",
        * H. Edelsbrunner, D. Letscher, and A. Zomorodian,
        * Discrete Computational Geometry, 28:511-533, 2002.
        
        * "Extreme elevation on a 2-manifold",
        * P.K. Agarwal, H. Edelsbrunner, J. Harer, and Y. Wang,
        * ACM Symposium on Computational Geometry, pp. 357-365, 2004.
        
        * "Simplifying flexible isosurfaces using local geometric
          measures",
        * H. Carr, J. Snoeyink, M van de Panne,
        * IEEE Visualization, 497-504, 2004
        
        * "Loop surgery for volumetric meshes: Reeb graphs reduced to contour
          trees",
        * J. Tierny, A. Gyulassy, E. Simon, V. Pascucci,
        * IEEE Trans. on Vis. and Comp. Graph. (Proc of IEEE VIS),
          15:1177-1184,2009.
        """
        ...
    
    def StreamTetrahedron(self, p_int, p_float, p_int_1, p_float_1, p_int_2, p_float_2, p_int_3, p_float_3):
        """
        V.StreamTetrahedron(int, float, int, float, int, float, int,
            float) -> int
        C++: int StreamTetrahedron(vtkIdType vertex0Id, double scalar0,
            vtkIdType vertex1Id, double scalar1, vtkIdType vertex2Id,
            double scalar2, vtkIdType vertex3Id, double scalar3)
        
        Streaming Reeb graph computation. Add to the streaming
        computation the tetrahedra of the vtkUnstructuredGrid volume mesh
        described by vertex0Id, scalar0 vertex1Id, scalar1 vertex2Id,
        scalar2 vertex3Id, scalar3
        
        * where vertexId is the Id of the vertex in the
          vtkUnstructuredGrid
        * structure and scalaris the corresponding scalar field value.
        
        * IMPORTANT: The stream _must_ be finalized with the
          "CloseStream" call.
        """
        ...
    
    def StreamTriangle(self, p_int, p_float, p_int_1, p_float_1, p_int_2, p_float_2):
        """
        V.StreamTriangle(int, float, int, float, int, float) -> int
        C++: int StreamTriangle(vtkIdType vertex0Id, double scalar0,
            vtkIdType vertex1Id, double scalar1, vtkIdType vertex2Id,
            double scalar2)
        
        Streaming Reeb graph computation. Add to the streaming
        computation the triangle of the vtkPolyData surface mesh
        described by vertex0Id, scalar0 vertex1Id, scalar1 vertex2Id,
        scalar2
        
        * where vertexId is the Id of the vertex in the vtkPolyData
          structure
        * and scalaris the corresponding scalar field value.
        
        * IMPORTANT: The stream _must_ be finalized with the
          "CloseStream" call.
        """
        ...
    
    def __delattr__(self, *args, **kwargs):
        """ Implement delattr(self, name). """
        ...
    
    def __getattribute__(self, *args, **kwargs):
        """ Return getattr(self, name). """
        ...
    
    def __init__(self, *args, **kwargs) -> None:
        ...
    
    @staticmethod
    def __new__(*args, **kwargs):
        """ Create and return a new object.  See help(type) for accurate signature. """
        ...
    
    def __repr__(self, *args, **kwargs):
        """ Return repr(self). """
        ...
    
    def __setattr__(self, *args, **kwargs):
        """ Implement setattr(self, name, value). """
        ...
    
    def __str__(self, *args, **kwargs) -> str:
        """ Return str(self). """
        ...
    
    __this__ = ...
    ERR_INCORRECT_FIELD = ...
    ERR_NOT_A_SIMPLICIAL_MESH = ...
    ERR_NO_SUCH_FIELD = ...
    __dict__ = ...
    __vtkname__ = ...


