"""
This type stub file was generated by pyright.
"""

from .vtkCell3D import vtkCell3D

class vtkTetra(vtkCell3D):
    """
    vtkTetra - a 3D cell that represents a tetrahedron
    
    Superclass: vtkCell3D
    
    vtkTetra is a concrete implementation of vtkCell to represent a 3D
    tetrahedron. vtkTetra uses the standard isoparametric shape functions
    for a linear tetrahedron. The tetrahedron is defined by the four
    points (0-3); where (0,1,2) is the base of the tetrahedron which,
    using the right hand rule, forms a triangle whose normal points in
    the direction of the fourth point.
    
    @sa
    vtkConvexPointSet vtkHexahedron vtkPyramid vtkVoxel vtkWedge
    """
    def BarycentricCoords(self, p_float=..., p_float=..., p_float=..., *args, **kwargs):
        """
        V.BarycentricCoords([float, float, float], [float, float, float],
            [float, float, float], [float, float, float], [float, float,
            float], [float, float, float, float]) -> int
        C++: static int BarycentricCoords(double x[3], double x1[3],
            double x2[3], double x3[3], double x4[3], double bcoords[4])
        
        Given a 3D point x[3], determine the barycentric coordinates of
        the point. Barycentric coordinates are a natural coordinate
        system for simplices that express a position as a linear
        combination of the vertices. For a tetrahedron, there are four
        barycentric coordinates (because there are four vertices), and
        the sum of the coordinates must equal 1. If a point x is inside a
        simplex, then all four coordinates will be strictly positive.  If
        three coordinates are zero (so the fourth =1), then the point x
        is on a vertex. If two coordinates are zero, the point x is on an
        edge (and so on). In this method, you must specify the vertex
        coordinates x1->x4. Returns 0 if tetrahedron is degenerate.
        """
        ...
    
    def CellBoundary(self, p_int, , vtkIdList):
        """
        V.CellBoundary(int, (float, float, float), vtkIdList) -> int
        C++: int CellBoundary(int subId, const double pcoords[3],
            vtkIdList *pts) override;
        
        Returns the set of points that are on the boundary of the
        tetrahedron that are closest parametrically to the point
        specified. This may include faces, edges, or vertices.
        """
        ...
    
    def Circumsphere(self, p_float=..., p_float=..., p_float=..., *args, **kwargs):
        """
        V.Circumsphere([float, float, float], [float, float, float],
            [float, float, float], [float, float, float], [float, float,
            float]) -> float
        C++: static double Circumsphere(double p1[3], double p2[3],
            double p3[3], double p4[3], double center[3])
        
        Compute the circumcenter (center[3]) and radius squared (method
        return value) of a tetrahedron defined by the four points x1, x2,
        x3, and x4.
        """
        ...
    
    def Clip(self, p_float, vtkDataArray, vtkIncrementalPointLocator, vtkCellArray, vtkPointData, vtkPointData_1, vtkCellData, p_int, vtkCellData_1, p_int_1):
        """
        V.Clip(float, vtkDataArray, vtkIncrementalPointLocator,
            vtkCellArray, vtkPointData, vtkPointData, vtkCellData, int,
            vtkCellData, int)
        C++: void Clip(double value, vtkDataArray *cellScalars,
            vtkIncrementalPointLocator *locator,
            vtkCellArray *connectivity, vtkPointData *inPd,
            vtkPointData *outPd, vtkCellData *inCd, vtkIdType cellId,
            vtkCellData *outCd, int insideOut) override;
        
        See the vtkCell API for descriptions of these methods.
        """
        ...
    
    def ComputeCentroid(self, vtkPoints, int_tuple, p_float=..., p_float=..., p_float=...):
        """
        V.ComputeCentroid(vtkPoints, (int, ...), [float, float, float])
            -> bool
        C++: static bool ComputeCentroid(vtkPoints *points,
            const vtkIdType *pointIds, double centroid[3])
        
        Static method version of GetCentroid.
        """
        ...
    
    def ComputeVolume(self, p_float=..., p_float=..., p_float=..., *args, **kwargs):
        """
        V.ComputeVolume([float, float, float], [float, float, float],
            [float, float, float], [float, float, float]) -> float
        C++: static double ComputeVolume(double p1[3], double p2[3],
            double p3[3], double p4[3])
        
        Compute the volume of a tetrahedron defined by the four points
        p1, p2, p3, and p4.
        """
        ...
    
    def Contour(self, p_float, vtkDataArray, vtkIncrementalPointLocator, vtkCellArray, vtkCellArray_1, vtkCellArray_2, vtkPointData, vtkPointData_1, vtkCellData, p_int, vtkCellData_1):
        """
        V.Contour(float, vtkDataArray, vtkIncrementalPointLocator,
            vtkCellArray, vtkCellArray, vtkCellArray, vtkPointData,
            vtkPointData, vtkCellData, int, vtkCellData)
        C++: void Contour(double value, vtkDataArray *cellScalars,
            vtkIncrementalPointLocator *locator, vtkCellArray *verts,
            vtkCellArray *lines, vtkCellArray *polys, vtkPointData *inPd,
            vtkPointData *outPd, vtkCellData *inCd, vtkIdType cellId,
            vtkCellData *outCd) override;
        
        See the vtkCell API for descriptions of these methods.
        """
        ...
    
    def Derivatives(self, p_int, , float_tuple, p_int_1, *float):
        """
        V.Derivatives(int, (float, float, float), (float, ...), int,
            [float, ...])
        C++: void Derivatives(int subId, const double pcoords[3],
            const double *values, int dim, double *derivs) override;
        
        See the vtkCell API for descriptions of these methods.
        """
        ...
    
    def EvaluateLocation(self, p_int, , p_float=..., p_float=..., p_float=..., *args, **kwargs):
        """
        V.EvaluateLocation(int, (float, float, float), [float, float,
            float], [float, ...])
        C++: void EvaluateLocation(int &subId, const double pcoords[3],
            double x[3], double *weights) override;
        
        See the vtkCell API for descriptions of these methods.
        """
        ...
    
    def EvaluatePosition(self, , p_float=..., p_float=..., p_float=..., *args, **kwargs):
        """
        V.EvaluatePosition((float, float, float), [float, float, float],
            int, [float, float, float], float, [float, ...]) -> int
        C++: int EvaluatePosition(const double x[3],
            double closestPoint[3], int &subId, double pcoords[3],
            double &dist2, double weights[]) override;
        
        See the vtkCell API for descriptions of these methods.
        """
        ...
    
    def GetCellType(self):
        """
        V.GetCellType() -> int
        C++: int GetCellType() override;
        
        See the vtkCell API for descriptions of these methods.
        """
        ...
    
    def GetCentroid(self, p_float=..., p_float=..., p_float=...):
        """
        V.GetCentroid([float, float, float]) -> bool
        C++: bool GetCentroid(double centroid[3]) override;
        
        Computes the centroid of the cell.
        """
        ...
    
    def GetEdge(self, p_int):
        """
        V.GetEdge(int) -> vtkCell
        C++: vtkCell *GetEdge(int edgeId) override;
        
        See the vtkCell API for descriptions of these methods.
        """
        ...
    
    def GetEdgeArray(self, p_int):
        """
        V.GetEdgeArray(int) -> (int, int)
        C++: static const vtkIdType *GetEdgeArray(vtkIdType edgeId)
        
        Return the ids of the vertices defining edge/face
        (`edgeId`/`faceId'). Ids are related to the cell, not to the
        dataset.
        
        ote The return type changed. It used to be int*, it is now const
        vtkIdType*. This is so ids are unified between vtkCell and
        vtkPoints, and so vtkCell ids can be used as inputs in algorithms
        such as vtkPolygon::ComputeNormal.
        """
        ...
    
    def GetEdgePoints(self, p_int, int_tuple):
        """
        V.GetEdgePoints(int, (int, ...))
        C++: void GetEdgePoints(vtkIdType edgeId, const vtkIdType *&pts)
            override;
        V.GetEdgePoints(int, [int, ...])
        C++: virtual void GetEdgePoints(int edgeId, int *&pts) override;
        
        See vtkCell3D API for description of these methods.
        """
        ...
    
    def GetEdgeToAdjacentFaces(self, p_int, int_tuple):
        """
        V.GetEdgeToAdjacentFaces(int, (int, ...))
        C++: void GetEdgeToAdjacentFaces(vtkIdType edgeId,
            const vtkIdType *&pts) override;
        
        Get the ids of the two adjacent faces to edge of id edgeId. The
        output face ids are sorted from id of lowest rank to highest.
        Note that the faces are 0-offset; that is, they refer to the ids
        of the cells, not the face ids of the mesh that the cell belongs
        to. The edgeId must range between
        0<=edgeId<this->GetNumberOfEdges().
        """
        ...
    
    def GetEdgeToAdjacentFacesArray(self, p_int):
        """
        V.GetEdgeToAdjacentFacesArray(int) -> (int, int)
        C++: static const vtkIdType *GetEdgeToAdjacentFacesArray(
            vtkIdType edgeId)
        
        Static method version of GetEdgeToAdjacentFaces.
        """
        ...
    
    def GetFace(self, p_int):
        """
        V.GetFace(int) -> vtkCell
        C++: vtkCell *GetFace(int faceId) override;
        
        See the vtkCell API for descriptions of these methods.
        """
        ...
    
    def GetFaceArray(self, p_int):
        """
        V.GetFaceArray(int) -> (int, int, int)
        C++: static const vtkIdType *GetFaceArray(vtkIdType faceId)
        
        Return the ids of the vertices defining edge/face
        (`edgeId`/`faceId'). Ids are related to the cell, not to the
        dataset.
        
        ote The return type changed. It used to be int*, it is now const
        vtkIdType*. This is so ids are unified between vtkCell and
        vtkPoints, and so vtkCell ids can be used as inputs in algorithms
        such as vtkPolygon::ComputeNormal.
        """
        ...
    
    def GetFacePoints(self, p_int, int_tuple):
        """
        V.GetFacePoints(int, (int, ...)) -> int
        C++: vtkIdType GetFacePoints(vtkIdType faceId,
            const vtkIdType *&pts) override;
        V.GetFacePoints(int, [int, ...])
        C++: virtual void GetFacePoints(int faceId, int *&pts) override;
        
        Get the list of vertices that define a face. The list is
        terminated with a negative number. Note that the vertices are
        0-offset; that is, they refer to the ids of the cell, not the
        point ids of the mesh that the cell belongs to. The faceId must
        range between 0<=faceId<this->GetNumberOfFaces().
        
        @return The number of points in face faceId
        """
        ...
    
    def GetFaceToAdjacentFaces(self, p_int, int_tuple):
        """
        V.GetFaceToAdjacentFaces(int, (int, ...)) -> int
        C++: vtkIdType GetFaceToAdjacentFaces(vtkIdType faceId,
            const vtkIdType *&faceIds) override;
        
        Get the ids of the adjacent faces to face of id faceId. The order
        of faces is consistent. They are always ordered in counter
        clockwise w.r.t. normal orientation. The first id faces[0]
        corresponds to the face sharing point of id pts[0] where pts is
        obtained from this->GetFacePoints(faceId, pts), being the "most counter
        clockwise" oriented w.r.t. face faceId. Note that the faces are
        0-offset; that is, they refer to the ids of the cell, not the
        face ids of the mesh that the cell belongs to. The faceId must be
        between 0<=faceId<this->GetNumberOfFaces();
        
        @warning If the vtkCell3D is "inside out", i.e. normals point
            inside the cell, the order is
        inverted.
        @return The number of adjacent faces to faceId.
        """
        ...
    
    def GetFaceToAdjacentFacesArray(self, p_int):
        """
        V.GetFaceToAdjacentFacesArray(int) -> (int, int, int)
        C++: static const vtkIdType *GetFaceToAdjacentFacesArray(
            vtkIdType faceId)
        
        Static method version of GetFaceToAdjacentFaces.
        """
        ...
    
    def GetNumberOfEdges(self):
        """
        V.GetNumberOfEdges() -> int
        C++: int GetNumberOfEdges() override;
        
        See the vtkCell API for descriptions of these methods.
        """
        ...
    
    def GetNumberOfFaces(self):
        """
        V.GetNumberOfFaces() -> int
        C++: int GetNumberOfFaces() override;
        
        See the vtkCell API for descriptions of these methods.
        """
        ...
    
    def GetNumberOfGenerationsFromBase(self, string):
        """
        V.GetNumberOfGenerationsFromBase(string) -> int
        C++: vtkIdType GetNumberOfGenerationsFromBase(const char *type)
            override;
        
        Given a the name of a base class of this class type, return the
        distance of inheritance between this class type and the named
        class (how many generations of inheritance are there between this
        class and the named class). If the named class is not in this
        class's inheritance tree, return a negative value. Valid
        responses will always be nonnegative. This method works in
        combination with vtkTypeMacro found in vtkSetGet.h.
        """
        ...
    
    def GetNumberOfGenerationsFromBaseType(self, string):
        """
        V.GetNumberOfGenerationsFromBaseType(string) -> int
        C++: static vtkIdType GetNumberOfGenerationsFromBaseType(
            const char *type)
        
        Given a the name of a base class of this class type, return the
        distance of inheritance between this class type and the named
        class (how many generations of inheritance are there between this
        class and the named class). If the named class is not in this
        class's inheritance tree, return a negative value. Valid
        responses will always be nonnegative. This method works in
        combination with vtkTypeMacro found in vtkSetGet.h.
        """
        ...
    
    def GetParametricCenter(self, p_float=..., p_float=..., p_float=...):
        """
        V.GetParametricCenter([float, float, float]) -> int
        C++: int GetParametricCenter(double pcoords[3]) override;
        
        Return the center of the tetrahedron in parametric coordinates.
        """
        ...
    
    def GetParametricCoords(self):
        """
        V.GetParametricCoords() -> (float, ...)
        C++: double *GetParametricCoords() override;
        
        See the vtkCell API for descriptions of these methods.
        """
        ...
    
    def GetParametricDistance(self, ):
        """
        V.GetParametricDistance((float, float, float)) -> float
        C++: double GetParametricDistance(const double pcoords[3])
            override;
        
        Return the distance of the parametric coordinate provided to the
        cell. If inside the cell, a distance of zero is returned.
        """
        ...
    
    def GetPointToIncidentEdges(self, p_int, int_tuple):
        """
        V.GetPointToIncidentEdges(int, (int, ...)) -> int
        C++: vtkIdType GetPointToIncidentEdges(vtkIdType pointId,
            const vtkIdType *&edgeIds) override;
        
        Get the ids of the incident edges to point of id pointId. Edges
        are sorted in counter clockwise order w.r.t. bisectrix pointing
        outside the cell at point of id pointId. The first edge
        corresponds to the edge containing point of id pts[0], where pts
        is obtained from this->GetPointToOnRingVertices(pointId, pts).
        Note that the edges are 0-offset; that is, they refer to the ids
        of the cell, not the edge ids of the mesh that the cell belongs
        to. The edgeId must be between
        0<=edgeId<this->GetNumberOfEdges();
        
        @warning If the vtkCell3D is "inside out", i.e. normals point
            inside the cell, the order is
        inverted.
        @return The valence of point pointId.
        """
        ...
    
    def GetPointToIncidentEdgesArray(self, p_int):
        """
        V.GetPointToIncidentEdgesArray(int) -> (int, int, int)
        C++: static const vtkIdType *GetPointToIncidentEdgesArray(
            vtkIdType pointId)
        
        Static method version of GetPointToIncidentEdgesArray.
        """
        ...
    
    def GetPointToIncidentFaces(self, p_int, int_tuple):
        """
        V.GetPointToIncidentFaces(int, (int, ...)) -> int
        C++: vtkIdType GetPointToIncidentFaces(vtkIdType pointId,
            const vtkIdType *&faceIds) override;
        
        Get the ids of the incident faces point of id pointId. Faces are
        sorted in counter clockwise order w.r.t. bisectrix pointing
        outside the cell at point of id pointId. The first face
        corresponds to the face containing edge of id edges[0], where
        edges is obtained from this->GetPointToIncidentEdges(pointId,
        edges), such that face faces[0] is the "most counterclockwise"
        face incident to point pointId containing edges[0]. Note that the
        faces are 0-offset; that is, they refer to the ids of the cell,
        not the face ids of the mesh that the cell belongs to. The
        pointId must be between 0<=pointId<this->GetNumberOfPoints().
        
        @warning If the vtkCell3D is "inside out", i.e. normals point
            inside the cell, the order is
        inverted.
        @return The valence of point pointId.
        """
        ...
    
    def GetPointToIncidentFacesArray(self, p_int):
        """
        V.GetPointToIncidentFacesArray(int) -> (int, int, int)
        C++: static const vtkIdType *GetPointToIncidentFacesArray(
            vtkIdType pointId)
        
        Static method version of GetPointToIncidentFacesArray.
        """
        ...
    
    def GetPointToOneRingPoints(self, p_int, int_tuple):
        """
        V.GetPointToOneRingPoints(int, (int, ...)) -> int
        C++: vtkIdType GetPointToOneRingPoints(vtkIdType pointId,
            const vtkIdType *&pts) override;
        
        Get the ids of a one-ring surrounding point of id pointId. Points
        are sorted in counter clockwise order w.r.t. bisectrix pointing
        outside the cell at point of id pointId. The first point
        corresponds to the point contained in edges[0], where edges is
        obtained from this->GetPointToIncidentEdges(pointId, edges). Note
        that the points are 0-offset; that is, they refer to the ids of
        the cell, not the point ids of the mesh that the cell belongs to.
        The pointId must be between 0<pointId<this->GetNumberOfPoints().
        @return The valence of point pointId.
        """
        ...
    
    def GetPointToOneRingPointsArray(self, p_int):
        """
        V.GetPointToOneRingPointsArray(int) -> (int, int, int)
        C++: static const vtkIdType *GetPointToOneRingPointsArray(
            vtkIdType pointId)
        
        Static method version of GetPointToOneRingPoints.
        """
        ...
    
    def GetTriangleCases(self, p_int):
        """
        V.GetTriangleCases(int) -> (int, ...)
        C++: static int *GetTriangleCases(int caseId)
        
        Return the case table for table-based isocontouring (aka marching
        cubes style implementations). A linear 3D cell with N vertices
        will have 2**N cases. The returned case array lists three edges
        in order to produce one output triangle which may be repeated to
        generate multiple triangles. The list of cases terminates with a
        -1 entry.
        """
        ...
    
    def Insphere(self, p_float=..., p_float=..., p_float=..., *args, **kwargs):
        """
        V.Insphere([float, float, float], [float, float, float], [float,
            float, float], [float, float, float], [float, float, float])
            -> float
        C++: static double Insphere(double p1[3], double p2[3],
            double p3[3], double p4[3], double center[3])
        
        Compute the center (center[3]) and radius (method return value)
        of a sphere that just fits inside the faces of a tetrahedron
        defined by the four points x1, x2, x3, and x4.
        """
        ...
    
    def InterpolateDerivs(self, , p_float=..., p_float=..., p_float=..., p_float=..., p_float=..., p_float=..., p_float=..., p_float=..., p_float=..., p_float=..., p_float=..., p_float=...):
        """
        V.InterpolateDerivs((float, float, float), [float, float, float,
            float, float, float, float, float, float, float, float,
            float])
        C++: void InterpolateDerivs(const double pcoords[3],
            double derivs[12]) override;
        
        Compute the interpolation functions/derivatives (aka shape
        functions/derivatives)
        """
        ...
    
    def InterpolateFunctions(self, , p_float=..., p_float=..., p_float=..., p_float=...):
        """
        V.InterpolateFunctions((float, float, float), [float, float,
            float, float])
        C++: void InterpolateFunctions(const double pcoords[3],
            double weights[4]) override;
        
        Compute the interpolation functions/derivatives (aka shape
        functions/derivatives)
        """
        ...
    
    def InterpolationDerivs(self, , p_float=..., p_float=..., p_float=..., p_float=..., p_float=..., p_float=..., p_float=..., p_float=..., p_float=..., p_float=..., p_float=..., p_float=...):
        """
        V.InterpolationDerivs((float, float, float), [float, float, float,
             float, float, float, float, float, float, float, float,
            float])
        C++: static void InterpolationDerivs(const double pcoords[3],
            double derivs[12])
        """
        ...
    
    def InterpolationFunctions(self, , p_float=..., p_float=..., p_float=..., p_float=...):
        """
        V.InterpolationFunctions((float, float, float), [float, float,
            float, float])
        C++: static void InterpolationFunctions(const double pcoords[3],
            double weights[4])
        """
        ...
    
    def IntersectWithLine(self, , , p_float_6, p_float_7, p_float=..., p_float=..., p_float=..., *args, **kwargs):
        """
        V.IntersectWithLine((float, float, float), (float, float, float),
            float, float, [float, float, float], [float, float, float],
            int) -> int
        C++: int IntersectWithLine(const double p1[3], const double p2[3],
             double tol, double &t, double x[3], double pcoords[3],
            int &subId) override;
        
        See the vtkCell API for descriptions of these methods.
        """
        ...
    
    def IsA(self, string):
        """
        V.IsA(string) -> int
        C++: vtkTypeBool IsA(const char *type) override;
        
        Return 1 if this class is the same type of (or a subclass of) the
        named class. Returns 0 otherwise. This method works in
        combination with vtkTypeMacro found in vtkSetGet.h.
        """
        ...
    
    def IsInsideOut(self):
        """
        V.IsInsideOut() -> bool
        C++: bool IsInsideOut() override;
        
        Returns true if the normals of the vtkCell3D point inside the
        cell.
        
        @warning This flag is not precomputed. It is advised for the
            return result of
        this method to be stored in a local boolean by the user if needed
        multiple times.
        """
        ...
    
    def IsTypeOf(self, string):
        """
        V.IsTypeOf(string) -> int
        C++: static vtkTypeBool IsTypeOf(const char *type)
        
        Return 1 if this class type is the same type of (or a subclass
        of) the named class. Returns 0 otherwise. This method works in
        combination with vtkTypeMacro found in vtkSetGet.h.
        """
        ...
    
    def NewInstance(self):
        """
        V.NewInstance() -> vtkTetra
        C++: vtkTetra *NewInstance()
        """
        ...
    
    def SafeDownCast(self, vtkObjectBase):
        """
        V.SafeDownCast(vtkObjectBase) -> vtkTetra
        C++: static vtkTetra *SafeDownCast(vtkObjectBase *o)
        """
        ...
    
    def TetraCenter(self, p_float=..., p_float=..., p_float=..., *args, **kwargs):
        """
        V.TetraCenter([float, float, float], [float, float, float],
            [float, float, float], [float, float, float], [float, float,
            float])
        C++: static void TetraCenter(double p1[3], double p2[3],
            double p3[3], double p4[3], double center[3])
        
        Compute the center of the tetrahedron,
        """
        ...
    
    def Triangulate(self, p_int, vtkIdList, vtkPoints):
        """
        V.Triangulate(int, vtkIdList, vtkPoints) -> int
        C++: int Triangulate(int index, vtkIdList *ptIds, vtkPoints *pts)
            override;
        
        See the vtkCell API for descriptions of these methods.
        """
        ...
    
    def __delattr__(self, *args, **kwargs):
        """ Implement delattr(self, name). """
        ...
    
    def __getattribute__(self, *args, **kwargs):
        """ Return getattr(self, name). """
        ...
    
    def __init__(self, *args, **kwargs) -> None:
        ...
    
    @staticmethod
    def __new__(*args, **kwargs):
        """ Create and return a new object.  See help(type) for accurate signature. """
        ...
    
    def __repr__(self, *args, **kwargs):
        """ Return repr(self). """
        ...
    
    def __setattr__(self, *args, **kwargs):
        """ Implement setattr(self, name, value). """
        ...
    
    def __str__(self, *args, **kwargs) -> str:
        """ Return str(self). """
        ...
    
    __this__ = ...
    __dict__ = ...
    __vtkname__ = ...


