"""
This type stub file was generated by pyright.
"""

import vtkmodules.vtkCommonCore as __vtkmodules_vtkCommonCore

class vtkHyperTree(__vtkmodules_vtkCommonCore.vtkObject):
    """
    vtkHyperTree - A data object structured as a tree.
    
    Superclass: vtkObject
    
    An hypertree grid is a dataobject containing a rectilinear grid of
    elements that can be either null or a hypertree. An hypertree is a
    dataobject describing a decomposition tree. A VERTICE is an element
    of this tree. A NODE, also called COARSE cell, is a specific vertice
    which is refined and than has either exactly f^d children, where f in
    {2,3} is the branching factor, the same value for all trees in this
    hypertree grid, and d in {1,2,3} is the spatial dimension. It is
    called coarse because there are smaller child cells. A LEAF, also
    called FINE cell, is a vertice without children, not refined. It is
    called fine because in the same space there are no finer cells. In a
    tree, we can find coarse cells smaller than fine cell but not in the
    same space.
    
    Such trees have particular names for f=2:
    - bintree (d=1),
    - quadtree (d=2),
    - octree (d=3).
    
    The original octree class name came from the following paper:
     @ARTICLE{yau-srihari-1983,
      author={Mann-May Yau and Sargur N. Srihari},
      title={A Hierarchical Data Structure for Multidimensional Digital Images},
      journal={Communications of the ACM},
      month={July},
      year={1983},
      volume={26},
      number={7},
      pages={504--515}
      }
     
    
    Attributes are associated with (all) cells, not with points. The
    attributes that are associated with coarses, it's used for LoD
    (Level-of-Detail). The attributes on coarse cells can be given by the
    code or/and computed by the use of a specifc filter exploiting the
    values from its children (which can be leaves or not).
    
    The geometry is implicitly given by the size of the root node on each
    axis and position of the origin. In fact, in 3D, the geometry is then
    not limited to a cube but can have a rectangular shape.
    
    By construction, an hypertree is efficient in memory usage. The LoD
    feature allows for quick culling of part of the dataobject.
    
    This is an abstract class used as a superclass by a custom templated
    compact class. Other versions of this code could be made available to
    meet other needs without questioning cursors and filters. All methods
    are pure virtual. This is done to hide templates.
    
    @par Case octree with f=2, d=3: For each node (coarse cell), 8
    children are encoded in a child index (from 0 to 7) in the following
    orientation described in hypertree grid. It is easy to access each
    child as a cell of a grid. Note also that the binary representation
    is relevant, each bit codes a side: bit 0 encodes -x side (0) or +x
    side (1) bit 1 encodes -y side (0) or +y side (1) bit 2 encodes -z
    side (0) or +z side (1)
    -z side is first, in counter-clockwise order: 0: -y -x sides 1: -y +x
    sides 2: +y -x sides 3: +y +x sides +z side is last, in
       counter-clockwise order: 4: -y -x sides 5: -y +x sides 6: +y -x
       sides 7: +y +x sides
                  +y
     +-+-+        ^
     |2|3|        |
     +-+-+  O +z  +-> +x
     |0|1|
     +-+-+
                  +y
     +-+-+        ^
     |6|7|        |
     +-+-+  1 +z  +-> +x
     |4|5|
     +-+-+
     
    
    @par Case quadtree with f=2, d=2: Just use 2 bits.
                  +y
     +-+-+        ^
     |2|3|        |
     +-+-+        +-> +x
     |0|1|
     +-+-+
     
    
    @par Case bintree with f=2, d=1: Just use 1 bits.
                 O+-> +x
     
    
    It's more difficult with f=3.
    
    @par Thanks: This class was written by Philippe Pebay, Joachim
    Pouderoux, and Charles Law, Kitware 2013 This class was modified by
    Guenole Harel and Jacques-Bernard Lekien 2014 This class was modified
    by Philippe Pebay, 2016 Among others, this class was simplified,
    optimized (memory), documented and completed for to improve IO XML by
    Jacques-Bernard Lekien 2018-19 This work was supported by
    Commissariat a l'Energie Atomique CEA, DAM, DIF, F-91297 Arpajon,
    France.
    """
    def CopyStructure(self, vtkHyperTree):
        """
        V.CopyStructure(vtkHyperTree)
        C++: void CopyStructure(vtkHyperTree *ht)
        
        Copy the structure by sharing the decomposition description of
        the tree.
        \pre ht_exist: ht!=nullptr
        """
        ...
    
    def CreateInstance(self, p_int, p_int_1):
        """
        V.CreateInstance(int, int) -> vtkHyperTree
        C++: static vtkHyperTree *CreateInstance(
            unsigned char branchFactor, unsigned char dimension)
        
        Return an instance of an implementation of a hypertree for given
        branch factor and dimension. Other versions of this code could be
        made available to meet other needs without questioning cursors
        and filters. Since an instance, an other instance can be creating
        by call the method Freeze (by default, nothing more, instance
        currently is returning).
        """
        ...
    
    def Freeze(self, string):
        """
        V.Freeze(string) -> vtkHyperTree
        C++: virtual vtkHyperTree *Freeze(const char *mode)
        
        Return a freeze instance (a priori compact but potentially
        unmodifiable). This method is calling by the Squeeze method of
        hypertree grid. The mode parameter will allow to propose
        different instances. Today, there is none, the freeze call does
        not do anything.
        """
        ...
    
    def GetActualMemorySize(self):
        """
        V.GetActualMemorySize() -> int
        C++: unsigned int GetActualMemorySize()
        
        Return memory used in kibibytes (1024 bytes). NB: Ignore the
        attribute array because its size is added by the data set.
        """
        ...
    
    def GetActualMemorySizeBytes(self):
        """
        V.GetActualMemorySizeBytes() -> int
        C++: virtual unsigned long GetActualMemorySizeBytes()
        
        Return memory used in bytes. NB: Ignore the attribute array
        because its size is added by the data set.
        """
        ...
    
    def GetBranchFactor(self):
        """
        V.GetBranchFactor() -> int
        C++: int GetBranchFactor()
        
        Return the branch factor of the tree.
        """
        ...
    
    def GetByLevelForWriter(self, vtkBitArray, vtkUnsignedLongArray, vtkBitArray_1, vtkBitArray_2, vtkIdList):
        """
        V.GetByLevelForWriter(vtkBitArray, vtkUnsignedLongArray,
            vtkBitArray, vtkBitArray, vtkIdList)
        C++: virtual void GetByLevelForWriter(vtkBitArray *inIsMasked,
            vtkUnsignedLongArray *nbVerticesbyLevel,
            vtkBitArray *isParent, vtkBitArray *isMasked, vtkIdList *ids)
        
        Initialize a state from write data. Call after create the
        hypertree grid.
        
        @param inIsMasked: the mask of hypertree grid including
        this hypertree which is a vtkBitArray.
        @param nbVerticesbyLevel: the number of vertices in tree
        (coarse and leaves) by each level.
        @param isParent: modify the vtkBitArray, a binary decomposition
        tree by level with constraint all describe children. It is
        useless to declare all the lastest values to False, especially
        the last level may not be defined.
        @param isMasked: modify the vtkBitArray, a binary mask
        corresponding. It is useless to declare all the latest values to
        False.
        """
        ...
    
    def GetDimension(self):
        """
        V.GetDimension() -> int
        C++: int GetDimension()
        
        Return the spatial dimension of the tree.
        """
        ...
    
    def GetElderChildIndex(self, p_int):
        """
        V.GetElderChildIndex(int) -> int
        C++: virtual vtkIdType GetElderChildIndex(
            unsigned int index_parent)
        
        Return the elder child index, local index node of first child, of
        node, coarse cell, identified by index_parent.
        \pre not_valid_index_parent
        Public only for entry: vtkHyperTreeGridEntry,
        vtkHyperTreeGridGeometryEntry, vtkHyperTreeGridGeometryLevelEntry
        """
        ...
    
    def GetGlobalIndexFromLocal(self, p_int):
        """
        V.GetGlobalIndexFromLocal(int) -> int
        C++: virtual vtkIdType GetGlobalIndexFromLocal(vtkIdType index)
        
        Get the global id of a local node identified by index. Use the
        explicit mapping function if available or the implicit mapping
        build with start global index.
        \pre not_valid_index
        \pre not_positive_start_index (case implicit global index
            mapping)
        \pre not_positive_global_index (case explicit global index
            mapping)
        """
        ...
    
    def GetGlobalIndexStart(self):
        """
        V.GetGlobalIndexStart() -> int
        C++: vtkIdType GetGlobalIndexStart()
        
        Get the start global index for the current tree for implicit
        global index mapping.
        """
        ...
    
    def GetGlobalNodeIndexMax(self):
        """
        V.GetGlobalNodeIndexMax() -> int
        C++: virtual vtkIdType GetGlobalNodeIndexMax()
        
        Return the maximum value reached by global index mapping
        (implicit or explicit).
        """
        ...
    
    def GetNumberOfChildren(self):
        """
        V.GetNumberOfChildren() -> int
        C++: vtkIdType GetNumberOfChildren()
        
        Return the number of children per node of the tree. This value is
        branchfactoring scale spatial dimenion (f^d).
        """
        ...
    
    def GetNumberOfGenerationsFromBase(self, string):
        """
        V.GetNumberOfGenerationsFromBase(string) -> int
        C++: vtkIdType GetNumberOfGenerationsFromBase(const char *type)
            override;
        
        Given a the name of a base class of this class type, return the
        distance of inheritance between this class type and the named
        class (how many generations of inheritance are there between this
        class and the named class). If the named class is not in this
        class's inheritance tree, return a negative value. Valid
        responses will always be nonnegative. This method works in
        combination with vtkTypeMacro found in vtkSetGet.h.
        """
        ...
    
    def GetNumberOfGenerationsFromBaseType(self, string):
        """
        V.GetNumberOfGenerationsFromBaseType(string) -> int
        C++: static vtkIdType GetNumberOfGenerationsFromBaseType(
            const char *type)
        
        Given a the name of a base class of this class type, return the
        distance of inheritance between this class type and the named
        class (how many generations of inheritance are there between this
        class and the named class). If the named class is not in this
        class's inheritance tree, return a negative value. Valid
        responses will always be nonnegative. This method works in
        combination with vtkTypeMacro found in vtkSetGet.h.
        """
        ...
    
    def GetNumberOfLeaves(self):
        """
        V.GetNumberOfLeaves() -> int
        C++: vtkIdType GetNumberOfLeaves()
        
        Return the number of leaf (fine) in the tree.
        """
        ...
    
    def GetNumberOfLevels(self):
        """
        V.GetNumberOfLevels() -> int
        C++: unsigned int GetNumberOfLevels()
        
        Return the number of levels.
        """
        ...
    
    def GetNumberOfNodes(self):
        """
        V.GetNumberOfNodes() -> int
        C++: vtkIdType GetNumberOfNodes()
        
        Return the number of nodes (coarse) in the tree.
        """
        ...
    
    def GetNumberOfVertices(self):
        """
        V.GetNumberOfVertices() -> int
        C++: vtkIdType GetNumberOfVertices()
        
        Return the number of all vertices (coarse and fine) in the tree.
        """
        ...
    
    def GetScale(self, p_float=..., p_float=..., p_float=...):
        """
        V.GetScale([float, float, float])
        C++: void GetScale(double s[3])
        V.GetScale(int) -> float
        C++: double GetScale(unsigned int d)
        
        Set/Get scale of the tree in each direction for the ground level
        (0).
        """
        ...
    
    def GetTreeIndex(self):
        """
        V.GetTreeIndex() -> int
        C++: vtkIdType GetTreeIndex()
        
        Set/Get tree index in hypertree grid. Services for internal use
        between hypertree grid and hypertree.
        """
        ...
    
    def HasScales(self):
        """
        V.HasScales() -> bool
        C++: bool HasScales()
        
        Return the existence scales.
        """
        ...
    
    def Initialize(self, p_int, p_int_1, p_int_2):
        """
        V.Initialize(int, int, int)
        C++: void Initialize(unsigned char, unsigned char, unsigned char)
        
        Restore the initial state: only one vertice is then a leaf: the
        root cell for the hypertree.
        @param branchFactor
        @param dimension
        @param numberOfChildren
        """
        ...
    
    def InitializeForReader(self, p_int, p_int_1, p_int_2, vtkBitArray, vtkBitArray_1, vtkBitArray_2):
        """
        V.InitializeForReader(int, int, int, vtkBitArray, vtkBitArray,
            vtkBitArray)
        C++: virtual void InitializeForReader(vtkIdType numberOfLevels,
            vtkIdType nbVertices, vtkIdType nbVerticesOfLastLevel,
            vtkBitArray *isParent, vtkBitArray *isMasked,
            vtkBitArray *outIsMasked)
        
        Restore a state from read data, without using a cursor Call after
        create hypertree with initialize.
        
        @param numberOfLevels: the maximum number of levels.
        @param nbVertices: the number of vertices of the future tree
        (coarse and leaves), fixed either the information loading (for
        load reduction) or defined by the fixed level of reader.
        @param nbVerticesOfLastLevel: the number of vertices of last
        valid level.
        @param isParent: a binary decomposition tree by level with
        constraint all describe children. It is useless to declare all
        the lastest values to False, especially the last level may not be
        defined.
        @param isMasked: a binary mask corresponding. It is useless
        to declare all the latest values to False.
        @param outIsMasked: the mask of hypertree grid including
        this hypertree which is a vtkBitArray.
        """
        ...
    
    def IsA(self, string):
        """
        V.IsA(string) -> int
        C++: vtkTypeBool IsA(const char *type) override;
        
        Return 1 if this class is the same type of (or a subclass of) the
        named class. Returns 0 otherwise. This method works in
        combination with vtkTypeMacro found in vtkSetGet.h.
        """
        ...
    
    def IsGlobalIndexImplicit(self):
        """
        V.IsGlobalIndexImplicit() -> bool
        C++: virtual bool IsGlobalIndexImplicit()
        
        Return if implicit global index maping has been used. If true,
        the initialize has been done by SetGlobalIndexStart (one call by
        hypertree). If false, the initialize has been done by
        SetGlobalIndexFromLocal (one call by cell of hypertree).
        GetGlobalIndexFromLocel get the good value of global index
        mapping for one cell what ever the initialize metho used.
        """
        ...
    
    def IsLeaf(self, p_int):
        """
        V.IsLeaf(int) -> bool
        C++: virtual bool IsLeaf(vtkIdType index)
        
        Return if a vertice identified by index in tree as being leaf.
        \pre not_valid_index
        """
        ...
    
    def IsTerminalNode(self, p_int):
        """
        V.IsTerminalNode(int) -> bool
        C++: virtual bool IsTerminalNode(vtkIdType index)
        
        Return if a vertice identified by index in tree as a terminal
        node. For this, all childrens mus be all leaves.
        \pre not_valid_index
        \pre not_valid_child_index
        """
        ...
    
    def IsTypeOf(self, string):
        """
        V.IsTypeOf(string) -> int
        C++: static vtkTypeBool IsTypeOf(const char *type)
        
        Return 1 if this class type is the same type of (or a subclass
        of) the named class. Returns 0 otherwise. This method works in
        combination with vtkTypeMacro found in vtkSetGet.h.
        """
        ...
    
    def NewInstance(self):
        """
        V.NewInstance() -> vtkHyperTree
        C++: vtkHyperTree *NewInstance()
        """
        ...
    
    def SafeDownCast(self, vtkObjectBase):
        """
        V.SafeDownCast(vtkObjectBase) -> vtkHyperTree
        C++: static vtkHyperTree *SafeDownCast(vtkObjectBase *o)
        """
        ...
    
    def SetGlobalIndexFromLocal(self, p_int, p_int_1):
        """
        V.SetGlobalIndexFromLocal(int, int)
        C++: virtual void SetGlobalIndexFromLocal(vtkIdType index,
            vtkIdType global)
        
        Set the mapping between a node index in tree and a explicit
        global index mapping. This global index mapping permits to access
        a value of field for a cell, in explicit, the index depend of
        order values. For this tree, in debug, assert is calling if tried
        call SetGlobalIndexStart.
        \pre not_global_index_from_local_if_use_global_index_start
        """
        ...
    
    def SetGlobalIndexStart(self, p_int):
        """
        V.SetGlobalIndexStart(int)
        C++: virtual void SetGlobalIndexStart(vtkIdType start)
        
        Set the start implicit global index mapping for the first cell in
        the current tree. The implicit global index mapping of a node
        will be computed by this start index + the node index (local
        offset in tree). The node index begin by 0, the origin cell in
        tree. The follow values are organizing by fatrie as i to
        i+NumberOfChildren, for all children of one coarse cell, i is
        1+8*s with s in integer. The order of fatrie depend of order to
        call SubdivideLeaf. This global index mapping permits to access a
        value of field for a cell, in implicit, the order values depends
        of implicit order linking with the order build of this tree.
        WARNING: See of hypertree grid, for to use a implicit global
        index mapping, you have to build hypertree by hypertree without
        to recome in hypertree also build. For this tree, in debug,
        assert is calling if tried call SetGlobalIndexFromLocal.
        \pre not_global_index_start_if_use_global_index_from_local
        """
        ...
    
    def SetTreeIndex(self, p_int):
        """
        V.SetTreeIndex(int)
        C++: void SetTreeIndex(vtkIdType treeIndex)
        
        Set/Get tree index in hypertree grid. Services for internal use
        between hypertree grid and hypertree.
        """
        ...
    
    def SubdivideLeaf(self, p_int, p_int_1):
        """
        V.SubdivideLeaf(int, int)
        C++: virtual void SubdivideLeaf(vtkIdType index,
            unsigned int level)
        
        Subdivide a vertice, only if its a leaf.
        \pre not_valide_index
        \pre not_leaf
        """
        ...
    
    def __delattr__(self, *args, **kwargs):
        """ Implement delattr(self, name). """
        ...
    
    def __getattribute__(self, *args, **kwargs):
        """ Return getattr(self, name). """
        ...
    
    def __init__(self, *args, **kwargs) -> None:
        ...
    
    @staticmethod
    def __new__(*args, **kwargs):
        """ Create and return a new object.  See help(type) for accurate signature. """
        ...
    
    def __repr__(self, *args, **kwargs):
        """ Return repr(self). """
        ...
    
    def __setattr__(self, *args, **kwargs):
        """ Implement setattr(self, name, value). """
        ...
    
    def __str__(self, *args, **kwargs) -> str:
        """ Return str(self). """
        ...
    
    __this__ = ...
    __dict__ = ...
    __vtkname__ = ...


