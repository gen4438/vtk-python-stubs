"""
This type stub file was generated by pyright.
"""

from .vtkAbstractCellLocator import vtkAbstractCellLocator

class vtkCellLocator(vtkAbstractCellLocator):
    """
    vtkCellLocator - octree-based spatial search object to quickly locate
    cells
    
    Superclass: vtkAbstractCellLocator
    
    vtkCellLocator is a spatial search object to quickly locate cells in
    3D. vtkCellLocator uses a uniform-level octree subdivision, where
    each octant (an octant is also referred to as a bucket) carries an
    indication of whether it is empty or not, and each leaf octant
    carries a list of the cells inside of it. (An octant is not empty if
    it has one or more cells inside of it.)  Typical operations are
    intersection with a line to return candidate cells, or intersection
    with another vtkCellLocator to return candidate cells.
    
    @warning
    Many other types of spatial locators have been developed, such as
    variable depth octrees and kd-trees. These are often more efficient
    for the operations described here. vtkCellLocator has been designed
    for subclassing; so these locators can be derived if necessary.
    
    @warning
    Most of the methods of this class are not thread-safe. For a
    thread-safe, more efficient generic implementation, please use
    vtkStaticCellLocator
    
    @sa
    vtkLocator vtkPointLocator vtkOBBTree vtkStaticCellLocator
    """
    def BuildLocator(self):
        """
        V.BuildLocator()
        C++: void BuildLocator() override;
        
        Satisfy vtkLocator abstract interface.
        """
        ...
    
    def BuildLocatorIfNeeded(self):
        """
        V.BuildLocatorIfNeeded()
        C++: virtual void BuildLocatorIfNeeded()
        
        Satisfy vtkLocator abstract interface.
        """
        ...
    
    def BuildLocatorInternal(self):
        """
        V.BuildLocatorInternal()
        C++: virtual void BuildLocatorInternal()
        
        Satisfy vtkLocator abstract interface.
        """
        ...
    
    def FindCell(self, p_float=..., p_float=..., p_float=..., *args, **kwargs):
        """
        V.FindCell([float, float, float], float, vtkGenericCell, [float,
            float, float], [float, ...]) -> int
        C++: vtkIdType FindCell(double x[3], double tol2,
            vtkGenericCell *GenCell, double pcoords[3], double *weights)
            override;
        V.FindCell([float, float, float]) -> int
        C++: virtual vtkIdType FindCell(double x[3])
        
        Find the cell containing a given point. returns -1 if no cell
        found the cell parameters are copied into the supplied variables,
        a cell must be provided to store the information.
        """
        ...
    
    def FindCellsAlongLine(self, , , p_float_6, vtkIdList):
        """
        V.FindCellsAlongLine((float, float, float), (float, float, float),
             float, vtkIdList)
        C++: void FindCellsAlongLine(const double p1[3],
            const double p2[3], double tolerance, vtkIdList *cells)
            override;
        
        Given a finite line defined by the two points (p1,p2), return the
        list of unique cell ids in the buckets containing the line. It is
        possible that an empty cell list is returned. The user must
        provide the vtkIdList to populate. This method returns data only
        after the locator has been built. THIS METHOD IS NOT THREAD SAFE.
        """
        ...
    
    def FindCellsWithinBounds(self, *float, **kwargs):
        """
        V.FindCellsWithinBounds([float, ...], vtkIdList)
        C++: void FindCellsWithinBounds(double *bbox, vtkIdList *cells)
            override;
        
        Return a list of unique cell ids inside of a given bounding box.
        The user must provide the vtkIdList to populate. This method
        returns data only after the locator has been built.
        """
        ...
    
    def FindClosestPoint(self, , p_float=..., p_float=..., p_float=..., *args, **kwargs):
        """
        V.FindClosestPoint((float, float, float), [float, float, float],
            vtkGenericCell, int, int, float)
        C++: void FindClosestPoint(const double x[3],
            double closestPoint[3], vtkGenericCell *cell,
            vtkIdType &cellId, int &subId, double &dist2) override;
        V.FindClosestPoint((float, float, float), [float, float, float],
            int, int, float)
        C++: virtual void FindClosestPoint(const double x[3],
            double closestPoint[3], vtkIdType &cellId, int &subId,
            double &dist2)
        
        Return the closest point and the cell which is closest to the
        point x. The closest point is somewhere on a cell, it need not be
        one of the vertices of the cell.  This version takes in a
        vtkGenericCell to avoid allocating and deallocating the cell. 
        This is much faster than the version which does not take a *cell,
        especially when this function is called many times in a row such
        as by a for loop, where the allocation and deallocation can be
        done only once outside the for loop.  If a cell is found, "cell"
        contains the points and ptIds for the cell "cellId" upon exit.
        THIS METHOD IS NOT THREAD SAFE.
        """
        ...
    
    def FindClosestPointWithinRadius(self, p_float=..., p_float=..., p_float=..., *args, **kwargs):
        """
        V.FindClosestPointWithinRadius([float, float, float], float,
            [float, float, float], vtkGenericCell, int, int, float, int)
            -> int
        C++: vtkIdType FindClosestPointWithinRadius(double x[3],
            double radius, double closestPoint[3], vtkGenericCell *cell,
            vtkIdType &cellId, int &subId, double &dist2, int &inside)
            override;
        V.FindClosestPointWithinRadius([float, float, float], float,
            [float, float, float], int, int, float) -> int
        C++: virtual vtkIdType FindClosestPointWithinRadius(double x[3],
            double radius, double closestPoint[3], vtkIdType &cellId,
            int &subId, double &dist2)
        V.FindClosestPointWithinRadius([float, float, float], float,
            [float, float, float], vtkGenericCell, int, int, float) -> int
        C++: virtual vtkIdType FindClosestPointWithinRadius(double x[3],
            double radius, double closestPoint[3], vtkGenericCell *cell,
            vtkIdType &cellId, int &subId, double &dist2)
        
        Return the closest point within a specified radius and the cell
        which is closest to the point x. The closest point is somewhere
        on a cell, it need not be one of the vertices of the cell. This
        method returns 1 if a point is found within the specified radius.
        If there are no cells within the specified radius, the method
        returns 0 and the values of closestPoint, cellId, subId, and
        dist2 are undefined. This version takes in a vtkGenericCell to
        avoid allocating and deallocating the cell.  This is much faster
        than the version which does not take a *cell, especially when
        this function is called many times in a row such as by a for
        loop, where the allocation and dealloction can be done only once
        outside the for loop.  If a closest point is found, "cell"
        contains the points and ptIds for the cell "cellId" upon exit. 
        If a closest point is found, inside returns the return value of
        the EvaluatePosition call to the closest cell; inside(=1) or
        outside(=0). For other FindClosestPointWithinRadius signatures,
        see vtkAbstractCellLocator. THIS METHOD IS NOT THREAD SAFE.
        """
        ...
    
    def ForceBuildLocator(self):
        """
        V.ForceBuildLocator()
        C++: virtual void ForceBuildLocator()
        
        Satisfy vtkLocator abstract interface.
        """
        ...
    
    def FreeSearchStructure(self):
        """
        V.FreeSearchStructure()
        C++: void FreeSearchStructure() override;
        
        Satisfy vtkLocator abstract interface.
        """
        ...
    
    def GenerateRepresentation(self, p_int, vtkPolyData):
        """
        V.GenerateRepresentation(int, vtkPolyData)
        C++: void GenerateRepresentation(int level, vtkPolyData *pd)
            override;
        
        Satisfy vtkLocator abstract interface.
        """
        ...
    
    def GetCells(self, p_int):
        """
        V.GetCells(int) -> vtkIdList
        C++: virtual vtkIdList *GetCells(int bucket)
        
        Get the cells in a particular bucket.
        """
        ...
    
    def GetNumberOfBuckets(self):
        """
        V.GetNumberOfBuckets() -> int
        C++: virtual int GetNumberOfBuckets(void)
        
        Return number of buckets available. Insure that the locator has
        been built before attempting to access buckets (octants).
        """
        ...
    
    def GetNumberOfCellsPerBucket(self):
        """
        V.GetNumberOfCellsPerBucket() -> int
        C++: int GetNumberOfCellsPerBucket()
        """
        ...
    
    def GetNumberOfGenerationsFromBase(self, string):
        """
        V.GetNumberOfGenerationsFromBase(string) -> int
        C++: vtkIdType GetNumberOfGenerationsFromBase(const char *type)
            override;
        
        Standard type and print methods.
        """
        ...
    
    def GetNumberOfGenerationsFromBaseType(self, string):
        """
        V.GetNumberOfGenerationsFromBaseType(string) -> int
        C++: static vtkIdType GetNumberOfGenerationsFromBaseType(
            const char *type)
        
        Standard type and print methods.
        """
        ...
    
    def IntersectWithLine(self, , , p_float_6, p_float_7, p_float=..., p_float=..., p_float=..., *args, **kwargs):
        """
        V.IntersectWithLine((float, float, float), (float, float, float),
            float, float, [float, float, float], [float, float, float],
            int, int, vtkGenericCell) -> int
        C++: int IntersectWithLine(const double a0[3], const double a1[3],
             double tol, double &t, double x[3], double pcoords[3],
            int &subId, vtkIdType &cellId, vtkGenericCell *cell) override;
        V.IntersectWithLine((float, float, float), (float, float, float),
            float, float, [float, float, float], [float, float, float],
            int) -> int
        C++: virtual int IntersectWithLine(const double p1[3],
            const double p2[3], double tol, double &t, double x[3],
            double pcoords[3], int &subId)
        V.IntersectWithLine((float, float, float), (float, float, float),
            float, float, [float, float, float], [float, float, float],
            int, int) -> int
        C++: virtual int IntersectWithLine(const double p1[3],
            const double p2[3], double tol, double &t, double x[3],
            double pcoords[3], int &subId, vtkIdType &cellId)
        V.IntersectWithLine((float, float, float), (float, float, float),
            vtkPoints, vtkIdList) -> int
        C++: virtual int IntersectWithLine(const double p1[3],
            const double p2[3], vtkPoints *points, vtkIdList *cellIds)
        
        Return intersection point (if any) AND the cell which was
        intersected by the finite line. The cell is returned as a cell id
        and as a generic cell.  For other IntersectWithLine signatures,
        see vtkAbstractCellLocator. THIS METHOD IS NOT THREAD SAFE.
        """
        ...
    
    def IsA(self, string):
        """
        V.IsA(string) -> int
        C++: vtkTypeBool IsA(const char *type) override;
        
        Standard type and print methods.
        """
        ...
    
    def IsTypeOf(self, string):
        """
        V.IsTypeOf(string) -> int
        C++: static vtkTypeBool IsTypeOf(const char *type)
        
        Standard type and print methods.
        """
        ...
    
    def NewInstance(self):
        """
        V.NewInstance() -> vtkCellLocator
        C++: vtkCellLocator *NewInstance()
        
        Standard type and print methods.
        """
        ...
    
    def SafeDownCast(self, vtkObjectBase):
        """
        V.SafeDownCast(vtkObjectBase) -> vtkCellLocator
        C++: static vtkCellLocator *SafeDownCast(vtkObjectBase *o)
        
        Standard type and print methods.
        """
        ...
    
    def SetNumberOfCellsPerBucket(self, p_int):
        """
        V.SetNumberOfCellsPerBucket(int)
        C++: void SetNumberOfCellsPerBucket(int N)
        
        Specify the average number of cells in each octant.
        """
        ...
    
    def __delattr__(self, *args, **kwargs):
        """ Implement delattr(self, name). """
        ...
    
    def __getattribute__(self, *args, **kwargs):
        """ Return getattr(self, name). """
        ...
    
    def __init__(self, *args, **kwargs) -> None:
        ...
    
    @staticmethod
    def __new__(*args, **kwargs):
        """ Create and return a new object.  See help(type) for accurate signature. """
        ...
    
    def __repr__(self, *args, **kwargs):
        """ Return repr(self). """
        ...
    
    def __setattr__(self, *args, **kwargs):
        """ Implement setattr(self, name, value). """
        ...
    
    def __str__(self, *args, **kwargs) -> str:
        """ Return str(self). """
        ...
    
    __this__ = ...
    __dict__ = ...
    __vtkname__ = ...


