"""
This type stub file was generated by pyright.
"""

import vtkmodules.vtkRenderingCore as __vtkmodules_vtkRenderingCore

class vtkWidgetRepresentation(__vtkmodules_vtkRenderingCore.vtkProp):
    """
    vtkWidgetRepresentation - abstract class defines interface between
    the widget and widget representation classes
    
    Superclass: vtkProp
    
    This class is used to define the API for, and partially implement, a
    representation for different types of widgets. Note that the widget
    representation (i.e., subclasses of vtkWidgetRepresentation) are a
    type of vtkProp; meaning that they can be associated with a
    vtkRenderer end embedded in a scene like any other vtkActor. However,
    vtkWidgetRepresentation also defines an API that enables it to be
    paired with a subclass vtkAbstractWidget, meaning that it can be
    driven by a widget, serving to represent the widget as the widget
    responds to registered events.
    
    The API defined here should be regarded as a guideline for
    implementing widgets and widget representations. Widget behavior is
    complex, as is the way the representation responds to the registered
    widget events, so the API may vary from widget to widget to reflect
    this complexity.
    
    @warning
    The separation of the widget event handling and representation
    enables users and developers to create new appearances for the
    widget. It also facilitates parallel processing, where the client
    application handles events, and remote representations of the widget
    are slaves to the client (and do not handle events).
    """
    def BuildRepresentation(self):
        """
        V.BuildRepresentation()
        C++: virtual void BuildRepresentation()
        
        Subclasses of vtkWidgetRepresentation must implement these
        methods. This is considered the minimum API for a widget
        representation.
        
        SetRenderer() - the renderer in which the representations draws
        itself. Typically the renderer is set by the associated widget.
        Use the widget's SetCurrentRenderer() method in most cases;
        otherwise there is a risk of inconsistent behavior as events and
        drawing may be performed in different viewports.
        BuildRepresentation() - update the geometry of the widget based
        on its current state.  WARNING: The renderer is NOT reference
        counted by the representation, in order to avoid reference loops.
         Be sure that the representation lifetime does not extend beyond
        the renderer lifetime.
        """
        ...
    
    def ComplexInteraction(self, vtkRenderWindowInteractor, vtkAbstractWidget, p_int, void):
        """
        V.ComplexInteraction(vtkRenderWindowInteractor, vtkAbstractWidget,
             int, void)
        C++: virtual void ComplexInteraction(vtkRenderWindowInteractor *,
            vtkAbstractWidget *, unsigned long, void *)
        """
        ...
    
    def ComputeComplexInteractionState(self, vtkRenderWindowInteractor, vtkAbstractWidget, p_int, void, p_int_1):
        """
        V.ComputeComplexInteractionState(vtkRenderWindowInteractor,
            vtkAbstractWidget, int, void, int) -> int
        C++: virtual int ComputeComplexInteractionState(
            vtkRenderWindowInteractor *iren, vtkAbstractWidget *widget,
            unsigned long event, void *callData, int modify=0)
        """
        ...
    
    def ComputeInteractionState(self, p_int, p_int_1, p_int_2):
        """
        V.ComputeInteractionState(int, int, int) -> int
        C++: virtual int ComputeInteractionState(int X, int Y,
            int modify=0)
        """
        ...
    
    def EndComplexInteraction(self, vtkRenderWindowInteractor, vtkAbstractWidget, p_int, void):
        """
        V.EndComplexInteraction(vtkRenderWindowInteractor,
            vtkAbstractWidget, int, void)
        C++: virtual void EndComplexInteraction(
            vtkRenderWindowInteractor *, vtkAbstractWidget *,
            unsigned long, void *)
        """
        ...
    
    def EndWidgetInteraction(self, p_float=..., p_float=...):
        """
        V.EndWidgetInteraction([float, float])
        C++: virtual void EndWidgetInteraction(double newEventPos[2])
        """
        ...
    
    def GetActors(self, vtkPropCollection):
        """
        V.GetActors(vtkPropCollection)
        C++: void GetActors(vtkPropCollection *) override;
        
        For some exporters and other other operations we must be able to
        collect all the actors or volumes. These methods are used in that
        process.
        """
        ...
    
    def GetActors2D(self, vtkPropCollection):
        """
        V.GetActors2D(vtkPropCollection)
        C++: void GetActors2D(vtkPropCollection *) override;
        """
        ...
    
    def GetBounds(self):
        """
        V.GetBounds() -> (float, float, float, float, float, float)
        C++: double *GetBounds() override;
        
        Methods to make this class behave as a vtkProp. They are repeated
        here (from the vtkProp superclass) as a reminder to the widget
        implementor. Failure to implement these methods properly may
        result in the representation not appearing in the scene (i.e.,
        not implementing the Render() methods properly) or leaking
        graphics resources (i.e., not implementing
        ReleaseGraphicsResources() properly).
        """
        ...
    
    def GetHandleSize(self):
        """
        V.GetHandleSize() -> float
        C++: virtual double GetHandleSize()
        
        Set/Get the factor that controls the size of the handles that
        appear as part of the widget (if any). These handles (like
        spheres, etc.)  are used to manipulate the widget. The HandleSize
        data member allows you to change the relative size of the
        handles. Note that while the handle size is typically expressed
        in pixels, some subclasses may use a relative size with respect
        to the viewport. (As a corollary, the value of this ivar is often
        set by subclasses of this class during instance instantiation.)
        """
        ...
    
    def GetHandleSizeMaxValue(self):
        """
        V.GetHandleSizeMaxValue() -> float
        C++: virtual double GetHandleSizeMaxValue()
        
        Set/Get the factor that controls the size of the handles that
        appear as part of the widget (if any). These handles (like
        spheres, etc.)  are used to manipulate the widget. The HandleSize
        data member allows you to change the relative size of the
        handles. Note that while the handle size is typically expressed
        in pixels, some subclasses may use a relative size with respect
        to the viewport. (As a corollary, the value of this ivar is often
        set by subclasses of this class during instance instantiation.)
        """
        ...
    
    def GetHandleSizeMinValue(self):
        """
        V.GetHandleSizeMinValue() -> float
        C++: virtual double GetHandleSizeMinValue()
        
        Set/Get the factor that controls the size of the handles that
        appear as part of the widget (if any). These handles (like
        spheres, etc.)  are used to manipulate the widget. The HandleSize
        data member allows you to change the relative size of the
        handles. Note that while the handle size is typically expressed
        in pixels, some subclasses may use a relative size with respect
        to the viewport. (As a corollary, the value of this ivar is often
        set by subclasses of this class during instance instantiation.)
        """
        ...
    
    def GetInteractionState(self):
        """
        V.GetInteractionState() -> int
        C++: virtual int GetInteractionState()
        """
        ...
    
    def GetNeedToRender(self):
        """
        V.GetNeedToRender() -> int
        C++: virtual vtkTypeBool GetNeedToRender()
        
        Some subclasses use this data member to keep track of whether to
        render or not (i.e., to minimize the total number of renders).
        """
        ...
    
    def GetNeedToRenderMaxValue(self):
        """
        V.GetNeedToRenderMaxValue() -> int
        C++: virtual vtkTypeBool GetNeedToRenderMaxValue()
        
        Some subclasses use this data member to keep track of whether to
        render or not (i.e., to minimize the total number of renders).
        """
        ...
    
    def GetNeedToRenderMinValue(self):
        """
        V.GetNeedToRenderMinValue() -> int
        C++: virtual vtkTypeBool GetNeedToRenderMinValue()
        
        Some subclasses use this data member to keep track of whether to
        render or not (i.e., to minimize the total number of renders).
        """
        ...
    
    def GetNumberOfGenerationsFromBase(self, string):
        """
        V.GetNumberOfGenerationsFromBase(string) -> int
        C++: vtkIdType GetNumberOfGenerationsFromBase(const char *type)
            override;
        
        Standard methods for instances of this class.
        """
        ...
    
    def GetNumberOfGenerationsFromBaseType(self, string):
        """
        V.GetNumberOfGenerationsFromBaseType(string) -> int
        C++: static vtkIdType GetNumberOfGenerationsFromBaseType(
            const char *type)
        
        Standard methods for instances of this class.
        """
        ...
    
    def GetPickingManaged(self):
        """
        V.GetPickingManaged() -> bool
        C++: virtual bool GetPickingManaged()
        
        Enable/Disable the use of a manager to process the picking.
        Enabled by default.
        """
        ...
    
    def GetPlaceFactor(self):
        """
        V.GetPlaceFactor() -> float
        C++: virtual double GetPlaceFactor()
        
        Set/Get a factor representing the scaling of the widget upon
        placement (via the PlaceWidget() method). Normally the widget is
        placed so that it just fits within the bounding box defined in
        PlaceWidget(bounds). The PlaceFactor will make the widget larger
        (PlaceFactor > 1) or smaller (PlaceFactor < 1). By default,
        PlaceFactor is set to 0.5.
        """
        ...
    
    def GetPlaceFactorMaxValue(self):
        """
        V.GetPlaceFactorMaxValue() -> float
        C++: virtual double GetPlaceFactorMaxValue()
        
        Set/Get a factor representing the scaling of the widget upon
        placement (via the PlaceWidget() method). Normally the widget is
        placed so that it just fits within the bounding box defined in
        PlaceWidget(bounds). The PlaceFactor will make the widget larger
        (PlaceFactor > 1) or smaller (PlaceFactor < 1). By default,
        PlaceFactor is set to 0.5.
        """
        ...
    
    def GetPlaceFactorMinValue(self):
        """
        V.GetPlaceFactorMinValue() -> float
        C++: virtual double GetPlaceFactorMinValue()
        
        Set/Get a factor representing the scaling of the widget upon
        placement (via the PlaceWidget() method). Normally the widget is
        placed so that it just fits within the bounding box defined in
        PlaceWidget(bounds). The PlaceFactor will make the widget larger
        (PlaceFactor > 1) or smaller (PlaceFactor < 1). By default,
        PlaceFactor is set to 0.5.
        """
        ...
    
    def GetRenderer(self):
        """
        V.GetRenderer() -> vtkRenderer
        C++: virtual vtkRenderer *GetRenderer()
        
        Subclasses of vtkWidgetRepresentation must implement these
        methods. This is considered the minimum API for a widget
        representation.
        
        SetRenderer() - the renderer in which the representations draws
        itself. Typically the renderer is set by the associated widget.
        Use the widget's SetCurrentRenderer() method in most cases;
        otherwise there is a risk of inconsistent behavior as events and
        drawing may be performed in different viewports.
        BuildRepresentation() - update the geometry of the widget based
        on its current state.  WARNING: The renderer is NOT reference
        counted by the representation, in order to avoid reference loops.
         Be sure that the representation lifetime does not extend beyond
        the renderer lifetime.
        """
        ...
    
    def GetVolumes(self, vtkPropCollection):
        """
        V.GetVolumes(vtkPropCollection)
        C++: void GetVolumes(vtkPropCollection *) override;
        """
        ...
    
    def HasTranslucentPolygonalGeometry(self):
        """
        V.HasTranslucentPolygonalGeometry() -> int
        C++: vtkTypeBool HasTranslucentPolygonalGeometry() override;
        
        WARNING: INTERNAL METHOD - NOT INTENDED FOR GENERAL USE DO NOT
        USE THESE METHODS OUTSIDE OF THE RENDERING PROCESS Does this prop
        have some translucent polygonal geometry? This method is called
        during the rendering process to know if there is some translucent
        polygonal geometry. A simple prop that has some translucent
        polygonal geometry will return true. A composite prop (like
        vtkAssembly) that has at least one sub-prop that has some
        translucent polygonal geometry will return true. Default
        implementation return false.
        """
        ...
    
    def Highlight(self, p_int):
        """
        V.Highlight(int)
        C++: virtual void Highlight(int highlightOn)
        """
        ...
    
    def IsA(self, string):
        """
        V.IsA(string) -> int
        C++: vtkTypeBool IsA(const char *type) override;
        
        Standard methods for instances of this class.
        """
        ...
    
    def IsTypeOf(self, string):
        """
        V.IsTypeOf(string) -> int
        C++: static vtkTypeBool IsTypeOf(const char *type)
        
        Standard methods for instances of this class.
        """
        ...
    
    def NeedToRenderOff(self):
        """
        V.NeedToRenderOff()
        C++: virtual void NeedToRenderOff()
        
        Some subclasses use this data member to keep track of whether to
        render or not (i.e., to minimize the total number of renders).
        """
        ...
    
    def NeedToRenderOn(self):
        """
        V.NeedToRenderOn()
        C++: virtual void NeedToRenderOn()
        
        Some subclasses use this data member to keep track of whether to
        render or not (i.e., to minimize the total number of renders).
        """
        ...
    
    def NewInstance(self):
        """
        V.NewInstance() -> vtkWidgetRepresentation
        C++: vtkWidgetRepresentation *NewInstance()
        
        Standard methods for instances of this class.
        """
        ...
    
    def PickingManagedOff(self):
        """
        V.PickingManagedOff()
        C++: virtual void PickingManagedOff()
        
        Enable/Disable the use of a manager to process the picking.
        Enabled by default.
        """
        ...
    
    def PickingManagedOn(self):
        """
        V.PickingManagedOn()
        C++: virtual void PickingManagedOn()
        
        Enable/Disable the use of a manager to process the picking.
        Enabled by default.
        """
        ...
    
    def PlaceWidget(self, *float):
        """
        V.PlaceWidget([float, ...])
        C++: virtual void PlaceWidget(double *bounds)
        
        The following is a suggested API for widget representations.
        These methods define the communication between the widget and its
        representation. These methods are only suggestions because
        widgets take on so many different forms that a universal API is
        not deemed practical. However, these methods should be
        implemented when possible to insure that the VTK widget hierarchy
        remains self-consistent.
        
        PlaceWidget() - given a bounding box
        (xmin,xmax,ymin,ymax,zmin,zmax), place the widget inside of it.
        The current orientation of the widget is preserved, only scaling
        and translation is performed. StartWidgetInteraction() -
        generally corresponds to a initial event (e.g., mouse down) that
        starts the interaction process with the widget.
        WidgetInteraction() - invoked when an event causes the widget to
        change appearance. EndWidgetInteraction() - generally corresponds
        to a final event (e.g., mouse up) and completes the interaction
        sequence. ComputeInteractionState() - given (X,Y) display
        coordinates in a renderer, with a possible flag that modifies the
        computation, what is the state of the widget?
        GetInteractionState() - return the current state of the widget.
        Note that the value of "0" typically refers to "outside". The
        interaction state is strictly a function of the representation,
        and the widget/represent must agree on what they mean.
        Highlight() - turn on or off any highlights associated with the
        widget. Highlights are generally turned on when the widget is
        selected.  Note that subclasses may ignore some of these methods
        and implement their own depending on the specifics of the widget.
        """
        ...
    
    def RegisterPickers(self):
        """
        V.RegisterPickers()
        C++: virtual void RegisterPickers()
        
        Register internal Pickers in the Picking Manager. Must be
        reimplemented by concrete widget representations to register
        their pickers.
        """
        ...
    
    def ReleaseGraphicsResources(self, vtkWindow):
        """
        V.ReleaseGraphicsResources(vtkWindow)
        C++: void ReleaseGraphicsResources(vtkWindow *) override;
        
        WARNING: INTERNAL METHOD - NOT INTENDED FOR GENERAL USE Release
        any graphics resources that are being consumed by this actor. The
        parameter window could be used to determine which graphic
        resources to release.
        """
        ...
    
    def RenderOpaqueGeometry(self, vtkViewport):
        """
        V.RenderOpaqueGeometry(vtkViewport) -> int
        C++: int RenderOpaqueGeometry(vtkViewport *viewport) override;
        
        WARNING: INTERNAL METHOD - NOT INTENDED FOR GENERAL USE DO NOT
        USE THESE METHODS OUTSIDE OF THE RENDERING PROCESS All concrete
        subclasses must be able to render themselves. There are four key
        render methods in vtk and they correspond to four different
        points in the rendering cycle. Any given prop may implement one
        or more of these methods. The first method is intended for
        rendering all opaque geometry. The second method is intended for
        rendering all translucent polygonal geometry. The third one is
        intended for rendering all translucent volumetric geometry. Most
        of the volume rendering mappers draw their results during this
        third method. The last method is to render any 2D annotation or
        overlays. Each of these methods return an integer value
        indicating whether or not this render method was applied to this
        data.
        """
        ...
    
    def RenderOverlay(self, vtkViewport):
        """
        V.RenderOverlay(vtkViewport) -> int
        C++: int RenderOverlay(vtkViewport *viewport) override;
        """
        ...
    
    def RenderTranslucentPolygonalGeometry(self, vtkViewport):
        """
        V.RenderTranslucentPolygonalGeometry(vtkViewport) -> int
        C++: int RenderTranslucentPolygonalGeometry(vtkViewport *viewport)
             override;
        """
        ...
    
    def RenderVolumetricGeometry(self, vtkViewport):
        """
        V.RenderVolumetricGeometry(vtkViewport) -> int
        C++: int RenderVolumetricGeometry(vtkViewport *viewport) override;
        """
        ...
    
    def SafeDownCast(self, vtkObjectBase):
        """
        V.SafeDownCast(vtkObjectBase) -> vtkWidgetRepresentation
        C++: static vtkWidgetRepresentation *SafeDownCast(
            vtkObjectBase *o)
        
        Standard methods for instances of this class.
        """
        ...
    
    def SetHandleSize(self, p_float):
        """
        V.SetHandleSize(float)
        C++: virtual void SetHandleSize(double _arg)
        
        Set/Get the factor that controls the size of the handles that
        appear as part of the widget (if any). These handles (like
        spheres, etc.)  are used to manipulate the widget. The HandleSize
        data member allows you to change the relative size of the
        handles. Note that while the handle size is typically expressed
        in pixels, some subclasses may use a relative size with respect
        to the viewport. (As a corollary, the value of this ivar is often
        set by subclasses of this class during instance instantiation.)
        """
        ...
    
    def SetNeedToRender(self, p_int):
        """
        V.SetNeedToRender(int)
        C++: virtual void SetNeedToRender(vtkTypeBool _arg)
        
        Some subclasses use this data member to keep track of whether to
        render or not (i.e., to minimize the total number of renders).
        """
        ...
    
    def SetPickingManaged(self, bool):
        """
        V.SetPickingManaged(bool)
        C++: void SetPickingManaged(bool managed)
        
        Enable/Disable the use of a manager to process the picking.
        Enabled by default.
        """
        ...
    
    def SetPlaceFactor(self, p_float):
        """
        V.SetPlaceFactor(float)
        C++: virtual void SetPlaceFactor(double _arg)
        
        Set/Get a factor representing the scaling of the widget upon
        placement (via the PlaceWidget() method). Normally the widget is
        placed so that it just fits within the bounding box defined in
        PlaceWidget(bounds). The PlaceFactor will make the widget larger
        (PlaceFactor > 1) or smaller (PlaceFactor < 1). By default,
        PlaceFactor is set to 0.5.
        """
        ...
    
    def SetRenderer(self, vtkRenderer):
        """
        V.SetRenderer(vtkRenderer)
        C++: virtual void SetRenderer(vtkRenderer *ren)
        
        Subclasses of vtkWidgetRepresentation must implement these
        methods. This is considered the minimum API for a widget
        representation.
        
        SetRenderer() - the renderer in which the representations draws
        itself. Typically the renderer is set by the associated widget.
        Use the widget's SetCurrentRenderer() method in most cases;
        otherwise there is a risk of inconsistent behavior as events and
        drawing may be performed in different viewports.
        BuildRepresentation() - update the geometry of the widget based
        on its current state.  WARNING: The renderer is NOT reference
        counted by the representation, in order to avoid reference loops.
         Be sure that the representation lifetime does not extend beyond
        the renderer lifetime.
        """
        ...
    
    def ShallowCopy(self, vtkProp):
        """
        V.ShallowCopy(vtkProp)
        C++: void ShallowCopy(vtkProp *prop) override;
        
        Shallow copy of this vtkProp.
        """
        ...
    
    def StartComplexInteraction(self, vtkRenderWindowInteractor, vtkAbstractWidget, p_int, void):
        """
        V.StartComplexInteraction(vtkRenderWindowInteractor,
            vtkAbstractWidget, int, void)
        C++: virtual void StartComplexInteraction(
            vtkRenderWindowInteractor *, vtkAbstractWidget *,
            unsigned long, void *)
        """
        ...
    
    def StartWidgetInteraction(self, p_float=..., p_float=...):
        """
        V.StartWidgetInteraction([float, float])
        C++: virtual void StartWidgetInteraction(double eventPos[2])
        """
        ...
    
    def UnRegisterPickers(self):
        """
        V.UnRegisterPickers()
        C++: virtual void UnRegisterPickers()
        
        Unregister internal pickers from the Picking Manager.
        """
        ...
    
    def WidgetInteraction(self, p_float=..., p_float=...):
        """
        V.WidgetInteraction([float, float])
        C++: virtual void WidgetInteraction(double newEventPos[2])
        """
        ...
    
    def __delattr__(self, *args, **kwargs):
        """ Implement delattr(self, name). """
        ...
    
    def __getattribute__(self, *args, **kwargs):
        """ Return getattr(self, name). """
        ...
    
    def __init__(self, *args, **kwargs) -> None:
        ...
    
    @staticmethod
    def __new__(*args, **kwargs):
        """ Create and return a new object.  See help(type) for accurate signature. """
        ...
    
    def __repr__(self, *args, **kwargs):
        """ Return repr(self). """
        ...
    
    def __setattr__(self, *args, **kwargs):
        """ Implement setattr(self, name, value). """
        ...
    
    def __str__(self, *args, **kwargs) -> str:
        """ Return str(self). """
        ...
    
    __this__ = ...
    Axis = ...
    NONE = ...
    XAxis = ...
    YAxis = ...
    ZAxis = ...
    __dict__ = ...
    __vtkname__ = ...


