"""
This type stub file was generated by pyright.
"""

import vtkmodules.vtkCommonExecutionModel as __vtkmodules_vtkCommonExecutionModel

class vtkSelectEnclosedPoints(__vtkmodules_vtkCommonExecutionModel.vtkDataSetAlgorithm):
    """
    vtkSelectEnclosedPoints - mark points as to whether they are inside a
    closed surface
    
    Superclass: vtkDataSetAlgorithm
    
    vtkSelectEnclosedPoints is a filter that evaluates all the input
    points to determine whether they are in an enclosed surface. The
    filter produces a (0,1) mask (in the form of a vtkDataArray) that
    indicates whether points are outside (mask value=0) or inside (mask
    value=1) a provided surface. (The name of the output vtkDataArray is
    "SelectedPoints".)
    
    After running the filter, it is possible to query it as to whether a
    point is inside/outside by invoking the IsInside(ptId) method.
    
    @warning
    The filter assumes that the surface is closed and manifold. A boolean
    flag can be set to force the filter to first check whether this is
    true. If false, all points will be marked outside. Note that if this
    check is not performed and the surface is not closed, the results are
    undefined.
    
    @warning
    This filter produces and output data array, but does not modify the
    input dataset. If you wish to extract cells or points, various
    threshold filters are available (i.e., threshold the output array).
    Also, see the filter vtkExtractEnclosedPoints which operates on point
    clouds.
    
    @warning
    This class has been threaded with vtkSMPTools. Using TBB or other
    non-sequential type (set in the CMake variable
    VTK_SMP_IMPLEMENTATION_TYPE) may improve performance significantly.
    
    @sa
    vtkMaskPoints vtkExtractEnclosedPoints
    """
    def CheckSurfaceOff(self):
        """
        V.CheckSurfaceOff()
        C++: virtual void CheckSurfaceOff()
        
        Specify whether to check the surface for closure. If on, then the
        algorithm first checks to see if the surface is closed and
        manifold.
        """
        ...
    
    def CheckSurfaceOn(self):
        """
        V.CheckSurfaceOn()
        C++: virtual void CheckSurfaceOn()
        
        Specify whether to check the surface for closure. If on, then the
        algorithm first checks to see if the surface is closed and
        manifold.
        """
        ...
    
    def Complete(self):
        """
        V.Complete()
        C++: void Complete()
        
        This is a backdoor that can be used to test many points for
        containment. First initialize the instance, then repeated calls
        to IsInsideSurface() can be used without rebuilding the search
        structures. The Complete() method releases memory.
        """
        ...
    
    def GetCheckSurface(self):
        """
        V.GetCheckSurface() -> int
        C++: virtual vtkTypeBool GetCheckSurface()
        
        Specify whether to check the surface for closure. If on, then the
        algorithm first checks to see if the surface is closed and
        manifold.
        """
        ...
    
    def GetInsideOut(self):
        """
        V.GetInsideOut() -> int
        C++: virtual vtkTypeBool GetInsideOut()
        
        By default, points inside the surface are marked inside or sent
        to the output. If InsideOut is on, then the points outside the
        surface are marked inside.
        """
        ...
    
    def GetNumberOfGenerationsFromBase(self, string):
        """
        V.GetNumberOfGenerationsFromBase(string) -> int
        C++: vtkIdType GetNumberOfGenerationsFromBase(const char *type)
            override;
        
        Standard methods for type information and printing.
        """
        ...
    
    def GetNumberOfGenerationsFromBaseType(self, string):
        """
        V.GetNumberOfGenerationsFromBaseType(string) -> int
        C++: static vtkIdType GetNumberOfGenerationsFromBaseType(
            const char *type)
        
        Standard methods for type information and printing.
        """
        ...
    
    def GetSurface(self):
        """
        V.GetSurface() -> vtkPolyData
        C++: vtkPolyData *GetSurface()
        V.GetSurface(vtkInformationVector) -> vtkPolyData
        C++: vtkPolyData *GetSurface(vtkInformationVector *sourceInfo)
        
        Return a pointer to the enclosing surface.
        """
        ...
    
    def GetTolerance(self):
        """
        V.GetTolerance() -> float
        C++: virtual double GetTolerance()
        
        Specify the tolerance on the intersection. The tolerance is
        expressed as a fraction of the diagonal of the bounding box of
        the enclosing surface.
        """
        ...
    
    def GetToleranceMaxValue(self):
        """
        V.GetToleranceMaxValue() -> float
        C++: virtual double GetToleranceMaxValue()
        
        Specify the tolerance on the intersection. The tolerance is
        expressed as a fraction of the diagonal of the bounding box of
        the enclosing surface.
        """
        ...
    
    def GetToleranceMinValue(self):
        """
        V.GetToleranceMinValue() -> float
        C++: virtual double GetToleranceMinValue()
        
        Specify the tolerance on the intersection. The tolerance is
        expressed as a fraction of the diagonal of the bounding box of
        the enclosing surface.
        """
        ...
    
    def Initialize(self, vtkPolyData):
        """
        V.Initialize(vtkPolyData)
        C++: void Initialize(vtkPolyData *surface)
        
        This is a backdoor that can be used to test many points for
        containment. First initialize the instance, then repeated calls
        to IsInsideSurface() can be used without rebuilding the search
        structures. The Complete() method releases memory.
        """
        ...
    
    def InsideOutOff(self):
        """
        V.InsideOutOff()
        C++: virtual void InsideOutOff()
        
        By default, points inside the surface are marked inside or sent
        to the output. If InsideOut is on, then the points outside the
        surface are marked inside.
        """
        ...
    
    def InsideOutOn(self):
        """
        V.InsideOutOn()
        C++: virtual void InsideOutOn()
        
        By default, points inside the surface are marked inside or sent
        to the output. If InsideOut is on, then the points outside the
        surface are marked inside.
        """
        ...
    
    def IsA(self, string):
        """
        V.IsA(string) -> int
        C++: vtkTypeBool IsA(const char *type) override;
        
        Standard methods for type information and printing.
        """
        ...
    
    def IsInside(self, p_int):
        """
        V.IsInside(int) -> int
        C++: int IsInside(vtkIdType inputPtId)
        
        Query an input point id as to whether it is inside or outside.
        Note that the result requires that the filter execute first.
        """
        ...
    
    def IsInsideSurface(self, p_float=..., p_float=..., p_float=...):
        """
        V.IsInsideSurface([float, float, float]) -> int
        C++: int IsInsideSurface(double x[3])
        V.IsInsideSurface(float, float, float) -> int
        C++: int IsInsideSurface(double x, double y, double z)
        V.IsInsideSurface([float, float, float], vtkPolyData, [float,
            float, float, float, float, float], float, float,
            vtkAbstractCellLocator, vtkIdList, vtkGenericCell,
            vtkIntersectionCounter, vtkRandomPool, int) -> int
        C++: static int IsInsideSurface(double x[3], vtkPolyData *surface,
             double bds[6], double length, double tol,
            vtkAbstractCellLocator *locator, vtkIdList *cellIds,
            vtkGenericCell *genCell, vtkIntersectionCounter &counter,
            vtkRandomPool *poole=nullptr, vtkIdType seqIdx=0)
        
        This is a backdoor that can be used to test many points for
        containment. First initialize the instance, then repeated calls
        to IsInsideSurface() can be used without rebuilding the search
        structures. The Complete() method releases memory.
        """
        ...
    
    def IsSurfaceClosed(self, vtkPolyData):
        """
        V.IsSurfaceClosed(vtkPolyData) -> int
        C++: static int IsSurfaceClosed(vtkPolyData *surface)
        
        A static method for determining whether a surface is closed.
        Provide as input a vtkPolyData. The method returns >0 is the
        surface is closed and manifold.
        """
        ...
    
    def IsTypeOf(self, string):
        """
        V.IsTypeOf(string) -> int
        C++: static vtkTypeBool IsTypeOf(const char *type)
        
        Standard methods for type information and printing.
        """
        ...
    
    def NewInstance(self):
        """
        V.NewInstance() -> vtkSelectEnclosedPoints
        C++: vtkSelectEnclosedPoints *NewInstance()
        
        Standard methods for type information and printing.
        """
        ...
    
    def SafeDownCast(self, vtkObjectBase):
        """
        V.SafeDownCast(vtkObjectBase) -> vtkSelectEnclosedPoints
        C++: static vtkSelectEnclosedPoints *SafeDownCast(
            vtkObjectBase *o)
        
        Standard methods for type information and printing.
        """
        ...
    
    def SetCheckSurface(self, p_int):
        """
        V.SetCheckSurface(int)
        C++: virtual void SetCheckSurface(vtkTypeBool _arg)
        
        Specify whether to check the surface for closure. If on, then the
        algorithm first checks to see if the surface is closed and
        manifold.
        """
        ...
    
    def SetInsideOut(self, p_int):
        """
        V.SetInsideOut(int)
        C++: virtual void SetInsideOut(vtkTypeBool _arg)
        
        By default, points inside the surface are marked inside or sent
        to the output. If InsideOut is on, then the points outside the
        surface are marked inside.
        """
        ...
    
    def SetSurfaceConnection(self, vtkAlgorithmOutput):
        """
        V.SetSurfaceConnection(vtkAlgorithmOutput)
        C++: void SetSurfaceConnection(vtkAlgorithmOutput *algOutput)
        
        Set the surface to be used to test for containment. Two methods
        are provided: one directly for vtkPolyData, and one for the
        output of a filter.
        """
        ...
    
    def SetSurfaceData(self, vtkPolyData):
        """
        V.SetSurfaceData(vtkPolyData)
        C++: void SetSurfaceData(vtkPolyData *pd)
        
        Set the surface to be used to test for containment. Two methods
        are provided: one directly for vtkPolyData, and one for the
        output of a filter.
        """
        ...
    
    def SetTolerance(self, p_float):
        """
        V.SetTolerance(float)
        C++: virtual void SetTolerance(double _arg)
        
        Specify the tolerance on the intersection. The tolerance is
        expressed as a fraction of the diagonal of the bounding box of
        the enclosing surface.
        """
        ...
    
    def __delattr__(self, *args, **kwargs):
        """ Implement delattr(self, name). """
        ...
    
    def __getattribute__(self, *args, **kwargs):
        """ Return getattr(self, name). """
        ...
    
    def __init__(self, *args, **kwargs) -> None:
        ...
    
    @staticmethod
    def __new__(*args, **kwargs):
        """ Create and return a new object.  See help(type) for accurate signature. """
        ...
    
    def __repr__(self, *args, **kwargs):
        """ Return repr(self). """
        ...
    
    def __setattr__(self, *args, **kwargs):
        """ Implement setattr(self, name, value). """
        ...
    
    def __str__(self, *args, **kwargs) -> str:
        """ Return str(self). """
        ...
    
    __this__ = ...
    __dict__ = ...
    __vtkname__ = ...


