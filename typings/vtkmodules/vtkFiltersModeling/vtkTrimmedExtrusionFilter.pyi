"""
This type stub file was generated by pyright.
"""

import vtkmodules.vtkCommonExecutionModel as __vtkmodules_vtkCommonExecutionModel

class vtkTrimmedExtrusionFilter(__vtkmodules_vtkCommonExecutionModel.vtkPolyDataAlgorithm):
    """
    vtkTrimmedExtrusionFilter - extrude polygonal data trimmed by a
    second input surface
    
    Superclass: vtkPolyDataAlgorithm
    
    vtkTrimmedExtrusionFilter is a modeling filter. It takes polygonal
    data as input and generates polygonal data on output. The input
    dataset is swept along a specified direction forming a "skirt" from
    the boundary edges 2D primitives (i.e., edges used by only one
    polygon); and/or from vertices and lines. The extent of the sweeping
    is limited by a second input: defined where the sweep intersects a
    user-specified surface.
    
    Capping of the extrusion can be enabled. In this case the input,
    generating primitive is copied inplace as well as to the end of the
    extrusion skirt. (See warnings below on what happens if the
    intersecting sweep does not intersect, or partially intersects the
    trim surface.)
    
    Note that this filter operates in two fundamentally different modes
    based on the extrusion strategy. If the strategy is BOUNDARY_EDGES,
    then only the boundary edges of the input's 2D primitives are
    extruded (verts and lines are extruded to generate lines and quads).
    However, if the extrusions strategy is ALL_EDGES, then every edge of
    the 2D primitives is used to sweep out a quadrilateral polygon (again
    verts and lines are swept to produce lines and quads).
    
    @warning
    The extrusion direction is assumed to define an infinite line. The
    intersection with the trim surface is along a ray from the - to +
    direction, however only the first intersection is taken.
    
    @warning
    Some polygonal objects have no free edges (e.g., sphere). When swept,
    this will result in two separate surfaces if capping is on and
    BOUNDARY_EDGES enabled, or no surface if capping is off and
    BOUNDARY_EDGES is enabled.
    
    @warning
    If all the extrusion lines emanating from an extruding primitive do
    not intersect the trim surface, then no output for that primitive
    will be generated. In extreme cases, it it possible that no output
    whatsoever will be generated by the filter.
    
    @warning
    This class has been threaded with vtkSMPTools. Using TBB or other
    non-sequential type (set in the CMake variable
    VTK_SMP_IMPLEMENTATION_TYPE) may improve performance significantly.
    
    @sa
    vtkLinearExtrusionFilter vtkRotationalExtrusionFilter
    """
    def CappingOff(self):
        """
        V.CappingOff()
        C++: virtual void CappingOff()
        
        Turn on/off the capping of the extruded skirt.
        """
        ...
    
    def CappingOn(self):
        """
        V.CappingOn()
        C++: virtual void CappingOn()
        
        Turn on/off the capping of the extruded skirt.
        """
        ...
    
    def GetCapping(self):
        """
        V.GetCapping() -> int
        C++: virtual int GetCapping()
        
        Turn on/off the capping of the extruded skirt.
        """
        ...
    
    def GetCappingStrategy(self):
        """
        V.GetCappingStrategy() -> int
        C++: virtual int GetCappingStrategy()
        
        Specify a strategy for capping. By default the points of the cap
        polygons are located where the extrusion intersects the capping
        surface. However, to preserve planarity, or to place the capping
        surface at the average/minimum/maximum distance of extrusion,
        different strategies can be used. By default the average distance
        is used.
        
        Note if none of the extrusion rays intersect the trim surface,
        then capping is not performed, nor is an extrusion skirt sent to
        the output. Also note that if the capping strategy is set to
        INTERSECTION, and one of the extrusion rays of the generating
        primitive does not intersect the trim surface, then no output
        will be generated for that primitive. However if any other
        capping strategy is used, capping will succeed if at least one
        extrusion ray strikes the trim surface (although missed extrusion
        ray intersections will not factor into the determination of final
        cap location).
        
        Finally, note that any capping strategy other than INTERSECTION
        may produce more points than expected because the output
        primitives may have to be "split apart" to satisy the capping
        constraint.
        """
        ...
    
    def GetExtrusionDirection(self):
        """
        V.GetExtrusionDirection() -> (float, float, float)
        C++: virtual double *GetExtrusionDirection()
        
        Set/Get the extrusion direction.
        """
        ...
    
    def GetExtrusionStrategy(self):
        """
        V.GetExtrusionStrategy() -> int
        C++: virtual int GetExtrusionStrategy()
        
        Specify a strategy for extrusion. If the strategy is set to
        "BOUNDARY_EDGES" then the boundary edges of the input polygons
        and triangle strips are swept. (A boundary edge is an edge used
        by only one 2D primitive, e.g., polygon or triangle.)
        Alternatively, all edges can be swept. (This is particularly
        useful when only sinple disconnected polygons exist in the input
        and so boundary calculation can be avoided.) By default boundary
        edges are extruded.
        """
        ...
    
    def GetLocator(self):
        """
        V.GetLocator() -> vtkAbstractCellLocator
        C++: virtual vtkAbstractCellLocator *GetLocator()
        
        Specify a cell locator. By default a vtkStaticCellLocator is
        used. The locator performs efficient searches to intersect cells.
        """
        ...
    
    def GetNumberOfGenerationsFromBase(self, string):
        """
        V.GetNumberOfGenerationsFromBase(string) -> int
        C++: vtkIdType GetNumberOfGenerationsFromBase(const char *type)
            override;
        
        Given a the name of a base class of this class type, return the
        distance of inheritance between this class type and the named
        class (how many generations of inheritance are there between this
        class and the named class). If the named class is not in this
        class's inheritance tree, return a negative value. Valid
        responses will always be nonnegative. This method works in
        combination with vtkTypeMacro found in vtkSetGet.h.
        """
        ...
    
    def GetNumberOfGenerationsFromBaseType(self, string):
        """
        V.GetNumberOfGenerationsFromBaseType(string) -> int
        C++: static vtkIdType GetNumberOfGenerationsFromBaseType(
            const char *type)
        
        Given a the name of a base class of this class type, return the
        distance of inheritance between this class type and the named
        class (how many generations of inheritance are there between this
        class and the named class). If the named class is not in this
        class's inheritance tree, return a negative value. Valid
        responses will always be nonnegative. This method works in
        combination with vtkTypeMacro found in vtkSetGet.h.
        """
        ...
    
    def GetTrimSurface(self):
        """
        V.GetTrimSurface() -> vtkPolyData
        C++: vtkPolyData *GetTrimSurface()
        V.GetTrimSurface(vtkInformationVector) -> vtkPolyData
        C++: vtkPolyData *GetTrimSurface(vtkInformationVector *sourceInfo)
        
        Return a pointer to the enclosing surface.
        """
        ...
    
    def IsA(self, string):
        """
        V.IsA(string) -> int
        C++: vtkTypeBool IsA(const char *type) override;
        
        Return 1 if this class is the same type of (or a subclass of) the
        named class. Returns 0 otherwise. This method works in
        combination with vtkTypeMacro found in vtkSetGet.h.
        """
        ...
    
    def IsTypeOf(self, string):
        """
        V.IsTypeOf(string) -> int
        C++: static vtkTypeBool IsTypeOf(const char *type)
        
        Return 1 if this class type is the same type of (or a subclass
        of) the named class. Returns 0 otherwise. This method works in
        combination with vtkTypeMacro found in vtkSetGet.h.
        """
        ...
    
    def NewInstance(self):
        """
        V.NewInstance() -> vtkTrimmedExtrusionFilter
        C++: vtkTrimmedExtrusionFilter *NewInstance()
        """
        ...
    
    def SafeDownCast(self, vtkObjectBase):
        """
        V.SafeDownCast(vtkObjectBase) -> vtkTrimmedExtrusionFilter
        C++: static vtkTrimmedExtrusionFilter *SafeDownCast(
            vtkObjectBase *o)
        """
        ...
    
    def SetCapping(self, p_int):
        """
        V.SetCapping(int)
        C++: virtual void SetCapping(int _arg)
        
        Turn on/off the capping of the extruded skirt.
        """
        ...
    
    def SetCappingStrategy(self, p_int):
        """
        V.SetCappingStrategy(int)
        C++: virtual void SetCappingStrategy(int _arg)
        
        Specify a strategy for capping. By default the points of the cap
        polygons are located where the extrusion intersects the capping
        surface. However, to preserve planarity, or to place the capping
        surface at the average/minimum/maximum distance of extrusion,
        different strategies can be used. By default the average distance
        is used.
        
        Note if none of the extrusion rays intersect the trim surface,
        then capping is not performed, nor is an extrusion skirt sent to
        the output. Also note that if the capping strategy is set to
        INTERSECTION, and one of the extrusion rays of the generating
        primitive does not intersect the trim surface, then no output
        will be generated for that primitive. However if any other
        capping strategy is used, capping will succeed if at least one
        extrusion ray strikes the trim surface (although missed extrusion
        ray intersections will not factor into the determination of final
        cap location).
        
        Finally, note that any capping strategy other than INTERSECTION
        may produce more points than expected because the output
        primitives may have to be "split apart" to satisy the capping
        constraint.
        """
        ...
    
    def SetCappingStrategyToAverageDistance(self):
        """
        V.SetCappingStrategyToAverageDistance()
        C++: void SetCappingStrategyToAverageDistance()
        
        Specify a strategy for capping. By default the points of the cap
        polygons are located where the extrusion intersects the capping
        surface. However, to preserve planarity, or to place the capping
        surface at the average/minimum/maximum distance of extrusion,
        different strategies can be used. By default the average distance
        is used.
        
        Note if none of the extrusion rays intersect the trim surface,
        then capping is not performed, nor is an extrusion skirt sent to
        the output. Also note that if the capping strategy is set to
        INTERSECTION, and one of the extrusion rays of the generating
        primitive does not intersect the trim surface, then no output
        will be generated for that primitive. However if any other
        capping strategy is used, capping will succeed if at least one
        extrusion ray strikes the trim surface (although missed extrusion
        ray intersections will not factor into the determination of final
        cap location).
        
        Finally, note that any capping strategy other than INTERSECTION
        may produce more points than expected because the output
        primitives may have to be "split apart" to satisy the capping
        constraint.
        """
        ...
    
    def SetCappingStrategyToIntersection(self):
        """
        V.SetCappingStrategyToIntersection()
        C++: void SetCappingStrategyToIntersection()
        
        Specify a strategy for capping. By default the points of the cap
        polygons are located where the extrusion intersects the capping
        surface. However, to preserve planarity, or to place the capping
        surface at the average/minimum/maximum distance of extrusion,
        different strategies can be used. By default the average distance
        is used.
        
        Note if none of the extrusion rays intersect the trim surface,
        then capping is not performed, nor is an extrusion skirt sent to
        the output. Also note that if the capping strategy is set to
        INTERSECTION, and one of the extrusion rays of the generating
        primitive does not intersect the trim surface, then no output
        will be generated for that primitive. However if any other
        capping strategy is used, capping will succeed if at least one
        extrusion ray strikes the trim surface (although missed extrusion
        ray intersections will not factor into the determination of final
        cap location).
        
        Finally, note that any capping strategy other than INTERSECTION
        may produce more points than expected because the output
        primitives may have to be "split apart" to satisy the capping
        constraint.
        """
        ...
    
    def SetCappingStrategyToMaximumDistance(self):
        """
        V.SetCappingStrategyToMaximumDistance()
        C++: void SetCappingStrategyToMaximumDistance()
        
        Specify a strategy for capping. By default the points of the cap
        polygons are located where the extrusion intersects the capping
        surface. However, to preserve planarity, or to place the capping
        surface at the average/minimum/maximum distance of extrusion,
        different strategies can be used. By default the average distance
        is used.
        
        Note if none of the extrusion rays intersect the trim surface,
        then capping is not performed, nor is an extrusion skirt sent to
        the output. Also note that if the capping strategy is set to
        INTERSECTION, and one of the extrusion rays of the generating
        primitive does not intersect the trim surface, then no output
        will be generated for that primitive. However if any other
        capping strategy is used, capping will succeed if at least one
        extrusion ray strikes the trim surface (although missed extrusion
        ray intersections will not factor into the determination of final
        cap location).
        
        Finally, note that any capping strategy other than INTERSECTION
        may produce more points than expected because the output
        primitives may have to be "split apart" to satisy the capping
        constraint.
        """
        ...
    
    def SetCappingStrategyToMinimumDistance(self):
        """
        V.SetCappingStrategyToMinimumDistance()
        C++: void SetCappingStrategyToMinimumDistance()
        
        Specify a strategy for capping. By default the points of the cap
        polygons are located where the extrusion intersects the capping
        surface. However, to preserve planarity, or to place the capping
        surface at the average/minimum/maximum distance of extrusion,
        different strategies can be used. By default the average distance
        is used.
        
        Note if none of the extrusion rays intersect the trim surface,
        then capping is not performed, nor is an extrusion skirt sent to
        the output. Also note that if the capping strategy is set to
        INTERSECTION, and one of the extrusion rays of the generating
        primitive does not intersect the trim surface, then no output
        will be generated for that primitive. However if any other
        capping strategy is used, capping will succeed if at least one
        extrusion ray strikes the trim surface (although missed extrusion
        ray intersections will not factor into the determination of final
        cap location).
        
        Finally, note that any capping strategy other than INTERSECTION
        may produce more points than expected because the output
        primitives may have to be "split apart" to satisy the capping
        constraint.
        """
        ...
    
    def SetExtrusionDirection(self, p_float, p_float_1, p_float_2):
        """
        V.SetExtrusionDirection(float, float, float)
        C++: virtual void SetExtrusionDirection(double _arg1,
            double _arg2, double _arg3)
        V.SetExtrusionDirection((float, float, float))
        C++: virtual void SetExtrusionDirection(const double _arg[3])
        
        Set/Get the extrusion direction.
        """
        ...
    
    def SetExtrusionStrategy(self, p_int):
        """
        V.SetExtrusionStrategy(int)
        C++: virtual void SetExtrusionStrategy(int _arg)
        
        Specify a strategy for extrusion. If the strategy is set to
        "BOUNDARY_EDGES" then the boundary edges of the input polygons
        and triangle strips are swept. (A boundary edge is an edge used
        by only one 2D primitive, e.g., polygon or triangle.)
        Alternatively, all edges can be swept. (This is particularly
        useful when only sinple disconnected polygons exist in the input
        and so boundary calculation can be avoided.) By default boundary
        edges are extruded.
        """
        ...
    
    def SetExtrusionStrategyToAllEdges(self):
        """
        V.SetExtrusionStrategyToAllEdges()
        C++: void SetExtrusionStrategyToAllEdges()
        
        Specify a strategy for extrusion. If the strategy is set to
        "BOUNDARY_EDGES" then the boundary edges of the input polygons
        and triangle strips are swept. (A boundary edge is an edge used
        by only one 2D primitive, e.g., polygon or triangle.)
        Alternatively, all edges can be swept. (This is particularly
        useful when only sinple disconnected polygons exist in the input
        and so boundary calculation can be avoided.) By default boundary
        edges are extruded.
        """
        ...
    
    def SetExtrusionStrategyToBoundaryEdges(self):
        """
        V.SetExtrusionStrategyToBoundaryEdges()
        C++: void SetExtrusionStrategyToBoundaryEdges()
        
        Specify a strategy for extrusion. If the strategy is set to
        "BOUNDARY_EDGES" then the boundary edges of the input polygons
        and triangle strips are swept. (A boundary edge is an edge used
        by only one 2D primitive, e.g., polygon or triangle.)
        Alternatively, all edges can be swept. (This is particularly
        useful when only sinple disconnected polygons exist in the input
        and so boundary calculation can be avoided.) By default boundary
        edges are extruded.
        """
        ...
    
    def SetLocator(self, vtkAbstractCellLocator):
        """
        V.SetLocator(vtkAbstractCellLocator)
        C++: void SetLocator(vtkAbstractCellLocator *locator)
        
        Specify a cell locator. By default a vtkStaticCellLocator is
        used. The locator performs efficient searches to intersect cells.
        """
        ...
    
    def SetTrimSurfaceConnection(self, vtkAlgorithmOutput):
        """
        V.SetTrimSurfaceConnection(vtkAlgorithmOutput)
        C++: void SetTrimSurfaceConnection(vtkAlgorithmOutput *algOutput)
        
        Specify the surface which trims the surface.  Note that the
        method SetTrimSurfaceData does not connect the pipeline. The
        algorithm will work on the input data as it is without updating
        the producer of the data.  The method SetTrimSurfaceConnection
        connects the pipeline.
        """
        ...
    
    def SetTrimSurfaceData(self, vtkPolyData):
        """
        V.SetTrimSurfaceData(vtkPolyData)
        C++: void SetTrimSurfaceData(vtkPolyData *pd)
        
        Specify the surface which trims the surface.  Note that the
        method SetTrimSurfaceData does not connect the pipeline. The
        algorithm will work on the input data as it is without updating
        the producer of the data.  The method SetTrimSurfaceConnection
        connects the pipeline.
        """
        ...
    
    def __delattr__(self, *args, **kwargs):
        """ Implement delattr(self, name). """
        ...
    
    def __getattribute__(self, *args, **kwargs):
        """ Return getattr(self, name). """
        ...
    
    def __init__(self, *args, **kwargs) -> None:
        ...
    
    @staticmethod
    def __new__(*args, **kwargs):
        """ Create and return a new object.  See help(type) for accurate signature. """
        ...
    
    def __repr__(self, *args, **kwargs):
        """ Return repr(self). """
        ...
    
    def __setattr__(self, *args, **kwargs):
        """ Implement setattr(self, name, value). """
        ...
    
    def __str__(self, *args, **kwargs) -> str:
        """ Return str(self). """
        ...
    
    __this__ = ...
    ALL_EDGES = ...
    AVERAGE_DISTANCE = ...
    BOUNDARY_EDGES = ...
    CappingStrategy = ...
    ExtrusionStrategy = ...
    INTERSECTION = ...
    MAXIMUM_DISTANCE = ...
    MINIMUM_DISTANCE = ...
    __dict__ = ...
    __vtkname__ = ...


