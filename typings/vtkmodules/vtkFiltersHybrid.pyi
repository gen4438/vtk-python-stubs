"""
This type stub file was generated by pyright.
"""

import vtkmodules.vtkCommonCore as __vtkmodules_vtkCommonCore
import vtkmodules.vtkCommonExecutionModel as __vtkmodules_vtkCommonExecutionModel
import vtkmodules.vtkCommonTransforms as __vtkmodules_vtkCommonTransforms
import vtkmodules.vtkFiltersGeometry as __vtkmodules_vtkFiltersGeometry

VTK_BSPLINE_EDGE = ...
VTK_BSPLINE_ZERO = ...
VTK_BSPLINE_ZERO_AT_BORDER = ...
VTK_CELL_MODE = ...
VTK_COLOR_MODE_LINEAR_256 = ...
VTK_COLOR_MODE_LUT = ...
VTK_ERROR_ABSOLUTE = ...
VTK_ERROR_NUMBER_OF_TRIANGLES = ...
VTK_ERROR_RELATIVE = ...
VTK_ERROR_SPECIFIED_REDUCTION = ...
VTK_GRID_CUBIC = ...
VTK_GRID_LINEAR = ...
VTK_GRID_NEAREST = ...
VTK_STYLE_PIXELIZE = ...
VTK_STYLE_POLYGONALIZE = ...
VTK_STYLE_RUN_LENGTH = ...
VTK_VOXEL_MODE = ...
class vtkAdaptiveDataSetSurfaceFilter(__vtkmodules_vtkFiltersGeometry.vtkGeometryFilter):
    """
    vtkAdaptiveDataSetSurfaceFilter - Adaptively extract dataset surface
    
    Superclass: vtkGeometryFilter
    
    vtkAdaptiveDataSetSurfaceFilter uses view and dataset properties to
    create the outside surface mesh with the minimum minimorum of facets
    @warning
    Only implemented currently for 2-dimensional vtkHyperTreeGrid objects
    @sa
    vtkHyperTreeGrid vtkDataSetSurfaceFilter@par Thanks: This class was
    written by Guenole Harel and Jacques-Bernard Lekien, 2014 This class
    was rewritten by Philippe Pebay, 2016 This class was modified by
    Rogeli Grima, 2016 This work was supported by Commissariat a
    l'Energie Atomique (CEA/DIF) CEA, DAM, DIF, F-91297 Arpajon, France.
    """
    def GetBBSelection(self):
        """
        V.GetBBSelection() -> bool
        C++: virtual bool GetBBSelection()
        
        Set/Get for active the bounding box selection viewport (defaut
        false) JB C'est un facteur supplementaire d'acceleration possible
        JB uniquement si l'on ne peut faire de rotation dans la vue.
        """
        ...
    
    def GetCircleSelection(self):
        """
        V.GetCircleSelection() -> bool
        C++: virtual bool GetCircleSelection()
        
        Set/Get for active the circle selection viewport (defaut true)
        """
        ...
    
    def GetDynamicDecimateLevelMax(self):
        """
        V.GetDynamicDecimateLevelMax() -> int
        C++: virtual int GetDynamicDecimateLevelMax()
        
        JB Set/Get reduit de autant le niveau max de profondeur, calcule
        JB dynamiquement a parcourir dans la JB representation HTG.
        (defaut 0)
        """
        ...
    
    def GetFixedLevelMax(self):
        """
        V.GetFixedLevelMax() -> int
        C++: virtual int GetFixedLevelMax()
        
        Set/Get for forced a fixed the level max (lost dynamicity)
        (defaut -1)
        """
        ...
    
    def GetMTime(self):
        """
        V.GetMTime() -> int
        C++: vtkMTimeType GetMTime() override;
        
        Get the mtime of this object.
        """
        ...
    
    def GetNumberOfGenerationsFromBase(self, string):
        """
        V.GetNumberOfGenerationsFromBase(string) -> int
        C++: vtkIdType GetNumberOfGenerationsFromBase(const char *type)
            override;
        
        Given a the name of a base class of this class type, return the
        distance of inheritance between this class type and the named
        class (how many generations of inheritance are there between this
        class and the named class). If the named class is not in this
        class's inheritance tree, return a negative value. Valid
        responses will always be nonnegative. This method works in
        combination with vtkTypeMacro found in vtkSetGet.h.
        """
        ...
    
    def GetNumberOfGenerationsFromBaseType(self, string):
        """
        V.GetNumberOfGenerationsFromBaseType(string) -> int
        C++: static vtkIdType GetNumberOfGenerationsFromBaseType(
            const char *type)
        
        Given a the name of a base class of this class type, return the
        distance of inheritance between this class type and the named
        class (how many generations of inheritance are there between this
        class and the named class). If the named class is not in this
        class's inheritance tree, return a negative value. Valid
        responses will always be nonnegative. This method works in
        combination with vtkTypeMacro found in vtkSetGet.h.
        """
        ...
    
    def GetRenderer(self):
        """
        V.GetRenderer() -> vtkRenderer
        C++: virtual vtkRenderer *GetRenderer()
        
        Set/Get the renderer attached to this adaptive surface extractor
        """
        ...
    
    def GetScale(self):
        """
        V.GetScale() -> float
        C++: virtual double GetScale()
        
        JB Set/Get the scale factor influence le calcul de l'adaptive
        view. JB Pour un raffinement de 2, donner Scale=2*X revient a
        faire un JB appel a DynamicDecimateLevelMax avec la valeur X.
        (defaut 1)
        """
        ...
    
    def GetViewPointDepend(self):
        """
        V.GetViewPointDepend() -> bool
        C++: virtual bool GetViewPointDepend()
        
        JB Activation de la dependance au point de vue. Par defaut a
        True.
        """
        ...
    
    def IsA(self, string):
        """
        V.IsA(string) -> int
        C++: vtkTypeBool IsA(const char *type) override;
        
        Return 1 if this class is the same type of (or a subclass of) the
        named class. Returns 0 otherwise. This method works in
        combination with vtkTypeMacro found in vtkSetGet.h.
        """
        ...
    
    def IsTypeOf(self, string):
        """
        V.IsTypeOf(string) -> int
        C++: static vtkTypeBool IsTypeOf(const char *type)
        
        Return 1 if this class type is the same type of (or a subclass
        of) the named class. Returns 0 otherwise. This method works in
        combination with vtkTypeMacro found in vtkSetGet.h.
        """
        ...
    
    def NewInstance(self):
        """
        V.NewInstance() -> vtkAdaptiveDataSetSurfaceFilter
        C++: vtkAdaptiveDataSetSurfaceFilter *NewInstance()
        """
        ...
    
    def SafeDownCast(self, vtkObjectBase):
        """
        V.SafeDownCast(vtkObjectBase) -> vtkAdaptiveDataSetSurfaceFilter
        C++: static vtkAdaptiveDataSetSurfaceFilter *SafeDownCast(
            vtkObjectBase *o)
        """
        ...
    
    def SetBBSelection(self, bool):
        """
        V.SetBBSelection(bool)
        C++: virtual void SetBBSelection(bool _arg)
        
        Set/Get for active the bounding box selection viewport (defaut
        false) JB C'est un facteur supplementaire d'acceleration possible
        JB uniquement si l'on ne peut faire de rotation dans la vue.
        """
        ...
    
    def SetCircleSelection(self, bool):
        """
        V.SetCircleSelection(bool)
        C++: virtual void SetCircleSelection(bool _arg)
        
        Set/Get for active the circle selection viewport (defaut true)
        """
        ...
    
    def SetDynamicDecimateLevelMax(self, p_int):
        """
        V.SetDynamicDecimateLevelMax(int)
        C++: virtual void SetDynamicDecimateLevelMax(int _arg)
        
        JB Set/Get reduit de autant le niveau max de profondeur, calcule
        JB dynamiquement a parcourir dans la JB representation HTG.
        (defaut 0)
        """
        ...
    
    def SetFixedLevelMax(self, p_int):
        """
        V.SetFixedLevelMax(int)
        C++: virtual void SetFixedLevelMax(int _arg)
        
        Set/Get for forced a fixed the level max (lost dynamicity)
        (defaut -1)
        """
        ...
    
    def SetRenderer(self, vtkRenderer):
        """
        V.SetRenderer(vtkRenderer)
        C++: void SetRenderer(vtkRenderer *ren)
        
        Set/Get the renderer attached to this adaptive surface extractor
        """
        ...
    
    def SetScale(self, p_float):
        """
        V.SetScale(float)
        C++: virtual void SetScale(double _arg)
        
        JB Set/Get the scale factor influence le calcul de l'adaptive
        view. JB Pour un raffinement de 2, donner Scale=2*X revient a
        faire un JB appel a DynamicDecimateLevelMax avec la valeur X.
        (defaut 1)
        """
        ...
    
    def SetViewPointDepend(self, bool):
        """
        V.SetViewPointDepend(bool)
        C++: virtual void SetViewPointDepend(bool _arg)
        
        JB Activation de la dependance au point de vue. Par defaut a
        True.
        """
        ...
    
    def __delattr__(self, *args, **kwargs):
        """ Implement delattr(self, name). """
        ...
    
    def __getattribute__(self, *args, **kwargs):
        """ Return getattr(self, name). """
        ...
    
    def __init__(self, *args, **kwargs) -> None:
        ...
    
    @staticmethod
    def __new__(*args, **kwargs):
        """ Create and return a new object.  See help(type) for accurate signature. """
        ...
    
    def __repr__(self, *args, **kwargs):
        """ Return repr(self). """
        ...
    
    def __setattr__(self, *args, **kwargs):
        """ Implement setattr(self, name, value). """
        ...
    
    def __str__(self, *args, **kwargs) -> str:
        """ Return str(self). """
        ...
    
    __this__ = ...
    __dict__ = ...
    __vtkname__ = ...


class vtkBSplineTransform(__vtkmodules_vtkCommonTransforms.vtkWarpTransform):
    """
    vtkBSplineTransform - a cubic b-spline deformation transformation
    
    Superclass: vtkWarpTransform
    
    vtkBSplineTransform computes a cubic b-spline transformation from a
    grid of b-spline coefficients.
    @warning
    The inverse grid transform is calculated using an iterative method,
    and is several times more expensive than the forward transform.
    @sa
    vtkGeneralTransform vtkTransformToGrid
    vtkImageBSplineCoefficients@par Thanks: This class was written by
    David Gobbi at the Seaman Family MR Research Centre, Foothills
    Medical Centre, Calgary, Alberta. DG Gobbi and YP Starreveld, "Uniform B-Splines for the VTK Imaging
    Pipeline," VTK Journal, 2011, http://hdl.handle.net/10380/3252
    """
    def GetBorderMode(self):
        """
        V.GetBorderMode() -> int
        C++: virtual int GetBorderMode()
        
        Set/Get the border mode, to alter behavior at the edge of the
        grid. The Edge mode allows the displacement to converge to the
        edge coefficient past the boundary, which is similar to the
        behavior of the vtkGridTransform. The Zero mode allows the
        displacement to smoothly converge to zero two node-spacings past
        the boundary, which is useful when you want to create a localized
        transform. The ZeroAtBorder mode sacrifices smoothness to further
        localize the transform to just one node-spacing past the
        boundary.
        """
        ...
    
    def GetBorderModeAsString(self):
        """
        V.GetBorderModeAsString() -> string
        C++: const char *GetBorderModeAsString()
        
        Set/Get the border mode, to alter behavior at the edge of the
        grid. The Edge mode allows the displacement to converge to the
        edge coefficient past the boundary, which is similar to the
        behavior of the vtkGridTransform. The Zero mode allows the
        displacement to smoothly converge to zero two node-spacings past
        the boundary, which is useful when you want to create a localized
        transform. The ZeroAtBorder mode sacrifices smoothness to further
        localize the transform to just one node-spacing past the
        boundary.
        """
        ...
    
    def GetBorderModeMaxValue(self):
        """
        V.GetBorderModeMaxValue() -> int
        C++: virtual int GetBorderModeMaxValue()
        
        Set/Get the border mode, to alter behavior at the edge of the
        grid. The Edge mode allows the displacement to converge to the
        edge coefficient past the boundary, which is similar to the
        behavior of the vtkGridTransform. The Zero mode allows the
        displacement to smoothly converge to zero two node-spacings past
        the boundary, which is useful when you want to create a localized
        transform. The ZeroAtBorder mode sacrifices smoothness to further
        localize the transform to just one node-spacing past the
        boundary.
        """
        ...
    
    def GetBorderModeMinValue(self):
        """
        V.GetBorderModeMinValue() -> int
        C++: virtual int GetBorderModeMinValue()
        
        Set/Get the border mode, to alter behavior at the edge of the
        grid. The Edge mode allows the displacement to converge to the
        edge coefficient past the boundary, which is similar to the
        behavior of the vtkGridTransform. The Zero mode allows the
        displacement to smoothly converge to zero two node-spacings past
        the boundary, which is useful when you want to create a localized
        transform. The ZeroAtBorder mode sacrifices smoothness to further
        localize the transform to just one node-spacing past the
        boundary.
        """
        ...
    
    def GetCoefficientData(self):
        """
        V.GetCoefficientData() -> vtkImageData
        C++: virtual vtkImageData *GetCoefficientData()
        
        Set/Get the coefficient grid for the b-spline transform. The
        vtkBSplineTransform class will never modify the data. Note that
        SetCoefficientData() does not setup a pipeline connection whereas
        SetCoefficientConnection does.
        """
        ...
    
    def GetDisplacementScale(self):
        """
        V.GetDisplacementScale() -> float
        C++: virtual double GetDisplacementScale()
        
        Set/Get a scale to apply to the transformation.
        """
        ...
    
    def GetMTime(self):
        """
        V.GetMTime() -> int
        C++: vtkMTimeType GetMTime() override;
        
        Get the MTime.
        """
        ...
    
    def GetNumberOfGenerationsFromBase(self, string):
        """
        V.GetNumberOfGenerationsFromBase(string) -> int
        C++: vtkIdType GetNumberOfGenerationsFromBase(const char *type)
            override;
        
        Given a the name of a base class of this class type, return the
        distance of inheritance between this class type and the named
        class (how many generations of inheritance are there between this
        class and the named class). If the named class is not in this
        class's inheritance tree, return a negative value. Valid
        responses will always be nonnegative. This method works in
        combination with vtkTypeMacro found in vtkSetGet.h.
        """
        ...
    
    def GetNumberOfGenerationsFromBaseType(self, string):
        """
        V.GetNumberOfGenerationsFromBaseType(string) -> int
        C++: static vtkIdType GetNumberOfGenerationsFromBaseType(
            const char *type)
        
        Given a the name of a base class of this class type, return the
        distance of inheritance between this class type and the named
        class (how many generations of inheritance are there between this
        class and the named class). If the named class is not in this
        class's inheritance tree, return a negative value. Valid
        responses will always be nonnegative. This method works in
        combination with vtkTypeMacro found in vtkSetGet.h.
        """
        ...
    
    def IsA(self, string):
        """
        V.IsA(string) -> int
        C++: vtkTypeBool IsA(const char *type) override;
        
        Return 1 if this class is the same type of (or a subclass of) the
        named class. Returns 0 otherwise. This method works in
        combination with vtkTypeMacro found in vtkSetGet.h.
        """
        ...
    
    def IsTypeOf(self, string):
        """
        V.IsTypeOf(string) -> int
        C++: static vtkTypeBool IsTypeOf(const char *type)
        
        Return 1 if this class type is the same type of (or a subclass
        of) the named class. Returns 0 otherwise. This method works in
        combination with vtkTypeMacro found in vtkSetGet.h.
        """
        ...
    
    def MakeTransform(self):
        """
        V.MakeTransform() -> vtkAbstractTransform
        C++: vtkAbstractTransform *MakeTransform() override;
        
        Make another transform of the same type.
        """
        ...
    
    def NewInstance(self):
        """
        V.NewInstance() -> vtkBSplineTransform
        C++: vtkBSplineTransform *NewInstance()
        """
        ...
    
    def SafeDownCast(self, vtkObjectBase):
        """
        V.SafeDownCast(vtkObjectBase) -> vtkBSplineTransform
        C++: static vtkBSplineTransform *SafeDownCast(vtkObjectBase *o)
        """
        ...
    
    def SetBorderMode(self, p_int):
        """
        V.SetBorderMode(int)
        C++: virtual void SetBorderMode(int _arg)
        
        Set/Get the border mode, to alter behavior at the edge of the
        grid. The Edge mode allows the displacement to converge to the
        edge coefficient past the boundary, which is similar to the
        behavior of the vtkGridTransform. The Zero mode allows the
        displacement to smoothly converge to zero two node-spacings past
        the boundary, which is useful when you want to create a localized
        transform. The ZeroAtBorder mode sacrifices smoothness to further
        localize the transform to just one node-spacing past the
        boundary.
        """
        ...
    
    def SetBorderModeToEdge(self):
        """
        V.SetBorderModeToEdge()
        C++: void SetBorderModeToEdge()
        
        Set/Get the border mode, to alter behavior at the edge of the
        grid. The Edge mode allows the displacement to converge to the
        edge coefficient past the boundary, which is similar to the
        behavior of the vtkGridTransform. The Zero mode allows the
        displacement to smoothly converge to zero two node-spacings past
        the boundary, which is useful when you want to create a localized
        transform. The ZeroAtBorder mode sacrifices smoothness to further
        localize the transform to just one node-spacing past the
        boundary.
        """
        ...
    
    def SetBorderModeToZero(self):
        """
        V.SetBorderModeToZero()
        C++: void SetBorderModeToZero()
        
        Set/Get the border mode, to alter behavior at the edge of the
        grid. The Edge mode allows the displacement to converge to the
        edge coefficient past the boundary, which is similar to the
        behavior of the vtkGridTransform. The Zero mode allows the
        displacement to smoothly converge to zero two node-spacings past
        the boundary, which is useful when you want to create a localized
        transform. The ZeroAtBorder mode sacrifices smoothness to further
        localize the transform to just one node-spacing past the
        boundary.
        """
        ...
    
    def SetBorderModeToZeroAtBorder(self):
        """
        V.SetBorderModeToZeroAtBorder()
        C++: void SetBorderModeToZeroAtBorder()
        
        Set/Get the border mode, to alter behavior at the edge of the
        grid. The Edge mode allows the displacement to converge to the
        edge coefficient past the boundary, which is similar to the
        behavior of the vtkGridTransform. The Zero mode allows the
        displacement to smoothly converge to zero two node-spacings past
        the boundary, which is useful when you want to create a localized
        transform. The ZeroAtBorder mode sacrifices smoothness to further
        localize the transform to just one node-spacing past the
        boundary.
        """
        ...
    
    def SetCoefficientConnection(self, vtkAlgorithmOutput):
        """
        V.SetCoefficientConnection(vtkAlgorithmOutput)
        C++: virtual void SetCoefficientConnection(vtkAlgorithmOutput *)
        
        Set/Get the coefficient grid for the b-spline transform. The
        vtkBSplineTransform class will never modify the data. Note that
        SetCoefficientData() does not setup a pipeline connection whereas
        SetCoefficientConnection does.
        """
        ...
    
    def SetCoefficientData(self, vtkImageData):
        """
        V.SetCoefficientData(vtkImageData)
        C++: virtual void SetCoefficientData(vtkImageData *)
        
        Set/Get the coefficient grid for the b-spline transform. The
        vtkBSplineTransform class will never modify the data. Note that
        SetCoefficientData() does not setup a pipeline connection whereas
        SetCoefficientConnection does.
        """
        ...
    
    def SetDisplacementScale(self, p_float):
        """
        V.SetDisplacementScale(float)
        C++: virtual void SetDisplacementScale(double _arg)
        
        Set/Get a scale to apply to the transformation.
        """
        ...
    
    def __delattr__(self, *args, **kwargs):
        """ Implement delattr(self, name). """
        ...
    
    def __getattribute__(self, *args, **kwargs):
        """ Return getattr(self, name). """
        ...
    
    def __init__(self, *args, **kwargs) -> None:
        ...
    
    @staticmethod
    def __new__(*args, **kwargs):
        """ Create and return a new object.  See help(type) for accurate signature. """
        ...
    
    def __repr__(self, *args, **kwargs):
        """ Return repr(self). """
        ...
    
    def __setattr__(self, *args, **kwargs):
        """ Implement setattr(self, name, value). """
        ...
    
    def __str__(self, *args, **kwargs) -> str:
        """ Return str(self). """
        ...
    
    __this__ = ...
    __dict__ = ...
    __vtkname__ = ...


class vtkDepthSortPolyData(__vtkmodules_vtkCommonExecutionModel.vtkPolyDataAlgorithm):
    """
    vtkDepthSortPolyData - sort poly data along camera view direction
    
    Superclass: vtkPolyDataAlgorithm
    
    vtkDepthSortPolyData rearranges the order of cells so that certain
    rendering operations (e.g., transparency or Painter's algorithms)
    generate correct results. To use this filter you must specify the
    direction vector along which to sort the cells. You can do this by
    specifying a camera and/or prop to define a view direction; or
    explicitly set a view direction.
    
    @warning
    The sort operation will not work well for long, thin primitives, or
    cells that intersect, overlap, or interpenetrate each other.
    """
    def GetCamera(self):
        """
        V.GetCamera() -> vtkCamera
        C++: virtual vtkCamera *GetCamera()
        
        Specify a camera that is used to define a view direction along
        which the cells are sorted. This ivar only has effect if the
        direction is set to front-to-back or back-to-front, and a camera
        is specified.
        """
        ...
    
    def GetDepthSortMode(self):
        """
        V.GetDepthSortMode() -> int
        C++: virtual int GetDepthSortMode()
        
        Specify the point to use when sorting. The fastest is to just
        take the first cell point. Other options are to take the bounding
        box center or the parametric center of the cell. By default, the
        first cell point is used.
        """
        ...
    
    def GetDirection(self):
        """
        V.GetDirection() -> int
        C++: virtual int GetDirection()
        
        Specify the sort method for the polygonal primitives. By default,
        the poly data is sorted from back to front.
        """
        ...
    
    def GetMTime(self):
        """
        V.GetMTime() -> int
        C++: vtkMTimeType GetMTime() override;
        
        Return MTime also considering the dependent objects: the camera
        and/or the prop3D.
        """
        ...
    
    def GetNumberOfGenerationsFromBase(self, string):
        """
        V.GetNumberOfGenerationsFromBase(string) -> int
        C++: vtkIdType GetNumberOfGenerationsFromBase(const char *type)
            override;
        
        Given a the name of a base class of this class type, return the
        distance of inheritance between this class type and the named
        class (how many generations of inheritance are there between this
        class and the named class). If the named class is not in this
        class's inheritance tree, return a negative value. Valid
        responses will always be nonnegative. This method works in
        combination with vtkTypeMacro found in vtkSetGet.h.
        """
        ...
    
    def GetNumberOfGenerationsFromBaseType(self, string):
        """
        V.GetNumberOfGenerationsFromBaseType(string) -> int
        C++: static vtkIdType GetNumberOfGenerationsFromBaseType(
            const char *type)
        
        Given a the name of a base class of this class type, return the
        distance of inheritance between this class type and the named
        class (how many generations of inheritance are there between this
        class and the named class). If the named class is not in this
        class's inheritance tree, return a negative value. Valid
        responses will always be nonnegative. This method works in
        combination with vtkTypeMacro found in vtkSetGet.h.
        """
        ...
    
    def GetOrigin(self):
        """
        V.GetOrigin() -> (float, float, float)
        C++: virtual double *GetOrigin()
        
        Set/Get the sort origin. This ivar only has effect if the sort
        direction is set to SetDirectionToSpecifiedVector(). The sort
        occurs in the direction of the vector, with this point specifying
        the origin.
        """
        ...
    
    def GetProp3D(self):
        """
        V.GetProp3D() -> vtkProp3D
        C++: vtkProp3D *GetProp3D()
        """
        ...
    
    def GetSortScalars(self):
        """
        V.GetSortScalars() -> int
        C++: virtual vtkTypeBool GetSortScalars()
        
        Set/Get a flag that controls the generation of scalar values
        corresponding to the sort order. If enabled, the output of this
        filter will include scalar values that range from 0 to
        (ncells-1), where 0 is closest to the sort direction.
        """
        ...
    
    def GetVector(self):
        """
        V.GetVector() -> (float, float, float)
        C++: virtual double *GetVector()
        
        Set/Get the sort direction. This ivar only has effect if the sort
        direction is set to SetDirectionToSpecifiedVector(). The sort
        occurs in the direction of the vector.
        """
        ...
    
    def IsA(self, string):
        """
        V.IsA(string) -> int
        C++: vtkTypeBool IsA(const char *type) override;
        
        Return 1 if this class is the same type of (or a subclass of) the
        named class. Returns 0 otherwise. This method works in
        combination with vtkTypeMacro found in vtkSetGet.h.
        """
        ...
    
    def IsTypeOf(self, string):
        """
        V.IsTypeOf(string) -> int
        C++: static vtkTypeBool IsTypeOf(const char *type)
        
        Return 1 if this class type is the same type of (or a subclass
        of) the named class. Returns 0 otherwise. This method works in
        combination with vtkTypeMacro found in vtkSetGet.h.
        """
        ...
    
    def NewInstance(self):
        """
        V.NewInstance() -> vtkDepthSortPolyData
        C++: vtkDepthSortPolyData *NewInstance()
        """
        ...
    
    def SafeDownCast(self, vtkObjectBase):
        """
        V.SafeDownCast(vtkObjectBase) -> vtkDepthSortPolyData
        C++: static vtkDepthSortPolyData *SafeDownCast(vtkObjectBase *o)
        """
        ...
    
    def SetCamera(self, vtkCamera):
        """
        V.SetCamera(vtkCamera)
        C++: virtual void SetCamera(vtkCamera *)
        
        Specify a camera that is used to define a view direction along
        which the cells are sorted. This ivar only has effect if the
        direction is set to front-to-back or back-to-front, and a camera
        is specified.
        """
        ...
    
    def SetDepthSortMode(self, p_int):
        """
        V.SetDepthSortMode(int)
        C++: virtual void SetDepthSortMode(int _arg)
        
        Specify the point to use when sorting. The fastest is to just
        take the first cell point. Other options are to take the bounding
        box center or the parametric center of the cell. By default, the
        first cell point is used.
        """
        ...
    
    def SetDepthSortModeToBoundsCenter(self):
        """
        V.SetDepthSortModeToBoundsCenter()
        C++: void SetDepthSortModeToBoundsCenter()
        
        Specify the point to use when sorting. The fastest is to just
        take the first cell point. Other options are to take the bounding
        box center or the parametric center of the cell. By default, the
        first cell point is used.
        """
        ...
    
    def SetDepthSortModeToFirstPoint(self):
        """
        V.SetDepthSortModeToFirstPoint()
        C++: void SetDepthSortModeToFirstPoint()
        
        Specify the point to use when sorting. The fastest is to just
        take the first cell point. Other options are to take the bounding
        box center or the parametric center of the cell. By default, the
        first cell point is used.
        """
        ...
    
    def SetDepthSortModeToParametricCenter(self):
        """
        V.SetDepthSortModeToParametricCenter()
        C++: void SetDepthSortModeToParametricCenter()
        
        Specify the point to use when sorting. The fastest is to just
        take the first cell point. Other options are to take the bounding
        box center or the parametric center of the cell. By default, the
        first cell point is used.
        """
        ...
    
    def SetDirection(self, p_int):
        """
        V.SetDirection(int)
        C++: virtual void SetDirection(int _arg)
        
        Specify the sort method for the polygonal primitives. By default,
        the poly data is sorted from back to front.
        """
        ...
    
    def SetDirectionToBackToFront(self):
        """
        V.SetDirectionToBackToFront()
        C++: void SetDirectionToBackToFront()
        
        Specify the sort method for the polygonal primitives. By default,
        the poly data is sorted from back to front.
        """
        ...
    
    def SetDirectionToFrontToBack(self):
        """
        V.SetDirectionToFrontToBack()
        C++: void SetDirectionToFrontToBack()
        
        Specify the sort method for the polygonal primitives. By default,
        the poly data is sorted from back to front.
        """
        ...
    
    def SetDirectionToSpecifiedVector(self):
        """
        V.SetDirectionToSpecifiedVector()
        C++: void SetDirectionToSpecifiedVector()
        
        Specify the sort method for the polygonal primitives. By default,
        the poly data is sorted from back to front.
        """
        ...
    
    def SetOrigin(self, p_float, p_float_1, p_float_2):
        """
        V.SetOrigin(float, float, float)
        C++: virtual void SetOrigin(double _arg1, double _arg2,
            double _arg3)
        V.SetOrigin((float, float, float))
        C++: virtual void SetOrigin(const double _arg[3])
        
        Set/Get the sort origin. This ivar only has effect if the sort
        direction is set to SetDirectionToSpecifiedVector(). The sort
        occurs in the direction of the vector, with this point specifying
        the origin.
        """
        ...
    
    def SetProp3D(self, vtkProp3D):
        """
        V.SetProp3D(vtkProp3D)
        C++: void SetProp3D(vtkProp3D *)
        
        Specify a transformation matrix (via the vtkProp3D::GetMatrix()
        method) that is used to include the effects of transformation.
        This ivar only has effect if the direction is set to
        front-to-back or back-to-front, and a camera is specified.
        Specifying the vtkProp3D is optional.
        """
        ...
    
    def SetSortScalars(self, p_int):
        """
        V.SetSortScalars(int)
        C++: virtual void SetSortScalars(vtkTypeBool _arg)
        
        Set/Get a flag that controls the generation of scalar values
        corresponding to the sort order. If enabled, the output of this
        filter will include scalar values that range from 0 to
        (ncells-1), where 0 is closest to the sort direction.
        """
        ...
    
    def SetVector(self, p_float, p_float_1, p_float_2):
        """
        V.SetVector(float, float, float)
        C++: virtual void SetVector(double _arg1, double _arg2,
            double _arg3)
        V.SetVector((float, float, float))
        C++: virtual void SetVector(const double _arg[3])
        
        Set/Get the sort direction. This ivar only has effect if the sort
        direction is set to SetDirectionToSpecifiedVector(). The sort
        occurs in the direction of the vector.
        """
        ...
    
    def SortScalarsOff(self):
        """
        V.SortScalarsOff()
        C++: virtual void SortScalarsOff()
        
        Set/Get a flag that controls the generation of scalar values
        corresponding to the sort order. If enabled, the output of this
        filter will include scalar values that range from 0 to
        (ncells-1), where 0 is closest to the sort direction.
        """
        ...
    
    def SortScalarsOn(self):
        """
        V.SortScalarsOn()
        C++: virtual void SortScalarsOn()
        
        Set/Get a flag that controls the generation of scalar values
        corresponding to the sort order. If enabled, the output of this
        filter will include scalar values that range from 0 to
        (ncells-1), where 0 is closest to the sort direction.
        """
        ...
    
    def __delattr__(self, *args, **kwargs):
        """ Implement delattr(self, name). """
        ...
    
    def __getattribute__(self, *args, **kwargs):
        """ Return getattr(self, name). """
        ...
    
    def __init__(self, *args, **kwargs) -> None:
        ...
    
    @staticmethod
    def __new__(*args, **kwargs):
        """ Create and return a new object.  See help(type) for accurate signature. """
        ...
    
    def __repr__(self, *args, **kwargs):
        """ Return repr(self). """
        ...
    
    def __setattr__(self, *args, **kwargs):
        """ Implement setattr(self, name, value). """
        ...
    
    def __str__(self, *args, **kwargs) -> str:
        """ Return str(self). """
        ...
    
    __this__ = ...
    Directions = ...
    SortMode = ...
    VTK_DIRECTION_BACK_TO_FRONT = ...
    VTK_DIRECTION_FRONT_TO_BACK = ...
    VTK_DIRECTION_SPECIFIED_VECTOR = ...
    VTK_SORT_BOUNDS_CENTER = ...
    VTK_SORT_FIRST_POINT = ...
    VTK_SORT_PARAMETRIC_CENTER = ...
    __dict__ = ...
    __vtkname__ = ...


class vtkDSPFilterDefinition(__vtkmodules_vtkCommonCore.vtkObject):
    """
    vtkDSPFilterDefinition - used by the Exodus readers
    
    Superclass: vtkObject
    
    vtkDSPFilterDefinition is used by vtkExodusReader, vtkExodusIIReader
    and vtkPExodusReader to do temporal smoothing of data
    @sa
    vtkDSPFilterGroup vtkExodusReader vtkExodusIIReader vtkPExodusReader
    """
    def Clear(self):
        """
        V.Clear()
        C++: void Clear()
        """
        ...
    
    def Copy(self, vtkDSPFilterDefinition):
        """
        V.Copy(vtkDSPFilterDefinition)
        C++: void Copy(vtkDSPFilterDefinition *other)
        """
        ...
    
    def GetDenominatorWeight(self, p_int):
        """
        V.GetDenominatorWeight(int) -> float
        C++: double GetDenominatorWeight(int a_which)
        """
        ...
    
    def GetForwardNumeratorWeight(self, p_int):
        """
        V.GetForwardNumeratorWeight(int) -> float
        C++: double GetForwardNumeratorWeight(int a_which)
        """
        ...
    
    def GetInputVariableName(self):
        """
        V.GetInputVariableName() -> string
        C++: const char *GetInputVariableName()
        """
        ...
    
    def GetNumberOfGenerationsFromBase(self, string):
        """
        V.GetNumberOfGenerationsFromBase(string) -> int
        C++: vtkIdType GetNumberOfGenerationsFromBase(const char *type)
            override;
        
        Given a the name of a base class of this class type, return the
        distance of inheritance between this class type and the named
        class (how many generations of inheritance are there between this
        class and the named class). If the named class is not in this
        class's inheritance tree, return a negative value. Valid
        responses will always be nonnegative. This method works in
        combination with vtkTypeMacro found in vtkSetGet.h.
        """
        ...
    
    def GetNumberOfGenerationsFromBaseType(self, string):
        """
        V.GetNumberOfGenerationsFromBaseType(string) -> int
        C++: static vtkIdType GetNumberOfGenerationsFromBaseType(
            const char *type)
        
        Given a the name of a base class of this class type, return the
        distance of inheritance between this class type and the named
        class (how many generations of inheritance are there between this
        class and the named class). If the named class is not in this
        class's inheritance tree, return a negative value. Valid
        responses will always be nonnegative. This method works in
        combination with vtkTypeMacro found in vtkSetGet.h.
        """
        ...
    
    def GetNumDenominatorWeights(self):
        """
        V.GetNumDenominatorWeights() -> int
        C++: int GetNumDenominatorWeights()
        """
        ...
    
    def GetNumeratorWeight(self, p_int):
        """
        V.GetNumeratorWeight(int) -> float
        C++: double GetNumeratorWeight(int a_which)
        """
        ...
    
    def GetNumForwardNumeratorWeights(self):
        """
        V.GetNumForwardNumeratorWeights() -> int
        C++: int GetNumForwardNumeratorWeights()
        """
        ...
    
    def GetNumNumeratorWeights(self):
        """
        V.GetNumNumeratorWeights() -> int
        C++: int GetNumNumeratorWeights()
        """
        ...
    
    def GetOutputVariableName(self):
        """
        V.GetOutputVariableName() -> string
        C++: const char *GetOutputVariableName()
        """
        ...
    
    def IsA(self, string):
        """
        V.IsA(string) -> int
        C++: vtkTypeBool IsA(const char *type) override;
        
        Return 1 if this class is the same type of (or a subclass of) the
        named class. Returns 0 otherwise. This method works in
        combination with vtkTypeMacro found in vtkSetGet.h.
        """
        ...
    
    def IsThisInputVariableInstanceNeeded(self, p_int, p_int_1):
        """
        V.IsThisInputVariableInstanceNeeded(int, int) -> bool
        C++: bool IsThisInputVariableInstanceNeeded(int a_timestep,
            int a_outputTimestep)
        """
        ...
    
    def IsTypeOf(self, string):
        """
        V.IsTypeOf(string) -> int
        C++: static vtkTypeBool IsTypeOf(const char *type)
        
        Return 1 if this class type is the same type of (or a subclass
        of) the named class. Returns 0 otherwise. This method works in
        combination with vtkTypeMacro found in vtkSetGet.h.
        """
        ...
    
    def NewInstance(self):
        """
        V.NewInstance() -> vtkDSPFilterDefinition
        C++: vtkDSPFilterDefinition *NewInstance()
        """
        ...
    
    def PushBackDenominatorWeight(self, p_float):
        """
        V.PushBackDenominatorWeight(float)
        C++: void PushBackDenominatorWeight(double a_value)
        """
        ...
    
    def PushBackForwardNumeratorWeight(self, p_float):
        """
        V.PushBackForwardNumeratorWeight(float)
        C++: void PushBackForwardNumeratorWeight(double a_value)
        """
        ...
    
    def PushBackNumeratorWeight(self, p_float):
        """
        V.PushBackNumeratorWeight(float)
        C++: void PushBackNumeratorWeight(double a_value)
        """
        ...
    
    def SafeDownCast(self, vtkObjectBase):
        """
        V.SafeDownCast(vtkObjectBase) -> vtkDSPFilterDefinition
        C++: static vtkDSPFilterDefinition *SafeDownCast(vtkObjectBase *o)
        """
        ...
    
    def SetInputVariableName(self, string):
        """
        V.SetInputVariableName(string)
        C++: void SetInputVariableName(const char *a_value)
        """
        ...
    
    def SetOutputVariableName(self, string):
        """
        V.SetOutputVariableName(string)
        C++: void SetOutputVariableName(const char *a_value)
        """
        ...
    
    def __delattr__(self, *args, **kwargs):
        """ Implement delattr(self, name). """
        ...
    
    def __getattribute__(self, *args, **kwargs):
        """ Return getattr(self, name). """
        ...
    
    def __init__(self, *args, **kwargs) -> None:
        ...
    
    @staticmethod
    def __new__(*args, **kwargs):
        """ Create and return a new object.  See help(type) for accurate signature. """
        ...
    
    def __repr__(self, *args, **kwargs):
        """ Return repr(self). """
        ...
    
    def __setattr__(self, *args, **kwargs):
        """ Implement setattr(self, name, value). """
        ...
    
    def __str__(self, *args, **kwargs) -> str:
        """ Return str(self). """
        ...
    
    __this__ = ...
    __dict__ = ...
    __vtkname__ = ...


class vtkDSPFilterGroup(__vtkmodules_vtkCommonCore.vtkObject):
    """
    vtkDSPFilterGroup - used by the Exodus readers
    
    Superclass: vtkObject
    
    vtkDSPFilterGroup is used by vtkExodusReader, vtkExodusIIReader and
    vtkPExodusReader to do temporal smoothing of data
    @sa
    vtkDSPFilterDefinition vtkExodusReader vtkExodusIIReader
    vtkPExodusReader
    """
    def AddFilter(self, vtkDSPFilterDefinition):
        """
        V.AddFilter(vtkDSPFilterDefinition)
        C++: void AddFilter(vtkDSPFilterDefinition *filter)
        """
        ...
    
    def AddInputVariableInstance(self, string, p_int, vtkFloatArray):
        """
        V.AddInputVariableInstance(string, int, vtkFloatArray)
        C++: void AddInputVariableInstance(const char *a_name,
            int a_timestep, vtkFloatArray *a_data)
        """
        ...
    
    def Copy(self, vtkDSPFilterGroup):
        """
        V.Copy(vtkDSPFilterGroup)
        C++: void Copy(vtkDSPFilterGroup *other)
        """
        ...
    
    def GetCachedInput(self, p_int, p_int_1):
        """
        V.GetCachedInput(int, int) -> vtkFloatArray
        C++: vtkFloatArray *GetCachedInput(int a_whichFilter,
            int a_whichTimestep)
        """
        ...
    
    def GetCachedOutput(self, p_int, p_int_1):
        """
        V.GetCachedOutput(int, int) -> vtkFloatArray
        C++: vtkFloatArray *GetCachedOutput(int a_whichFilter,
            int a_whichTimestep)
        """
        ...
    
    def GetFilter(self, p_int):
        """
        V.GetFilter(int) -> vtkDSPFilterDefinition
        C++: vtkDSPFilterDefinition *GetFilter(int a_whichFilter)
        """
        ...
    
    def GetInputVariableName(self, p_int):
        """
        V.GetInputVariableName(int) -> string
        C++: const char *GetInputVariableName(int a_whichFilter)
        """
        ...
    
    def GetNumberOfGenerationsFromBase(self, string):
        """
        V.GetNumberOfGenerationsFromBase(string) -> int
        C++: vtkIdType GetNumberOfGenerationsFromBase(const char *type)
            override;
        
        Given a the name of a base class of this class type, return the
        distance of inheritance between this class type and the named
        class (how many generations of inheritance are there between this
        class and the named class). If the named class is not in this
        class's inheritance tree, return a negative value. Valid
        responses will always be nonnegative. This method works in
        combination with vtkTypeMacro found in vtkSetGet.h.
        """
        ...
    
    def GetNumberOfGenerationsFromBaseType(self, string):
        """
        V.GetNumberOfGenerationsFromBaseType(string) -> int
        C++: static vtkIdType GetNumberOfGenerationsFromBaseType(
            const char *type)
        
        Given a the name of a base class of this class type, return the
        distance of inheritance between this class type and the named
        class (how many generations of inheritance are there between this
        class and the named class). If the named class is not in this
        class's inheritance tree, return a negative value. Valid
        responses will always be nonnegative. This method works in
        combination with vtkTypeMacro found in vtkSetGet.h.
        """
        ...
    
    def GetNumFilters(self):
        """
        V.GetNumFilters() -> int
        C++: int GetNumFilters()
        """
        ...
    
    def GetOutput(self, p_int, p_int_1, p_int_2):
        """
        V.GetOutput(int, int, int) -> vtkFloatArray
        C++: vtkFloatArray *GetOutput(int a_whichFilter,
            int a_whichTimestep, int &a_instancesCalculated)
        """
        ...
    
    def IsA(self, string):
        """
        V.IsA(string) -> int
        C++: vtkTypeBool IsA(const char *type) override;
        
        Return 1 if this class is the same type of (or a subclass of) the
        named class. Returns 0 otherwise. This method works in
        combination with vtkTypeMacro found in vtkSetGet.h.
        """
        ...
    
    def IsThisInputVariableInstanceCached(self, string, p_int):
        """
        V.IsThisInputVariableInstanceCached(string, int) -> bool
        C++: bool IsThisInputVariableInstanceCached(const char *a_name,
            int a_timestep)
        """
        ...
    
    def IsThisInputVariableInstanceNeeded(self, string, p_int, p_int_1):
        """
        V.IsThisInputVariableInstanceNeeded(string, int, int) -> bool
        C++: bool IsThisInputVariableInstanceNeeded(const char *a_name,
            int a_timestep, int a_outputTimestep)
        """
        ...
    
    def IsTypeOf(self, string):
        """
        V.IsTypeOf(string) -> int
        C++: static vtkTypeBool IsTypeOf(const char *type)
        
        Return 1 if this class type is the same type of (or a subclass
        of) the named class. Returns 0 otherwise. This method works in
        combination with vtkTypeMacro found in vtkSetGet.h.
        """
        ...
    
    def NewInstance(self):
        """
        V.NewInstance() -> vtkDSPFilterGroup
        C++: vtkDSPFilterGroup *NewInstance()
        """
        ...
    
    def RemoveFilter(self, string):
        """
        V.RemoveFilter(string)
        C++: void RemoveFilter(const char *a_outputVariableName)
        """
        ...
    
    def SafeDownCast(self, vtkObjectBase):
        """
        V.SafeDownCast(vtkObjectBase) -> vtkDSPFilterGroup
        C++: static vtkDSPFilterGroup *SafeDownCast(vtkObjectBase *o)
        """
        ...
    
    def __delattr__(self, *args, **kwargs):
        """ Implement delattr(self, name). """
        ...
    
    def __getattribute__(self, *args, **kwargs):
        """ Return getattr(self, name). """
        ...
    
    def __init__(self, *args, **kwargs) -> None:
        ...
    
    @staticmethod
    def __new__(*args, **kwargs):
        """ Create and return a new object.  See help(type) for accurate signature. """
        ...
    
    def __repr__(self, *args, **kwargs):
        """ Return repr(self). """
        ...
    
    def __setattr__(self, *args, **kwargs):
        """ Implement setattr(self, name, value). """
        ...
    
    def __str__(self, *args, **kwargs) -> str:
        """ Return str(self). """
        ...
    
    __this__ = ...
    __dict__ = ...
    __vtkname__ = ...


class vtkEarthSource(__vtkmodules_vtkCommonExecutionModel.vtkPolyDataAlgorithm):
    """
    vtkEarthSource - create the continents of the Earth as a sphere
    
    Superclass: vtkPolyDataAlgorithm
    
    vtkEarthSource creates a spherical rendering of the geographical
    shapes of the major continents of the earth. The OnRatio determines
    how much of the data is actually used. The radius defines the radius
    of the sphere at which the continents are placed. Obtains data from
    an embedded array of coordinates.
    """
    def GetNumberOfGenerationsFromBase(self, string):
        """
        V.GetNumberOfGenerationsFromBase(string) -> int
        C++: vtkIdType GetNumberOfGenerationsFromBase(const char *type)
            override;
        
        Given a the name of a base class of this class type, return the
        distance of inheritance between this class type and the named
        class (how many generations of inheritance are there between this
        class and the named class). If the named class is not in this
        class's inheritance tree, return a negative value. Valid
        responses will always be nonnegative. This method works in
        combination with vtkTypeMacro found in vtkSetGet.h.
        """
        ...
    
    def GetNumberOfGenerationsFromBaseType(self, string):
        """
        V.GetNumberOfGenerationsFromBaseType(string) -> int
        C++: static vtkIdType GetNumberOfGenerationsFromBaseType(
            const char *type)
        
        Given a the name of a base class of this class type, return the
        distance of inheritance between this class type and the named
        class (how many generations of inheritance are there between this
        class and the named class). If the named class is not in this
        class's inheritance tree, return a negative value. Valid
        responses will always be nonnegative. This method works in
        combination with vtkTypeMacro found in vtkSetGet.h.
        """
        ...
    
    def GetOnRatio(self):
        """
        V.GetOnRatio() -> int
        C++: virtual int GetOnRatio()
        
        Turn on every nth entity. This controls how much detail the model
        will have. The maximum ratio is sixteen. (The smaller OnRatio,
        the more detail there is.)
        """
        ...
    
    def GetOnRatioMaxValue(self):
        """
        V.GetOnRatioMaxValue() -> int
        C++: virtual int GetOnRatioMaxValue()
        
        Turn on every nth entity. This controls how much detail the model
        will have. The maximum ratio is sixteen. (The smaller OnRatio,
        the more detail there is.)
        """
        ...
    
    def GetOnRatioMinValue(self):
        """
        V.GetOnRatioMinValue() -> int
        C++: virtual int GetOnRatioMinValue()
        
        Turn on every nth entity. This controls how much detail the model
        will have. The maximum ratio is sixteen. (The smaller OnRatio,
        the more detail there is.)
        """
        ...
    
    def GetOutline(self):
        """
        V.GetOutline() -> int
        C++: virtual vtkTypeBool GetOutline()
        
        Turn on/off drawing continents as filled polygons or as wireframe
        outlines. Warning: some graphics systems will have trouble with
        the very large, concave filled polygons. Recommend you use
        OutlienOn (i.e., disable filled polygons) for now.
        """
        ...
    
    def GetRadius(self):
        """
        V.GetRadius() -> float
        C++: virtual double GetRadius()
        
        Set radius of earth.
        """
        ...
    
    def GetRadiusMaxValue(self):
        """
        V.GetRadiusMaxValue() -> float
        C++: virtual double GetRadiusMaxValue()
        
        Set radius of earth.
        """
        ...
    
    def GetRadiusMinValue(self):
        """
        V.GetRadiusMinValue() -> float
        C++: virtual double GetRadiusMinValue()
        
        Set radius of earth.
        """
        ...
    
    def IsA(self, string):
        """
        V.IsA(string) -> int
        C++: vtkTypeBool IsA(const char *type) override;
        
        Return 1 if this class is the same type of (or a subclass of) the
        named class. Returns 0 otherwise. This method works in
        combination with vtkTypeMacro found in vtkSetGet.h.
        """
        ...
    
    def IsTypeOf(self, string):
        """
        V.IsTypeOf(string) -> int
        C++: static vtkTypeBool IsTypeOf(const char *type)
        
        Return 1 if this class type is the same type of (or a subclass
        of) the named class. Returns 0 otherwise. This method works in
        combination with vtkTypeMacro found in vtkSetGet.h.
        """
        ...
    
    def NewInstance(self):
        """
        V.NewInstance() -> vtkEarthSource
        C++: vtkEarthSource *NewInstance()
        """
        ...
    
    def OutlineOff(self):
        """
        V.OutlineOff()
        C++: virtual void OutlineOff()
        
        Turn on/off drawing continents as filled polygons or as wireframe
        outlines. Warning: some graphics systems will have trouble with
        the very large, concave filled polygons. Recommend you use
        OutlienOn (i.e., disable filled polygons) for now.
        """
        ...
    
    def OutlineOn(self):
        """
        V.OutlineOn()
        C++: virtual void OutlineOn()
        
        Turn on/off drawing continents as filled polygons or as wireframe
        outlines. Warning: some graphics systems will have trouble with
        the very large, concave filled polygons. Recommend you use
        OutlienOn (i.e., disable filled polygons) for now.
        """
        ...
    
    def SafeDownCast(self, vtkObjectBase):
        """
        V.SafeDownCast(vtkObjectBase) -> vtkEarthSource
        C++: static vtkEarthSource *SafeDownCast(vtkObjectBase *o)
        """
        ...
    
    def SetOnRatio(self, p_int):
        """
        V.SetOnRatio(int)
        C++: virtual void SetOnRatio(int _arg)
        
        Turn on every nth entity. This controls how much detail the model
        will have. The maximum ratio is sixteen. (The smaller OnRatio,
        the more detail there is.)
        """
        ...
    
    def SetOutline(self, p_int):
        """
        V.SetOutline(int)
        C++: virtual void SetOutline(vtkTypeBool _arg)
        
        Turn on/off drawing continents as filled polygons or as wireframe
        outlines. Warning: some graphics systems will have trouble with
        the very large, concave filled polygons. Recommend you use
        OutlienOn (i.e., disable filled polygons) for now.
        """
        ...
    
    def SetRadius(self, p_float):
        """
        V.SetRadius(float)
        C++: virtual void SetRadius(double _arg)
        
        Set radius of earth.
        """
        ...
    
    def __delattr__(self, *args, **kwargs):
        """ Implement delattr(self, name). """
        ...
    
    def __getattribute__(self, *args, **kwargs):
        """ Return getattr(self, name). """
        ...
    
    def __init__(self, *args, **kwargs) -> None:
        ...
    
    @staticmethod
    def __new__(*args, **kwargs):
        """ Create and return a new object.  See help(type) for accurate signature. """
        ...
    
    def __repr__(self, *args, **kwargs):
        """ Return repr(self). """
        ...
    
    def __setattr__(self, *args, **kwargs):
        """ Implement setattr(self, name, value). """
        ...
    
    def __str__(self, *args, **kwargs) -> str:
        """ Return str(self). """
        ...
    
    __this__ = ...
    __dict__ = ...
    __vtkname__ = ...


class vtkFacetReader(__vtkmodules_vtkCommonExecutionModel.vtkPolyDataAlgorithm):
    """
    vtkFacetReader - reads a dataset in Facet format
    
    Superclass: vtkPolyDataAlgorithm
    
    vtkFacetReader creates a poly data dataset. It reads ASCII files
    stored in Facet format
    
    The facet format looks like this: FACET FILE ... nparts Part 1 name 0
    npoints 0 0 p1x p1y p1z p2x p2y p2z ... 1 Part 1 name ncells
    npointspercell p1c1 p2c1 p3c1 ... pnc1 materialnum partnum p1c2 p2c2
    p3c2 ... pnc2 materialnum partnum ...
    """
    def CanReadFile(self, string):
        """
        V.CanReadFile(string) -> int
        C++: static int CanReadFile(const char *filename)
        """
        ...
    
    def GetFileName(self):
        """
        V.GetFileName() -> string
        C++: virtual char *GetFileName()
        
        Specify file name of Facet datafile to read
        """
        ...
    
    def GetNumberOfGenerationsFromBase(self, string):
        """
        V.GetNumberOfGenerationsFromBase(string) -> int
        C++: vtkIdType GetNumberOfGenerationsFromBase(const char *type)
            override;
        
        Given a the name of a base class of this class type, return the
        distance of inheritance between this class type and the named
        class (how many generations of inheritance are there between this
        class and the named class). If the named class is not in this
        class's inheritance tree, return a negative value. Valid
        responses will always be nonnegative. This method works in
        combination with vtkTypeMacro found in vtkSetGet.h.
        """
        ...
    
    def GetNumberOfGenerationsFromBaseType(self, string):
        """
        V.GetNumberOfGenerationsFromBaseType(string) -> int
        C++: static vtkIdType GetNumberOfGenerationsFromBaseType(
            const char *type)
        
        Given a the name of a base class of this class type, return the
        distance of inheritance between this class type and the named
        class (how many generations of inheritance are there between this
        class and the named class). If the named class is not in this
        class's inheritance tree, return a negative value. Valid
        responses will always be nonnegative. This method works in
        combination with vtkTypeMacro found in vtkSetGet.h.
        """
        ...
    
    def IsA(self, string):
        """
        V.IsA(string) -> int
        C++: vtkTypeBool IsA(const char *type) override;
        
        Return 1 if this class is the same type of (or a subclass of) the
        named class. Returns 0 otherwise. This method works in
        combination with vtkTypeMacro found in vtkSetGet.h.
        """
        ...
    
    def IsTypeOf(self, string):
        """
        V.IsTypeOf(string) -> int
        C++: static vtkTypeBool IsTypeOf(const char *type)
        
        Return 1 if this class type is the same type of (or a subclass
        of) the named class. Returns 0 otherwise. This method works in
        combination with vtkTypeMacro found in vtkSetGet.h.
        """
        ...
    
    def NewInstance(self):
        """
        V.NewInstance() -> vtkFacetReader
        C++: vtkFacetReader *NewInstance()
        """
        ...
    
    def SafeDownCast(self, vtkObjectBase):
        """
        V.SafeDownCast(vtkObjectBase) -> vtkFacetReader
        C++: static vtkFacetReader *SafeDownCast(vtkObjectBase *o)
        """
        ...
    
    def SetFileName(self, string):
        """
        V.SetFileName(string)
        C++: virtual void SetFileName(const char *_arg)
        
        Specify file name of Facet datafile to read
        """
        ...
    
    def __delattr__(self, *args, **kwargs):
        """ Implement delattr(self, name). """
        ...
    
    def __getattribute__(self, *args, **kwargs):
        """ Return getattr(self, name). """
        ...
    
    def __init__(self, *args, **kwargs) -> None:
        ...
    
    @staticmethod
    def __new__(*args, **kwargs):
        """ Create and return a new object.  See help(type) for accurate signature. """
        ...
    
    def __repr__(self, *args, **kwargs):
        """ Return repr(self). """
        ...
    
    def __setattr__(self, *args, **kwargs):
        """ Implement setattr(self, name, value). """
        ...
    
    def __str__(self, *args, **kwargs) -> str:
        """ Return str(self). """
        ...
    
    __this__ = ...
    __dict__ = ...
    __vtkname__ = ...


class vtkForceTime(__vtkmodules_vtkCommonExecutionModel.vtkPassInputTypeAlgorithm):
    """
    vtkForceTime - no description provided.
    
    Superclass: vtkPassInputTypeAlgorithm
    """
    def GetForcedTime(self):
        """
        V.GetForcedTime() -> float
        C++: virtual double GetForcedTime()
        
        Replace the pipeline time by this one.
        """
        ...
    
    def GetIgnorePipelineTime(self):
        """
        V.GetIgnorePipelineTime() -> bool
        C++: virtual bool GetIgnorePipelineTime()
        
        Use the ForcedTime. If disabled, use usual pipeline time.
        """
        ...
    
    def GetNumberOfGenerationsFromBase(self, string):
        """
        V.GetNumberOfGenerationsFromBase(string) -> int
        C++: vtkIdType GetNumberOfGenerationsFromBase(const char *type)
            override;
        
        Given a the name of a base class of this class type, return the
        distance of inheritance between this class type and the named
        class (how many generations of inheritance are there between this
        class and the named class). If the named class is not in this
        class's inheritance tree, return a negative value. Valid
        responses will always be nonnegative. This method works in
        combination with vtkTypeMacro found in vtkSetGet.h.
        """
        ...
    
    def GetNumberOfGenerationsFromBaseType(self, string):
        """
        V.GetNumberOfGenerationsFromBaseType(string) -> int
        C++: static vtkIdType GetNumberOfGenerationsFromBaseType(
            const char *type)
        
        Given a the name of a base class of this class type, return the
        distance of inheritance between this class type and the named
        class (how many generations of inheritance are there between this
        class and the named class). If the named class is not in this
        class's inheritance tree, return a negative value. Valid
        responses will always be nonnegative. This method works in
        combination with vtkTypeMacro found in vtkSetGet.h.
        """
        ...
    
    def IgnorePipelineTimeOff(self):
        """
        V.IgnorePipelineTimeOff()
        C++: virtual void IgnorePipelineTimeOff()
        
        Use the ForcedTime. If disabled, use usual pipeline time.
        """
        ...
    
    def IgnorePipelineTimeOn(self):
        """
        V.IgnorePipelineTimeOn()
        C++: virtual void IgnorePipelineTimeOn()
        
        Use the ForcedTime. If disabled, use usual pipeline time.
        """
        ...
    
    def IsA(self, string):
        """
        V.IsA(string) -> int
        C++: vtkTypeBool IsA(const char *type) override;
        
        Return 1 if this class is the same type of (or a subclass of) the
        named class. Returns 0 otherwise. This method works in
        combination with vtkTypeMacro found in vtkSetGet.h.
        """
        ...
    
    def IsTypeOf(self, string):
        """
        V.IsTypeOf(string) -> int
        C++: static vtkTypeBool IsTypeOf(const char *type)
        
        Return 1 if this class type is the same type of (or a subclass
        of) the named class. Returns 0 otherwise. This method works in
        combination with vtkTypeMacro found in vtkSetGet.h.
        """
        ...
    
    def NewInstance(self):
        """
        V.NewInstance() -> vtkForceTime
        C++: vtkForceTime *NewInstance()
        """
        ...
    
    def SafeDownCast(self, vtkObjectBase):
        """
        V.SafeDownCast(vtkObjectBase) -> vtkForceTime
        C++: static vtkForceTime *SafeDownCast(vtkObjectBase *o)
        """
        ...
    
    def SetForcedTime(self, p_float):
        """
        V.SetForcedTime(float)
        C++: virtual void SetForcedTime(double _arg)
        
        Replace the pipeline time by this one.
        """
        ...
    
    def SetIgnorePipelineTime(self, bool):
        """
        V.SetIgnorePipelineTime(bool)
        C++: virtual void SetIgnorePipelineTime(bool _arg)
        
        Use the ForcedTime. If disabled, use usual pipeline time.
        """
        ...
    
    def __delattr__(self, *args, **kwargs):
        """ Implement delattr(self, name). """
        ...
    
    def __getattribute__(self, *args, **kwargs):
        """ Return getattr(self, name). """
        ...
    
    def __init__(self, *args, **kwargs) -> None:
        ...
    
    @staticmethod
    def __new__(*args, **kwargs):
        """ Create and return a new object.  See help(type) for accurate signature. """
        ...
    
    def __repr__(self, *args, **kwargs):
        """ Return repr(self). """
        ...
    
    def __setattr__(self, *args, **kwargs):
        """ Implement setattr(self, name, value). """
        ...
    
    def __str__(self, *args, **kwargs) -> str:
        """ Return str(self). """
        ...
    
    __this__ = ...
    __dict__ = ...
    __vtkname__ = ...


class vtkGreedyTerrainDecimation(__vtkmodules_vtkCommonExecutionModel.vtkPolyDataAlgorithm):
    """
    vtkGreedyTerrainDecimation - reduce height field (represented as
    image) to reduced TIN
    
    Superclass: vtkPolyDataAlgorithm
    
    vtkGreedyTerrainDecimation approximates a height field with a
    triangle mesh (triangulated irregular network - TIN) using a greedy
    insertion algorithm similar to that described by Garland and Heckbert
    in their paper "Fast Polygonal Approximations of Terrain and Height
    Fields" (Technical Report CMU-CS-95-181).  The input to the filter is
    a height field (represented by a image whose scalar values are
    height) and the output of the filter is polygonal data consisting of
    triangles. The number of triangles in the output is reduced in number
    as compared to a naive tessellation of the input height field. This
    filter copies point data from the input to the output for those
    points present in the output.
    
    An brief description of the algorithm is as follows. The algorithm
    uses a top-down decimation approach that initially represents the
    height field with two triangles (whose vertices are at the four
    corners of the image). These two triangles form a Delaunay
    triangulation. In an iterative fashion, the point in the image with
    the greatest error (as compared to the original height field) is
    injected into the triangulation. (Note that the single point with the
    greatest error per triangle is identified and placed into a priority
    queue. As the triangulation is modified, the errors from the deleted
    triangles are removed from the queue, error values from the new
    triangles are added.) The point whose error is at the top of the
    queue is added to the triangulaion modifying it using the standard
    incremental Delaunay point insertion (see vtkDelaunay2D) algorithm.
    Points are repeatedly inserted until the appropriate (user-specified)
    error criterion is met.
    
    To use this filter, set the input and specify the error measure to be
    used.  The error measure options are 1) the absolute number of
    triangles to be produced; 2) a fractional reduction of the mesh
    (numTris/maxTris) where maxTris is the largest possible number of
    triangles 2*(dims[0]-1)*(dims[1]-1); 3) an absolute measure on error
    (maximum difference in height field to reduced TIN); and 4) relative
    error (the absolute error is normalized by the diagonal of the
    bounding box of the height field).
    
    @warning
    This algorithm requires the entire input dataset to be in memory,
    hence it may not work for extremely large images. Invoking
    BoundaryVertexDeletionOff will allow you to stitch together images
    with matching boundaries.
    
    @warning
    The input height image is assumed to be positioned in the x-y plane
    so the scalar value is the z-coordinate, height value.
    
    @sa
    vtkDecimatePro vtkQuadricDecimation vtkQuadricClustering
    """
    def BoundaryVertexDeletionOff(self):
        """
        V.BoundaryVertexDeletionOff()
        C++: virtual void BoundaryVertexDeletionOff()
        
        Turn on/off the deletion of vertices on the boundary of a mesh.
        This may limit the maximum reduction that may be achieved.
        """
        ...
    
    def BoundaryVertexDeletionOn(self):
        """
        V.BoundaryVertexDeletionOn()
        C++: virtual void BoundaryVertexDeletionOn()
        
        Turn on/off the deletion of vertices on the boundary of a mesh.
        This may limit the maximum reduction that may be achieved.
        """
        ...
    
    def ComputeNormalsOff(self):
        """
        V.ComputeNormalsOff()
        C++: virtual void ComputeNormalsOff()
        
        Compute normals based on the input image. Off by default.
        """
        ...
    
    def ComputeNormalsOn(self):
        """
        V.ComputeNormalsOn()
        C++: virtual void ComputeNormalsOn()
        
        Compute normals based on the input image. Off by default.
        """
        ...
    
    def GetAbsoluteError(self):
        """
        V.GetAbsoluteError() -> float
        C++: virtual double GetAbsoluteError()
        
        Specify the absolute error of the mesh; that is, the error in
        height between the decimated mesh and the original height field. 
        You need to set this value only when the error measure is set to
        AbsoluteError.
        """
        ...
    
    def GetAbsoluteErrorMaxValue(self):
        """
        V.GetAbsoluteErrorMaxValue() -> float
        C++: virtual double GetAbsoluteErrorMaxValue()
        
        Specify the absolute error of the mesh; that is, the error in
        height between the decimated mesh and the original height field. 
        You need to set this value only when the error measure is set to
        AbsoluteError.
        """
        ...
    
    def GetAbsoluteErrorMinValue(self):
        """
        V.GetAbsoluteErrorMinValue() -> float
        C++: virtual double GetAbsoluteErrorMinValue()
        
        Specify the absolute error of the mesh; that is, the error in
        height between the decimated mesh and the original height field. 
        You need to set this value only when the error measure is set to
        AbsoluteError.
        """
        ...
    
    def GetBoundaryVertexDeletion(self):
        """
        V.GetBoundaryVertexDeletion() -> int
        C++: virtual vtkTypeBool GetBoundaryVertexDeletion()
        
        Turn on/off the deletion of vertices on the boundary of a mesh.
        This may limit the maximum reduction that may be achieved.
        """
        ...
    
    def GetComputeNormals(self):
        """
        V.GetComputeNormals() -> int
        C++: virtual vtkTypeBool GetComputeNormals()
        
        Compute normals based on the input image. Off by default.
        """
        ...
    
    def GetErrorMeasure(self):
        """
        V.GetErrorMeasure() -> int
        C++: virtual int GetErrorMeasure()
        
        Specify how to terminate the algorithm: either as an absolute
        number of triangles, a relative number of triangles (normalized
        by the full resolution mesh), an absolute error (in the height
        field), or relative error (normalized by the length of the
        diagonal of the image).
        """
        ...
    
    def GetErrorMeasureMaxValue(self):
        """
        V.GetErrorMeasureMaxValue() -> int
        C++: virtual int GetErrorMeasureMaxValue()
        
        Specify how to terminate the algorithm: either as an absolute
        number of triangles, a relative number of triangles (normalized
        by the full resolution mesh), an absolute error (in the height
        field), or relative error (normalized by the length of the
        diagonal of the image).
        """
        ...
    
    def GetErrorMeasureMinValue(self):
        """
        V.GetErrorMeasureMinValue() -> int
        C++: virtual int GetErrorMeasureMinValue()
        
        Specify how to terminate the algorithm: either as an absolute
        number of triangles, a relative number of triangles (normalized
        by the full resolution mesh), an absolute error (in the height
        field), or relative error (normalized by the length of the
        diagonal of the image).
        """
        ...
    
    def GetNumberOfGenerationsFromBase(self, string):
        """
        V.GetNumberOfGenerationsFromBase(string) -> int
        C++: vtkIdType GetNumberOfGenerationsFromBase(const char *type)
            override;
        
        Given a the name of a base class of this class type, return the
        distance of inheritance between this class type and the named
        class (how many generations of inheritance are there between this
        class and the named class). If the named class is not in this
        class's inheritance tree, return a negative value. Valid
        responses will always be nonnegative. This method works in
        combination with vtkTypeMacro found in vtkSetGet.h.
        """
        ...
    
    def GetNumberOfGenerationsFromBaseType(self, string):
        """
        V.GetNumberOfGenerationsFromBaseType(string) -> int
        C++: static vtkIdType GetNumberOfGenerationsFromBaseType(
            const char *type)
        
        Given a the name of a base class of this class type, return the
        distance of inheritance between this class type and the named
        class (how many generations of inheritance are there between this
        class and the named class). If the named class is not in this
        class's inheritance tree, return a negative value. Valid
        responses will always be nonnegative. This method works in
        combination with vtkTypeMacro found in vtkSetGet.h.
        """
        ...
    
    def GetNumberOfTriangles(self):
        """
        V.GetNumberOfTriangles() -> int
        C++: virtual vtkIdType GetNumberOfTriangles()
        
        Specify the number of triangles to produce on output. (It is a
        good idea to make sure this is less than a tessellated mesh at
        full resolution.) You need to set this value only when the error
        measure is set to NumberOfTriangles.
        """
        ...
    
    def GetNumberOfTrianglesMaxValue(self):
        """
        V.GetNumberOfTrianglesMaxValue() -> int
        C++: virtual vtkIdType GetNumberOfTrianglesMaxValue()
        
        Specify the number of triangles to produce on output. (It is a
        good idea to make sure this is less than a tessellated mesh at
        full resolution.) You need to set this value only when the error
        measure is set to NumberOfTriangles.
        """
        ...
    
    def GetNumberOfTrianglesMinValue(self):
        """
        V.GetNumberOfTrianglesMinValue() -> int
        C++: virtual vtkIdType GetNumberOfTrianglesMinValue()
        
        Specify the number of triangles to produce on output. (It is a
        good idea to make sure this is less than a tessellated mesh at
        full resolution.) You need to set this value only when the error
        measure is set to NumberOfTriangles.
        """
        ...
    
    def GetReduction(self):
        """
        V.GetReduction() -> float
        C++: virtual double GetReduction()
        
        Specify the reduction of the mesh (represented as a fraction). 
        Note that a value of 0.10 means a 10% reduction.  You need to set
        this value only when the error measure is set to
        SpecifiedReduction.
        """
        ...
    
    def GetReductionMaxValue(self):
        """
        V.GetReductionMaxValue() -> float
        C++: virtual double GetReductionMaxValue()
        
        Specify the reduction of the mesh (represented as a fraction). 
        Note that a value of 0.10 means a 10% reduction.  You need to set
        this value only when the error measure is set to
        SpecifiedReduction.
        """
        ...
    
    def GetReductionMinValue(self):
        """
        V.GetReductionMinValue() -> float
        C++: virtual double GetReductionMinValue()
        
        Specify the reduction of the mesh (represented as a fraction). 
        Note that a value of 0.10 means a 10% reduction.  You need to set
        this value only when the error measure is set to
        SpecifiedReduction.
        """
        ...
    
    def GetRelativeError(self):
        """
        V.GetRelativeError() -> float
        C++: virtual double GetRelativeError()
        
        Specify the relative error of the mesh; that is, the error in
        height between the decimated mesh and the original height field
        normalized by the diagonal of the image.  You need to set this
        value only when the error measure is set to RelativeError.
        """
        ...
    
    def GetRelativeErrorMaxValue(self):
        """
        V.GetRelativeErrorMaxValue() -> float
        C++: virtual double GetRelativeErrorMaxValue()
        
        Specify the relative error of the mesh; that is, the error in
        height between the decimated mesh and the original height field
        normalized by the diagonal of the image.  You need to set this
        value only when the error measure is set to RelativeError.
        """
        ...
    
    def GetRelativeErrorMinValue(self):
        """
        V.GetRelativeErrorMinValue() -> float
        C++: virtual double GetRelativeErrorMinValue()
        
        Specify the relative error of the mesh; that is, the error in
        height between the decimated mesh and the original height field
        normalized by the diagonal of the image.  You need to set this
        value only when the error measure is set to RelativeError.
        """
        ...
    
    def IsA(self, string):
        """
        V.IsA(string) -> int
        C++: vtkTypeBool IsA(const char *type) override;
        
        Return 1 if this class is the same type of (or a subclass of) the
        named class. Returns 0 otherwise. This method works in
        combination with vtkTypeMacro found in vtkSetGet.h.
        """
        ...
    
    def IsTypeOf(self, string):
        """
        V.IsTypeOf(string) -> int
        C++: static vtkTypeBool IsTypeOf(const char *type)
        
        Return 1 if this class type is the same type of (or a subclass
        of) the named class. Returns 0 otherwise. This method works in
        combination with vtkTypeMacro found in vtkSetGet.h.
        """
        ...
    
    def NewInstance(self):
        """
        V.NewInstance() -> vtkGreedyTerrainDecimation
        C++: vtkGreedyTerrainDecimation *NewInstance()
        """
        ...
    
    def SafeDownCast(self, vtkObjectBase):
        """
        V.SafeDownCast(vtkObjectBase) -> vtkGreedyTerrainDecimation
        C++: static vtkGreedyTerrainDecimation *SafeDownCast(
            vtkObjectBase *o)
        """
        ...
    
    def SetAbsoluteError(self, p_float):
        """
        V.SetAbsoluteError(float)
        C++: virtual void SetAbsoluteError(double _arg)
        
        Specify the absolute error of the mesh; that is, the error in
        height between the decimated mesh and the original height field. 
        You need to set this value only when the error measure is set to
        AbsoluteError.
        """
        ...
    
    def SetBoundaryVertexDeletion(self, p_int):
        """
        V.SetBoundaryVertexDeletion(int)
        C++: virtual void SetBoundaryVertexDeletion(vtkTypeBool _arg)
        
        Turn on/off the deletion of vertices on the boundary of a mesh.
        This may limit the maximum reduction that may be achieved.
        """
        ...
    
    def SetComputeNormals(self, p_int):
        """
        V.SetComputeNormals(int)
        C++: virtual void SetComputeNormals(vtkTypeBool _arg)
        
        Compute normals based on the input image. Off by default.
        """
        ...
    
    def SetErrorMeasure(self, p_int):
        """
        V.SetErrorMeasure(int)
        C++: virtual void SetErrorMeasure(int _arg)
        
        Specify how to terminate the algorithm: either as an absolute
        number of triangles, a relative number of triangles (normalized
        by the full resolution mesh), an absolute error (in the height
        field), or relative error (normalized by the length of the
        diagonal of the image).
        """
        ...
    
    def SetErrorMeasureToAbsoluteError(self):
        """
        V.SetErrorMeasureToAbsoluteError()
        C++: void SetErrorMeasureToAbsoluteError()
        
        Specify how to terminate the algorithm: either as an absolute
        number of triangles, a relative number of triangles (normalized
        by the full resolution mesh), an absolute error (in the height
        field), or relative error (normalized by the length of the
        diagonal of the image).
        """
        ...
    
    def SetErrorMeasureToNumberOfTriangles(self):
        """
        V.SetErrorMeasureToNumberOfTriangles()
        C++: void SetErrorMeasureToNumberOfTriangles()
        
        Specify how to terminate the algorithm: either as an absolute
        number of triangles, a relative number of triangles (normalized
        by the full resolution mesh), an absolute error (in the height
        field), or relative error (normalized by the length of the
        diagonal of the image).
        """
        ...
    
    def SetErrorMeasureToRelativeError(self):
        """
        V.SetErrorMeasureToRelativeError()
        C++: void SetErrorMeasureToRelativeError()
        
        Specify how to terminate the algorithm: either as an absolute
        number of triangles, a relative number of triangles (normalized
        by the full resolution mesh), an absolute error (in the height
        field), or relative error (normalized by the length of the
        diagonal of the image).
        """
        ...
    
    def SetErrorMeasureToSpecifiedReduction(self):
        """
        V.SetErrorMeasureToSpecifiedReduction()
        C++: void SetErrorMeasureToSpecifiedReduction()
        
        Specify how to terminate the algorithm: either as an absolute
        number of triangles, a relative number of triangles (normalized
        by the full resolution mesh), an absolute error (in the height
        field), or relative error (normalized by the length of the
        diagonal of the image).
        """
        ...
    
    def SetNumberOfTriangles(self, p_int):
        """
        V.SetNumberOfTriangles(int)
        C++: virtual void SetNumberOfTriangles(vtkIdType _arg)
        
        Specify the number of triangles to produce on output. (It is a
        good idea to make sure this is less than a tessellated mesh at
        full resolution.) You need to set this value only when the error
        measure is set to NumberOfTriangles.
        """
        ...
    
    def SetReduction(self, p_float):
        """
        V.SetReduction(float)
        C++: virtual void SetReduction(double _arg)
        
        Specify the reduction of the mesh (represented as a fraction). 
        Note that a value of 0.10 means a 10% reduction.  You need to set
        this value only when the error measure is set to
        SpecifiedReduction.
        """
        ...
    
    def SetRelativeError(self, p_float):
        """
        V.SetRelativeError(float)
        C++: virtual void SetRelativeError(double _arg)
        
        Specify the relative error of the mesh; that is, the error in
        height between the decimated mesh and the original height field
        normalized by the diagonal of the image.  You need to set this
        value only when the error measure is set to RelativeError.
        """
        ...
    
    def __delattr__(self, *args, **kwargs):
        """ Implement delattr(self, name). """
        ...
    
    def __getattribute__(self, *args, **kwargs):
        """ Return getattr(self, name). """
        ...
    
    def __init__(self, *args, **kwargs) -> None:
        ...
    
    @staticmethod
    def __new__(*args, **kwargs):
        """ Create and return a new object.  See help(type) for accurate signature. """
        ...
    
    def __repr__(self, *args, **kwargs):
        """ Return repr(self). """
        ...
    
    def __setattr__(self, *args, **kwargs):
        """ Implement setattr(self, name, value). """
        ...
    
    def __str__(self, *args, **kwargs) -> str:
        """ Return str(self). """
        ...
    
    __this__ = ...
    __dict__ = ...
    __vtkname__ = ...


class vtkGridTransform(__vtkmodules_vtkCommonTransforms.vtkWarpTransform):
    """
    vtkGridTransform - a nonlinear warp transformation
    
    Superclass: vtkWarpTransform
    
    vtkGridTransform describes a nonlinear warp transformation as a set
    of displacement vectors sampled along a uniform 3D grid.
    @warning
    The inverse grid transform is calculated using an iterative method,
    and is several times more expensive than the forward transform.
    @sa
    vtkThinPlateSplineTransform vtkGeneralTransform vtkTransformToGrid
    """
    def GetDisplacementGrid(self):
        """
        V.GetDisplacementGrid() -> vtkImageData
        C++: virtual vtkImageData *GetDisplacementGrid()
        
        Set/Get the grid transform (the grid transform must have three
        components for displacement in x, y, and z respectively). The
        vtkGridTransform class will never modify the data. Note that
        SetDisplacementGridData() does not setup a pipeline connection
        whereas SetDisplacementGridConnection does.
        """
        ...
    
    def GetDisplacementScale(self):
        """
        V.GetDisplacementScale() -> float
        C++: virtual double GetDisplacementScale()
        
        Set scale factor to be applied to the displacements. This is used
        primarily for grids which contain integer data types.  Default: 1
        """
        ...
    
    def GetDisplacementShift(self):
        """
        V.GetDisplacementShift() -> float
        C++: virtual double GetDisplacementShift()
        
        Set a shift to be applied to the displacements.  The shift is
        applied after the scale, i.e. x = scale*y + shift. Default: 0
        """
        ...
    
    def GetInterpolationMode(self):
        """
        V.GetInterpolationMode() -> int
        C++: virtual int GetInterpolationMode()
        
        Set interpolation mode for sampling the grid.  Higher-order
        interpolation allows you to use a sparser grid. Default: Linear.
        """
        ...
    
    def GetInterpolationModeAsString(self):
        """
        V.GetInterpolationModeAsString() -> string
        C++: const char *GetInterpolationModeAsString()
        
        Set interpolation mode for sampling the grid.  Higher-order
        interpolation allows you to use a sparser grid. Default: Linear.
        """
        ...
    
    def GetMTime(self):
        """
        V.GetMTime() -> int
        C++: vtkMTimeType GetMTime() override;
        
        Get the MTime.
        """
        ...
    
    def GetNumberOfGenerationsFromBase(self, string):
        """
        V.GetNumberOfGenerationsFromBase(string) -> int
        C++: vtkIdType GetNumberOfGenerationsFromBase(const char *type)
            override;
        
        Given a the name of a base class of this class type, return the
        distance of inheritance between this class type and the named
        class (how many generations of inheritance are there between this
        class and the named class). If the named class is not in this
        class's inheritance tree, return a negative value. Valid
        responses will always be nonnegative. This method works in
        combination with vtkTypeMacro found in vtkSetGet.h.
        """
        ...
    
    def GetNumberOfGenerationsFromBaseType(self, string):
        """
        V.GetNumberOfGenerationsFromBaseType(string) -> int
        C++: static vtkIdType GetNumberOfGenerationsFromBaseType(
            const char *type)
        
        Given a the name of a base class of this class type, return the
        distance of inheritance between this class type and the named
        class (how many generations of inheritance are there between this
        class and the named class). If the named class is not in this
        class's inheritance tree, return a negative value. Valid
        responses will always be nonnegative. This method works in
        combination with vtkTypeMacro found in vtkSetGet.h.
        """
        ...
    
    def IsA(self, string):
        """
        V.IsA(string) -> int
        C++: vtkTypeBool IsA(const char *type) override;
        
        Return 1 if this class is the same type of (or a subclass of) the
        named class. Returns 0 otherwise. This method works in
        combination with vtkTypeMacro found in vtkSetGet.h.
        """
        ...
    
    def IsTypeOf(self, string):
        """
        V.IsTypeOf(string) -> int
        C++: static vtkTypeBool IsTypeOf(const char *type)
        
        Return 1 if this class type is the same type of (or a subclass
        of) the named class. Returns 0 otherwise. This method works in
        combination with vtkTypeMacro found in vtkSetGet.h.
        """
        ...
    
    def MakeTransform(self):
        """
        V.MakeTransform() -> vtkAbstractTransform
        C++: vtkAbstractTransform *MakeTransform() override;
        
        Make another transform of the same type.
        """
        ...
    
    def NewInstance(self):
        """
        V.NewInstance() -> vtkGridTransform
        C++: vtkGridTransform *NewInstance()
        """
        ...
    
    def SafeDownCast(self, vtkObjectBase):
        """
        V.SafeDownCast(vtkObjectBase) -> vtkGridTransform
        C++: static vtkGridTransform *SafeDownCast(vtkObjectBase *o)
        """
        ...
    
    def SetDisplacementGridConnection(self, vtkAlgorithmOutput):
        """
        V.SetDisplacementGridConnection(vtkAlgorithmOutput)
        C++: virtual void SetDisplacementGridConnection(
            vtkAlgorithmOutput *)
        
        Set/Get the grid transform (the grid transform must have three
        components for displacement in x, y, and z respectively). The
        vtkGridTransform class will never modify the data. Note that
        SetDisplacementGridData() does not setup a pipeline connection
        whereas SetDisplacementGridConnection does.
        """
        ...
    
    def SetDisplacementGridData(self, vtkImageData):
        """
        V.SetDisplacementGridData(vtkImageData)
        C++: virtual void SetDisplacementGridData(vtkImageData *)
        
        Set/Get the grid transform (the grid transform must have three
        components for displacement in x, y, and z respectively). The
        vtkGridTransform class will never modify the data. Note that
        SetDisplacementGridData() does not setup a pipeline connection
        whereas SetDisplacementGridConnection does.
        """
        ...
    
    def SetDisplacementScale(self, p_float):
        """
        V.SetDisplacementScale(float)
        C++: virtual void SetDisplacementScale(double _arg)
        
        Set scale factor to be applied to the displacements. This is used
        primarily for grids which contain integer data types.  Default: 1
        """
        ...
    
    def SetDisplacementShift(self, p_float):
        """
        V.SetDisplacementShift(float)
        C++: virtual void SetDisplacementShift(double _arg)
        
        Set a shift to be applied to the displacements.  The shift is
        applied after the scale, i.e. x = scale*y + shift. Default: 0
        """
        ...
    
    def SetInterpolationMode(self, p_int):
        """
        V.SetInterpolationMode(int)
        C++: void SetInterpolationMode(int mode)
        
        Set interpolation mode for sampling the grid.  Higher-order
        interpolation allows you to use a sparser grid. Default: Linear.
        """
        ...
    
    def SetInterpolationModeToCubic(self):
        """
        V.SetInterpolationModeToCubic()
        C++: void SetInterpolationModeToCubic()
        
        Set interpolation mode for sampling the grid.  Higher-order
        interpolation allows you to use a sparser grid. Default: Linear.
        """
        ...
    
    def SetInterpolationModeToLinear(self):
        """
        V.SetInterpolationModeToLinear()
        C++: void SetInterpolationModeToLinear()
        
        Set interpolation mode for sampling the grid.  Higher-order
        interpolation allows you to use a sparser grid. Default: Linear.
        """
        ...
    
    def SetInterpolationModeToNearestNeighbor(self):
        """
        V.SetInterpolationModeToNearestNeighbor()
        C++: void SetInterpolationModeToNearestNeighbor()
        
        Set interpolation mode for sampling the grid.  Higher-order
        interpolation allows you to use a sparser grid. Default: Linear.
        """
        ...
    
    def __delattr__(self, *args, **kwargs):
        """ Implement delattr(self, name). """
        ...
    
    def __getattribute__(self, *args, **kwargs):
        """ Return getattr(self, name). """
        ...
    
    def __init__(self, *args, **kwargs) -> None:
        ...
    
    @staticmethod
    def __new__(*args, **kwargs):
        """ Create and return a new object.  See help(type) for accurate signature. """
        ...
    
    def __repr__(self, *args, **kwargs):
        """ Return repr(self). """
        ...
    
    def __setattr__(self, *args, **kwargs):
        """ Implement setattr(self, name, value). """
        ...
    
    def __str__(self, *args, **kwargs) -> str:
        """ Return str(self). """
        ...
    
    __this__ = ...
    __dict__ = ...
    __vtkname__ = ...


class vtkImageToPolyDataFilter(__vtkmodules_vtkCommonExecutionModel.vtkPolyDataAlgorithm):
    """
    vtkImageToPolyDataFilter - generate linear primitives (vtkPolyData)
    from an image
    
    Superclass: vtkPolyDataAlgorithm
    
    vtkImageToPolyDataFilter converts raster data (i.e., an image) into
    polygonal data (i.e., quads or n-sided polygons), with each polygon
    assigned a constant color. This is useful for writers that generate
    vector formats (i.e., CGM or PostScript). To use this filter, you
    specify how to quantize the color (or whether to use an image with a
    lookup table), and what style the output should be. The output is
    always polygons, but the choice is n x m quads (where n and m define
    the input image dimensions) "Pixelize" option; arbitrary polygons
    "Polygonalize" option; or variable number of quads of constant color
    generated along scan lines "RunLength" option.
    
    The algorithm quantizes color in order to create coherent regions
    that the polygons can represent with good compression. By default,
    the input image is quantized to 256 colors using a 3-3-2 bits for
    red-green-blue. However, you can also supply a single component image
    and a lookup table, with the single component assumed to be an index
    into the table.  (Note: a quantized image can be generated with the
    filter vtkImageQuantizeRGBToIndex.) The number of colors on output is
    equal to the number of colors in the input lookup table (or 256 if
    the built in linear ramp is used).
    
    The output of the filter is polygons with a single color per polygon
    cell. If the output style is set to "Polygonalize", the polygons may
    have an large number of points (bounded by something like 2*(n+m));
    and the polygon may not be convex which may cause rendering problems
    on some systems (use vtkTriangleFilter). Otherwise, each polygon will
    have four vertices. The output also contains scalar data defining RGB
    color in unsigned char form.
    
    @warning
    The input linear lookup table must be of the form of 3-component
    unsigned char.
    
    @warning
    This filter defines constant cell colors. If you have a plotting
    device that supports Gouraud shading (linear interpolation of color),
    then superior algorithms are available for generating polygons from
    images.
    
    @warning
    Note that many plotting devices/formats support only a limited number
    of colors.
    
    @sa
    vtkCGMWriter vtkImageQuantizeRGBToIndex vtkTriangleFilter
    """
    def DecimationOff(self):
        """
        V.DecimationOff()
        C++: virtual void DecimationOff()
        
        Turn on/off whether the final polygons should be decimated.
        whether to smooth boundaries.
        """
        ...
    
    def DecimationOn(self):
        """
        V.DecimationOn()
        C++: virtual void DecimationOn()
        
        Turn on/off whether the final polygons should be decimated.
        whether to smooth boundaries.
        """
        ...
    
    def GetColorMode(self):
        """
        V.GetColorMode() -> int
        C++: virtual int GetColorMode()
        
        Specify how to quantize color.
        """
        ...
    
    def GetColorModeMaxValue(self):
        """
        V.GetColorModeMaxValue() -> int
        C++: virtual int GetColorModeMaxValue()
        
        Specify how to quantize color.
        """
        ...
    
    def GetColorModeMinValue(self):
        """
        V.GetColorModeMinValue() -> int
        C++: virtual int GetColorModeMinValue()
        
        Specify how to quantize color.
        """
        ...
    
    def GetDecimation(self):
        """
        V.GetDecimation() -> int
        C++: virtual vtkTypeBool GetDecimation()
        
        Turn on/off whether the final polygons should be decimated.
        whether to smooth boundaries.
        """
        ...
    
    def GetDecimationError(self):
        """
        V.GetDecimationError() -> float
        C++: virtual double GetDecimationError()
        
        Specify the error to use for decimation (if decimation is on).
        The error is an absolute number--the image spacing and dimensions
        are used to create points so the error should be consistent with
        the image size.
        """
        ...
    
    def GetDecimationErrorMaxValue(self):
        """
        V.GetDecimationErrorMaxValue() -> float
        C++: virtual double GetDecimationErrorMaxValue()
        
        Specify the error to use for decimation (if decimation is on).
        The error is an absolute number--the image spacing and dimensions
        are used to create points so the error should be consistent with
        the image size.
        """
        ...
    
    def GetDecimationErrorMinValue(self):
        """
        V.GetDecimationErrorMinValue() -> float
        C++: virtual double GetDecimationErrorMinValue()
        
        Specify the error to use for decimation (if decimation is on).
        The error is an absolute number--the image spacing and dimensions
        are used to create points so the error should be consistent with
        the image size.
        """
        ...
    
    def GetError(self):
        """
        V.GetError() -> int
        C++: virtual int GetError()
        
        Specify the error value between two colors where the colors are
        considered the same. Only use this if the color mode uses the
        default 256 table.
        """
        ...
    
    def GetErrorMaxValue(self):
        """
        V.GetErrorMaxValue() -> int
        C++: virtual int GetErrorMaxValue()
        
        Specify the error value between two colors where the colors are
        considered the same. Only use this if the color mode uses the
        default 256 table.
        """
        ...
    
    def GetErrorMinValue(self):
        """
        V.GetErrorMinValue() -> int
        C++: virtual int GetErrorMinValue()
        
        Specify the error value between two colors where the colors are
        considered the same. Only use this if the color mode uses the
        default 256 table.
        """
        ...
    
    def GetLookupTable(self):
        """
        V.GetLookupTable() -> vtkScalarsToColors
        C++: virtual vtkScalarsToColors *GetLookupTable()
        
        Set/Get the vtkLookupTable to use. The lookup table is used when
        the color mode is set to LUT and a single component scalar is
        input.
        """
        ...
    
    def GetNumberOfGenerationsFromBase(self, string):
        """
        V.GetNumberOfGenerationsFromBase(string) -> int
        C++: vtkIdType GetNumberOfGenerationsFromBase(const char *type)
            override;
        
        Given a the name of a base class of this class type, return the
        distance of inheritance between this class type and the named
        class (how many generations of inheritance are there between this
        class and the named class). If the named class is not in this
        class's inheritance tree, return a negative value. Valid
        responses will always be nonnegative. This method works in
        combination with vtkTypeMacro found in vtkSetGet.h.
        """
        ...
    
    def GetNumberOfGenerationsFromBaseType(self, string):
        """
        V.GetNumberOfGenerationsFromBaseType(string) -> int
        C++: static vtkIdType GetNumberOfGenerationsFromBaseType(
            const char *type)
        
        Given a the name of a base class of this class type, return the
        distance of inheritance between this class type and the named
        class (how many generations of inheritance are there between this
        class and the named class). If the named class is not in this
        class's inheritance tree, return a negative value. Valid
        responses will always be nonnegative. This method works in
        combination with vtkTypeMacro found in vtkSetGet.h.
        """
        ...
    
    def GetNumberOfSmoothingIterations(self):
        """
        V.GetNumberOfSmoothingIterations() -> int
        C++: virtual int GetNumberOfSmoothingIterations()
        
        Specify the number of smoothing iterations to smooth polygons.
        (Only in effect if output style is Polygonalize and smoothing is
        on.)
        """
        ...
    
    def GetNumberOfSmoothingIterationsMaxValue(self):
        """
        V.GetNumberOfSmoothingIterationsMaxValue() -> int
        C++: virtual int GetNumberOfSmoothingIterationsMaxValue()
        
        Specify the number of smoothing iterations to smooth polygons.
        (Only in effect if output style is Polygonalize and smoothing is
        on.)
        """
        ...
    
    def GetNumberOfSmoothingIterationsMinValue(self):
        """
        V.GetNumberOfSmoothingIterationsMinValue() -> int
        C++: virtual int GetNumberOfSmoothingIterationsMinValue()
        
        Specify the number of smoothing iterations to smooth polygons.
        (Only in effect if output style is Polygonalize and smoothing is
        on.)
        """
        ...
    
    def GetOutputStyle(self):
        """
        V.GetOutputStyle() -> int
        C++: virtual int GetOutputStyle()
        
        Specify how to create the output. Pixelize means converting the
        image to quad polygons with a constant color per quad.
        Polygonalize means merging colors together into polygonal
        regions, and then smoothing the regions (if smoothing is turned
        on). RunLength means creating quad polygons that may encompass
        several pixels on a scan line. The default behavior is
        Polygonalize.
        """
        ...
    
    def GetOutputStyleMaxValue(self):
        """
        V.GetOutputStyleMaxValue() -> int
        C++: virtual int GetOutputStyleMaxValue()
        
        Specify how to create the output. Pixelize means converting the
        image to quad polygons with a constant color per quad.
        Polygonalize means merging colors together into polygonal
        regions, and then smoothing the regions (if smoothing is turned
        on). RunLength means creating quad polygons that may encompass
        several pixels on a scan line. The default behavior is
        Polygonalize.
        """
        ...
    
    def GetOutputStyleMinValue(self):
        """
        V.GetOutputStyleMinValue() -> int
        C++: virtual int GetOutputStyleMinValue()
        
        Specify how to create the output. Pixelize means converting the
        image to quad polygons with a constant color per quad.
        Polygonalize means merging colors together into polygonal
        regions, and then smoothing the regions (if smoothing is turned
        on). RunLength means creating quad polygons that may encompass
        several pixels on a scan line. The default behavior is
        Polygonalize.
        """
        ...
    
    def GetSmoothing(self):
        """
        V.GetSmoothing() -> int
        C++: virtual vtkTypeBool GetSmoothing()
        
        If the output style is set to polygonalize, then you can control
        whether to smooth boundaries.
        """
        ...
    
    def GetSubImageSize(self):
        """
        V.GetSubImageSize() -> int
        C++: virtual int GetSubImageSize()
        
        Specify the size (n by n pixels) of the largest region to
        polygonalize. When the OutputStyle is set to
        VTK_STYLE_POLYGONALIZE, large amounts of memory are used. In
        order to process large images, the image is broken into pieces
        that are at most Size pixels in width and height.
        """
        ...
    
    def GetSubImageSizeMaxValue(self):
        """
        V.GetSubImageSizeMaxValue() -> int
        C++: virtual int GetSubImageSizeMaxValue()
        
        Specify the size (n by n pixels) of the largest region to
        polygonalize. When the OutputStyle is set to
        VTK_STYLE_POLYGONALIZE, large amounts of memory are used. In
        order to process large images, the image is broken into pieces
        that are at most Size pixels in width and height.
        """
        ...
    
    def GetSubImageSizeMinValue(self):
        """
        V.GetSubImageSizeMinValue() -> int
        C++: virtual int GetSubImageSizeMinValue()
        
        Specify the size (n by n pixels) of the largest region to
        polygonalize. When the OutputStyle is set to
        VTK_STYLE_POLYGONALIZE, large amounts of memory are used. In
        order to process large images, the image is broken into pieces
        that are at most Size pixels in width and height.
        """
        ...
    
    def IsA(self, string):
        """
        V.IsA(string) -> int
        C++: vtkTypeBool IsA(const char *type) override;
        
        Return 1 if this class is the same type of (or a subclass of) the
        named class. Returns 0 otherwise. This method works in
        combination with vtkTypeMacro found in vtkSetGet.h.
        """
        ...
    
    def IsTypeOf(self, string):
        """
        V.IsTypeOf(string) -> int
        C++: static vtkTypeBool IsTypeOf(const char *type)
        
        Return 1 if this class type is the same type of (or a subclass
        of) the named class. Returns 0 otherwise. This method works in
        combination with vtkTypeMacro found in vtkSetGet.h.
        """
        ...
    
    def NewInstance(self):
        """
        V.NewInstance() -> vtkImageToPolyDataFilter
        C++: vtkImageToPolyDataFilter *NewInstance()
        """
        ...
    
    def SafeDownCast(self, vtkObjectBase):
        """
        V.SafeDownCast(vtkObjectBase) -> vtkImageToPolyDataFilter
        C++: static vtkImageToPolyDataFilter *SafeDownCast(
            vtkObjectBase *o)
        """
        ...
    
    def SetColorMode(self, p_int):
        """
        V.SetColorMode(int)
        C++: virtual void SetColorMode(int _arg)
        
        Specify how to quantize color.
        """
        ...
    
    def SetColorModeToLinear256(self):
        """
        V.SetColorModeToLinear256()
        C++: void SetColorModeToLinear256()
        
        Specify how to quantize color.
        """
        ...
    
    def SetColorModeToLUT(self):
        """
        V.SetColorModeToLUT()
        C++: void SetColorModeToLUT()
        
        Specify how to quantize color.
        """
        ...
    
    def SetDecimation(self, p_int):
        """
        V.SetDecimation(int)
        C++: virtual void SetDecimation(vtkTypeBool _arg)
        
        Turn on/off whether the final polygons should be decimated.
        whether to smooth boundaries.
        """
        ...
    
    def SetDecimationError(self, p_float):
        """
        V.SetDecimationError(float)
        C++: virtual void SetDecimationError(double _arg)
        
        Specify the error to use for decimation (if decimation is on).
        The error is an absolute number--the image spacing and dimensions
        are used to create points so the error should be consistent with
        the image size.
        """
        ...
    
    def SetError(self, p_int):
        """
        V.SetError(int)
        C++: virtual void SetError(int _arg)
        
        Specify the error value between two colors where the colors are
        considered the same. Only use this if the color mode uses the
        default 256 table.
        """
        ...
    
    def SetLookupTable(self, vtkScalarsToColors):
        """
        V.SetLookupTable(vtkScalarsToColors)
        C++: virtual void SetLookupTable(vtkScalarsToColors *)
        
        Set/Get the vtkLookupTable to use. The lookup table is used when
        the color mode is set to LUT and a single component scalar is
        input.
        """
        ...
    
    def SetNumberOfSmoothingIterations(self, p_int):
        """
        V.SetNumberOfSmoothingIterations(int)
        C++: virtual void SetNumberOfSmoothingIterations(int _arg)
        
        Specify the number of smoothing iterations to smooth polygons.
        (Only in effect if output style is Polygonalize and smoothing is
        on.)
        """
        ...
    
    def SetOutputStyle(self, p_int):
        """
        V.SetOutputStyle(int)
        C++: virtual void SetOutputStyle(int _arg)
        
        Specify how to create the output. Pixelize means converting the
        image to quad polygons with a constant color per quad.
        Polygonalize means merging colors together into polygonal
        regions, and then smoothing the regions (if smoothing is turned
        on). RunLength means creating quad polygons that may encompass
        several pixels on a scan line. The default behavior is
        Polygonalize.
        """
        ...
    
    def SetOutputStyleToPixelize(self):
        """
        V.SetOutputStyleToPixelize()
        C++: void SetOutputStyleToPixelize()
        
        Specify how to create the output. Pixelize means converting the
        image to quad polygons with a constant color per quad.
        Polygonalize means merging colors together into polygonal
        regions, and then smoothing the regions (if smoothing is turned
        on). RunLength means creating quad polygons that may encompass
        several pixels on a scan line. The default behavior is
        Polygonalize.
        """
        ...
    
    def SetOutputStyleToPolygonalize(self):
        """
        V.SetOutputStyleToPolygonalize()
        C++: void SetOutputStyleToPolygonalize()
        
        Specify how to create the output. Pixelize means converting the
        image to quad polygons with a constant color per quad.
        Polygonalize means merging colors together into polygonal
        regions, and then smoothing the regions (if smoothing is turned
        on). RunLength means creating quad polygons that may encompass
        several pixels on a scan line. The default behavior is
        Polygonalize.
        """
        ...
    
    def SetOutputStyleToRunLength(self):
        """
        V.SetOutputStyleToRunLength()
        C++: void SetOutputStyleToRunLength()
        
        Specify how to create the output. Pixelize means converting the
        image to quad polygons with a constant color per quad.
        Polygonalize means merging colors together into polygonal
        regions, and then smoothing the regions (if smoothing is turned
        on). RunLength means creating quad polygons that may encompass
        several pixels on a scan line. The default behavior is
        Polygonalize.
        """
        ...
    
    def SetSmoothing(self, p_int):
        """
        V.SetSmoothing(int)
        C++: virtual void SetSmoothing(vtkTypeBool _arg)
        
        If the output style is set to polygonalize, then you can control
        whether to smooth boundaries.
        """
        ...
    
    def SetSubImageSize(self, p_int):
        """
        V.SetSubImageSize(int)
        C++: virtual void SetSubImageSize(int _arg)
        
        Specify the size (n by n pixels) of the largest region to
        polygonalize. When the OutputStyle is set to
        VTK_STYLE_POLYGONALIZE, large amounts of memory are used. In
        order to process large images, the image is broken into pieces
        that are at most Size pixels in width and height.
        """
        ...
    
    def SmoothingOff(self):
        """
        V.SmoothingOff()
        C++: virtual void SmoothingOff()
        
        If the output style is set to polygonalize, then you can control
        whether to smooth boundaries.
        """
        ...
    
    def SmoothingOn(self):
        """
        V.SmoothingOn()
        C++: virtual void SmoothingOn()
        
        If the output style is set to polygonalize, then you can control
        whether to smooth boundaries.
        """
        ...
    
    def __delattr__(self, *args, **kwargs):
        """ Implement delattr(self, name). """
        ...
    
    def __getattribute__(self, *args, **kwargs):
        """ Return getattr(self, name). """
        ...
    
    def __init__(self, *args, **kwargs) -> None:
        ...
    
    @staticmethod
    def __new__(*args, **kwargs):
        """ Create and return a new object.  See help(type) for accurate signature. """
        ...
    
    def __repr__(self, *args, **kwargs):
        """ Return repr(self). """
        ...
    
    def __setattr__(self, *args, **kwargs):
        """ Implement setattr(self, name, value). """
        ...
    
    def __str__(self, *args, **kwargs) -> str:
        """ Return str(self). """
        ...
    
    __this__ = ...
    __dict__ = ...
    __vtkname__ = ...


class vtkImplicitModeller(__vtkmodules_vtkCommonExecutionModel.vtkImageAlgorithm):
    """
    vtkImplicitModeller - compute distance from input geometry on
    structured point dataset
    
    Superclass: vtkImageAlgorithm
    
    vtkImplicitModeller is a filter that computes the distance from the
    input geometry to the points of an output structured point set. This
    distance function can then be "contoured" to generate new, offset
    surfaces from the original geometry. An important feature of this
    object is "capping". If capping is turned on, after the implicit
    model is created, the values on the boundary of the structured points
    dataset are set to the cap value. This is used to force closure of
    the resulting contoured surface. Note, however, that large cap values
    can generate weird surface normals in those cells adjacent to the
    boundary of the dataset. Using smaller cap value will reduce this
    effect.
    
    Another important ivar is MaximumDistance. This controls how far into
    the volume the distance function is computed from the input geometry.
     Small values give significant increases in performance. However,
    there can strange sampling effects at the extreme range of the
    MaximumDistance.
    
    In order to properly execute and sample the input data, a rectangular
    region in space must be defined (this is the ivar ModelBounds).  If
    not explicitly defined, the model bounds will be computed. Note that
    to avoid boundary effects, it is possible to adjust the model bounds
    (i.e., using the AdjustBounds and AdjustDistance ivars) to strictly
    contain the sampled data.
    
    This filter has one other unusual capability: it is possible to
    append data in a sequence of operations to generate a single output.
    This is useful when you have multiple datasets and want to create a
    conglomeration of all the data.  However, the user must be careful to
    either specify the ModelBounds or specify the first item such that
    its bounds completely contain all other items.  This is because the
    rectangular region of the output can not be changed after the 1st
    Append.
    
    The ProcessMode ivar controls the method used within the Append
    function (where the actual work is done regardless if the Append
    function is explicitly called) to compute the implicit model.  If set
    to work in voxel mode, each voxel is visited once.  If set to cell
    mode, each cell is visited once.  Tests have shown once per voxel to
    be faster when there are a lot of cells (at least a thousand?);
    relative performance improvement increases with addition cells.
    Primitives should not be stripped for best performance of the voxel
    mode.  Also, if explicitly using the Append feature many times, the
    cell mode will probably be better because each voxel will be visited
    each Append.  Append the data before input if possible when using the
    voxel mode.  Do not switch between voxel and cell mode between
    execution of StartAppend and EndAppend.
    
    Further performance improvement is now possible using the PerVoxel
    process mode on multi-processor machines (the mode is now
    multithreaded).  Each thread processes a different "slab" of the
    output.  Also, if the input is vtkPolyData, it is appropriately
    clipped for each thread; that is, each thread only considers the
    input which could affect its slab of the output.
    
    This filter can now produce output of any type supported by
    vtkImageData. However to support this change, additional sqrts must
    be executed during the Append step.  Previously, the output was
    initialized to the squared CapValue in StartAppend, the output was
    updated with squared distance values during the Append, and then the
    sqrt of the distances was computed in EndAppend. To support different
    scalar types in the output (largely to reduce memory requirements as
    an vtkImageShiftScale and/or vtkImageCast could have achieved the
    same result), we can't "afford" to save squared value in the output,
    because then we could only represent up to the sqrt of the scalar max
    for an integer type in the output; 1 (instead of 255) for an unsigned
    char; 11 for a char (instead of 127).  Thus this change may result in
    a minor performance degradation.  Non-float output types can be
    scaled to the CapValue by turning ScaleToMaximumDistance On.
    
    @sa
    vtkSampleFunction vtkContourFilter
    """
    def AdjustBoundsOff(self):
        """
        V.AdjustBoundsOff()
        C++: virtual void AdjustBoundsOff()
        
        Control how the model bounds are computed. If the ivar
        AdjustBounds is set, then the bounds specified (or computed
        automatically) is modified by the fraction given by
        AdjustDistance. This means that the model bounds is expanded in
        each of the x-y-z directions.
        """
        ...
    
    def AdjustBoundsOn(self):
        """
        V.AdjustBoundsOn()
        C++: virtual void AdjustBoundsOn()
        
        Control how the model bounds are computed. If the ivar
        AdjustBounds is set, then the bounds specified (or computed
        automatically) is modified by the fraction given by
        AdjustDistance. This means that the model bounds is expanded in
        each of the x-y-z directions.
        """
        ...
    
    def Append(self, vtkDataSet):
        """
        V.Append(vtkDataSet)
        C++: void Append(vtkDataSet *input)
        
        Append a data set to the existing output. To use this function,
        you'll have to invoke the StartAppend() method before doing
        successive appends. It's also a good idea to specify the model
        bounds; otherwise the input model bounds is used. When you've
        finished appending, use the EndAppend() method.
        """
        ...
    
    def CappingOff(self):
        """
        V.CappingOff()
        C++: virtual void CappingOff()
        
        The outer boundary of the structured point set can be assigned a
        particular value. This can be used to close or "cap" all
        surfaces.
        """
        ...
    
    def CappingOn(self):
        """
        V.CappingOn()
        C++: virtual void CappingOn()
        
        The outer boundary of the structured point set can be assigned a
        particular value. This can be used to close or "cap" all
        surfaces.
        """
        ...
    
    def ComputeModelBounds(self, vtkDataSet):
        """
        V.ComputeModelBounds(vtkDataSet) -> float
        C++: double ComputeModelBounds(vtkDataSet *input=nullptr)
        
        Compute ModelBounds from input geometry. If input is not
        specified, the input of the filter will be used.
        """
        ...
    
    def EndAppend(self):
        """
        V.EndAppend()
        C++: void EndAppend()
        
        Method completes the append process.
        """
        ...
    
    def GetAdjustBounds(self):
        """
        V.GetAdjustBounds() -> int
        C++: virtual vtkTypeBool GetAdjustBounds()
        
        Control how the model bounds are computed. If the ivar
        AdjustBounds is set, then the bounds specified (or computed
        automatically) is modified by the fraction given by
        AdjustDistance. This means that the model bounds is expanded in
        each of the x-y-z directions.
        """
        ...
    
    def GetAdjustDistance(self):
        """
        V.GetAdjustDistance() -> float
        C++: virtual double GetAdjustDistance()
        
        Specify the amount to grow the model bounds (if the ivar
        AdjustBounds is set). The value is a fraction of the maximum
        length of the sides of the box specified by the model bounds.
        """
        ...
    
    def GetAdjustDistanceMaxValue(self):
        """
        V.GetAdjustDistanceMaxValue() -> float
        C++: virtual double GetAdjustDistanceMaxValue()
        
        Specify the amount to grow the model bounds (if the ivar
        AdjustBounds is set). The value is a fraction of the maximum
        length of the sides of the box specified by the model bounds.
        """
        ...
    
    def GetAdjustDistanceMinValue(self):
        """
        V.GetAdjustDistanceMinValue() -> float
        C++: virtual double GetAdjustDistanceMinValue()
        
        Specify the amount to grow the model bounds (if the ivar
        AdjustBounds is set). The value is a fraction of the maximum
        length of the sides of the box specified by the model bounds.
        """
        ...
    
    def GetCapping(self):
        """
        V.GetCapping() -> int
        C++: virtual vtkTypeBool GetCapping()
        
        The outer boundary of the structured point set can be assigned a
        particular value. This can be used to close or "cap" all
        surfaces.
        """
        ...
    
    def GetCapValue(self):
        """
        V.GetCapValue() -> float
        C++: virtual double GetCapValue()
        
        Specify the capping value to use. The CapValue is also used as an
        initial distance value at each point in the dataset.
        """
        ...
    
    def GetLocatorMaxLevel(self):
        """
        V.GetLocatorMaxLevel() -> int
        C++: virtual int GetLocatorMaxLevel()
        
        Specify the level of the locator to use when using the per voxel
        process mode.
        """
        ...
    
    def GetMaximumDistance(self):
        """
        V.GetMaximumDistance() -> float
        C++: virtual double GetMaximumDistance()
        
        Set / get the distance away from surface of input geometry to
        sample. This value is specified as a percentage of the length of
        the diagonal of the input data bounding box. Smaller values make
        large increases in performance.
        """
        ...
    
    def GetMaximumDistanceMaxValue(self):
        """
        V.GetMaximumDistanceMaxValue() -> float
        C++: virtual double GetMaximumDistanceMaxValue()
        
        Set / get the distance away from surface of input geometry to
        sample. This value is specified as a percentage of the length of
        the diagonal of the input data bounding box. Smaller values make
        large increases in performance.
        """
        ...
    
    def GetMaximumDistanceMinValue(self):
        """
        V.GetMaximumDistanceMinValue() -> float
        C++: virtual double GetMaximumDistanceMinValue()
        
        Set / get the distance away from surface of input geometry to
        sample. This value is specified as a percentage of the length of
        the diagonal of the input data bounding box. Smaller values make
        large increases in performance.
        """
        ...
    
    def GetModelBounds(self):
        """
        V.GetModelBounds() -> (float, float, float, float, float, float)
        C++: virtual double *GetModelBounds()
        
        Set / get the region in space in which to perform the sampling.
        If not specified, it will be computed automatically.
        """
        ...
    
    def GetNumberOfGenerationsFromBase(self, string):
        """
        V.GetNumberOfGenerationsFromBase(string) -> int
        C++: vtkIdType GetNumberOfGenerationsFromBase(const char *type)
            override;
        
        Given a the name of a base class of this class type, return the
        distance of inheritance between this class type and the named
        class (how many generations of inheritance are there between this
        class and the named class). If the named class is not in this
        class's inheritance tree, return a negative value. Valid
        responses will always be nonnegative. This method works in
        combination with vtkTypeMacro found in vtkSetGet.h.
        """
        ...
    
    def GetNumberOfGenerationsFromBaseType(self, string):
        """
        V.GetNumberOfGenerationsFromBaseType(string) -> int
        C++: static vtkIdType GetNumberOfGenerationsFromBaseType(
            const char *type)
        
        Given a the name of a base class of this class type, return the
        distance of inheritance between this class type and the named
        class (how many generations of inheritance are there between this
        class and the named class). If the named class is not in this
        class's inheritance tree, return a negative value. Valid
        responses will always be nonnegative. This method works in
        combination with vtkTypeMacro found in vtkSetGet.h.
        """
        ...
    
    def GetNumberOfThreads(self):
        """
        V.GetNumberOfThreads() -> int
        C++: virtual int GetNumberOfThreads()
        
        Set / Get the number of threads used during Per-Voxel processing
        mode
        """
        ...
    
    def GetNumberOfThreadsMaxValue(self):
        """
        V.GetNumberOfThreadsMaxValue() -> int
        C++: virtual int GetNumberOfThreadsMaxValue()
        
        Set / Get the number of threads used during Per-Voxel processing
        mode
        """
        ...
    
    def GetNumberOfThreadsMinValue(self):
        """
        V.GetNumberOfThreadsMinValue() -> int
        C++: virtual int GetNumberOfThreadsMinValue()
        
        Set / Get the number of threads used during Per-Voxel processing
        mode
        """
        ...
    
    def GetOutputScalarType(self):
        """
        V.GetOutputScalarType() -> int
        C++: virtual int GetOutputScalarType()
        
        Set the desired output scalar type.
        """
        ...
    
    def GetProcessMode(self):
        """
        V.GetProcessMode() -> int
        C++: virtual int GetProcessMode()
        
        Specify whether to visit each cell once per append or each voxel
        once per append.  Some tests have shown once per voxel to be
        faster when there are a lot of cells (at least a thousand?);
        relative performance improvement increases with addition cells. 
        Primitives should not be stripped for best performance of the
        voxel mode.
        """
        ...
    
    def GetProcessModeAsString(self):
        """
        V.GetProcessModeAsString() -> string
        C++: const char *GetProcessModeAsString(void)
        
        Specify whether to visit each cell once per append or each voxel
        once per append.  Some tests have shown once per voxel to be
        faster when there are a lot of cells (at least a thousand?);
        relative performance improvement increases with addition cells. 
        Primitives should not be stripped for best performance of the
        voxel mode.
        """
        ...
    
    def GetProcessModeMaxValue(self):
        """
        V.GetProcessModeMaxValue() -> int
        C++: virtual int GetProcessModeMaxValue()
        
        Specify whether to visit each cell once per append or each voxel
        once per append.  Some tests have shown once per voxel to be
        faster when there are a lot of cells (at least a thousand?);
        relative performance improvement increases with addition cells. 
        Primitives should not be stripped for best performance of the
        voxel mode.
        """
        ...
    
    def GetProcessModeMinValue(self):
        """
        V.GetProcessModeMinValue() -> int
        C++: virtual int GetProcessModeMinValue()
        
        Specify whether to visit each cell once per append or each voxel
        once per append.  Some tests have shown once per voxel to be
        faster when there are a lot of cells (at least a thousand?);
        relative performance improvement increases with addition cells. 
        Primitives should not be stripped for best performance of the
        voxel mode.
        """
        ...
    
    def GetSampleDimensions(self):
        """
        V.GetSampleDimensions() -> (int, int, int)
        C++: virtual int *GetSampleDimensions()
        
        Set/Get the i-j-k dimensions on which to sample distance
        function.
        """
        ...
    
    def GetScaleToMaximumDistance(self):
        """
        V.GetScaleToMaximumDistance() -> int
        C++: virtual vtkTypeBool GetScaleToMaximumDistance()
        
        If a non-floating output type is specified, the output distances
        can be scaled to use the entire positive scalar range of the
        output type specified (up to the CapValue which is equal to the
        max for the type unless modified by the user).  For example, if
        ScaleToMaximumDistance is On and the OutputScalarType is
        UnsignedChar the distances saved in the output would be linearly
        scaled between 0 (for distances "very close" to the surface) and
        255 (at the specified maximum distance)... assuming the CapValue
        is not changed from 255.
        """
        ...
    
    def IsA(self, string):
        """
        V.IsA(string) -> int
        C++: vtkTypeBool IsA(const char *type) override;
        
        Return 1 if this class is the same type of (or a subclass of) the
        named class. Returns 0 otherwise. This method works in
        combination with vtkTypeMacro found in vtkSetGet.h.
        """
        ...
    
    def IsTypeOf(self, string):
        """
        V.IsTypeOf(string) -> int
        C++: static vtkTypeBool IsTypeOf(const char *type)
        
        Return 1 if this class type is the same type of (or a subclass
        of) the named class. Returns 0 otherwise. This method works in
        combination with vtkTypeMacro found in vtkSetGet.h.
        """
        ...
    
    def NewInstance(self):
        """
        V.NewInstance() -> vtkImplicitModeller
        C++: vtkImplicitModeller *NewInstance()
        """
        ...
    
    def SafeDownCast(self, vtkObjectBase):
        """
        V.SafeDownCast(vtkObjectBase) -> vtkImplicitModeller
        C++: static vtkImplicitModeller *SafeDownCast(vtkObjectBase *o)
        """
        ...
    
    def ScaleToMaximumDistanceOff(self):
        """
        V.ScaleToMaximumDistanceOff()
        C++: virtual void ScaleToMaximumDistanceOff()
        
        If a non-floating output type is specified, the output distances
        can be scaled to use the entire positive scalar range of the
        output type specified (up to the CapValue which is equal to the
        max for the type unless modified by the user).  For example, if
        ScaleToMaximumDistance is On and the OutputScalarType is
        UnsignedChar the distances saved in the output would be linearly
        scaled between 0 (for distances "very close" to the surface) and
        255 (at the specified maximum distance)... assuming the CapValue
        is not changed from 255.
        """
        ...
    
    def ScaleToMaximumDistanceOn(self):
        """
        V.ScaleToMaximumDistanceOn()
        C++: virtual void ScaleToMaximumDistanceOn()
        
        If a non-floating output type is specified, the output distances
        can be scaled to use the entire positive scalar range of the
        output type specified (up to the CapValue which is equal to the
        max for the type unless modified by the user).  For example, if
        ScaleToMaximumDistance is On and the OutputScalarType is
        UnsignedChar the distances saved in the output would be linearly
        scaled between 0 (for distances "very close" to the surface) and
        255 (at the specified maximum distance)... assuming the CapValue
        is not changed from 255.
        """
        ...
    
    def SetAdjustBounds(self, p_int):
        """
        V.SetAdjustBounds(int)
        C++: virtual void SetAdjustBounds(vtkTypeBool _arg)
        
        Control how the model bounds are computed. If the ivar
        AdjustBounds is set, then the bounds specified (or computed
        automatically) is modified by the fraction given by
        AdjustDistance. This means that the model bounds is expanded in
        each of the x-y-z directions.
        """
        ...
    
    def SetAdjustDistance(self, p_float):
        """
        V.SetAdjustDistance(float)
        C++: virtual void SetAdjustDistance(double _arg)
        
        Specify the amount to grow the model bounds (if the ivar
        AdjustBounds is set). The value is a fraction of the maximum
        length of the sides of the box specified by the model bounds.
        """
        ...
    
    def SetCapping(self, p_int):
        """
        V.SetCapping(int)
        C++: virtual void SetCapping(vtkTypeBool _arg)
        
        The outer boundary of the structured point set can be assigned a
        particular value. This can be used to close or "cap" all
        surfaces.
        """
        ...
    
    def SetCapValue(self, p_float):
        """
        V.SetCapValue(float)
        C++: void SetCapValue(double value)
        
        Specify the capping value to use. The CapValue is also used as an
        initial distance value at each point in the dataset.
        """
        ...
    
    def SetLocatorMaxLevel(self, p_int):
        """
        V.SetLocatorMaxLevel(int)
        C++: virtual void SetLocatorMaxLevel(int _arg)
        
        Specify the level of the locator to use when using the per voxel
        process mode.
        """
        ...
    
    def SetMaximumDistance(self, p_float):
        """
        V.SetMaximumDistance(float)
        C++: virtual void SetMaximumDistance(double _arg)
        
        Set / get the distance away from surface of input geometry to
        sample. This value is specified as a percentage of the length of
        the diagonal of the input data bounding box. Smaller values make
        large increases in performance.
        """
        ...
    
    def SetModelBounds(self, p_float, p_float_1, p_float_2, p_float_3, p_float_4, p_float_5):
        """
        V.SetModelBounds(float, float, float, float, float, float)
        C++: virtual void SetModelBounds(double _arg1, double _arg2,
            double _arg3, double _arg4, double _arg5, double _arg6)
        V.SetModelBounds((float, float, float, float, float, float))
        C++: virtual void SetModelBounds(const double _arg[6])
        
        Set / get the region in space in which to perform the sampling.
        If not specified, it will be computed automatically.
        """
        ...
    
    def SetNumberOfThreads(self, p_int):
        """
        V.SetNumberOfThreads(int)
        C++: virtual void SetNumberOfThreads(int _arg)
        
        Set / Get the number of threads used during Per-Voxel processing
        mode
        """
        ...
    
    def SetOutputScalarType(self, p_int):
        """
        V.SetOutputScalarType(int)
        C++: void SetOutputScalarType(int type)
        
        Set the desired output scalar type.
        """
        ...
    
    def SetOutputScalarTypeToChar(self):
        """
        V.SetOutputScalarTypeToChar()
        C++: void SetOutputScalarTypeToChar()
        
        Set the desired output scalar type.
        """
        ...
    
    def SetOutputScalarTypeToDouble(self):
        """
        V.SetOutputScalarTypeToDouble()
        C++: void SetOutputScalarTypeToDouble()
        
        Set the desired output scalar type.
        """
        ...
    
    def SetOutputScalarTypeToFloat(self):
        """
        V.SetOutputScalarTypeToFloat()
        C++: void SetOutputScalarTypeToFloat()
        
        Set the desired output scalar type.
        """
        ...
    
    def SetOutputScalarTypeToInt(self):
        """
        V.SetOutputScalarTypeToInt()
        C++: void SetOutputScalarTypeToInt()
        
        Set the desired output scalar type.
        """
        ...
    
    def SetOutputScalarTypeToLong(self):
        """
        V.SetOutputScalarTypeToLong()
        C++: void SetOutputScalarTypeToLong()
        
        Set the desired output scalar type.
        """
        ...
    
    def SetOutputScalarTypeToShort(self):
        """
        V.SetOutputScalarTypeToShort()
        C++: void SetOutputScalarTypeToShort()
        
        Set the desired output scalar type.
        """
        ...
    
    def SetOutputScalarTypeToUnsignedChar(self):
        """
        V.SetOutputScalarTypeToUnsignedChar()
        C++: void SetOutputScalarTypeToUnsignedChar()
        
        Set the desired output scalar type.
        """
        ...
    
    def SetOutputScalarTypeToUnsignedInt(self):
        """
        V.SetOutputScalarTypeToUnsignedInt()
        C++: void SetOutputScalarTypeToUnsignedInt()
        
        Set the desired output scalar type.
        """
        ...
    
    def SetOutputScalarTypeToUnsignedLong(self):
        """
        V.SetOutputScalarTypeToUnsignedLong()
        C++: void SetOutputScalarTypeToUnsignedLong()
        
        Set the desired output scalar type.
        """
        ...
    
    def SetOutputScalarTypeToUnsignedShort(self):
        """
        V.SetOutputScalarTypeToUnsignedShort()
        C++: void SetOutputScalarTypeToUnsignedShort()
        
        Set the desired output scalar type.
        """
        ...
    
    def SetProcessMode(self, p_int):
        """
        V.SetProcessMode(int)
        C++: virtual void SetProcessMode(int _arg)
        
        Specify whether to visit each cell once per append or each voxel
        once per append.  Some tests have shown once per voxel to be
        faster when there are a lot of cells (at least a thousand?);
        relative performance improvement increases with addition cells. 
        Primitives should not be stripped for best performance of the
        voxel mode.
        """
        ...
    
    def SetProcessModeToPerCell(self):
        """
        V.SetProcessModeToPerCell()
        C++: void SetProcessModeToPerCell()
        
        Specify whether to visit each cell once per append or each voxel
        once per append.  Some tests have shown once per voxel to be
        faster when there are a lot of cells (at least a thousand?);
        relative performance improvement increases with addition cells. 
        Primitives should not be stripped for best performance of the
        voxel mode.
        """
        ...
    
    def SetProcessModeToPerVoxel(self):
        """
        V.SetProcessModeToPerVoxel()
        C++: void SetProcessModeToPerVoxel()
        
        Specify whether to visit each cell once per append or each voxel
        once per append.  Some tests have shown once per voxel to be
        faster when there are a lot of cells (at least a thousand?);
        relative performance improvement increases with addition cells. 
        Primitives should not be stripped for best performance of the
        voxel mode.
        """
        ...
    
    def SetSampleDimensions(self, p_int, p_int_1, p_int_2):
        """
        V.SetSampleDimensions(int, int, int)
        C++: void SetSampleDimensions(int i, int j, int k)
        V.SetSampleDimensions([int, int, int])
        C++: void SetSampleDimensions(int dim[3])
        
        Set/Get the i-j-k dimensions on which to sample distance
        function.
        """
        ...
    
    def SetScaleToMaximumDistance(self, p_int):
        """
        V.SetScaleToMaximumDistance(int)
        C++: virtual void SetScaleToMaximumDistance(vtkTypeBool _arg)
        
        If a non-floating output type is specified, the output distances
        can be scaled to use the entire positive scalar range of the
        output type specified (up to the CapValue which is equal to the
        max for the type unless modified by the user).  For example, if
        ScaleToMaximumDistance is On and the OutputScalarType is
        UnsignedChar the distances saved in the output would be linearly
        scaled between 0 (for distances "very close" to the surface) and
        255 (at the specified maximum distance)... assuming the CapValue
        is not changed from 255.
        """
        ...
    
    def StartAppend(self):
        """
        V.StartAppend()
        C++: void StartAppend()
        
        Initialize the filter for appending data. You must invoke the
        StartAppend() method before doing successive Appends(). It's also
        a good idea to manually specify the model bounds; otherwise the
        input bounds for the data will be used.
        """
        ...
    
    def __delattr__(self, *args, **kwargs):
        """ Implement delattr(self, name). """
        ...
    
    def __getattribute__(self, *args, **kwargs):
        """ Return getattr(self, name). """
        ...
    
    def __init__(self, *args, **kwargs) -> None:
        ...
    
    @staticmethod
    def __new__(*args, **kwargs):
        """ Create and return a new object.  See help(type) for accurate signature. """
        ...
    
    def __repr__(self, *args, **kwargs):
        """ Return repr(self). """
        ...
    
    def __setattr__(self, *args, **kwargs):
        """ Implement setattr(self, name, value). """
        ...
    
    def __str__(self, *args, **kwargs) -> str:
        """ Return str(self). """
        ...
    
    __this__ = ...
    __dict__ = ...
    __vtkname__ = ...


class vtkPCAAnalysisFilter(__vtkmodules_vtkCommonExecutionModel.vtkMultiBlockDataSetAlgorithm):
    """
    vtkPCAAnalysisFilter - Performs principal component analysis of a set
    of aligned pointsets
    
    Superclass: vtkMultiBlockDataSetAlgorithm
    
    vtkPCAAnalysisFilter is a filter that takes as input a set of aligned
    pointsets (any object derived from vtkPointSet) and performs a
    principal component analysis of the coordinates. This can be used to
    visualise the major or minor modes of variation seen in a set of
    similar biological objects with corresponding landmarks.
    vtkPCAAnalysisFilter is designed to work with the output from the
    vtkProcrustesAnalysisFilter vtkPCAAnalysisFilter requires a
    vtkMultiBlock input consisting of vtkPointSets as first level
    children.
    
    vtkPCAAnalysisFilter is an implementation of (for example):
    
    T. Cootes et al. : Active Shape Models - their training and
    application. Computer Vision and Image Understanding, 61(1):38-59,
    1995.
    
    The material can also be found in Tim Cootes' ever-changing online
    report published at his website: http://www.isbe.man.ac.uk/~bim/
    
    @warning
    All of the input pointsets must have the same number of points.
    
    @par Thanks: Rasmus Paulsen and Tim Hutton who developed and
    contributed this class
    
    @sa
    vtkProcrustesAlignmentFilter
    """
    def GetEvals(self):
        """
        V.GetEvals() -> vtkFloatArray
        C++: virtual vtkFloatArray *GetEvals()
        
        Get the vector of eigenvalues sorted in descending order
        """
        ...
    
    def GetModesRequiredFor(self, p_float):
        """
        V.GetModesRequiredFor(float) -> int
        C++: int GetModesRequiredFor(double proportion)
        
        Retrieve how many modes are necessary to model the given
        proportion of the variation. proportion should be between 0 and 1
        """
        ...
    
    def GetNumberOfGenerationsFromBase(self, string):
        """
        V.GetNumberOfGenerationsFromBase(string) -> int
        C++: vtkIdType GetNumberOfGenerationsFromBase(const char *type)
            override;
        
        Given a the name of a base class of this class type, return the
        distance of inheritance between this class type and the named
        class (how many generations of inheritance are there between this
        class and the named class). If the named class is not in this
        class's inheritance tree, return a negative value. Valid
        responses will always be nonnegative. This method works in
        combination with vtkTypeMacro found in vtkSetGet.h.
        """
        ...
    
    def GetNumberOfGenerationsFromBaseType(self, string):
        """
        V.GetNumberOfGenerationsFromBaseType(string) -> int
        C++: static vtkIdType GetNumberOfGenerationsFromBaseType(
            const char *type)
        
        Given a the name of a base class of this class type, return the
        distance of inheritance between this class type and the named
        class (how many generations of inheritance are there between this
        class and the named class). If the named class is not in this
        class's inheritance tree, return a negative value. Valid
        responses will always be nonnegative. This method works in
        combination with vtkTypeMacro found in vtkSetGet.h.
        """
        ...
    
    def GetParameterisedShape(self, vtkFloatArray, vtkPointSet):
        """
        V.GetParameterisedShape(vtkFloatArray, vtkPointSet)
        C++: void GetParameterisedShape(vtkFloatArray *b,
            vtkPointSet *shape)
        
        Fills the shape with:
        
        * mean + b[0] * sqrt(eigenvalue[0]) * eigenvector[0]
        * + b[1] * sqrt(eigenvalue[1]) * eigenvector[1]
        * ...
        * + b[sizeb-1] * sqrt(eigenvalue[bsize-1]) * eigenvector[bsize-1]
        
        * here b are the parameters expressed in standard deviations
        * bsize is the number of parameters in the b vector
        * This function assumes that shape is already allocated
        * with the right size, it just moves the points.
        """
        ...
    
    def GetShapeParameters(self, vtkPointSet, vtkFloatArray, p_int):
        """
        V.GetShapeParameters(vtkPointSet, vtkFloatArray, int)
        C++: void GetShapeParameters(vtkPointSet *shape, vtkFloatArray *b,
             int bsize)
        
        Return the bsize parameters b that best model the given shape (in
        standard deviations). That is that the given shape will be
        approximated by:
        
        * shape ~ mean + b[0] * sqrt(eigenvalue[0]) * eigenvector[0]
        * + b[1] * sqrt(eigenvalue[1]) * eigenvector[1]
        * ...
        * + b[bsize-1] * sqrt(eigenvalue[bsize-1]) * eigenvector[bsize-1]
        """
        ...
    
    def IsA(self, string):
        """
        V.IsA(string) -> int
        C++: vtkTypeBool IsA(const char *type) override;
        
        Return 1 if this class is the same type of (or a subclass of) the
        named class. Returns 0 otherwise. This method works in
        combination with vtkTypeMacro found in vtkSetGet.h.
        """
        ...
    
    def IsTypeOf(self, string):
        """
        V.IsTypeOf(string) -> int
        C++: static vtkTypeBool IsTypeOf(const char *type)
        
        Return 1 if this class type is the same type of (or a subclass
        of) the named class. Returns 0 otherwise. This method works in
        combination with vtkTypeMacro found in vtkSetGet.h.
        """
        ...
    
    def NewInstance(self):
        """
        V.NewInstance() -> vtkPCAAnalysisFilter
        C++: vtkPCAAnalysisFilter *NewInstance()
        """
        ...
    
    def SafeDownCast(self, vtkObjectBase):
        """
        V.SafeDownCast(vtkObjectBase) -> vtkPCAAnalysisFilter
        C++: static vtkPCAAnalysisFilter *SafeDownCast(vtkObjectBase *o)
        """
        ...
    
    def __delattr__(self, *args, **kwargs):
        """ Implement delattr(self, name). """
        ...
    
    def __getattribute__(self, *args, **kwargs):
        """ Return getattr(self, name). """
        ...
    
    def __init__(self, *args, **kwargs) -> None:
        ...
    
    @staticmethod
    def __new__(*args, **kwargs):
        """ Create and return a new object.  See help(type) for accurate signature. """
        ...
    
    def __repr__(self, *args, **kwargs):
        """ Return repr(self). """
        ...
    
    def __setattr__(self, *args, **kwargs):
        """ Implement setattr(self, name, value). """
        ...
    
    def __str__(self, *args, **kwargs) -> str:
        """ Return str(self). """
        ...
    
    __this__ = ...
    __dict__ = ...
    __vtkname__ = ...


class vtkPolyDataSilhouette(__vtkmodules_vtkCommonExecutionModel.vtkPolyDataAlgorithm):
    """
    vtkPolyDataSilhouette - sort polydata along camera view direction
    
    Superclass: vtkPolyDataAlgorithm
    
    vtkPolyDataSilhouette extracts a subset of a polygonal mesh edges to
    generate an outline (silhouette) of the corresponding 3D object. In
    addition, this filter can also extracts sharp edges (aka feature
    angles). In order to use this filter you must specify the a point of
    view (origin) or a direction (vector).  given this direction or
    origin, a silhouette is generated wherever the surface's normal is
    orthogonal to the view direction.
    
    @warning
    when the active camera is used, almost everything is recomputed for
    each frame, keep this in mind when dealing with extremely large
    surface data sets.
    
    @par Thanks: Contribution by Thierry Carrard
    
    CEA/DIF - Commissariat a l'Energie Atomique, Centre DAM Ile-De-France
    
    BP12, F-91297 Arpajon, France.
    """
    def BorderEdgesOff(self):
        """
        V.BorderEdgesOff()
        C++: virtual void BorderEdgesOff()
        
        Enables or Disables generation of border edges. Note: borders
        exist only in case of non closed surface
        """
        ...
    
    def BorderEdgesOn(self):
        """
        V.BorderEdgesOn()
        C++: virtual void BorderEdgesOn()
        
        Enables or Disables generation of border edges. Note: borders
        exist only in case of non closed surface
        """
        ...
    
    def GetBorderEdges(self):
        """
        V.GetBorderEdges() -> int
        C++: virtual vtkTypeBool GetBorderEdges()
        
        Enables or Disables generation of border edges. Note: borders
        exist only in case of non closed surface
        """
        ...
    
    def GetCamera(self):
        """
        V.GetCamera() -> vtkCamera
        C++: virtual vtkCamera *GetCamera()
        
        Specify a camera that is used to define the view direction.  This
        ivar only has effect if the direction is set to
        VTK_DIRECTION_CAMERA_ORIGIN or VTK_DIRECTION_CAMERA_VECTOR, and a
        camera is specified.
        """
        ...
    
    def GetDirection(self):
        """
        V.GetDirection() -> int
        C++: virtual int GetDirection()
        
        Specify how view direction is computed. By default, the camera
        origin (eye) is used.
        """
        ...
    
    def GetEnableFeatureAngle(self):
        """
        V.GetEnableFeatureAngle() -> int
        C++: virtual int GetEnableFeatureAngle()
        
        Enables or Disables generation of silhouette edges along sharp
        edges
        """
        ...
    
    def GetFeatureAngle(self):
        """
        V.GetFeatureAngle() -> float
        C++: virtual double GetFeatureAngle()
        
        Sets/Gets minimal angle for sharp edges detection. Default is 60
        """
        ...
    
    def GetMTime(self):
        """
        V.GetMTime() -> int
        C++: vtkMTimeType GetMTime() override;
        
        Return MTime also considering the dependent objects: the camera
        and/or the prop3D.
        """
        ...
    
    def GetNumberOfGenerationsFromBase(self, string):
        """
        V.GetNumberOfGenerationsFromBase(string) -> int
        C++: vtkIdType GetNumberOfGenerationsFromBase(const char *type)
            override;
        
        Given a the name of a base class of this class type, return the
        distance of inheritance between this class type and the named
        class (how many generations of inheritance are there between this
        class and the named class). If the named class is not in this
        class's inheritance tree, return a negative value. Valid
        responses will always be nonnegative. This method works in
        combination with vtkTypeMacro found in vtkSetGet.h.
        """
        ...
    
    def GetNumberOfGenerationsFromBaseType(self, string):
        """
        V.GetNumberOfGenerationsFromBaseType(string) -> int
        C++: static vtkIdType GetNumberOfGenerationsFromBaseType(
            const char *type)
        
        Given a the name of a base class of this class type, return the
        distance of inheritance between this class type and the named
        class (how many generations of inheritance are there between this
        class and the named class). If the named class is not in this
        class's inheritance tree, return a negative value. Valid
        responses will always be nonnegative. This method works in
        combination with vtkTypeMacro found in vtkSetGet.h.
        """
        ...
    
    def GetOrigin(self):
        """
        V.GetOrigin() -> (float, float, float)
        C++: virtual double *GetOrigin()
        
        Set/Get the sort origin. This ivar only has effect if the sort
        direction is set to SetDirectionToSpecifiedOrigin(). The edge
        detection occurs in the direction of the origin to each edge's
        center.
        """
        ...
    
    def GetPieceInvariant(self):
        """
        V.GetPieceInvariant() -> int
        C++: virtual vtkTypeBool GetPieceInvariant()
        
        Enables or Disables piece invariance. This is useful when dealing
        with multi-block data sets. Note: requires one level of ghost
        cells
        """
        ...
    
    def GetProp3D(self):
        """
        V.GetProp3D() -> vtkProp3D
        C++: vtkProp3D *GetProp3D()
        
        Specify a transformation matrix (via the vtkProp3D::GetMatrix()
        method) that is used to include the effects of transformation.
        This ivar only has effect if the direction is set to
        VTK_DIRECTION_CAMERA_ORIGIN or VTK_DIRECTION_CAMERA_VECTOR, and a
        camera is specified. Specifying the vtkProp3D is optional.
        """
        ...
    
    def GetVector(self):
        """
        V.GetVector() -> (float, float, float)
        C++: virtual double *GetVector()
        
        Set/Get the sort direction. This ivar only has effect if the sort
        direction is set to SetDirectionToSpecifiedVector(). The edge
        detection occurs in the direction of the vector.
        """
        ...
    
    def IsA(self, string):
        """
        V.IsA(string) -> int
        C++: vtkTypeBool IsA(const char *type) override;
        
        Return 1 if this class is the same type of (or a subclass of) the
        named class. Returns 0 otherwise. This method works in
        combination with vtkTypeMacro found in vtkSetGet.h.
        """
        ...
    
    def IsTypeOf(self, string):
        """
        V.IsTypeOf(string) -> int
        C++: static vtkTypeBool IsTypeOf(const char *type)
        
        Return 1 if this class type is the same type of (or a subclass
        of) the named class. Returns 0 otherwise. This method works in
        combination with vtkTypeMacro found in vtkSetGet.h.
        """
        ...
    
    def NewInstance(self):
        """
        V.NewInstance() -> vtkPolyDataSilhouette
        C++: vtkPolyDataSilhouette *NewInstance()
        """
        ...
    
    def PieceInvariantOff(self):
        """
        V.PieceInvariantOff()
        C++: virtual void PieceInvariantOff()
        
        Enables or Disables piece invariance. This is useful when dealing
        with multi-block data sets. Note: requires one level of ghost
        cells
        """
        ...
    
    def PieceInvariantOn(self):
        """
        V.PieceInvariantOn()
        C++: virtual void PieceInvariantOn()
        
        Enables or Disables piece invariance. This is useful when dealing
        with multi-block data sets. Note: requires one level of ghost
        cells
        """
        ...
    
    def SafeDownCast(self, vtkObjectBase):
        """
        V.SafeDownCast(vtkObjectBase) -> vtkPolyDataSilhouette
        C++: static vtkPolyDataSilhouette *SafeDownCast(vtkObjectBase *o)
        """
        ...
    
    def SetBorderEdges(self, p_int):
        """
        V.SetBorderEdges(int)
        C++: virtual void SetBorderEdges(vtkTypeBool _arg)
        
        Enables or Disables generation of border edges. Note: borders
        exist only in case of non closed surface
        """
        ...
    
    def SetCamera(self, vtkCamera):
        """
        V.SetCamera(vtkCamera)
        C++: virtual void SetCamera(vtkCamera *)
        
        Specify a camera that is used to define the view direction.  This
        ivar only has effect if the direction is set to
        VTK_DIRECTION_CAMERA_ORIGIN or VTK_DIRECTION_CAMERA_VECTOR, and a
        camera is specified.
        """
        ...
    
    def SetDirection(self, p_int):
        """
        V.SetDirection(int)
        C++: virtual void SetDirection(int _arg)
        
        Specify how view direction is computed. By default, the camera
        origin (eye) is used.
        """
        ...
    
    def SetDirectionToCameraOrigin(self):
        """
        V.SetDirectionToCameraOrigin()
        C++: void SetDirectionToCameraOrigin()
        
        Specify how view direction is computed. By default, the camera
        origin (eye) is used.
        """
        ...
    
    def SetDirectionToCameraVector(self):
        """
        V.SetDirectionToCameraVector()
        C++: void SetDirectionToCameraVector()
        
        Specify how view direction is computed. By default, the camera
        origin (eye) is used.
        """
        ...
    
    def SetDirectionToSpecifiedOrigin(self):
        """
        V.SetDirectionToSpecifiedOrigin()
        C++: void SetDirectionToSpecifiedOrigin()
        
        Specify how view direction is computed. By default, the camera
        origin (eye) is used.
        """
        ...
    
    def SetDirectionToSpecifiedVector(self):
        """
        V.SetDirectionToSpecifiedVector()
        C++: void SetDirectionToSpecifiedVector()
        
        Specify how view direction is computed. By default, the camera
        origin (eye) is used.
        """
        ...
    
    def SetEnableFeatureAngle(self, p_int):
        """
        V.SetEnableFeatureAngle(int)
        C++: virtual void SetEnableFeatureAngle(int _arg)
        
        Enables or Disables generation of silhouette edges along sharp
        edges
        """
        ...
    
    def SetFeatureAngle(self, p_float):
        """
        V.SetFeatureAngle(float)
        C++: virtual void SetFeatureAngle(double _arg)
        
        Sets/Gets minimal angle for sharp edges detection. Default is 60
        """
        ...
    
    def SetOrigin(self, p_float, p_float_1, p_float_2):
        """
        V.SetOrigin(float, float, float)
        C++: virtual void SetOrigin(double _arg1, double _arg2,
            double _arg3)
        V.SetOrigin((float, float, float))
        C++: virtual void SetOrigin(const double _arg[3])
        
        Set/Get the sort origin. This ivar only has effect if the sort
        direction is set to SetDirectionToSpecifiedOrigin(). The edge
        detection occurs in the direction of the origin to each edge's
        center.
        """
        ...
    
    def SetPieceInvariant(self, p_int):
        """
        V.SetPieceInvariant(int)
        C++: virtual void SetPieceInvariant(vtkTypeBool _arg)
        
        Enables or Disables piece invariance. This is useful when dealing
        with multi-block data sets. Note: requires one level of ghost
        cells
        """
        ...
    
    def SetProp3D(self, vtkProp3D):
        """
        V.SetProp3D(vtkProp3D)
        C++: void SetProp3D(vtkProp3D *)
        
        Specify a transformation matrix (via the vtkProp3D::GetMatrix()
        method) that is used to include the effects of transformation.
        This ivar only has effect if the direction is set to
        VTK_DIRECTION_CAMERA_ORIGIN or VTK_DIRECTION_CAMERA_VECTOR, and a
        camera is specified. Specifying the vtkProp3D is optional.
        """
        ...
    
    def SetVector(self, p_float, p_float_1, p_float_2):
        """
        V.SetVector(float, float, float)
        C++: virtual void SetVector(double _arg1, double _arg2,
            double _arg3)
        V.SetVector((float, float, float))
        C++: virtual void SetVector(const double _arg[3])
        
        Set/Get the sort direction. This ivar only has effect if the sort
        direction is set to SetDirectionToSpecifiedVector(). The edge
        detection occurs in the direction of the vector.
        """
        ...
    
    def __delattr__(self, *args, **kwargs):
        """ Implement delattr(self, name). """
        ...
    
    def __getattribute__(self, *args, **kwargs):
        """ Return getattr(self, name). """
        ...
    
    def __init__(self, *args, **kwargs) -> None:
        ...
    
    @staticmethod
    def __new__(*args, **kwargs):
        """ Create and return a new object.  See help(type) for accurate signature. """
        ...
    
    def __repr__(self, *args, **kwargs):
        """ Return repr(self). """
        ...
    
    def __setattr__(self, *args, **kwargs):
        """ Implement setattr(self, name, value). """
        ...
    
    def __str__(self, *args, **kwargs) -> str:
        """ Return str(self). """
        ...
    
    __this__ = ...
    Directions = ...
    VTK_DIRECTION_CAMERA_ORIGIN = ...
    VTK_DIRECTION_CAMERA_VECTOR = ...
    VTK_DIRECTION_SPECIFIED_ORIGIN = ...
    VTK_DIRECTION_SPECIFIED_VECTOR = ...
    __dict__ = ...
    __vtkname__ = ...


class vtkProcrustesAlignmentFilter(__vtkmodules_vtkCommonExecutionModel.vtkMultiBlockDataSetAlgorithm):
    """
    vtkProcrustesAlignmentFilter - aligns a set of pointsets together
    
    Superclass: vtkMultiBlockDataSetAlgorithm
    
    vtkProcrustesAlignmentFilter is a filter that takes a set of
    pointsets (any object derived from vtkPointSet) and aligns them in a
    least-squares sense to their mutual mean. The algorithm is iterated
    until convergence, as the mean must be recomputed after each
    alignment.
    
    vtkProcrustesAlignmentFilter requires a vtkMultiBlock input
    consisting of vtkPointSets as first level children.
    
    The default (in vtkLandmarkTransform) is for a similarity alignment.
    For a rigid-body alignment (to build a 'size-and-shape' model) use:
    
    
       GetLandmarkTransform()->SetModeToRigidBody().
    
    Affine alignments are not normally used but are left in for
    completeness:
    
    
       GetLandmarkTransform()->SetModeToAffine().
    
    vtkProcrustesAlignmentFilter is an implementation of:
    
    
       J.C. Gower (1975)
       Generalized Procrustes Analysis. Psychometrika, 40:33-51.
    
    @warning
    All of the input pointsets must have the same number of points.
    
    @par Thanks: Tim Hutton and Rasmus Paulsen who developed and
    contributed this class
    
    @sa
    vtkLandmarkTransform
    """
    def GetLandmarkTransform(self):
        """
        V.GetLandmarkTransform() -> vtkLandmarkTransform
        C++: virtual vtkLandmarkTransform *GetLandmarkTransform()
        
        Get the internal landmark transform. Use it to constrain the
        number of degrees of freedom of the alignment (i.e. rigid body,
        similarity, etc.). The default is a similarity alignment.
        """
        ...
    
    def GetMeanPoints(self):
        """
        V.GetMeanPoints() -> vtkPoints
        C++: virtual vtkPoints *GetMeanPoints()
        
        Get the estimated mean point cloud
        """
        ...
    
    def GetNumberOfGenerationsFromBase(self, string):
        """
        V.GetNumberOfGenerationsFromBase(string) -> int
        C++: vtkIdType GetNumberOfGenerationsFromBase(const char *type)
            override;
        
        Given a the name of a base class of this class type, return the
        distance of inheritance between this class type and the named
        class (how many generations of inheritance are there between this
        class and the named class). If the named class is not in this
        class's inheritance tree, return a negative value. Valid
        responses will always be nonnegative. This method works in
        combination with vtkTypeMacro found in vtkSetGet.h.
        """
        ...
    
    def GetNumberOfGenerationsFromBaseType(self, string):
        """
        V.GetNumberOfGenerationsFromBaseType(string) -> int
        C++: static vtkIdType GetNumberOfGenerationsFromBaseType(
            const char *type)
        
        Given a the name of a base class of this class type, return the
        distance of inheritance between this class type and the named
        class (how many generations of inheritance are there between this
        class and the named class). If the named class is not in this
        class's inheritance tree, return a negative value. Valid
        responses will always be nonnegative. This method works in
        combination with vtkTypeMacro found in vtkSetGet.h.
        """
        ...
    
    def GetOutputPointsPrecision(self):
        """
        V.GetOutputPointsPrecision() -> int
        C++: virtual int GetOutputPointsPrecision()
        
        Set/get the desired precision for the output types. See the
        documentation for the vtkAlgorithm::DesiredOutputPrecision enum
        for an explanation of the available precision settings. If the
        desired precision is DEFAULT_PRECISION and any of the inputs are
        double precision, then the mean points will be double precision.
        Otherwise, if the desired precision is DEFAULT_PRECISION and all
        the inputs are single precision, then the mean points will be
        single precision.
        """
        ...
    
    def GetStartFromCentroid(self):
        """
        V.GetStartFromCentroid() -> bool
        C++: virtual bool GetStartFromCentroid()
        
        When on, the initial alignment is to the centroid of the cohort
        curves.  When off, the alignment is to the centroid of the first
        input.  Default is off for backward compatibility.
        """
        ...
    
    def IsA(self, string):
        """
        V.IsA(string) -> int
        C++: vtkTypeBool IsA(const char *type) override;
        
        Return 1 if this class is the same type of (or a subclass of) the
        named class. Returns 0 otherwise. This method works in
        combination with vtkTypeMacro found in vtkSetGet.h.
        """
        ...
    
    def IsTypeOf(self, string):
        """
        V.IsTypeOf(string) -> int
        C++: static vtkTypeBool IsTypeOf(const char *type)
        
        Return 1 if this class type is the same type of (or a subclass
        of) the named class. Returns 0 otherwise. This method works in
        combination with vtkTypeMacro found in vtkSetGet.h.
        """
        ...
    
    def NewInstance(self):
        """
        V.NewInstance() -> vtkProcrustesAlignmentFilter
        C++: vtkProcrustesAlignmentFilter *NewInstance()
        """
        ...
    
    def SafeDownCast(self, vtkObjectBase):
        """
        V.SafeDownCast(vtkObjectBase) -> vtkProcrustesAlignmentFilter
        C++: static vtkProcrustesAlignmentFilter *SafeDownCast(
            vtkObjectBase *o)
        """
        ...
    
    def SetOutputPointsPrecision(self, p_int):
        """
        V.SetOutputPointsPrecision(int)
        C++: virtual void SetOutputPointsPrecision(int _arg)
        
        Set/get the desired precision for the output types. See the
        documentation for the vtkAlgorithm::DesiredOutputPrecision enum
        for an explanation of the available precision settings. If the
        desired precision is DEFAULT_PRECISION and any of the inputs are
        double precision, then the mean points will be double precision.
        Otherwise, if the desired precision is DEFAULT_PRECISION and all
        the inputs are single precision, then the mean points will be
        single precision.
        """
        ...
    
    def SetStartFromCentroid(self, bool):
        """
        V.SetStartFromCentroid(bool)
        C++: virtual void SetStartFromCentroid(bool _arg)
        
        When on, the initial alignment is to the centroid of the cohort
        curves.  When off, the alignment is to the centroid of the first
        input.  Default is off for backward compatibility.
        """
        ...
    
    def StartFromCentroidOff(self):
        """
        V.StartFromCentroidOff()
        C++: virtual void StartFromCentroidOff()
        
        When on, the initial alignment is to the centroid of the cohort
        curves.  When off, the alignment is to the centroid of the first
        input.  Default is off for backward compatibility.
        """
        ...
    
    def StartFromCentroidOn(self):
        """
        V.StartFromCentroidOn()
        C++: virtual void StartFromCentroidOn()
        
        When on, the initial alignment is to the centroid of the cohort
        curves.  When off, the alignment is to the centroid of the first
        input.  Default is off for backward compatibility.
        """
        ...
    
    def __delattr__(self, *args, **kwargs):
        """ Implement delattr(self, name). """
        ...
    
    def __getattribute__(self, *args, **kwargs):
        """ Return getattr(self, name). """
        ...
    
    def __init__(self, *args, **kwargs) -> None:
        ...
    
    @staticmethod
    def __new__(*args, **kwargs):
        """ Create and return a new object.  See help(type) for accurate signature. """
        ...
    
    def __repr__(self, *args, **kwargs):
        """ Return repr(self). """
        ...
    
    def __setattr__(self, *args, **kwargs):
        """ Implement setattr(self, name, value). """
        ...
    
    def __str__(self, *args, **kwargs) -> str:
        """ Return str(self). """
        ...
    
    __this__ = ...
    __dict__ = ...
    __vtkname__ = ...


class vtkProjectedTerrainPath(__vtkmodules_vtkCommonExecutionModel.vtkPolyDataAlgorithm):
    """
    vtkProjectedTerrainPath - project a polyline onto a terrain
    
    Superclass: vtkPolyDataAlgorithm
    
    vtkProjectedTerrainPath projects an input polyline onto a terrain.
    (The terrain is defined by a 2D height image and is the second input
    to the filter.) The polyline projection is controlled via several
    modes as follows. 1) Simple mode projects the polyline points onto
    the terrain, taking into account the height offset instance variable.
    2) Non-occluded mode insures that no parts of the polyline are
    occluded by the terrain (e.g. a line passes through a mountain). This
    may require recursive subdivision of the polyline. 3) Hug mode
    insures that the polyine points remain within a constant distance
    from the surface. This may also require recursive subdivision of the
    polyline. Note that both non-occluded mode and hug mode also take
    into account the height offset, so it is possible to create paths
    that hug terrain a certain distance above it. To use this filter,
    define two inputs: 1) a polyline, and 2) an image whose scalar values
    represent a height field. Then specify the mode, and the height
    offset to use.
    
    An description of the algorithm is as follows. The filter begins by
    projecting the polyline points to the image (offset by the specified
    height offset).  If the mode is non-occluded or hug, then the maximum
    error along each line segment is computed and placed into a priority
    queue. Each line segment is then split at the point of maximum error,
    and the two new line segments are evaluated for maximum error. This
    process continues until the line is not occluded by the terrain
    (non-occluded mode) or satisfies the error on variation from the
    surface (hug mode). (Note this process is repeated for each polyline
    in the input. Also, the maximum error is computed in two parts: a
    maximum positive error and maximum negative error. If the polyline is
    above the terrain--i.e., the height offset is positive--in
    non-occluded or hug mode all negative errors are eliminated. If the
    polyline is below the terrain--i.e., the height offset is
    negative--in non-occluded or hug mode all positive errors are
    eliminated.)
    
    @warning
    This algorithm requires the entire input image to be in memory, hence
    it may not work for extremely large images.
    
    @warning
    The input height image is assumed to be positioned in the x-y plane
    so the scalar value is the z-coordinate, height value.
    
    @warning
    A priority queue is used so that the 1) the total number of line
    segments can be controlled, and 2) the algorithm can terminate when
    the errors in the queue are less than the specified error tolerance.
    
    @sa
    vtkGreedyTerrainDecimation
    """
    def GetHeightOffset(self):
        """
        V.GetHeightOffset() -> float
        C++: virtual double GetHeightOffset()
        
        This is the height above (or below) the terrain that the
        projected path should be. Positive values indicate distances
        above the terrain; negative values indicate distances below the
        terrain.
        """
        ...
    
    def GetHeightTolerance(self):
        """
        V.GetHeightTolerance() -> float
        C++: virtual double GetHeightTolerance()
        
        This is the allowable variation in the altitude of the path with
        respect to the variation in the terrain. It only comes into play
        if the hug projection mode is enabled.
        """
        ...
    
    def GetHeightToleranceMaxValue(self):
        """
        V.GetHeightToleranceMaxValue() -> float
        C++: virtual double GetHeightToleranceMaxValue()
        
        This is the allowable variation in the altitude of the path with
        respect to the variation in the terrain. It only comes into play
        if the hug projection mode is enabled.
        """
        ...
    
    def GetHeightToleranceMinValue(self):
        """
        V.GetHeightToleranceMinValue() -> float
        C++: virtual double GetHeightToleranceMinValue()
        
        This is the allowable variation in the altitude of the path with
        respect to the variation in the terrain. It only comes into play
        if the hug projection mode is enabled.
        """
        ...
    
    def GetMaximumNumberOfLines(self):
        """
        V.GetMaximumNumberOfLines() -> int
        C++: virtual vtkIdType GetMaximumNumberOfLines()
        
        This instance variable can be used to limit the total number of
        line segments created during subdivision. Note that the number of
        input line segments will be the minimum number that cab be
        output.
        """
        ...
    
    def GetMaximumNumberOfLinesMaxValue(self):
        """
        V.GetMaximumNumberOfLinesMaxValue() -> int
        C++: virtual vtkIdType GetMaximumNumberOfLinesMaxValue()
        
        This instance variable can be used to limit the total number of
        line segments created during subdivision. Note that the number of
        input line segments will be the minimum number that cab be
        output.
        """
        ...
    
    def GetMaximumNumberOfLinesMinValue(self):
        """
        V.GetMaximumNumberOfLinesMinValue() -> int
        C++: virtual vtkIdType GetMaximumNumberOfLinesMinValue()
        
        This instance variable can be used to limit the total number of
        line segments created during subdivision. Note that the number of
        input line segments will be the minimum number that cab be
        output.
        """
        ...
    
    def GetNumberOfGenerationsFromBase(self, string):
        """
        V.GetNumberOfGenerationsFromBase(string) -> int
        C++: vtkIdType GetNumberOfGenerationsFromBase(const char *type)
            override;
        
        Standard methods for printing and determining type information.
        """
        ...
    
    def GetNumberOfGenerationsFromBaseType(self, string):
        """
        V.GetNumberOfGenerationsFromBaseType(string) -> int
        C++: static vtkIdType GetNumberOfGenerationsFromBaseType(
            const char *type)
        
        Standard methods for printing and determining type information.
        """
        ...
    
    def GetProjectionMode(self):
        """
        V.GetProjectionMode() -> int
        C++: virtual int GetProjectionMode()
        
        Determine how to control the projection process. Simple
        projection just projects the original polyline points.
        Non-occluded projection insures that the polyline does not
        intersect the terrain surface. Hug projection is similar to
        non-occulded projection except that produces a path that is
        nearly parallel to the terrain (within the user specified height
        tolerance).
        """
        ...
    
    def GetProjectionModeMaxValue(self):
        """
        V.GetProjectionModeMaxValue() -> int
        C++: virtual int GetProjectionModeMaxValue()
        
        Determine how to control the projection process. Simple
        projection just projects the original polyline points.
        Non-occluded projection insures that the polyline does not
        intersect the terrain surface. Hug projection is similar to
        non-occulded projection except that produces a path that is
        nearly parallel to the terrain (within the user specified height
        tolerance).
        """
        ...
    
    def GetProjectionModeMinValue(self):
        """
        V.GetProjectionModeMinValue() -> int
        C++: virtual int GetProjectionModeMinValue()
        
        Determine how to control the projection process. Simple
        projection just projects the original polyline points.
        Non-occluded projection insures that the polyline does not
        intersect the terrain surface. Hug projection is similar to
        non-occulded projection except that produces a path that is
        nearly parallel to the terrain (within the user specified height
        tolerance).
        """
        ...
    
    def GetSource(self):
        """
        V.GetSource() -> vtkImageData
        C++: vtkImageData *GetSource()
        
        Specify the second input (the terrain) onto which the polyline(s)
        should be projected. Note: This assigns a data object as the
        input terrain. To establish a pipeline connection, use
        SetSourceConnection() method.
        """
        ...
    
    def IsA(self, string):
        """
        V.IsA(string) -> int
        C++: vtkTypeBool IsA(const char *type) override;
        
        Standard methods for printing and determining type information.
        """
        ...
    
    def IsTypeOf(self, string):
        """
        V.IsTypeOf(string) -> int
        C++: static vtkTypeBool IsTypeOf(const char *type)
        
        Standard methods for printing and determining type information.
        """
        ...
    
    def NewInstance(self):
        """
        V.NewInstance() -> vtkProjectedTerrainPath
        C++: vtkProjectedTerrainPath *NewInstance()
        
        Standard methods for printing and determining type information.
        """
        ...
    
    def SafeDownCast(self, vtkObjectBase):
        """
        V.SafeDownCast(vtkObjectBase) -> vtkProjectedTerrainPath
        C++: static vtkProjectedTerrainPath *SafeDownCast(
            vtkObjectBase *o)
        
        Standard methods for printing and determining type information.
        """
        ...
    
    def SetHeightOffset(self, p_float):
        """
        V.SetHeightOffset(float)
        C++: virtual void SetHeightOffset(double _arg)
        
        This is the height above (or below) the terrain that the
        projected path should be. Positive values indicate distances
        above the terrain; negative values indicate distances below the
        terrain.
        """
        ...
    
    def SetHeightTolerance(self, p_float):
        """
        V.SetHeightTolerance(float)
        C++: virtual void SetHeightTolerance(double _arg)
        
        This is the allowable variation in the altitude of the path with
        respect to the variation in the terrain. It only comes into play
        if the hug projection mode is enabled.
        """
        ...
    
    def SetMaximumNumberOfLines(self, p_int):
        """
        V.SetMaximumNumberOfLines(int)
        C++: virtual void SetMaximumNumberOfLines(vtkIdType _arg)
        
        This instance variable can be used to limit the total number of
        line segments created during subdivision. Note that the number of
        input line segments will be the minimum number that cab be
        output.
        """
        ...
    
    def SetProjectionMode(self, p_int):
        """
        V.SetProjectionMode(int)
        C++: virtual void SetProjectionMode(int _arg)
        
        Determine how to control the projection process. Simple
        projection just projects the original polyline points.
        Non-occluded projection insures that the polyline does not
        intersect the terrain surface. Hug projection is similar to
        non-occulded projection except that produces a path that is
        nearly parallel to the terrain (within the user specified height
        tolerance).
        """
        ...
    
    def SetProjectionModeToHug(self):
        """
        V.SetProjectionModeToHug()
        C++: void SetProjectionModeToHug()
        
        Determine how to control the projection process. Simple
        projection just projects the original polyline points.
        Non-occluded projection insures that the polyline does not
        intersect the terrain surface. Hug projection is similar to
        non-occulded projection except that produces a path that is
        nearly parallel to the terrain (within the user specified height
        tolerance).
        """
        ...
    
    def SetProjectionModeToNonOccluded(self):
        """
        V.SetProjectionModeToNonOccluded()
        C++: void SetProjectionModeToNonOccluded()
        
        Determine how to control the projection process. Simple
        projection just projects the original polyline points.
        Non-occluded projection insures that the polyline does not
        intersect the terrain surface. Hug projection is similar to
        non-occulded projection except that produces a path that is
        nearly parallel to the terrain (within the user specified height
        tolerance).
        """
        ...
    
    def SetProjectionModeToSimple(self):
        """
        V.SetProjectionModeToSimple()
        C++: void SetProjectionModeToSimple()
        
        Determine how to control the projection process. Simple
        projection just projects the original polyline points.
        Non-occluded projection insures that the polyline does not
        intersect the terrain surface. Hug projection is similar to
        non-occulded projection except that produces a path that is
        nearly parallel to the terrain (within the user specified height
        tolerance).
        """
        ...
    
    def SetSourceConnection(self, vtkAlgorithmOutput):
        """
        V.SetSourceConnection(vtkAlgorithmOutput)
        C++: void SetSourceConnection(vtkAlgorithmOutput *algOutput)
        
        Specify the second input (the terrain) onto which the polyline(s)
        should be projected. Note: vtkImageData* is required
        """
        ...
    
    def SetSourceData(self, vtkImageData):
        """
        V.SetSourceData(vtkImageData)
        C++: void SetSourceData(vtkImageData *source)
        
        Specify the second input (the terrain) onto which the polyline(s)
        should be projected. Note: This assigns a data object as the
        input terrain. To establish a pipeline connection, use
        SetSourceConnection() method.
        """
        ...
    
    def __delattr__(self, *args, **kwargs):
        """ Implement delattr(self, name). """
        ...
    
    def __getattribute__(self, *args, **kwargs):
        """ Return getattr(self, name). """
        ...
    
    def __init__(self, *args, **kwargs) -> None:
        ...
    
    @staticmethod
    def __new__(*args, **kwargs):
        """ Create and return a new object.  See help(type) for accurate signature. """
        ...
    
    def __repr__(self, *args, **kwargs):
        """ Return repr(self). """
        ...
    
    def __setattr__(self, *args, **kwargs):
        """ Implement setattr(self, name, value). """
        ...
    
    def __str__(self, *args, **kwargs) -> str:
        """ Return str(self). """
        ...
    
    __this__ = ...
    HUG_PROJECTION = ...
    NONOCCLUDED_PROJECTION = ...
    SIMPLE_PROJECTION = ...
    __dict__ = ...
    __vtkname__ = ...


class vtkRenderLargeImage(__vtkmodules_vtkCommonExecutionModel.vtkAlgorithm):
    """
    vtkRenderLargeImage - Use tiling to generate a large rendering
    
    Superclass: vtkAlgorithm
    
    vtkRenderLargeImage provides methods needed to read a region from a
    file.
    """
    def GetInput(self):
        """
        V.GetInput() -> vtkRenderer
        C++: virtual vtkRenderer *GetInput()
        
        Returns which renderer is being used as the source for the pixel
        data.
        """
        ...
    
    def GetMagnification(self):
        """
        V.GetMagnification() -> int
        C++: virtual int GetMagnification()
        
        The magnification of the current render window
        """
        ...
    
    def GetNumberOfGenerationsFromBase(self, string):
        """
        V.GetNumberOfGenerationsFromBase(string) -> int
        C++: vtkIdType GetNumberOfGenerationsFromBase(const char *type)
            override;
        
        Given a the name of a base class of this class type, return the
        distance of inheritance between this class type and the named
        class (how many generations of inheritance are there between this
        class and the named class). If the named class is not in this
        class's inheritance tree, return a negative value. Valid
        responses will always be nonnegative. This method works in
        combination with vtkTypeMacro found in vtkSetGet.h.
        """
        ...
    
    def GetNumberOfGenerationsFromBaseType(self, string):
        """
        V.GetNumberOfGenerationsFromBaseType(string) -> int
        C++: static vtkIdType GetNumberOfGenerationsFromBaseType(
            const char *type)
        
        Given a the name of a base class of this class type, return the
        distance of inheritance between this class type and the named
        class (how many generations of inheritance are there between this
        class and the named class). If the named class is not in this
        class's inheritance tree, return a negative value. Valid
        responses will always be nonnegative. This method works in
        combination with vtkTypeMacro found in vtkSetGet.h.
        """
        ...
    
    def GetOutput(self):
        """
        V.GetOutput() -> vtkImageData
        C++: vtkImageData *GetOutput()
        
        Get the output data object for a port on this algorithm.
        """
        ...
    
    def IsA(self, string):
        """
        V.IsA(string) -> int
        C++: vtkTypeBool IsA(const char *type) override;
        
        Return 1 if this class is the same type of (or a subclass of) the
        named class. Returns 0 otherwise. This method works in
        combination with vtkTypeMacro found in vtkSetGet.h.
        """
        ...
    
    def IsTypeOf(self, string):
        """
        V.IsTypeOf(string) -> int
        C++: static vtkTypeBool IsTypeOf(const char *type)
        
        Return 1 if this class type is the same type of (or a subclass
        of) the named class. Returns 0 otherwise. This method works in
        combination with vtkTypeMacro found in vtkSetGet.h.
        """
        ...
    
    def NewInstance(self):
        """
        V.NewInstance() -> vtkRenderLargeImage
        C++: vtkRenderLargeImage *NewInstance()
        """
        ...
    
    def SafeDownCast(self, vtkObjectBase):
        """
        V.SafeDownCast(vtkObjectBase) -> vtkRenderLargeImage
        C++: static vtkRenderLargeImage *SafeDownCast(vtkObjectBase *o)
        """
        ...
    
    def SetInput(self, vtkRenderer):
        """
        V.SetInput(vtkRenderer)
        C++: virtual void SetInput(vtkRenderer *)
        
        Indicates what renderer to get the pixel data from.
        """
        ...
    
    def SetMagnification(self, p_int):
        """
        V.SetMagnification(int)
        C++: virtual void SetMagnification(int _arg)
        
        The magnification of the current render window
        """
        ...
    
    def __delattr__(self, *args, **kwargs):
        """ Implement delattr(self, name). """
        ...
    
    def __getattribute__(self, *args, **kwargs):
        """ Return getattr(self, name). """
        ...
    
    def __init__(self, *args, **kwargs) -> None:
        ...
    
    @staticmethod
    def __new__(*args, **kwargs):
        """ Create and return a new object.  See help(type) for accurate signature. """
        ...
    
    def __repr__(self, *args, **kwargs):
        """ Return repr(self). """
        ...
    
    def __setattr__(self, *args, **kwargs):
        """ Implement setattr(self, name, value). """
        ...
    
    def __str__(self, *args, **kwargs) -> str:
        """ Return str(self). """
        ...
    
    __this__ = ...
    __dict__ = ...
    __vtkname__ = ...


class vtkTemporalArrayOperatorFilter(__vtkmodules_vtkCommonExecutionModel.vtkMultiTimeStepAlgorithm):
    """
    vtkTemporalArrayOperatorFilter - perform simple mathematical
    operation on a data array at different time
    
    Superclass: vtkMultiTimeStepAlgorithm
    
    This filter computes a simple operation between two time steps of one
    data array.
    
    @sa
    vtkArrayCalulator
    """
    def GetFirstTimeStepIndex(self):
        """
        V.GetFirstTimeStepIndex() -> int
        C++: virtual int GetFirstTimeStepIndex()
        
        Set/Get the first time step.
        """
        ...
    
    def GetNumberOfGenerationsFromBase(self, string):
        """
        V.GetNumberOfGenerationsFromBase(string) -> int
        C++: vtkIdType GetNumberOfGenerationsFromBase(const char *type)
            override;
        
        Given a the name of a base class of this class type, return the
        distance of inheritance between this class type and the named
        class (how many generations of inheritance are there between this
        class and the named class). If the named class is not in this
        class's inheritance tree, return a negative value. Valid
        responses will always be nonnegative. This method works in
        combination with vtkTypeMacro found in vtkSetGet.h.
        """
        ...
    
    def GetNumberOfGenerationsFromBaseType(self, string):
        """
        V.GetNumberOfGenerationsFromBaseType(string) -> int
        C++: static vtkIdType GetNumberOfGenerationsFromBaseType(
            const char *type)
        
        Given a the name of a base class of this class type, return the
        distance of inheritance between this class type and the named
        class (how many generations of inheritance are there between this
        class and the named class). If the named class is not in this
        class's inheritance tree, return a negative value. Valid
        responses will always be nonnegative. This method works in
        combination with vtkTypeMacro found in vtkSetGet.h.
        """
        ...
    
    def GetOperator(self):
        """
        V.GetOperator() -> int
        C++: virtual int GetOperator()
        
        Set/Get the operator to apply. Default is ADD (0).
        """
        ...
    
    def GetOutputArrayNameSuffix(self):
        """
        V.GetOutputArrayNameSuffix() -> string
        C++: virtual char *GetOutputArrayNameSuffix()
        
        Set/Get the suffix to be append to the output array name.
        If not specified, output will be suffixed with '_' and the
        operation type (eg. myarrayname_add).
        """
        ...
    
    def GetSecondTimeStepIndex(self):
        """
        V.GetSecondTimeStepIndex() -> int
        C++: virtual int GetSecondTimeStepIndex()
        
        Set/Get the second time step.
        """
        ...
    
    def IsA(self, string):
        """
        V.IsA(string) -> int
        C++: vtkTypeBool IsA(const char *type) override;
        
        Return 1 if this class is the same type of (or a subclass of) the
        named class. Returns 0 otherwise. This method works in
        combination with vtkTypeMacro found in vtkSetGet.h.
        """
        ...
    
    def IsTypeOf(self, string):
        """
        V.IsTypeOf(string) -> int
        C++: static vtkTypeBool IsTypeOf(const char *type)
        
        Return 1 if this class type is the same type of (or a subclass
        of) the named class. Returns 0 otherwise. This method works in
        combination with vtkTypeMacro found in vtkSetGet.h.
        """
        ...
    
    def NewInstance(self):
        """
        V.NewInstance() -> vtkTemporalArrayOperatorFilter
        C++: vtkTemporalArrayOperatorFilter *NewInstance()
        """
        ...
    
    def SafeDownCast(self, vtkObjectBase):
        """
        V.SafeDownCast(vtkObjectBase) -> vtkTemporalArrayOperatorFilter
        C++: static vtkTemporalArrayOperatorFilter *SafeDownCast(
            vtkObjectBase *o)
        """
        ...
    
    def SetFirstTimeStepIndex(self, p_int):
        """
        V.SetFirstTimeStepIndex(int)
        C++: virtual void SetFirstTimeStepIndex(int _arg)
        
        Set/Get the first time step.
        """
        ...
    
    def SetOperator(self, p_int):
        """
        V.SetOperator(int)
        C++: virtual void SetOperator(int _arg)
        
        Set/Get the operator to apply. Default is ADD (0).
        """
        ...
    
    def SetOutputArrayNameSuffix(self, string):
        """
        V.SetOutputArrayNameSuffix(string)
        C++: virtual void SetOutputArrayNameSuffix(const char *_arg)
        
        Set/Get the suffix to be append to the output array name.
        If not specified, output will be suffixed with '_' and the
        operation type (eg. myarrayname_add).
        """
        ...
    
    def SetSecondTimeStepIndex(self, p_int):
        """
        V.SetSecondTimeStepIndex(int)
        C++: virtual void SetSecondTimeStepIndex(int _arg)
        
        Set/Get the second time step.
        """
        ...
    
    def __delattr__(self, *args, **kwargs):
        """ Implement delattr(self, name). """
        ...
    
    def __getattribute__(self, *args, **kwargs):
        """ Return getattr(self, name). """
        ...
    
    def __init__(self, *args, **kwargs) -> None:
        ...
    
    @staticmethod
    def __new__(*args, **kwargs):
        """ Create and return a new object.  See help(type) for accurate signature. """
        ...
    
    def __repr__(self, *args, **kwargs):
        """ Return repr(self). """
        ...
    
    def __setattr__(self, *args, **kwargs):
        """ Implement setattr(self, name, value). """
        ...
    
    def __str__(self, *args, **kwargs) -> str:
        """ Return str(self). """
        ...
    
    __this__ = ...
    ADD = ...
    DIV = ...
    MUL = ...
    OperatorType = ...
    SUB = ...
    __dict__ = ...
    __vtkname__ = ...


class vtkTemporalDataSetCache(__vtkmodules_vtkCommonExecutionModel.vtkAlgorithm):
    """
    vtkTemporalDataSetCache - cache time steps
    
    Superclass: vtkAlgorithm
    
    vtkTemporalDataSetCache cache time step requests of a temporal
    dataset, when cached data is requested it is returned using a shallow
    copy.@par Thanks: Ken Martin (Kitware) and John Bidiscombe of CSCS -
    Swiss National Supercomputing Centre for creating and contributing
    this class. For related material, please refer to : John Biddiscombe,
    Berk Geveci, Ken Martin, Kenneth Moreland, David Thompson, "Time Dependent Processing in a Parallel Pipeline
    Architecture", IEEE Visualization 2007.
    """
    def GetCacheSize(self):
        """
        V.GetCacheSize() -> int
        C++: virtual int GetCacheSize()
        
        This is the maximum number of time steps that can be retained in
        memory. it defaults to 10.
        """
        ...
    
    def GetNumberOfGenerationsFromBase(self, string):
        """
        V.GetNumberOfGenerationsFromBase(string) -> int
        C++: vtkIdType GetNumberOfGenerationsFromBase(const char *type)
            override;
        
        Given a the name of a base class of this class type, return the
        distance of inheritance between this class type and the named
        class (how many generations of inheritance are there between this
        class and the named class). If the named class is not in this
        class's inheritance tree, return a negative value. Valid
        responses will always be nonnegative. This method works in
        combination with vtkTypeMacro found in vtkSetGet.h.
        """
        ...
    
    def GetNumberOfGenerationsFromBaseType(self, string):
        """
        V.GetNumberOfGenerationsFromBaseType(string) -> int
        C++: static vtkIdType GetNumberOfGenerationsFromBaseType(
            const char *type)
        
        Given a the name of a base class of this class type, return the
        distance of inheritance between this class type and the named
        class (how many generations of inheritance are there between this
        class and the named class). If the named class is not in this
        class's inheritance tree, return a negative value. Valid
        responses will always be nonnegative. This method works in
        combination with vtkTypeMacro found in vtkSetGet.h.
        """
        ...
    
    def IsA(self, string):
        """
        V.IsA(string) -> int
        C++: vtkTypeBool IsA(const char *type) override;
        
        Return 1 if this class is the same type of (or a subclass of) the
        named class. Returns 0 otherwise. This method works in
        combination with vtkTypeMacro found in vtkSetGet.h.
        """
        ...
    
    def IsTypeOf(self, string):
        """
        V.IsTypeOf(string) -> int
        C++: static vtkTypeBool IsTypeOf(const char *type)
        
        Return 1 if this class type is the same type of (or a subclass
        of) the named class. Returns 0 otherwise. This method works in
        combination with vtkTypeMacro found in vtkSetGet.h.
        """
        ...
    
    def NewInstance(self):
        """
        V.NewInstance() -> vtkTemporalDataSetCache
        C++: vtkTemporalDataSetCache *NewInstance()
        """
        ...
    
    def SafeDownCast(self, vtkObjectBase):
        """
        V.SafeDownCast(vtkObjectBase) -> vtkTemporalDataSetCache
        C++: static vtkTemporalDataSetCache *SafeDownCast(
            vtkObjectBase *o)
        """
        ...
    
    def SetCacheSize(self, p_int):
        """
        V.SetCacheSize(int)
        C++: void SetCacheSize(int size)
        
        This is the maximum number of time steps that can be retained in
        memory. it defaults to 10.
        """
        ...
    
    def __delattr__(self, *args, **kwargs):
        """ Implement delattr(self, name). """
        ...
    
    def __getattribute__(self, *args, **kwargs):
        """ Return getattr(self, name). """
        ...
    
    def __init__(self, *args, **kwargs) -> None:
        ...
    
    @staticmethod
    def __new__(*args, **kwargs):
        """ Create and return a new object.  See help(type) for accurate signature. """
        ...
    
    def __repr__(self, *args, **kwargs):
        """ Return repr(self). """
        ...
    
    def __setattr__(self, *args, **kwargs):
        """ Implement setattr(self, name, value). """
        ...
    
    def __str__(self, *args, **kwargs) -> str:
        """ Return str(self). """
        ...
    
    __this__ = ...
    __dict__ = ...
    __vtkname__ = ...


class vtkTemporalFractal(__vtkmodules_vtkCommonExecutionModel.vtkAlgorithm):
    """
    vtkTemporalFractal - A source to test AMR data object.
    
    Superclass: vtkAlgorithm
    
    vtkTemporalFractal is a collection of uniform grids.  All have the
    same dimensions. Each block has a different origin and spacing.  It
    uses mandelbrot to create cell data. The fractal array is scaled to
    look like a volume fraction.
    
    I may also add block id and level as extra cell arrays. This source
    produces a vtkHierarchicalBoxDataSet when GenerateRectilinearGrids is
    off, otherwise produces a vtkMultiBlockDataSet.
    """
    def AdaptiveSubdivisionOff(self):
        """
        V.AdaptiveSubdivisionOff()
        C++: virtual void AdaptiveSubdivisionOff()
        
        Make the division adaptive or not, defaults to Adaptive
        """
        ...
    
    def AdaptiveSubdivisionOn(self):
        """
        V.AdaptiveSubdivisionOn()
        C++: virtual void AdaptiveSubdivisionOn()
        
        Make the division adaptive or not, defaults to Adaptive
        """
        ...
    
    def DiscreteTimeStepsOff(self):
        """
        V.DiscreteTimeStepsOff()
        C++: virtual void DiscreteTimeStepsOff()
        
        Limit this source to discrete integer time steps Default is off
        (continuous)
        """
        ...
    
    def DiscreteTimeStepsOn(self):
        """
        V.DiscreteTimeStepsOn()
        C++: virtual void DiscreteTimeStepsOn()
        
        Limit this source to discrete integer time steps Default is off
        (continuous)
        """
        ...
    
    def GenerateRectilinearGridsOff(self):
        """
        V.GenerateRectilinearGridsOff()
        C++: virtual void GenerateRectilinearGridsOff()
        
        Generate either rectilinear grids either uniform grids. Default
        is false.
        """
        ...
    
    def GenerateRectilinearGridsOn(self):
        """
        V.GenerateRectilinearGridsOn()
        C++: virtual void GenerateRectilinearGridsOn()
        
        Generate either rectilinear grids either uniform grids. Default
        is false.
        """
        ...
    
    def GetAdaptiveSubdivision(self):
        """
        V.GetAdaptiveSubdivision() -> int
        C++: virtual vtkTypeBool GetAdaptiveSubdivision()
        
        Make the division adaptive or not, defaults to Adaptive
        """
        ...
    
    def GetAsymmetric(self):
        """
        V.GetAsymmetric() -> int
        C++: virtual int GetAsymmetric()
        
        Test the case when the blocks do not have the same sizes. Adds 2
        to the x extent of the far x blocks (level 1).
        """
        ...
    
    def GetDimensions(self):
        """
        V.GetDimensions() -> int
        C++: virtual int GetDimensions()
        
        XYZ dimensions of cells.
        """
        ...
    
    def GetDiscreteTimeSteps(self):
        """
        V.GetDiscreteTimeSteps() -> int
        C++: virtual vtkTypeBool GetDiscreteTimeSteps()
        
        Limit this source to discrete integer time steps Default is off
        (continuous)
        """
        ...
    
    def GetFractalValue(self):
        """
        V.GetFractalValue() -> float
        C++: virtual float GetFractalValue()
        
        Essentially the iso surface value.  The fractal array is scaled
        to map this value to 0.5 for use as a volume fraction.
        """
        ...
    
    def GetGenerateRectilinearGrids(self):
        """
        V.GetGenerateRectilinearGrids() -> int
        C++: virtual vtkTypeBool GetGenerateRectilinearGrids()
        
        Generate either rectilinear grids either uniform grids. Default
        is false.
        """
        ...
    
    def GetGhostLevels(self):
        """
        V.GetGhostLevels() -> int
        C++: virtual vtkTypeBool GetGhostLevels()
        
        For testing ghost levels.
        """
        ...
    
    def GetMaximumLevel(self):
        """
        V.GetMaximumLevel() -> int
        C++: virtual int GetMaximumLevel()
        
        Any blocks touching a predefined line will be subdivided to this
        level. Other blocks are subdivided so that neighboring blocks
        only differ by one level.
        """
        ...
    
    def GetNumberOfGenerationsFromBase(self, string):
        """
        V.GetNumberOfGenerationsFromBase(string) -> int
        C++: vtkIdType GetNumberOfGenerationsFromBase(const char *type)
            override;
        
        Standard methods for instantiation, type information, and
        printing.
        """
        ...
    
    def GetNumberOfGenerationsFromBaseType(self, string):
        """
        V.GetNumberOfGenerationsFromBaseType(string) -> int
        C++: static vtkIdType GetNumberOfGenerationsFromBaseType(
            const char *type)
        
        Standard methods for instantiation, type information, and
        printing.
        """
        ...
    
    def GetTwoDimensional(self):
        """
        V.GetTwoDimensional() -> int
        C++: virtual vtkTypeBool GetTwoDimensional()
        
        Make a 2D data set to test.
        """
        ...
    
    def GhostLevelsOff(self):
        """
        V.GhostLevelsOff()
        C++: virtual void GhostLevelsOff()
        
        For testing ghost levels.
        """
        ...
    
    def GhostLevelsOn(self):
        """
        V.GhostLevelsOn()
        C++: virtual void GhostLevelsOn()
        
        For testing ghost levels.
        """
        ...
    
    def IsA(self, string):
        """
        V.IsA(string) -> int
        C++: vtkTypeBool IsA(const char *type) override;
        
        Standard methods for instantiation, type information, and
        printing.
        """
        ...
    
    def IsTypeOf(self, string):
        """
        V.IsTypeOf(string) -> int
        C++: static vtkTypeBool IsTypeOf(const char *type)
        
        Standard methods for instantiation, type information, and
        printing.
        """
        ...
    
    def NewInstance(self):
        """
        V.NewInstance() -> vtkTemporalFractal
        C++: vtkTemporalFractal *NewInstance()
        
        Standard methods for instantiation, type information, and
        printing.
        """
        ...
    
    def SafeDownCast(self, vtkObjectBase):
        """
        V.SafeDownCast(vtkObjectBase) -> vtkTemporalFractal
        C++: static vtkTemporalFractal *SafeDownCast(vtkObjectBase *o)
        
        Standard methods for instantiation, type information, and
        printing.
        """
        ...
    
    def SetAdaptiveSubdivision(self, p_int):
        """
        V.SetAdaptiveSubdivision(int)
        C++: virtual void SetAdaptiveSubdivision(vtkTypeBool _arg)
        
        Make the division adaptive or not, defaults to Adaptive
        """
        ...
    
    def SetAsymmetric(self, p_int):
        """
        V.SetAsymmetric(int)
        C++: virtual void SetAsymmetric(int _arg)
        
        Test the case when the blocks do not have the same sizes. Adds 2
        to the x extent of the far x blocks (level 1).
        """
        ...
    
    def SetDimensions(self, p_int):
        """
        V.SetDimensions(int)
        C++: virtual void SetDimensions(int _arg)
        
        XYZ dimensions of cells.
        """
        ...
    
    def SetDiscreteTimeSteps(self, p_int):
        """
        V.SetDiscreteTimeSteps(int)
        C++: virtual void SetDiscreteTimeSteps(vtkTypeBool _arg)
        
        Limit this source to discrete integer time steps Default is off
        (continuous)
        """
        ...
    
    def SetFractalValue(self, p_float):
        """
        V.SetFractalValue(float)
        C++: virtual void SetFractalValue(float _arg)
        
        Essentially the iso surface value.  The fractal array is scaled
        to map this value to 0.5 for use as a volume fraction.
        """
        ...
    
    def SetGenerateRectilinearGrids(self, p_int):
        """
        V.SetGenerateRectilinearGrids(int)
        C++: virtual void SetGenerateRectilinearGrids(vtkTypeBool _arg)
        
        Generate either rectilinear grids either uniform grids. Default
        is false.
        """
        ...
    
    def SetGhostLevels(self, p_int):
        """
        V.SetGhostLevels(int)
        C++: virtual void SetGhostLevels(vtkTypeBool _arg)
        
        For testing ghost levels.
        """
        ...
    
    def SetMaximumLevel(self, p_int):
        """
        V.SetMaximumLevel(int)
        C++: virtual void SetMaximumLevel(int _arg)
        
        Any blocks touching a predefined line will be subdivided to this
        level. Other blocks are subdivided so that neighboring blocks
        only differ by one level.
        """
        ...
    
    def SetTwoDimensional(self, p_int):
        """
        V.SetTwoDimensional(int)
        C++: virtual void SetTwoDimensional(vtkTypeBool _arg)
        
        Make a 2D data set to test.
        """
        ...
    
    def TwoDimensionalOff(self):
        """
        V.TwoDimensionalOff()
        C++: virtual void TwoDimensionalOff()
        
        Make a 2D data set to test.
        """
        ...
    
    def TwoDimensionalOn(self):
        """
        V.TwoDimensionalOn()
        C++: virtual void TwoDimensionalOn()
        
        Make a 2D data set to test.
        """
        ...
    
    def __delattr__(self, *args, **kwargs):
        """ Implement delattr(self, name). """
        ...
    
    def __getattribute__(self, *args, **kwargs):
        """ Return getattr(self, name). """
        ...
    
    def __init__(self, *args, **kwargs) -> None:
        ...
    
    @staticmethod
    def __new__(*args, **kwargs):
        """ Create and return a new object.  See help(type) for accurate signature. """
        ...
    
    def __repr__(self, *args, **kwargs):
        """ Return repr(self). """
        ...
    
    def __setattr__(self, *args, **kwargs):
        """ Implement setattr(self, name, value). """
        ...
    
    def __str__(self, *args, **kwargs) -> str:
        """ Return str(self). """
        ...
    
    __this__ = ...
    __dict__ = ...
    __vtkname__ = ...


class vtkTemporalInterpolator(__vtkmodules_vtkCommonExecutionModel.vtkMultiTimeStepAlgorithm):
    """
    vtkTemporalInterpolator - interpolate datasets between time steps to
    produce a new dataset
    
    Superclass: vtkMultiTimeStepAlgorithm
    
    vtkTemporalInterpolator interpolates between two time steps to
    produce new data for an arbitrary T. vtkTemporalInterpolator has
    three modes of operation. The default mode is to produce a continuous
    range of time values as output, which enables a filter downstream to
    request any value of T within the range. The second mode of operation
    is enabled by setting DiscreteTimeStepInterval to a non zero value.
    When this mode is activated, the filter will report a finite number
    of Time steps separated by deltaT between the original range of
    values. This mode is useful when a dataset of N time steps has one
    (or more) missing datasets for certain T values and you simply wish
    to smooth over the missing steps but otherwise use the original data.
    The third mode of operation is enabled by setting ResampleFactor to a
    non zero positive integer value. When this mode is activated, the
    filter will report a finite number of Time steps which contain the
    original steps, plus N new values between each original step
    1/ResampleFactor time units apart. Note that if the input time steps
    are irregular, then using ResampleFactor will produce an irregular
    sequence of regular steps between each of the original irregular
    steps (clear enough, yes?).
    
    @TODO Higher order interpolation schemes will require changes to the
    API as most calls assume only two timesteps are used.
    
    @par Thanks: Ken Martin (Kitware) and John Bidiscombe of CSCS - Swiss
    National Supercomputing Centre for creating and contributing this
    class. For related material, please refer to : John Biddiscombe, Berk
    Geveci, Ken Martin, Kenneth Moreland, David Thompson, "Time Dependent Processing in a Parallel Pipeline
    Architecture", IEEE Visualization 2007.
    """
    def GetCacheData(self):
        """
        V.GetCacheData() -> bool
        C++: virtual bool GetCacheData()
        
        Controls whether input data is cached to avoid updating input
        when multiple interpolations are asked between 2 time steps.
        """
        ...
    
    def GetDiscreteTimeStepInterval(self):
        """
        V.GetDiscreteTimeStepInterval() -> float
        C++: virtual double GetDiscreteTimeStepInterval()
        
        If you require a discrete number of outputs steps, to be
        generated from an input source - for example, you required N
        steps separated by T, then set DiscreteTimeStepInterval to T and
        you will get TIME_RANGE/DiscreteTimeStepInterval steps This is a
        useful option to use if you have a dataset with one missing time
        step and wish to 'fill-in' the missing data with an interpolated
        value from the steps either side
        """
        ...
    
    def GetNumberOfGenerationsFromBase(self, string):
        """
        V.GetNumberOfGenerationsFromBase(string) -> int
        C++: vtkIdType GetNumberOfGenerationsFromBase(const char *type)
            override;
        
        Given a the name of a base class of this class type, return the
        distance of inheritance between this class type and the named
        class (how many generations of inheritance are there between this
        class and the named class). If the named class is not in this
        class's inheritance tree, return a negative value. Valid
        responses will always be nonnegative. This method works in
        combination with vtkTypeMacro found in vtkSetGet.h.
        """
        ...
    
    def GetNumberOfGenerationsFromBaseType(self, string):
        """
        V.GetNumberOfGenerationsFromBaseType(string) -> int
        C++: static vtkIdType GetNumberOfGenerationsFromBaseType(
            const char *type)
        
        Given a the name of a base class of this class type, return the
        distance of inheritance between this class type and the named
        class (how many generations of inheritance are there between this
        class and the named class). If the named class is not in this
        class's inheritance tree, return a negative value. Valid
        responses will always be nonnegative. This method works in
        combination with vtkTypeMacro found in vtkSetGet.h.
        """
        ...
    
    def GetResampleFactor(self):
        """
        V.GetResampleFactor() -> int
        C++: virtual int GetResampleFactor()
        
        When ResampleFactor is a non zero positive integer, each pair of
        input time steps will be interpolated between with the number of
        steps specified. For example an input of 1,2,3,4,5 and a resample
        factor of 10, will produce steps 0f 1.0, 1.1, 1.2.....1.9, 2.0
        etc NB. Irregular input steps will produce irregular output
        steps. Resample factor wuill only be used if
        DiscreteTimeStepInterval is zero otherwise the
        DiscreteTimeStepInterval takes precedence
        """
        ...
    
    def IsA(self, string):
        """
        V.IsA(string) -> int
        C++: vtkTypeBool IsA(const char *type) override;
        
        Return 1 if this class is the same type of (or a subclass of) the
        named class. Returns 0 otherwise. This method works in
        combination with vtkTypeMacro found in vtkSetGet.h.
        """
        ...
    
    def IsTypeOf(self, string):
        """
        V.IsTypeOf(string) -> int
        C++: static vtkTypeBool IsTypeOf(const char *type)
        
        Return 1 if this class type is the same type of (or a subclass
        of) the named class. Returns 0 otherwise. This method works in
        combination with vtkTypeMacro found in vtkSetGet.h.
        """
        ...
    
    def NewInstance(self):
        """
        V.NewInstance() -> vtkTemporalInterpolator
        C++: vtkTemporalInterpolator *NewInstance()
        """
        ...
    
    def SafeDownCast(self, vtkObjectBase):
        """
        V.SafeDownCast(vtkObjectBase) -> vtkTemporalInterpolator
        C++: static vtkTemporalInterpolator *SafeDownCast(
            vtkObjectBase *o)
        """
        ...
    
    def SetCacheData(self, bool):
        """
        V.SetCacheData(bool)
        C++: virtual void SetCacheData(bool _arg)
        
        Controls whether input data is cached to avoid updating input
        when multiple interpolations are asked between 2 time steps.
        """
        ...
    
    def SetDiscreteTimeStepInterval(self, p_float):
        """
        V.SetDiscreteTimeStepInterval(float)
        C++: virtual void SetDiscreteTimeStepInterval(double _arg)
        
        If you require a discrete number of outputs steps, to be
        generated from an input source - for example, you required N
        steps separated by T, then set DiscreteTimeStepInterval to T and
        you will get TIME_RANGE/DiscreteTimeStepInterval steps This is a
        useful option to use if you have a dataset with one missing time
        step and wish to 'fill-in' the missing data with an interpolated
        value from the steps either side
        """
        ...
    
    def SetResampleFactor(self, p_int):
        """
        V.SetResampleFactor(int)
        C++: virtual void SetResampleFactor(int _arg)
        
        When ResampleFactor is a non zero positive integer, each pair of
        input time steps will be interpolated between with the number of
        steps specified. For example an input of 1,2,3,4,5 and a resample
        factor of 10, will produce steps 0f 1.0, 1.1, 1.2.....1.9, 2.0
        etc NB. Irregular input steps will produce irregular output
        steps. Resample factor wuill only be used if
        DiscreteTimeStepInterval is zero otherwise the
        DiscreteTimeStepInterval takes precedence
        """
        ...
    
    def __delattr__(self, *args, **kwargs):
        """ Implement delattr(self, name). """
        ...
    
    def __getattribute__(self, *args, **kwargs):
        """ Return getattr(self, name). """
        ...
    
    def __init__(self, *args, **kwargs) -> None:
        ...
    
    @staticmethod
    def __new__(*args, **kwargs):
        """ Create and return a new object.  See help(type) for accurate signature. """
        ...
    
    def __repr__(self, *args, **kwargs):
        """ Return repr(self). """
        ...
    
    def __setattr__(self, *args, **kwargs):
        """ Implement setattr(self, name, value). """
        ...
    
    def __str__(self, *args, **kwargs) -> str:
        """ Return str(self). """
        ...
    
    __this__ = ...
    __dict__ = ...
    __vtkname__ = ...


class vtkTemporalShiftScale(__vtkmodules_vtkCommonExecutionModel.vtkAlgorithm):
    """
    vtkTemporalShiftScale - modify the time range/steps of temporal data
    
    Superclass: vtkAlgorithm
    
    vtkTemporalShiftScale  modify the time range or time steps of the
    data without changing the data itself. The data is not resampled by
    this filter, only the information accompanying the data is modified.
    
    @par Thanks: Ken Martin (Kitware) and John Bidiscombe of CSCS - Swiss
    National Supercomputing Centre for creating and contributing this
    class. For related material, please refer to : John Biddiscombe, Berk
    Geveci, Ken Martin, Kenneth Moreland, David Thompson, "Time Dependent Processing in a Parallel Pipeline
    Architecture", IEEE Visualization 2007.
    """
    def GetMaximumNumberOfPeriods(self):
        """
        V.GetMaximumNumberOfPeriods() -> float
        C++: virtual double GetMaximumNumberOfPeriods()
        
        if Periodic time is enabled, this controls how many time periods
        time is reported for. A filter cannot output an infinite number
        of time steps and therefore a finite number of periods is
        generated when reporting time.
        """
        ...
    
    def GetNumberOfGenerationsFromBase(self, string):
        """
        V.GetNumberOfGenerationsFromBase(string) -> int
        C++: vtkIdType GetNumberOfGenerationsFromBase(const char *type)
            override;
        
        Given a the name of a base class of this class type, return the
        distance of inheritance between this class type and the named
        class (how many generations of inheritance are there between this
        class and the named class). If the named class is not in this
        class's inheritance tree, return a negative value. Valid
        responses will always be nonnegative. This method works in
        combination with vtkTypeMacro found in vtkSetGet.h.
        """
        ...
    
    def GetNumberOfGenerationsFromBaseType(self, string):
        """
        V.GetNumberOfGenerationsFromBaseType(string) -> int
        C++: static vtkIdType GetNumberOfGenerationsFromBaseType(
            const char *type)
        
        Given a the name of a base class of this class type, return the
        distance of inheritance between this class type and the named
        class (how many generations of inheritance are there between this
        class and the named class). If the named class is not in this
        class's inheritance tree, return a negative value. Valid
        responses will always be nonnegative. This method works in
        combination with vtkTypeMacro found in vtkSetGet.h.
        """
        ...
    
    def GetPeriodic(self):
        """
        V.GetPeriodic() -> int
        C++: virtual vtkTypeBool GetPeriodic()
        
        If Periodic is true, requests for time will be wrapped around so
        that the source appears to be a periodic time source. If data
        exists for times {0,N-1}, setting periodic to true will cause
        time 0 to be produced when time N, 2N, 2N etc is requested. This
        effectively gives the source the ability to generate time data
        indefinitely in a loop. When combined with Shift/Scale, the time
        becomes periodic in the shifted and scaled time frame of
        reference. Note: Since the input time may not start at zero, the
        wrapping of time from the end of one period to the start of the
        next, will subtract the initial time - a source with T{5..6}
        repeated periodically will have output time {5..6..7..8} etc.
        """
        ...
    
    def GetPeriodicEndCorrection(self):
        """
        V.GetPeriodicEndCorrection() -> int
        C++: virtual vtkTypeBool GetPeriodicEndCorrection()
        
        if Periodic time is enabled, this flag determines if the last
        time step is the same as the first. If PeriodicEndCorrection is
        true, then it is assumed that the input data goes from 0-1 (or
        whatever scaled/shifted actual time) and time 1 is the same as
        time 0 so that steps will be 0,1,2,3...N,1,2,3...N,1,2,3 where
        step N is the same as 0 and step 0 is not repeated. When this
        flag is false the data is assumed to be literal and output is of
        the form 0,1,2,3...N,0,1,2,3... By default this flag is ON
        """
        ...
    
    def GetPostShift(self):
        """
        V.GetPostShift() -> float
        C++: virtual double GetPostShift()
        
        Apply a translation to the time
        """
        ...
    
    def GetPreShift(self):
        """
        V.GetPreShift() -> float
        C++: virtual double GetPreShift()
        
        Apply a translation to the data before scaling. To convert
        T{5,100} to T{0,1} use Preshift=-5, Scale=1/95, PostShift=0 To
        convert T{5,105} to T{5,10} use Preshift=-5, Scale=5/100,
        PostShift=5
        """
        ...
    
    def GetScale(self):
        """
        V.GetScale() -> float
        C++: virtual double GetScale()
        
        Apply a scale to the time.
        """
        ...
    
    def IsA(self, string):
        """
        V.IsA(string) -> int
        C++: vtkTypeBool IsA(const char *type) override;
        
        Return 1 if this class is the same type of (or a subclass of) the
        named class. Returns 0 otherwise. This method works in
        combination with vtkTypeMacro found in vtkSetGet.h.
        """
        ...
    
    def IsTypeOf(self, string):
        """
        V.IsTypeOf(string) -> int
        C++: static vtkTypeBool IsTypeOf(const char *type)
        
        Return 1 if this class type is the same type of (or a subclass
        of) the named class. Returns 0 otherwise. This method works in
        combination with vtkTypeMacro found in vtkSetGet.h.
        """
        ...
    
    def NewInstance(self):
        """
        V.NewInstance() -> vtkTemporalShiftScale
        C++: vtkTemporalShiftScale *NewInstance()
        """
        ...
    
    def PeriodicEndCorrectionOff(self):
        """
        V.PeriodicEndCorrectionOff()
        C++: virtual void PeriodicEndCorrectionOff()
        
        if Periodic time is enabled, this flag determines if the last
        time step is the same as the first. If PeriodicEndCorrection is
        true, then it is assumed that the input data goes from 0-1 (or
        whatever scaled/shifted actual time) and time 1 is the same as
        time 0 so that steps will be 0,1,2,3...N,1,2,3...N,1,2,3 where
        step N is the same as 0 and step 0 is not repeated. When this
        flag is false the data is assumed to be literal and output is of
        the form 0,1,2,3...N,0,1,2,3... By default this flag is ON
        """
        ...
    
    def PeriodicEndCorrectionOn(self):
        """
        V.PeriodicEndCorrectionOn()
        C++: virtual void PeriodicEndCorrectionOn()
        
        if Periodic time is enabled, this flag determines if the last
        time step is the same as the first. If PeriodicEndCorrection is
        true, then it is assumed that the input data goes from 0-1 (or
        whatever scaled/shifted actual time) and time 1 is the same as
        time 0 so that steps will be 0,1,2,3...N,1,2,3...N,1,2,3 where
        step N is the same as 0 and step 0 is not repeated. When this
        flag is false the data is assumed to be literal and output is of
        the form 0,1,2,3...N,0,1,2,3... By default this flag is ON
        """
        ...
    
    def PeriodicOff(self):
        """
        V.PeriodicOff()
        C++: virtual void PeriodicOff()
        
        If Periodic is true, requests for time will be wrapped around so
        that the source appears to be a periodic time source. If data
        exists for times {0,N-1}, setting periodic to true will cause
        time 0 to be produced when time N, 2N, 2N etc is requested. This
        effectively gives the source the ability to generate time data
        indefinitely in a loop. When combined with Shift/Scale, the time
        becomes periodic in the shifted and scaled time frame of
        reference. Note: Since the input time may not start at zero, the
        wrapping of time from the end of one period to the start of the
        next, will subtract the initial time - a source with T{5..6}
        repeated periodically will have output time {5..6..7..8} etc.
        """
        ...
    
    def PeriodicOn(self):
        """
        V.PeriodicOn()
        C++: virtual void PeriodicOn()
        
        If Periodic is true, requests for time will be wrapped around so
        that the source appears to be a periodic time source. If data
        exists for times {0,N-1}, setting periodic to true will cause
        time 0 to be produced when time N, 2N, 2N etc is requested. This
        effectively gives the source the ability to generate time data
        indefinitely in a loop. When combined with Shift/Scale, the time
        becomes periodic in the shifted and scaled time frame of
        reference. Note: Since the input time may not start at zero, the
        wrapping of time from the end of one period to the start of the
        next, will subtract the initial time - a source with T{5..6}
        repeated periodically will have output time {5..6..7..8} etc.
        """
        ...
    
    def SafeDownCast(self, vtkObjectBase):
        """
        V.SafeDownCast(vtkObjectBase) -> vtkTemporalShiftScale
        C++: static vtkTemporalShiftScale *SafeDownCast(vtkObjectBase *o)
        """
        ...
    
    def SetMaximumNumberOfPeriods(self, p_float):
        """
        V.SetMaximumNumberOfPeriods(float)
        C++: virtual void SetMaximumNumberOfPeriods(double _arg)
        
        if Periodic time is enabled, this controls how many time periods
        time is reported for. A filter cannot output an infinite number
        of time steps and therefore a finite number of periods is
        generated when reporting time.
        """
        ...
    
    def SetPeriodic(self, p_int):
        """
        V.SetPeriodic(int)
        C++: virtual void SetPeriodic(vtkTypeBool _arg)
        
        If Periodic is true, requests for time will be wrapped around so
        that the source appears to be a periodic time source. If data
        exists for times {0,N-1}, setting periodic to true will cause
        time 0 to be produced when time N, 2N, 2N etc is requested. This
        effectively gives the source the ability to generate time data
        indefinitely in a loop. When combined with Shift/Scale, the time
        becomes periodic in the shifted and scaled time frame of
        reference. Note: Since the input time may not start at zero, the
        wrapping of time from the end of one period to the start of the
        next, will subtract the initial time - a source with T{5..6}
        repeated periodically will have output time {5..6..7..8} etc.
        """
        ...
    
    def SetPeriodicEndCorrection(self, p_int):
        """
        V.SetPeriodicEndCorrection(int)
        C++: virtual void SetPeriodicEndCorrection(vtkTypeBool _arg)
        
        if Periodic time is enabled, this flag determines if the last
        time step is the same as the first. If PeriodicEndCorrection is
        true, then it is assumed that the input data goes from 0-1 (or
        whatever scaled/shifted actual time) and time 1 is the same as
        time 0 so that steps will be 0,1,2,3...N,1,2,3...N,1,2,3 where
        step N is the same as 0 and step 0 is not repeated. When this
        flag is false the data is assumed to be literal and output is of
        the form 0,1,2,3...N,0,1,2,3... By default this flag is ON
        """
        ...
    
    def SetPostShift(self, p_float):
        """
        V.SetPostShift(float)
        C++: virtual void SetPostShift(double _arg)
        
        Apply a translation to the time
        """
        ...
    
    def SetPreShift(self, p_float):
        """
        V.SetPreShift(float)
        C++: virtual void SetPreShift(double _arg)
        
        Apply a translation to the data before scaling. To convert
        T{5,100} to T{0,1} use Preshift=-5, Scale=1/95, PostShift=0 To
        convert T{5,105} to T{5,10} use Preshift=-5, Scale=5/100,
        PostShift=5
        """
        ...
    
    def SetScale(self, p_float):
        """
        V.SetScale(float)
        C++: virtual void SetScale(double _arg)
        
        Apply a scale to the time.
        """
        ...
    
    def __delattr__(self, *args, **kwargs):
        """ Implement delattr(self, name). """
        ...
    
    def __getattribute__(self, *args, **kwargs):
        """ Return getattr(self, name). """
        ...
    
    def __init__(self, *args, **kwargs) -> None:
        ...
    
    @staticmethod
    def __new__(*args, **kwargs):
        """ Create and return a new object.  See help(type) for accurate signature. """
        ...
    
    def __repr__(self, *args, **kwargs):
        """ Return repr(self). """
        ...
    
    def __setattr__(self, *args, **kwargs):
        """ Implement setattr(self, name, value). """
        ...
    
    def __str__(self, *args, **kwargs) -> str:
        """ Return str(self). """
        ...
    
    __this__ = ...
    __dict__ = ...
    __vtkname__ = ...


class vtkTemporalSnapToTimeStep(__vtkmodules_vtkCommonExecutionModel.vtkPassInputTypeAlgorithm):
    """
    vtkTemporalSnapToTimeStep - modify the time range/steps of temporal
    data
    
    Superclass: vtkPassInputTypeAlgorithm
    
    vtkTemporalSnapToTimeStep  modify the time range or time steps of the
    data without changing the data itself. The data is not resampled by
    this filter, only the information accompanying the data is modified.
    
    @par Thanks: John Bidiscombe of CSCS - Swiss National Supercomputing
    Centre for creating and contributing this class. For related
    material, please refer to : John Biddiscombe, Berk Geveci, Ken
    Martin, Kenneth Moreland, David Thompson, "Time Dependent Processing in a Parallel Pipeline
    Architecture", IEEE Visualization 2007.
    """
    def GetNumberOfGenerationsFromBase(self, string):
        """
        V.GetNumberOfGenerationsFromBase(string) -> int
        C++: vtkIdType GetNumberOfGenerationsFromBase(const char *type)
            override;
        
        Given a the name of a base class of this class type, return the
        distance of inheritance between this class type and the named
        class (how many generations of inheritance are there between this
        class and the named class). If the named class is not in this
        class's inheritance tree, return a negative value. Valid
        responses will always be nonnegative. This method works in
        combination with vtkTypeMacro found in vtkSetGet.h.
        """
        ...
    
    def GetNumberOfGenerationsFromBaseType(self, string):
        """
        V.GetNumberOfGenerationsFromBaseType(string) -> int
        C++: static vtkIdType GetNumberOfGenerationsFromBaseType(
            const char *type)
        
        Given a the name of a base class of this class type, return the
        distance of inheritance between this class type and the named
        class (how many generations of inheritance are there between this
        class and the named class). If the named class is not in this
        class's inheritance tree, return a negative value. Valid
        responses will always be nonnegative. This method works in
        combination with vtkTypeMacro found in vtkSetGet.h.
        """
        ...
    
    def GetSnapMode(self):
        """
        V.GetSnapMode() -> int
        C++: virtual int GetSnapMode()
        """
        ...
    
    def IsA(self, string):
        """
        V.IsA(string) -> int
        C++: vtkTypeBool IsA(const char *type) override;
        
        Return 1 if this class is the same type of (or a subclass of) the
        named class. Returns 0 otherwise. This method works in
        combination with vtkTypeMacro found in vtkSetGet.h.
        """
        ...
    
    def IsTypeOf(self, string):
        """
        V.IsTypeOf(string) -> int
        C++: static vtkTypeBool IsTypeOf(const char *type)
        
        Return 1 if this class type is the same type of (or a subclass
        of) the named class. Returns 0 otherwise. This method works in
        combination with vtkTypeMacro found in vtkSetGet.h.
        """
        ...
    
    def NewInstance(self):
        """
        V.NewInstance() -> vtkTemporalSnapToTimeStep
        C++: vtkTemporalSnapToTimeStep *NewInstance()
        """
        ...
    
    def SafeDownCast(self, vtkObjectBase):
        """
        V.SafeDownCast(vtkObjectBase) -> vtkTemporalSnapToTimeStep
        C++: static vtkTemporalSnapToTimeStep *SafeDownCast(
            vtkObjectBase *o)
        """
        ...
    
    def SetSnapMode(self, p_int):
        """
        V.SetSnapMode(int)
        C++: virtual void SetSnapMode(int _arg)
        """
        ...
    
    def SetSnapModeToNearest(self):
        """
        V.SetSnapModeToNearest()
        C++: void SetSnapModeToNearest()
        """
        ...
    
    def SetSnapModeToNextAboveOrEqual(self):
        """
        V.SetSnapModeToNextAboveOrEqual()
        C++: void SetSnapModeToNextAboveOrEqual()
        """
        ...
    
    def SetSnapModeToNextBelowOrEqual(self):
        """
        V.SetSnapModeToNextBelowOrEqual()
        C++: void SetSnapModeToNextBelowOrEqual()
        """
        ...
    
    def __delattr__(self, *args, **kwargs):
        """ Implement delattr(self, name). """
        ...
    
    def __getattribute__(self, *args, **kwargs):
        """ Return getattr(self, name). """
        ...
    
    def __init__(self, *args, **kwargs) -> None:
        ...
    
    @staticmethod
    def __new__(*args, **kwargs):
        """ Create and return a new object.  See help(type) for accurate signature. """
        ...
    
    def __repr__(self, *args, **kwargs):
        """ Return repr(self). """
        ...
    
    def __setattr__(self, *args, **kwargs):
        """ Implement setattr(self, name, value). """
        ...
    
    def __str__(self, *args, **kwargs) -> str:
        """ Return str(self). """
        ...
    
    __this__ = ...
    VTK_SNAP_NEAREST = ...
    VTK_SNAP_NEXTABOVE_OR_EQUAL = ...
    VTK_SNAP_NEXTBELOW_OR_EQUAL = ...
    __dict__ = ...
    __vtkname__ = ...


class vtkTransformToGrid(__vtkmodules_vtkCommonExecutionModel.vtkAlgorithm):
    """
    vtkTransformToGrid - create a grid for a vtkGridTransform
    
    Superclass: vtkAlgorithm
    
    vtkTransformToGrid takes any transform as input and produces a grid
    for use by a vtkGridTransform.  This can be used, for example, to
    invert a grid transform, concatenate two grid transforms, or to
    convert a thin plate spline transform into a grid transform.
    @sa
    vtkGridTransform vtkThinPlateSplineTransform vtkAbstractTransform
    """
    def GetDisplacementScale(self):
        """
        V.GetDisplacementScale() -> float
        C++: double GetDisplacementScale()
        
        Get the scale and shift to convert integer grid elements into
        real values:  dx = scale*di + shift.  If the grid is of double
        type, then scale = 1 and shift = 0.
        """
        ...
    
    def GetDisplacementShift(self):
        """
        V.GetDisplacementShift() -> float
        C++: double GetDisplacementShift()
        
        Get the scale and shift to convert integer grid elements into
        real values:  dx = scale*di + shift.  If the grid is of double
        type, then scale = 1 and shift = 0.
        """
        ...
    
    def GetGridExtent(self):
        """
        V.GetGridExtent() -> (int, int, int, int, int, int)
        C++: virtual int *GetGridExtent()
        
        Get/Set the extent of the grid.
        """
        ...
    
    def GetGridOrigin(self):
        """
        V.GetGridOrigin() -> (float, float, float)
        C++: virtual double *GetGridOrigin()
        
        Get/Set the origin of the grid.
        """
        ...
    
    def GetGridScalarType(self):
        """
        V.GetGridScalarType() -> int
        C++: virtual int GetGridScalarType()
        
        Get/Set the scalar type of the grid.  The default is float.
        """
        ...
    
    def GetGridSpacing(self):
        """
        V.GetGridSpacing() -> (float, float, float)
        C++: virtual double *GetGridSpacing()
        
        Get/Set the spacing between samples in the grid.
        """
        ...
    
    def GetInput(self):
        """
        V.GetInput() -> vtkAbstractTransform
        C++: virtual vtkAbstractTransform *GetInput()
        
        Set/Get the transform which will be converted into a grid.
        """
        ...
    
    def GetNumberOfGenerationsFromBase(self, string):
        """
        V.GetNumberOfGenerationsFromBase(string) -> int
        C++: vtkIdType GetNumberOfGenerationsFromBase(const char *type)
            override;
        
        Given a the name of a base class of this class type, return the
        distance of inheritance between this class type and the named
        class (how many generations of inheritance are there between this
        class and the named class). If the named class is not in this
        class's inheritance tree, return a negative value. Valid
        responses will always be nonnegative. This method works in
        combination with vtkTypeMacro found in vtkSetGet.h.
        """
        ...
    
    def GetNumberOfGenerationsFromBaseType(self, string):
        """
        V.GetNumberOfGenerationsFromBaseType(string) -> int
        C++: static vtkIdType GetNumberOfGenerationsFromBaseType(
            const char *type)
        
        Given a the name of a base class of this class type, return the
        distance of inheritance between this class type and the named
        class (how many generations of inheritance are there between this
        class and the named class). If the named class is not in this
        class's inheritance tree, return a negative value. Valid
        responses will always be nonnegative. This method works in
        combination with vtkTypeMacro found in vtkSetGet.h.
        """
        ...
    
    def GetOutput(self):
        """
        V.GetOutput() -> vtkImageData
        C++: vtkImageData *GetOutput()
        
        Get the output data object for a port on this algorithm.
        """
        ...
    
    def IsA(self, string):
        """
        V.IsA(string) -> int
        C++: vtkTypeBool IsA(const char *type) override;
        
        Return 1 if this class is the same type of (or a subclass of) the
        named class. Returns 0 otherwise. This method works in
        combination with vtkTypeMacro found in vtkSetGet.h.
        """
        ...
    
    def IsTypeOf(self, string):
        """
        V.IsTypeOf(string) -> int
        C++: static vtkTypeBool IsTypeOf(const char *type)
        
        Return 1 if this class type is the same type of (or a subclass
        of) the named class. Returns 0 otherwise. This method works in
        combination with vtkTypeMacro found in vtkSetGet.h.
        """
        ...
    
    def NewInstance(self):
        """
        V.NewInstance() -> vtkTransformToGrid
        C++: vtkTransformToGrid *NewInstance()
        """
        ...
    
    def SafeDownCast(self, vtkObjectBase):
        """
        V.SafeDownCast(vtkObjectBase) -> vtkTransformToGrid
        C++: static vtkTransformToGrid *SafeDownCast(vtkObjectBase *o)
        """
        ...
    
    def SetGridExtent(self, p_int, p_int_1, p_int_2, p_int_3, p_int_4, p_int_5):
        """
        V.SetGridExtent(int, int, int, int, int, int)
        C++: virtual void SetGridExtent(int _arg1, int _arg2, int _arg3,
            int _arg4, int _arg5, int _arg6)
        V.SetGridExtent((int, int, int, int, int, int))
        C++: virtual void SetGridExtent(const int _arg[6])
        
        Get/Set the extent of the grid.
        """
        ...
    
    def SetGridOrigin(self, p_float, p_float_1, p_float_2):
        """
        V.SetGridOrigin(float, float, float)
        C++: virtual void SetGridOrigin(double _arg1, double _arg2,
            double _arg3)
        V.SetGridOrigin((float, float, float))
        C++: virtual void SetGridOrigin(const double _arg[3])
        
        Get/Set the origin of the grid.
        """
        ...
    
    def SetGridScalarType(self, p_int):
        """
        V.SetGridScalarType(int)
        C++: virtual void SetGridScalarType(int _arg)
        
        Get/Set the scalar type of the grid.  The default is float.
        """
        ...
    
    def SetGridScalarTypeToChar(self):
        """
        V.SetGridScalarTypeToChar()
        C++: void SetGridScalarTypeToChar()
        
        Get/Set the scalar type of the grid.  The default is float.
        """
        ...
    
    def SetGridScalarTypeToDouble(self):
        """
        V.SetGridScalarTypeToDouble()
        C++: void SetGridScalarTypeToDouble()
        
        Get/Set the scalar type of the grid.  The default is float.
        """
        ...
    
    def SetGridScalarTypeToFloat(self):
        """
        V.SetGridScalarTypeToFloat()
        C++: void SetGridScalarTypeToFloat()
        
        Get/Set the scalar type of the grid.  The default is float.
        """
        ...
    
    def SetGridScalarTypeToShort(self):
        """
        V.SetGridScalarTypeToShort()
        C++: void SetGridScalarTypeToShort()
        
        Get/Set the scalar type of the grid.  The default is float.
        """
        ...
    
    def SetGridScalarTypeToUnsignedChar(self):
        """
        V.SetGridScalarTypeToUnsignedChar()
        C++: void SetGridScalarTypeToUnsignedChar()
        
        Get/Set the scalar type of the grid.  The default is float.
        """
        ...
    
    def SetGridScalarTypeToUnsignedShort(self):
        """
        V.SetGridScalarTypeToUnsignedShort()
        C++: void SetGridScalarTypeToUnsignedShort()
        
        Get/Set the scalar type of the grid.  The default is float.
        """
        ...
    
    def SetGridSpacing(self, p_float, p_float_1, p_float_2):
        """
        V.SetGridSpacing(float, float, float)
        C++: virtual void SetGridSpacing(double _arg1, double _arg2,
            double _arg3)
        V.SetGridSpacing((float, float, float))
        C++: virtual void SetGridSpacing(const double _arg[3])
        
        Get/Set the spacing between samples in the grid.
        """
        ...
    
    def SetInput(self, vtkAbstractTransform):
        """
        V.SetInput(vtkAbstractTransform)
        C++: virtual void SetInput(vtkAbstractTransform *)
        
        Set/Get the transform which will be converted into a grid.
        """
        ...
    
    def __delattr__(self, *args, **kwargs):
        """ Implement delattr(self, name). """
        ...
    
    def __getattribute__(self, *args, **kwargs):
        """ Return getattr(self, name). """
        ...
    
    def __init__(self, *args, **kwargs) -> None:
        ...
    
    @staticmethod
    def __new__(*args, **kwargs):
        """ Create and return a new object.  See help(type) for accurate signature. """
        ...
    
    def __repr__(self, *args, **kwargs):
        """ Return repr(self). """
        ...
    
    def __setattr__(self, *args, **kwargs):
        """ Implement setattr(self, name, value). """
        ...
    
    def __str__(self, *args, **kwargs) -> str:
        """ Return str(self). """
        ...
    
    __this__ = ...
    __dict__ = ...
    __vtkname__ = ...


class vtkWeightedTransformFilter(__vtkmodules_vtkCommonExecutionModel.vtkPointSetAlgorithm):
    """
    vtkWeightedTransformFilter - transform based on per-point or per-cell
    weighting functions.
    
    Superclass: vtkPointSetAlgorithm
    
    vtkWeightedTransformFilter is a filter that can be used to "skin"
    structures and to create new and complex shapes.  Unlike a
    traditional transform filter (which has one transform for a data set)
    or an assembly (which has one transform per part or group of parts),
    a weighted transform produces the weighted sum of transforms on a
    per-point or per-cell basis.
    
    Each point or cell in the filter's input has an attached DataArray
    that contains tuples of weighting functions, one per point or cell.
    The filter also has a set of fixed transforms.  When the filter
    executes, each input point/cell is transformed by each of the
    transforms.  These results are weighted by the point/cell's weighting
    factors to produce final output data.
    
    Linear transforms are performance-optimized.  Using arbitrary
    transforms will work, but performance may suffer.
    
    As an example of the utility of weighted transforms, here's how this
    filter can be used for "skinning."  Skinning is the process of
    putting a mesh cover over an underlying structure, like skin over
    bone.  Joints are difficult to skin because deformation is hard to
    do.  Visualize skin over an elbow joint.  Part of the skin moves with
    one bone, part of the skin moves with the other bone, and the skin in
    the middle moves a little with each.
    
    Weighted filtering can be used for a simple and efficient kind of
    skinning.  Begin with a cylindrical mesh.  Create a FloatArray with
    two components per tuple, and one tuple for each point in the mesh.
    Assign transform weights that linear interpolate the distance along
    the cylinder (one component is the distance along the cylinder, the
    other is one minus that distance).  Set the filter up to use two
    transforms, the two used to transform the two bones.  Now, when the
    transforms change, the mesh will deform so as to, hopefully, continue
    to cover the bones.
    
    vtkWeightedTransformFilter is also useful for creating "strange and
    complex" shapes using pinching, bending, and blending.
    
    @warning
    Weighted combination of normals and vectors are probably not
    appropriate in many cases.  Surface normals are treated somewhat
    specially, but in many cases you may need to regenerate the surface
    normals.
    
    @warning
    Cell data can only be transformed if all transforms are linear.
    
    @sa
    vtkAbstractTransform vtkLinearTransform vtkTransformPolyDataFilter
    vtkActor
    """
    def AddInputValuesOff(self):
        """
        V.AddInputValuesOff()
        C++: virtual void AddInputValuesOff()
        
        If AddInputValues is true, the output values of this filter will
        be offset from the input values.  The effect is exactly
        equivalent to having an identity transform of weight 1 added into
        each output point.
        """
        ...
    
    def AddInputValuesOn(self):
        """
        V.AddInputValuesOn()
        C++: virtual void AddInputValuesOn()
        
        If AddInputValues is true, the output values of this filter will
        be offset from the input values.  The effect is exactly
        equivalent to having an identity transform of weight 1 added into
        each output point.
        """
        ...
    
    def GetAddInputValues(self):
        """
        V.GetAddInputValues() -> int
        C++: virtual vtkTypeBool GetAddInputValues()
        
        If AddInputValues is true, the output values of this filter will
        be offset from the input values.  The effect is exactly
        equivalent to having an identity transform of weight 1 added into
        each output point.
        """
        ...
    
    def GetCellDataTransformIndexArray(self):
        """
        V.GetCellDataTransformIndexArray() -> string
        C++: virtual char *GetCellDataTransformIndexArray()
        
        The CellDataTransformIndexArray is like a TransformIndexArray,
        except for cell data.  The array must have type UnsignedShort.
        """
        ...
    
    def GetCellDataWeightArray(self):
        """
        V.GetCellDataWeightArray() -> string
        C++: virtual char *GetCellDataWeightArray()
        
        The CellDataWeightArray is analogous to the WeightArray, except
        for CellData.  The array is searched for first in the CellData
        FieldData, then in the input's FieldData.  The data array must
        have a tuple for each cell.  This array is used to transform only
        normals and vectors.
        """
        ...
    
    def GetMTime(self):
        """
        V.GetMTime() -> int
        C++: vtkMTimeType GetMTime() override;
        
        Return the MTime also considering the filter's transforms.
        """
        ...
    
    def GetNumberOfGenerationsFromBase(self, string):
        """
        V.GetNumberOfGenerationsFromBase(string) -> int
        C++: vtkIdType GetNumberOfGenerationsFromBase(const char *type)
            override;
        
        Given a the name of a base class of this class type, return the
        distance of inheritance between this class type and the named
        class (how many generations of inheritance are there between this
        class and the named class). If the named class is not in this
        class's inheritance tree, return a negative value. Valid
        responses will always be nonnegative. This method works in
        combination with vtkTypeMacro found in vtkSetGet.h.
        """
        ...
    
    def GetNumberOfGenerationsFromBaseType(self, string):
        """
        V.GetNumberOfGenerationsFromBaseType(string) -> int
        C++: static vtkIdType GetNumberOfGenerationsFromBaseType(
            const char *type)
        
        Given a the name of a base class of this class type, return the
        distance of inheritance between this class type and the named
        class (how many generations of inheritance are there between this
        class and the named class). If the named class is not in this
        class's inheritance tree, return a negative value. Valid
        responses will always be nonnegative. This method works in
        combination with vtkTypeMacro found in vtkSetGet.h.
        """
        ...
    
    def GetNumberOfTransforms(self):
        """
        V.GetNumberOfTransforms() -> int
        C++: virtual int GetNumberOfTransforms()
        
        Set the number of transforms for the filter.  References to
        non-existent filter numbers in the data array is equivalent to a
        weight of zero (i.e., no contribution of that filter or weight). 
        The maximum number of transforms is limited to 65536 if transform
        index arrays are used.
        """
        ...
    
    def GetTransform(self, p_int):
        """
        V.GetTransform(int) -> vtkAbstractTransform
        C++: virtual vtkAbstractTransform *GetTransform(int num)
        
        Set or Get one of the filter's transforms. The transform number
        must be less than the number of transforms allocated for the
        object.  Setting a transform slot to nullptr is equivalent to
        assigning an overriding weight of zero to that filter slot.
        """
        ...
    
    def GetTransformIndexArray(self):
        """
        V.GetTransformIndexArray() -> string
        C++: virtual char *GetTransformIndexArray()
        
        TransformIndexArray is the string name of the DataArray in the
        input's FieldData that holds the indices for the transforms for
        each point. These indices are used to select which transforms
        each weight of the DataArray refers.  If the TransformIndexArray
        is not specified, the weights of each point are assumed to map
        directly to a transform. This DataArray must be of type
        UnsignedShort, which effectively limits the number of transforms
        to 65536 if a transform index array is used.
        
        * The filter will first look for the array in the input's
          PointData
        * FieldData.  If the array isn't there, the filter looks in the
        * input's FieldData.  The TransformIndexArray can have tuples of
          any
        * length, but must have a tuple for every point in the input data
        set.
        * This array transforms points, normals, and vectors.
        """
        ...
    
    def GetWeightArray(self):
        """
        V.GetWeightArray() -> string
        C++: virtual char *GetWeightArray()
        
        WeightArray is the string name of the DataArray in the input's
        FieldData that holds the weighting coefficients for each point.
        The filter will first look for the array in the input's PointData
        FieldData.  If the array isn't there, the filter looks in the
        input's FieldData.  The WeightArray can have tuples of any
        length, but must have a tuple for every point in the input data
        set. This array transforms points, normals, and vectors.
        """
        ...
    
    def IsA(self, string):
        """
        V.IsA(string) -> int
        C++: vtkTypeBool IsA(const char *type) override;
        
        Return 1 if this class is the same type of (or a subclass of) the
        named class. Returns 0 otherwise. This method works in
        combination with vtkTypeMacro found in vtkSetGet.h.
        """
        ...
    
    def IsTypeOf(self, string):
        """
        V.IsTypeOf(string) -> int
        C++: static vtkTypeBool IsTypeOf(const char *type)
        
        Return 1 if this class type is the same type of (or a subclass
        of) the named class. Returns 0 otherwise. This method works in
        combination with vtkTypeMacro found in vtkSetGet.h.
        """
        ...
    
    def NewInstance(self):
        """
        V.NewInstance() -> vtkWeightedTransformFilter
        C++: vtkWeightedTransformFilter *NewInstance()
        """
        ...
    
    def SafeDownCast(self, vtkObjectBase):
        """
        V.SafeDownCast(vtkObjectBase) -> vtkWeightedTransformFilter
        C++: static vtkWeightedTransformFilter *SafeDownCast(
            vtkObjectBase *o)
        """
        ...
    
    def SetAddInputValues(self, p_int):
        """
        V.SetAddInputValues(int)
        C++: virtual void SetAddInputValues(vtkTypeBool _arg)
        
        If AddInputValues is true, the output values of this filter will
        be offset from the input values.  The effect is exactly
        equivalent to having an identity transform of weight 1 added into
        each output point.
        """
        ...
    
    def SetCellDataTransformIndexArray(self, string):
        """
        V.SetCellDataTransformIndexArray(string)
        C++: virtual void SetCellDataTransformIndexArray(const char *_arg)
        
        The CellDataTransformIndexArray is like a TransformIndexArray,
        except for cell data.  The array must have type UnsignedShort.
        """
        ...
    
    def SetCellDataWeightArray(self, string):
        """
        V.SetCellDataWeightArray(string)
        C++: virtual void SetCellDataWeightArray(const char *_arg)
        
        The CellDataWeightArray is analogous to the WeightArray, except
        for CellData.  The array is searched for first in the CellData
        FieldData, then in the input's FieldData.  The data array must
        have a tuple for each cell.  This array is used to transform only
        normals and vectors.
        """
        ...
    
    def SetNumberOfTransforms(self, p_int):
        """
        V.SetNumberOfTransforms(int)
        C++: virtual void SetNumberOfTransforms(int num)
        
        Set the number of transforms for the filter.  References to
        non-existent filter numbers in the data array is equivalent to a
        weight of zero (i.e., no contribution of that filter or weight). 
        The maximum number of transforms is limited to 65536 if transform
        index arrays are used.
        """
        ...
    
    def SetTransform(self, vtkAbstractTransform, p_int):
        """
        V.SetTransform(vtkAbstractTransform, int)
        C++: virtual void SetTransform(vtkAbstractTransform *transform,
            int num)
        
        Set or Get one of the filter's transforms. The transform number
        must be less than the number of transforms allocated for the
        object.  Setting a transform slot to nullptr is equivalent to
        assigning an overriding weight of zero to that filter slot.
        """
        ...
    
    def SetTransformIndexArray(self, string):
        """
        V.SetTransformIndexArray(string)
        C++: virtual void SetTransformIndexArray(const char *_arg)
        
        TransformIndexArray is the string name of the DataArray in the
        input's FieldData that holds the indices for the transforms for
        each point. These indices are used to select which transforms
        each weight of the DataArray refers.  If the TransformIndexArray
        is not specified, the weights of each point are assumed to map
        directly to a transform. This DataArray must be of type
        UnsignedShort, which effectively limits the number of transforms
        to 65536 if a transform index array is used.
        
        * The filter will first look for the array in the input's
          PointData
        * FieldData.  If the array isn't there, the filter looks in the
        * input's FieldData.  The TransformIndexArray can have tuples of
          any
        * length, but must have a tuple for every point in the input data
        set.
        * This array transforms points, normals, and vectors.
        """
        ...
    
    def SetWeightArray(self, string):
        """
        V.SetWeightArray(string)
        C++: virtual void SetWeightArray(const char *_arg)
        
        WeightArray is the string name of the DataArray in the input's
        FieldData that holds the weighting coefficients for each point.
        The filter will first look for the array in the input's PointData
        FieldData.  If the array isn't there, the filter looks in the
        input's FieldData.  The WeightArray can have tuples of any
        length, but must have a tuple for every point in the input data
        set. This array transforms points, normals, and vectors.
        """
        ...
    
    def __delattr__(self, *args, **kwargs):
        """ Implement delattr(self, name). """
        ...
    
    def __getattribute__(self, *args, **kwargs):
        """ Return getattr(self, name). """
        ...
    
    def __init__(self, *args, **kwargs) -> None:
        ...
    
    @staticmethod
    def __new__(*args, **kwargs):
        """ Create and return a new object.  See help(type) for accurate signature. """
        ...
    
    def __repr__(self, *args, **kwargs):
        """ Return repr(self). """
        ...
    
    def __setattr__(self, *args, **kwargs):
        """ Implement setattr(self, name, value). """
        ...
    
    def __str__(self, *args, **kwargs) -> str:
        """ Return str(self). """
        ...
    
    __this__ = ...
    __dict__ = ...
    __vtkname__ = ...


__loader__ = ...
__spec__ = ...
