"""
This type stub file was generated by pyright.
"""

import vtkmodules.vtkIOCore as __vtkmodules_vtkIOCore

VTK_BIG_ENDIAN = ...
VTK_COLOR_MODE_DEFAULT = ...
VTK_COLOR_MODE_OFF = ...
VTK_COLOR_MODE_UNIFORM_CELL_COLOR = ...
VTK_COLOR_MODE_UNIFORM_COLOR = ...
VTK_COLOR_MODE_UNIFORM_POINT_COLOR = ...
VTK_LITTLE_ENDIAN = ...
VTK_TEXTURECOORDS_TEXTUREUV = ...
VTK_TEXTURECOORDS_UV = ...
class vtkPLY(object):
    """
    vtkPLY - a modified version of the PLY 1.1 library
    
    vtkPLY is a modified version of the PLY 1.1 library. The library has
    been modified by wrapping in a class (to minimize global symbols); to
    take advantage of functionality generally not available through the
    PLY library API; and to correct problems with the PLY library.
    
    The original distribution was taken from the Stanford University PLY
    file format release 1.1 (see
    http://graphics.stanford.edu/data/3Dscanrep/).
    
    @sa
    vtkPLYWriter vtkPLYReader
    
    vtkPLY()
    vtkPLY(const &vtkPLY)
    """
    def equal_strings(self, string, string_1):
        """
        V.equal_strings(string, string) -> bool
        C++: static bool equal_strings(const char *, const char *)
        """
        ...
    
    def get_ascii_item(self, string, p_int, *int, **kwargs):
        """
        V.get_ascii_item(string, int, [int, ...], [int, ...], [float,
            ...])
        C++: static void get_ascii_item(const char *, int, int *,
            unsigned int *, double *)
        """
        ...
    
    def get_item_value(self, string, p_int):
        """
        V.get_item_value(string, int) -> float
        C++: static double get_item_value(const char *, int)
        """
        ...
    
    def get_prop_type(self, string):
        """
        V.get_prop_type(string) -> int
        C++: static int get_prop_type(const char *)
        """
        ...
    
    def get_stored_item(self, void, p_int, *int, **kwargs):
        """
        V.get_stored_item(void, int, [int, ...], [int, ...], [float, ...])
        C++: static void get_stored_item(const void *, int, int *,
            unsigned int *, double *)
        """
        ...
    
    def my_alloc(self, p_int, p_int_1, string):
        """
        V.my_alloc(int, int, string) -> void
        C++: static void *my_alloc(size_t, int, const char *)
        """
        ...
    
    def store_item(self, string, p_int, p_int_1, p_int_2, p_float):
        """
        V.store_item(string, int, int, int, float)
        C++: static void store_item(char *, int, int, unsigned int,
            double)
        """
        ...
    
    def __getattribute__(self, *args, **kwargs):
        """ Return getattr(self, name). """
        ...
    
    def __hash__(self, *args, **kwargs) -> int:
        """ Return hash(self). """
        ...
    
    def __init__(self) -> None:
        ...
    
    @staticmethod
    def __new__(*args, **kwargs):
        """ Create and return a new object.  See help(type) for accurate signature. """
        ...
    
    def __repr__(self, *args, **kwargs):
        """ Return repr(self). """
        ...
    


class vtkPLYReader(__vtkmodules_vtkIOCore.vtkAbstractPolyDataReader):
    """
    vtkPLYReader - read Stanford University PLY polygonal file format
    
    Superclass: vtkAbstractPolyDataReader
    
    vtkPLYReader is a source object that reads polygonal data in Stanford
    University PLY file format (see
    http://graphics.stanford.edu/data/3Dscanrep). It requires that the
    elements "vertex" and "face" are defined. The "vertex" element must
    have the properties "x", "y", and "z". The "face" element must have
    the property "vertex_indices" defined. Optionally, if the "face"
    element has the properties "intensity" and/or the triplet "red",
    "green", "blue", and optionally "alpha"; these are read and added as
    scalars to the output data. If the "face" element has the property
    "texcoord" a new TCoords point array is created and points are
    duplicated if they have 2 or more different texture coordinates.
    Points are duplicated only if DuplicatePointsForFaceTexture is true
    (default). This creates a polygonal data that can be textured without
    artifacts. If unique points are required use a vtkCleanPolyData
    filter after this reader or use this reader with
    DuplicatePointsForFaceTexture set to false.
    
    @sa
    vtkPLYWriter, vtkCleanPolyData
    """
    def CanReadFile(self, string):
        """
        V.CanReadFile(string) -> int
        C++: static int CanReadFile(const char *filename)
        
        A simple, non-exhaustive check to see if a file is a valid ply
        file.
        """
        ...
    
    def GetComments(self):
        """
        V.GetComments() -> vtkStringArray
        C++: virtual vtkStringArray *GetComments()
        """
        ...
    
    def GetDuplicatePointsForFaceTexture(self):
        """
        V.GetDuplicatePointsForFaceTexture() -> bool
        C++: virtual bool GetDuplicatePointsForFaceTexture()
        
        If true (default) and the "face" element has the property
        "texcoord" duplicate face points if they have 2 or more different
        texture coordinates. Otherwise, each texture coordinate for a
        face point overwrites previously set texture coordinates for that
        point.
        """
        ...
    
    def GetFaceTextureTolerance(self):
        """
        V.GetFaceTextureTolerance() -> float
        C++: virtual float GetFaceTextureTolerance()
        
        Tolerance used to detect different texture coordinates for shared
        points for faces.
        """
        ...
    
    def GetNumberOfGenerationsFromBase(self, string):
        """
        V.GetNumberOfGenerationsFromBase(string) -> int
        C++: vtkIdType GetNumberOfGenerationsFromBase(const char *type)
            override;
        
        Given a the name of a base class of this class type, return the
        distance of inheritance between this class type and the named
        class (how many generations of inheritance are there between this
        class and the named class). If the named class is not in this
        class's inheritance tree, return a negative value. Valid
        responses will always be nonnegative. This method works in
        combination with vtkTypeMacro found in vtkSetGet.h.
        """
        ...
    
    def GetNumberOfGenerationsFromBaseType(self, string):
        """
        V.GetNumberOfGenerationsFromBaseType(string) -> int
        C++: static vtkIdType GetNumberOfGenerationsFromBaseType(
            const char *type)
        
        Given a the name of a base class of this class type, return the
        distance of inheritance between this class type and the named
        class (how many generations of inheritance are there between this
        class and the named class). If the named class is not in this
        class's inheritance tree, return a negative value. Valid
        responses will always be nonnegative. This method works in
        combination with vtkTypeMacro found in vtkSetGet.h.
        """
        ...
    
    def GetReadFromInputString(self):
        """
        V.GetReadFromInputString() -> bool
        C++: virtual bool GetReadFromInputString()
        
        Enable reading from an InputString instead of the default, a
        file. Note that reading from an input stream would be more
        flexible (enabling other kind of streams) and possibly more
        efficient because we don't need to save the whole stream to a
        string. However a stream interface does not translate well to
        python and the string interface satisfies our current needs. So
        we leave the stream interface for future work.
        """
        ...
    
    def IsA(self, string):
        """
        V.IsA(string) -> int
        C++: vtkTypeBool IsA(const char *type) override;
        
        Return 1 if this class is the same type of (or a subclass of) the
        named class. Returns 0 otherwise. This method works in
        combination with vtkTypeMacro found in vtkSetGet.h.
        """
        ...
    
    def IsTypeOf(self, string):
        """
        V.IsTypeOf(string) -> int
        C++: static vtkTypeBool IsTypeOf(const char *type)
        
        Return 1 if this class type is the same type of (or a subclass
        of) the named class. Returns 0 otherwise. This method works in
        combination with vtkTypeMacro found in vtkSetGet.h.
        """
        ...
    
    def NewInstance(self):
        """
        V.NewInstance() -> vtkPLYReader
        C++: vtkPLYReader *NewInstance()
        """
        ...
    
    def ReadFromInputStringOff(self):
        """
        V.ReadFromInputStringOff()
        C++: virtual void ReadFromInputStringOff()
        
        Enable reading from an InputString instead of the default, a
        file. Note that reading from an input stream would be more
        flexible (enabling other kind of streams) and possibly more
        efficient because we don't need to save the whole stream to a
        string. However a stream interface does not translate well to
        python and the string interface satisfies our current needs. So
        we leave the stream interface for future work.
        """
        ...
    
    def ReadFromInputStringOn(self):
        """
        V.ReadFromInputStringOn()
        C++: virtual void ReadFromInputStringOn()
        
        Enable reading from an InputString instead of the default, a
        file. Note that reading from an input stream would be more
        flexible (enabling other kind of streams) and possibly more
        efficient because we don't need to save the whole stream to a
        string. However a stream interface does not translate well to
        python and the string interface satisfies our current needs. So
        we leave the stream interface for future work.
        """
        ...
    
    def SafeDownCast(self, vtkObjectBase):
        """
        V.SafeDownCast(vtkObjectBase) -> vtkPLYReader
        C++: static vtkPLYReader *SafeDownCast(vtkObjectBase *o)
        """
        ...
    
    def SetDuplicatePointsForFaceTexture(self, bool):
        """
        V.SetDuplicatePointsForFaceTexture(bool)
        C++: virtual void SetDuplicatePointsForFaceTexture(bool _arg)
        """
        ...
    
    def SetFaceTextureTolerance(self, p_float):
        """
        V.SetFaceTextureTolerance(float)
        C++: virtual void SetFaceTextureTolerance(float _arg)
        """
        ...
    
    def SetInputString(self, string):
        """
        V.SetInputString(string)
        C++: void SetInputString(const std::string &s)
        
        Enable reading from an InputString instead of the default, a
        file. Note that reading from an input stream would be more
        flexible (enabling other kind of streams) and possibly more
        efficient because we don't need to save the whole stream to a
        string. However a stream interface does not translate well to
        python and the string interface satisfies our current needs. So
        we leave the stream interface for future work.
        """
        ...
    
    def SetReadFromInputString(self, bool):
        """
        V.SetReadFromInputString(bool)
        C++: virtual void SetReadFromInputString(bool _arg)
        
        Enable reading from an InputString instead of the default, a
        file. Note that reading from an input stream would be more
        flexible (enabling other kind of streams) and possibly more
        efficient because we don't need to save the whole stream to a
        string. However a stream interface does not translate well to
        python and the string interface satisfies our current needs. So
        we leave the stream interface for future work.
        """
        ...
    
    def __delattr__(self, *args, **kwargs):
        """ Implement delattr(self, name). """
        ...
    
    def __getattribute__(self, *args, **kwargs):
        """ Return getattr(self, name). """
        ...
    
    def __init__(self, *args, **kwargs) -> None:
        ...
    
    @staticmethod
    def __new__(*args, **kwargs):
        """ Create and return a new object.  See help(type) for accurate signature. """
        ...
    
    def __repr__(self, *args, **kwargs):
        """ Return repr(self). """
        ...
    
    def __setattr__(self, *args, **kwargs):
        """ Implement setattr(self, name, value). """
        ...
    
    def __str__(self, *args, **kwargs) -> str:
        """ Return str(self). """
        ...
    
    __this__ = ...
    __dict__ = ...
    __vtkname__ = ...


class vtkPLYWriter(__vtkmodules_vtkIOCore.vtkWriter):
    """
    vtkPLYWriter - write Stanford PLY file format
    
    Superclass: vtkWriter
    
    vtkPLYWriter writes polygonal data in Stanford University PLY format
    (see http://graphics.stanford.edu/data/3Dscanrep/). The data can be
    written in either binary (little or big endian) or ASCII
    representation. As for PointData and CellData, vtkPLYWriter cannot
    handle normals or vectors. It only handles RGB PointData and
    CellData. You need to set the name of the array (using SetName for
    the array and SetArrayName for the writer). If the array is not a
    vtkUnsignedCharArray with 3 or 4 components, you need to specify a
    vtkLookupTable to map the scalars to RGB.
    
    To enable saving out alpha (opacity) values, you must enable alpha
    using `vtkPLYWriter::SetEnableAlpha()`.
    
    @warning
    PLY does not handle big endian versus little endian correctly.
    
    @sa
    vtkPLYReader
    """
    def AddComment(self, string):
        """
        V.AddComment(string)
        C++: void AddComment(const std::string &comment)
        
        Add a comment in the header part.
        """
        ...
    
    def EnableAlphaOff(self):
        """
        V.EnableAlphaOff()
        C++: virtual void EnableAlphaOff()
        
        Enable alpha output. Default is off, i.e. only color values will
        be saved based on ColorMode.
        """
        ...
    
    def EnableAlphaOn(self):
        """
        V.EnableAlphaOn()
        C++: virtual void EnableAlphaOn()
        
        Enable alpha output. Default is off, i.e. only color values will
        be saved based on ColorMode.
        """
        ...
    
    def GetAlpha(self):
        """
        V.GetAlpha() -> int
        C++: virtual unsigned char GetAlpha()
        
        Set the alpha to use when using a uniform color (effect point or
        cells, or both) and EnableAlpha is ON.
        """
        ...
    
    def GetArrayName(self):
        """
        V.GetArrayName() -> string
        C++: virtual char *GetArrayName()
        
        Specify the array name to use to color the data.
        """
        ...
    
    def GetColor(self):
        """
        V.GetColor() -> (int, int, int)
        C++: virtual unsigned char *GetColor()
        
        Set the color to use when using a uniform color (either point or
        cells, or both). The color is specified as a triplet of three
        unsigned chars between (0,255). This only takes effect when the
        ColorMode is set to uniform point, uniform cell, or uniform
        color.
        """
        ...
    
    def GetColorMode(self):
        """
        V.GetColorMode() -> int
        C++: virtual int GetColorMode()
        
        These methods enable the user to control how to add color into
        the PLY output file. The default behavior is as follows. The user
        provides the name of an array and a component number. If the type
        of the array is three components, unsigned char, then the data is
        written as three separate "red", "green" and "blue" properties.
        If the type of the array is four components, unsigned char, then
        the data is written as three separate "red", "green" and "blue"
        properties, dropping the "alpha". If the type is not unsigned
        char, and a lookup table is provided, then the array/component
        are mapped through the table to generate three separate "red",
        "green" and "blue" properties in the PLY file. The user can also
        set the ColorMode to specify a uniform color for the whole part
        (on a vertex colors, face colors, or both. (Note: vertex colors
        or cell colors may be written, depending on where the named array
        is found. If points and cells have the arrays with the same name,
        then both colors will be written.)
        """
        ...
    
    def GetComponent(self):
        """
        V.GetComponent() -> int
        C++: virtual int GetComponent()
        
        Specify the array component to use to color the data.
        """
        ...
    
    def GetComponentMaxValue(self):
        """
        V.GetComponentMaxValue() -> int
        C++: virtual int GetComponentMaxValue()
        
        Specify the array component to use to color the data.
        """
        ...
    
    def GetComponentMinValue(self):
        """
        V.GetComponentMinValue() -> int
        C++: virtual int GetComponentMinValue()
        
        Specify the array component to use to color the data.
        """
        ...
    
    def GetDataByteOrder(self):
        """
        V.GetDataByteOrder() -> int
        C++: virtual int GetDataByteOrder()
        
        If the file type is binary, then the user can specify which byte
        order to use (little versus big endian).
        """
        ...
    
    def GetDataByteOrderMaxValue(self):
        """
        V.GetDataByteOrderMaxValue() -> int
        C++: virtual int GetDataByteOrderMaxValue()
        
        If the file type is binary, then the user can specify which byte
        order to use (little versus big endian).
        """
        ...
    
    def GetDataByteOrderMinValue(self):
        """
        V.GetDataByteOrderMinValue() -> int
        C++: virtual int GetDataByteOrderMinValue()
        
        If the file type is binary, then the user can specify which byte
        order to use (little versus big endian).
        """
        ...
    
    def GetEnableAlpha(self):
        """
        V.GetEnableAlpha() -> bool
        C++: virtual bool GetEnableAlpha()
        
        Enable alpha output. Default is off, i.e. only color values will
        be saved based on ColorMode.
        """
        ...
    
    def GetFileName(self):
        """
        V.GetFileName() -> string
        C++: virtual char *GetFileName()
        
        Specify file name of vtk polygon data file to write.
        """
        ...
    
    def GetFileType(self):
        """
        V.GetFileType() -> int
        C++: virtual int GetFileType()
        
        Specify file type (ASCII or BINARY) for vtk data file.
        """
        ...
    
    def GetFileTypeMaxValue(self):
        """
        V.GetFileTypeMaxValue() -> int
        C++: virtual int GetFileTypeMaxValue()
        
        Specify file type (ASCII or BINARY) for vtk data file.
        """
        ...
    
    def GetFileTypeMinValue(self):
        """
        V.GetFileTypeMinValue() -> int
        C++: virtual int GetFileTypeMinValue()
        
        Specify file type (ASCII or BINARY) for vtk data file.
        """
        ...
    
    def GetInput(self):
        """
        V.GetInput() -> vtkPolyData
        C++: vtkPolyData *GetInput()
        V.GetInput(int) -> vtkPolyData
        C++: vtkPolyData *GetInput(int port)
        
        Get the input to this writer.
        """
        ...
    
    def GetLookupTable(self):
        """
        V.GetLookupTable() -> vtkScalarsToColors
        C++: virtual vtkScalarsToColors *GetLookupTable()
        
        A lookup table can be specified in order to convert data arrays
        to RGBA colors.
        """
        ...
    
    def GetNumberOfGenerationsFromBase(self, string):
        """
        V.GetNumberOfGenerationsFromBase(string) -> int
        C++: vtkIdType GetNumberOfGenerationsFromBase(const char *type)
            override;
        
        Given a the name of a base class of this class type, return the
        distance of inheritance between this class type and the named
        class (how many generations of inheritance are there between this
        class and the named class). If the named class is not in this
        class's inheritance tree, return a negative value. Valid
        responses will always be nonnegative. This method works in
        combination with vtkTypeMacro found in vtkSetGet.h.
        """
        ...
    
    def GetNumberOfGenerationsFromBaseType(self, string):
        """
        V.GetNumberOfGenerationsFromBaseType(string) -> int
        C++: static vtkIdType GetNumberOfGenerationsFromBaseType(
            const char *type)
        
        Given a the name of a base class of this class type, return the
        distance of inheritance between this class type and the named
        class (how many generations of inheritance are there between this
        class and the named class). If the named class is not in this
        class's inheritance tree, return a negative value. Valid
        responses will always be nonnegative. This method works in
        combination with vtkTypeMacro found in vtkSetGet.h.
        """
        ...
    
    def GetOutputString(self):
        """
        V.GetOutputString() -> string
        C++: const std::string &GetOutputString()
        
        Enable writing to an OutputString instead of the default, a file.
        Note that writing to an output stream would be more flexible
        (enabling other kind of streams) and possibly more efficient
        because we don't need to write the whole stream to a string.
        However a stream interface does not translate well to python and
        the string interface satisfies our current needs. So we leave the
        stream interface for future work.
        """
        ...
    
    def GetTextureCoordinatesName(self):
        """
        V.GetTextureCoordinatesName() -> int
        C++: virtual int GetTextureCoordinatesName()
        
        Choose the name used for the texture coordinates. (u, v) or
        (texture_u, texture_v)
        """
        ...
    
    def GetTextureCoordinatesNameMaxValue(self):
        """
        V.GetTextureCoordinatesNameMaxValue() -> int
        C++: virtual int GetTextureCoordinatesNameMaxValue()
        
        Choose the name used for the texture coordinates. (u, v) or
        (texture_u, texture_v)
        """
        ...
    
    def GetTextureCoordinatesNameMinValue(self):
        """
        V.GetTextureCoordinatesNameMinValue() -> int
        C++: virtual int GetTextureCoordinatesNameMinValue()
        
        Choose the name used for the texture coordinates. (u, v) or
        (texture_u, texture_v)
        """
        ...
    
    def GetWriteToOutputString(self):
        """
        V.GetWriteToOutputString() -> bool
        C++: virtual bool GetWriteToOutputString()
        
        Enable writing to an OutputString instead of the default, a file.
        Note that writing to an output stream would be more flexible
        (enabling other kind of streams) and possibly more efficient
        because we don't need to write the whole stream to a string.
        However a stream interface does not translate well to python and
        the string interface satisfies our current needs. So we leave the
        stream interface for future work.
        """
        ...
    
    def IsA(self, string):
        """
        V.IsA(string) -> int
        C++: vtkTypeBool IsA(const char *type) override;
        
        Return 1 if this class is the same type of (or a subclass of) the
        named class. Returns 0 otherwise. This method works in
        combination with vtkTypeMacro found in vtkSetGet.h.
        """
        ...
    
    def IsTypeOf(self, string):
        """
        V.IsTypeOf(string) -> int
        C++: static vtkTypeBool IsTypeOf(const char *type)
        
        Return 1 if this class type is the same type of (or a subclass
        of) the named class. Returns 0 otherwise. This method works in
        combination with vtkTypeMacro found in vtkSetGet.h.
        """
        ...
    
    def NewInstance(self):
        """
        V.NewInstance() -> vtkPLYWriter
        C++: vtkPLYWriter *NewInstance()
        """
        ...
    
    def SafeDownCast(self, vtkObjectBase):
        """
        V.SafeDownCast(vtkObjectBase) -> vtkPLYWriter
        C++: static vtkPLYWriter *SafeDownCast(vtkObjectBase *o)
        """
        ...
    
    def SetAlpha(self, p_int):
        """
        V.SetAlpha(int)
        C++: virtual void SetAlpha(unsigned char _arg)
        
        Set the alpha to use when using a uniform color (effect point or
        cells, or both) and EnableAlpha is ON.
        """
        ...
    
    def SetArrayName(self, string):
        """
        V.SetArrayName(string)
        C++: virtual void SetArrayName(const char *_arg)
        
        Specify the array name to use to color the data.
        """
        ...
    
    def SetColor(self, p_int, p_int_1, p_int_2):
        """
        V.SetColor(int, int, int)
        C++: virtual void SetColor(unsigned char _arg1,
            unsigned char _arg2, unsigned char _arg3)
        V.SetColor((int, int, int))
        C++: virtual void SetColor(const unsigned char _arg[3])
        
        Set the color to use when using a uniform color (either point or
        cells, or both). The color is specified as a triplet of three
        unsigned chars between (0,255). This only takes effect when the
        ColorMode is set to uniform point, uniform cell, or uniform
        color.
        """
        ...
    
    def SetColorMode(self, p_int):
        """
        V.SetColorMode(int)
        C++: virtual void SetColorMode(int _arg)
        
        These methods enable the user to control how to add color into
        the PLY output file. The default behavior is as follows. The user
        provides the name of an array and a component number. If the type
        of the array is three components, unsigned char, then the data is
        written as three separate "red", "green" and "blue" properties.
        If the type of the array is four components, unsigned char, then
        the data is written as three separate "red", "green" and "blue"
        properties, dropping the "alpha". If the type is not unsigned
        char, and a lookup table is provided, then the array/component
        are mapped through the table to generate three separate "red",
        "green" and "blue" properties in the PLY file. The user can also
        set the ColorMode to specify a uniform color for the whole part
        (on a vertex colors, face colors, or both. (Note: vertex colors
        or cell colors may be written, depending on where the named array
        is found. If points and cells have the arrays with the same name,
        then both colors will be written.)
        """
        ...
    
    def SetColorModeToDefault(self):
        """
        V.SetColorModeToDefault()
        C++: void SetColorModeToDefault()
        
        These methods enable the user to control how to add color into
        the PLY output file. The default behavior is as follows. The user
        provides the name of an array and a component number. If the type
        of the array is three components, unsigned char, then the data is
        written as three separate "red", "green" and "blue" properties.
        If the type of the array is four components, unsigned char, then
        the data is written as three separate "red", "green" and "blue"
        properties, dropping the "alpha". If the type is not unsigned
        char, and a lookup table is provided, then the array/component
        are mapped through the table to generate three separate "red",
        "green" and "blue" properties in the PLY file. The user can also
        set the ColorMode to specify a uniform color for the whole part
        (on a vertex colors, face colors, or both. (Note: vertex colors
        or cell colors may be written, depending on where the named array
        is found. If points and cells have the arrays with the same name,
        then both colors will be written.)
        """
        ...
    
    def SetColorModeToOff(self):
        """
        V.SetColorModeToOff()
        C++: void SetColorModeToOff()
        
        These methods enable the user to control how to add color into
        the PLY output file. The default behavior is as follows. The user
        provides the name of an array and a component number. If the type
        of the array is three components, unsigned char, then the data is
        written as three separate "red", "green" and "blue" properties.
        If the type of the array is four components, unsigned char, then
        the data is written as three separate "red", "green" and "blue"
        properties, dropping the "alpha". If the type is not unsigned
        char, and a lookup table is provided, then the array/component
        are mapped through the table to generate three separate "red",
        "green" and "blue" properties in the PLY file. The user can also
        set the ColorMode to specify a uniform color for the whole part
        (on a vertex colors, face colors, or both. (Note: vertex colors
        or cell colors may be written, depending on where the named array
        is found. If points and cells have the arrays with the same name,
        then both colors will be written.)
        """
        ...
    
    def SetColorModeToUniformCellColor(self):
        """
        V.SetColorModeToUniformCellColor()
        C++: void SetColorModeToUniformCellColor()
        
        These methods enable the user to control how to add color into
        the PLY output file. The default behavior is as follows. The user
        provides the name of an array and a component number. If the type
        of the array is three components, unsigned char, then the data is
        written as three separate "red", "green" and "blue" properties.
        If the type of the array is four components, unsigned char, then
        the data is written as three separate "red", "green" and "blue"
        properties, dropping the "alpha". If the type is not unsigned
        char, and a lookup table is provided, then the array/component
        are mapped through the table to generate three separate "red",
        "green" and "blue" properties in the PLY file. The user can also
        set the ColorMode to specify a uniform color for the whole part
        (on a vertex colors, face colors, or both. (Note: vertex colors
        or cell colors may be written, depending on where the named array
        is found. If points and cells have the arrays with the same name,
        then both colors will be written.)
        """
        ...
    
    def SetColorModeToUniformColor(self):
        """
        V.SetColorModeToUniformColor()
        C++: void SetColorModeToUniformColor()
        
        These methods enable the user to control how to add color into
        the PLY output file. The default behavior is as follows. The user
        provides the name of an array and a component number. If the type
        of the array is three components, unsigned char, then the data is
        written as three separate "red", "green" and "blue" properties.
        If the type of the array is four components, unsigned char, then
        the data is written as three separate "red", "green" and "blue"
        properties, dropping the "alpha". If the type is not unsigned
        char, and a lookup table is provided, then the array/component
        are mapped through the table to generate three separate "red",
        "green" and "blue" properties in the PLY file. The user can also
        set the ColorMode to specify a uniform color for the whole part
        (on a vertex colors, face colors, or both. (Note: vertex colors
        or cell colors may be written, depending on where the named array
        is found. If points and cells have the arrays with the same name,
        then both colors will be written.)
        """
        ...
    
    def SetColorModeToUniformPointColor(self):
        """
        V.SetColorModeToUniformPointColor()
        C++: void SetColorModeToUniformPointColor()
        
        These methods enable the user to control how to add color into
        the PLY output file. The default behavior is as follows. The user
        provides the name of an array and a component number. If the type
        of the array is three components, unsigned char, then the data is
        written as three separate "red", "green" and "blue" properties.
        If the type of the array is four components, unsigned char, then
        the data is written as three separate "red", "green" and "blue"
        properties, dropping the "alpha". If the type is not unsigned
        char, and a lookup table is provided, then the array/component
        are mapped through the table to generate three separate "red",
        "green" and "blue" properties in the PLY file. The user can also
        set the ColorMode to specify a uniform color for the whole part
        (on a vertex colors, face colors, or both. (Note: vertex colors
        or cell colors may be written, depending on where the named array
        is found. If points and cells have the arrays with the same name,
        then both colors will be written.)
        """
        ...
    
    def SetComponent(self, p_int):
        """
        V.SetComponent(int)
        C++: virtual void SetComponent(int _arg)
        
        Specify the array component to use to color the data.
        """
        ...
    
    def SetDataByteOrder(self, p_int):
        """
        V.SetDataByteOrder(int)
        C++: virtual void SetDataByteOrder(int _arg)
        
        If the file type is binary, then the user can specify which byte
        order to use (little versus big endian).
        """
        ...
    
    def SetDataByteOrderToBigEndian(self):
        """
        V.SetDataByteOrderToBigEndian()
        C++: void SetDataByteOrderToBigEndian()
        
        If the file type is binary, then the user can specify which byte
        order to use (little versus big endian).
        """
        ...
    
    def SetDataByteOrderToLittleEndian(self):
        """
        V.SetDataByteOrderToLittleEndian()
        C++: void SetDataByteOrderToLittleEndian()
        
        If the file type is binary, then the user can specify which byte
        order to use (little versus big endian).
        """
        ...
    
    def SetEnableAlpha(self, bool):
        """
        V.SetEnableAlpha(bool)
        C++: virtual void SetEnableAlpha(bool _arg)
        
        Enable alpha output. Default is off, i.e. only color values will
        be saved based on ColorMode.
        """
        ...
    
    def SetFileName(self, string):
        """
        V.SetFileName(string)
        C++: virtual void SetFileName(const char *_arg)
        
        Specify file name of vtk polygon data file to write.
        """
        ...
    
    def SetFileType(self, p_int):
        """
        V.SetFileType(int)
        C++: virtual void SetFileType(int _arg)
        
        Specify file type (ASCII or BINARY) for vtk data file.
        """
        ...
    
    def SetFileTypeToASCII(self):
        """
        V.SetFileTypeToASCII()
        C++: void SetFileTypeToASCII()
        
        Specify file type (ASCII or BINARY) for vtk data file.
        """
        ...
    
    def SetFileTypeToBinary(self):
        """
        V.SetFileTypeToBinary()
        C++: void SetFileTypeToBinary()
        
        Specify file type (ASCII or BINARY) for vtk data file.
        """
        ...
    
    def SetLookupTable(self, vtkScalarsToColors):
        """
        V.SetLookupTable(vtkScalarsToColors)
        C++: virtual void SetLookupTable(vtkScalarsToColors *)
        
        A lookup table can be specified in order to convert data arrays
        to RGBA colors.
        """
        ...
    
    def SetTextureCoordinatesName(self, p_int):
        """
        V.SetTextureCoordinatesName(int)
        C++: virtual void SetTextureCoordinatesName(int _arg)
        
        Choose the name used for the texture coordinates. (u, v) or
        (texture_u, texture_v)
        """
        ...
    
    def SetTextureCoordinatesNameToTextureUV(self):
        """
        V.SetTextureCoordinatesNameToTextureUV()
        C++: void SetTextureCoordinatesNameToTextureUV()
        
        Choose the name used for the texture coordinates. (u, v) or
        (texture_u, texture_v)
        """
        ...
    
    def SetTextureCoordinatesNameToUV(self):
        """
        V.SetTextureCoordinatesNameToUV()
        C++: void SetTextureCoordinatesNameToUV()
        
        Choose the name used for the texture coordinates. (u, v) or
        (texture_u, texture_v)
        """
        ...
    
    def SetWriteToOutputString(self, bool):
        """
        V.SetWriteToOutputString(bool)
        C++: virtual void SetWriteToOutputString(bool _arg)
        
        Enable writing to an OutputString instead of the default, a file.
        Note that writing to an output stream would be more flexible
        (enabling other kind of streams) and possibly more efficient
        because we don't need to write the whole stream to a string.
        However a stream interface does not translate well to python and
        the string interface satisfies our current needs. So we leave the
        stream interface for future work.
        """
        ...
    
    def WriteToOutputStringOff(self):
        """
        V.WriteToOutputStringOff()
        C++: virtual void WriteToOutputStringOff()
        
        Enable writing to an OutputString instead of the default, a file.
        Note that writing to an output stream would be more flexible
        (enabling other kind of streams) and possibly more efficient
        because we don't need to write the whole stream to a string.
        However a stream interface does not translate well to python and
        the string interface satisfies our current needs. So we leave the
        stream interface for future work.
        """
        ...
    
    def WriteToOutputStringOn(self):
        """
        V.WriteToOutputStringOn()
        C++: virtual void WriteToOutputStringOn()
        
        Enable writing to an OutputString instead of the default, a file.
        Note that writing to an output stream would be more flexible
        (enabling other kind of streams) and possibly more efficient
        because we don't need to write the whole stream to a string.
        However a stream interface does not translate well to python and
        the string interface satisfies our current needs. So we leave the
        stream interface for future work.
        """
        ...
    
    def __delattr__(self, *args, **kwargs):
        """ Implement delattr(self, name). """
        ...
    
    def __getattribute__(self, *args, **kwargs):
        """ Return getattr(self, name). """
        ...
    
    def __init__(self, *args, **kwargs) -> None:
        ...
    
    @staticmethod
    def __new__(*args, **kwargs):
        """ Create and return a new object.  See help(type) for accurate signature. """
        ...
    
    def __repr__(self, *args, **kwargs):
        """ Return repr(self). """
        ...
    
    def __setattr__(self, *args, **kwargs):
        """ Implement setattr(self, name, value). """
        ...
    
    def __str__(self, *args, **kwargs) -> str:
        """ Return str(self). """
        ...
    
    __this__ = ...
    __dict__ = ...
    __vtkname__ = ...


__loader__ = ...
__spec__ = ...
