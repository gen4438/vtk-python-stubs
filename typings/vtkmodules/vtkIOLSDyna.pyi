"""
This type stub file was generated by pyright.
"""

import vtkmodules.vtkCommonExecutionModel as __vtkmodules_vtkCommonExecutionModel
import vtkmodules.vtkIOXMLParser as __vtkmodules_vtkIOXMLParser

VTK_LSDYNA_BADFILE = ...
class vtkLSDynaReader(__vtkmodules_vtkCommonExecutionModel.vtkMultiBlockDataSetAlgorithm):
    """
    vtkLSDynaReader - Read LS-Dyna databases (d3plot)
    
    Superclass: vtkMultiBlockDataSetAlgorithm
    
    This filter reads LS-Dyna databases.
    
    The Set/GetFileName() routines are actually wrappers around the
    Set/GetDatabaseDirectory() members; the actual filename you choose is
    irrelevant -- only the directory name is used.  This is done in order
    to accommodate ParaView.
    
    Note that this reader produces 7 output meshes. These meshes are
    required as several attributes are defined on subsets of the mesh. 
    Below is a list of meshes in the order they are output and an
    explanation of which attributes are unique to each mesh:
    - solid (3D) elements: number of integration points are different
      than 2D
    - thick shell elements: number of integration points are different
      than planar 2D
    - shell (2D) elements: number of integration points are different
      than 3D
    - rigid surfaces: can't have deflection, only velocity, accel, etc.
    - road surfaces: have only a "segment ID" (serves as material ID) and
    a velocity.
    - beam elements: have Frenet (TNB) frame and cross-section attributes
      (shape and size)
    - spherical particle hydrodynamics (SPH) elements: have a radius of
      influence, internal energy, etc. Because each mesh has its own cell
    attributes, the vtkLSDynaReader has a rather large API.  Instead of a
    single set of routines to query and set cell array names and status,
      one exists for each possible output mesh. Also, GetNumberOfCells()
      will return the sum of all the cells in all 7 meshes.  If you want
      the number of cells in a specific mesh, there are separate routines
    for each mesh type.
    
    @attention LSDyna files contain 3 different types of sections:
    control, data, and state.  Control sections contain constants that
    describe the type of simulation data in a file or group of files. 
    Data sections contain simulation information that is invariant across
    individual time steps (but can vary when a mesh adaptation occurs). 
    This information includes material, connectivity, and undeformed
    geometry.  Finally, state data is information that varies with each
    time step.  Unless a mesh adaptation occurs, there will be a single
    control and data section, and they will be located at the start of
    the database (the first file).
    
    @attention In their infinite wisdom, LSDyna developers decided to
    split simulation data into multiple files, each no larger than some
    predetermined limit. Each file can contain one section, a partial
    section (if it would not fit into a single file), or multiple
    sections. Files are padded with zeros so that their lengths will be
    multiples of 512*512.  The size of each section is determined by
    constants in the control and data sections, which means that these
    must be parsed carefully in order to correctly locate desired
    information.  Unfortunately, the constants are not terribly
    well-documented and in some cases the documentation is in error.
    
    @par "Open Issues": The LS-Dyna file format document leaves a good
    bit open to interpretation.  In addition to the "documentation vs.
    files in the wild" issues there are also implementation problems.
    
    @par "Open Issues":
    - Where exactly may breaks to a new file occur in the pre-state
      information? At each section?
    - Will state data sections (node/cell data, element deletion, sph
      data, rigid body motion) be moved to the beginning of a new file if
    their data will be too large for a given file, or are all the
      sections counted together as a single state (makes more sense for
      keeping time word at start of every file). The questions above
      arise because the docs (p. 3) state "There are 3 sections in this
      database." but then call many smaller pieces of data "sections".
      Should they be subsections? The docs are quiet about whether the
      second section (of 3) is ever split across multiple files and, if
      so, whether it is done at (sub)section boundaries when possible or
      just wherever it needs to occur.
    - How many components does Eddy Viscosity have? It's shown as 7 bits
      in NCFDV1 which makes no sense at all.
    - Why is NARBS larger than 10+NUMNP+NEL8+NEL2+NEL4+NELT (which is the
      value specified by the documentation)? Obviously, NARBS is
      definitive, but what are the extra numbers at the end?
    - Is there a difference between rigid body elements NUMRBE and rigid
      road surfaces? It appears that the nodes and connectivity of the
      road surface are given separately (p.13) while on p.7 the Material
      Type Data subsection says that shells in a rigid body will just
      have a certain material ID but be interspersed among deformable
      shell elements.
    - Word 37 of the control section serves two possible purposes... it
      can mean NMSPH or EDLOPT. I assume that different versions of the
      code use that word differently. How do we know the difference?
    - It's unclear how much state isn't stored when a shell element is
      marked as rigid. Specifically, is element deletion data stored for
      rigid shells? Page 21 of the spec is mute on this.
    - The loop to read cell User IDs won't work if Rigid Body and Shell
      elements are interleaved (which I now believe they are).
    
    @par "Open Issues": On the VTK side of things:
    - Berk has nudged me towards multiblock outputs but hasn't committed
      to exactly how things can be made efficient for a parallel version
      of the reader.
    - This reader will eventually need to respond to a second output port
    for "small spatial, large temporal" queries.
    - The reader doesn't handle crack files (d3crck)
    - The reader doesn't handle interface force files (no default name)
    - The reader doesn't handle time history (abbreviated output) files
      (d3thdt)
    - The reader doesn't handle dynamic relaxation files (d3drfl)
    - The reader doesn't handle reduced parts (state for a subset of
      parts) files (d3part)
    - The reader doesn't handle mode shape files (d3eigv)
    - The reader doesn't handle equilibrium iteration files (d3iter)
    - The reader doesn't handle extra time data files (d3xtf)
    - The reader doesn't handle printer files (d3hsp)
    - The reader doesn't handle modal neutral files (d3mnf)
    - The reader doesn't handle packed connectivity.
    - The reader doesn't handle adapted element parent lists (but the
      2002 specification says LSDyna doesn't implement it).
    - All the sample datasets have MATTYP = 0. Need something to test
      MATTYP = 1.
    - I have no test datasets with rigid body and/or road surfaces, so
      the implementation is half-baked.
    - It's unclear how some of the data should be presented. Although
      blindly tacking the numbers into a large chuck of cell data is
      better than nothing, some attributes (e.g., forces & moments) lend
      themselves to more elaborate presentation. Also, shell and thick
      shell elements have stresses that belong to a particular side of an
    element or have a finite thickness that could be rendered. Finally,
      beam elements have cross sections that could be rendered. Some of
      these operations require numerical processing of the results and so
    we shouldn't eliminate the ability to get at the raw simulation data.
      Perhaps a filter could be applied to "fancify" the geometry.
    """
    def CanReadFile(self, string):
        """
        V.CanReadFile(string) -> int
        C++: virtual int CanReadFile(const char *fname)
        
        Determine if the file can be read with this reader.
        """
        ...
    
    def DebugDump(self):
        """
        V.DebugDump()
        C++: void DebugDump()
        
        A routine to call Dump() from within a lame debugger that won't
        properly pass a C++ iostream object like cout.
        """
        ...
    
    def DeformedMeshOff(self):
        """
        V.DeformedMeshOff()
        C++: virtual void DeformedMeshOff()
        
        Should deflected coordinates be used, or should the mesh remain
        undeflected?  By default, this is true but its value is ignored
        if the nodal "Deflected Coordinates" array is not set to be
        loaded.
        """
        ...
    
    def DeformedMeshOn(self):
        """
        V.DeformedMeshOn()
        C++: virtual void DeformedMeshOn()
        
        Should deflected coordinates be used, or should the mesh remain
        undeflected?  By default, this is true but its value is ignored
        if the nodal "Deflected Coordinates" array is not set to be
        loaded.
        """
        ...
    
    def DeletedCellsAsGhostArrayOff(self):
        """
        V.DeletedCellsAsGhostArrayOff()
        C++: virtual void DeletedCellsAsGhostArrayOff()
        
        Instead of removing the cells that are dead, hide them by setting
        the array as the ghost levels arrays
        """
        ...
    
    def DeletedCellsAsGhostArrayOn(self):
        """
        V.DeletedCellsAsGhostArrayOn()
        C++: virtual void DeletedCellsAsGhostArrayOn()
        
        Instead of removing the cells that are dead, hide them by setting
        the array as the ghost levels arrays
        """
        ...
    
    def GetBeamArrayName(self, p_int):
        """
        V.GetBeamArrayName(int) -> string
        C++: const char *GetBeamArrayName(int)
        
        These methods allow you to load only selected subsets of the cell
        variables defined over the mesh.
        """
        ...
    
    def GetBeamArrayStatus(self, p_int):
        """
        V.GetBeamArrayStatus(int) -> int
        C++: int GetBeamArrayStatus(int arr)
        V.GetBeamArrayStatus(string) -> int
        C++: int GetBeamArrayStatus(const char *arrName)
        
        These methods allow you to load only selected subsets of the cell
        variables defined over the mesh.
        """
        ...
    
    def GetCellArrayName(self, p_int, p_int_1):
        """
        V.GetCellArrayName(int, int) -> string
        C++: const char *GetCellArrayName(int cellType, int arr)
        
        Routines that allow the status of a cell variable to be adjusted
        or queried independent of the output mesh.  The cellType
        parameter should be one of: LS_POINT, LS_BEAM, LS_SHELL,
        LS_THICK_SHELL, LS_SOLID, LS_RIGID_BODY, or LS_ROAD_SURFACE
        """
        ...
    
    def GetCellArrayStatus(self, p_int, p_int_1):
        """
        V.GetCellArrayStatus(int, int) -> int
        C++: int GetCellArrayStatus(int cellType, int arr)
        V.GetCellArrayStatus(int, string) -> int
        C++: int GetCellArrayStatus(int cellType, const char *arrName)
        
        Routines that allow the status of a cell variable to be adjusted
        or queried independent of the output mesh.  The cellType
        parameter should be one of: LS_POINT, LS_BEAM, LS_SHELL,
        LS_THICK_SHELL, LS_SOLID, LS_RIGID_BODY, or LS_ROAD_SURFACE
        """
        ...
    
    def GetDatabaseDirectory(self):
        """
        V.GetDatabaseDirectory() -> string
        C++: const char *GetDatabaseDirectory()
        
        Get/Set the directory containing the LS-Dyna database and
        determine whether it is valid.
        """
        ...
    
    def GetDeformedMesh(self):
        """
        V.GetDeformedMesh() -> int
        C++: virtual vtkTypeBool GetDeformedMesh()
        
        Should deflected coordinates be used, or should the mesh remain
        undeflected?  By default, this is true but its value is ignored
        if the nodal "Deflected Coordinates" array is not set to be
        loaded.
        """
        ...
    
    def GetDeletedCellsAsGhostArray(self):
        """
        V.GetDeletedCellsAsGhostArray() -> int
        C++: virtual vtkTypeBool GetDeletedCellsAsGhostArray()
        
        Instead of removing the cells that are dead, hide them by setting
        the array as the ghost levels arrays
        """
        ...
    
    def GetDimensionality(self):
        """
        V.GetDimensionality() -> int
        C++: int GetDimensionality()
        
        Retrieve the dimension of points in the database. This should
        return 2 or 3.  Do not call this function before setting the
        database directory and calling UpdateInformation().
        """
        ...
    
    def GetFileName(self):
        """
        V.GetFileName() -> string
        C++: const char *GetFileName()
        
        Get/Set the filename. The Set/GetFileName() routines are actually
        wrappers around the Set/GetDatabaseDirectory() members; the
        actual filename you choose is irrelevant -- only the directory
        name is used. This is done in order to accommodate ParaView.
        """
        ...
    
    def GetInputDeck(self):
        """
        V.GetInputDeck() -> string
        C++: virtual char *GetInputDeck()
        
        The name of the input deck corresponding to the current database.
        This is used to determine the part names associated with each
        material ID. This file may be in two formats: a valid LSDyna
        input deck or a short XML summary. If the file begins with
        "<?xml" then the summary format is used. Otherwise, the keyword
        format is used and a summary file will be created if write
        permissions exist in the directory containing the keyword file.
        The newly created summary will have ".k" or ".key" stripped from
        the end of the keyword filename and ".lsdyna" appended.
        """
        ...
    
    def GetNumberOfBeamArrays(self):
        """
        V.GetNumberOfBeamArrays() -> int
        C++: int GetNumberOfBeamArrays()
        
        These methods allow you to load only selected subsets of the cell
        variables defined over the mesh.
        """
        ...
    
    def GetNumberOfBeamCells(self):
        """
        V.GetNumberOfBeamCells() -> int
        C++: vtkIdType GetNumberOfBeamCells()
        
        Retrieve the number of cells of a given type in the database. Do
        not call this function before setting the database directory and
        calling UpdateInformation().
        """
        ...
    
    def GetNumberOfCellArrays(self, p_int):
        """
        V.GetNumberOfCellArrays(int) -> int
        C++: int GetNumberOfCellArrays(int cellType)
        
        Routines that allow the status of a cell variable to be adjusted
        or queried independent of the output mesh.  The cellType
        parameter should be one of: LS_POINT, LS_BEAM, LS_SHELL,
        LS_THICK_SHELL, LS_SOLID, LS_RIGID_BODY, or LS_ROAD_SURFACE
        """
        ...
    
    def GetNumberOfCells(self):
        """
        V.GetNumberOfCells() -> int
        C++: vtkIdType GetNumberOfCells()
        
        Retrieve the number of cells of a given type in the database.  Do
        not call this function before setting the database directory and
        calling UpdateInformation().
        
        * Note that GetNumberOfCells() returns the sum of
        * GetNumberOfContinuumCells() and GetNumberOfParticleCells().
        """
        ...
    
    def GetNumberOfComponentsInBeamArray(self, p_int):
        """
        V.GetNumberOfComponentsInBeamArray(int) -> int
        C++: int GetNumberOfComponentsInBeamArray(int a)
        V.GetNumberOfComponentsInBeamArray(string) -> int
        C++: int GetNumberOfComponentsInBeamArray(const char *arrName)
        """
        ...
    
    def GetNumberOfComponentsInCellArray(self, p_int, p_int_1):
        """
        V.GetNumberOfComponentsInCellArray(int, int) -> int
        C++: int GetNumberOfComponentsInCellArray(int cellType, int arr)
        V.GetNumberOfComponentsInCellArray(int, string) -> int
        C++: int GetNumberOfComponentsInCellArray(int cellType,
            const char *arrName)
        
        Routines that allow the status of a cell variable to be adjusted
        or queried independent of the output mesh.  The cellType
        parameter should be one of: LS_POINT, LS_BEAM, LS_SHELL,
        LS_THICK_SHELL, LS_SOLID, LS_RIGID_BODY, or LS_ROAD_SURFACE
        """
        ...
    
    def GetNumberOfComponentsInParticleArray(self, p_int):
        """
        V.GetNumberOfComponentsInParticleArray(int) -> int
        C++: int GetNumberOfComponentsInParticleArray(int a)
        V.GetNumberOfComponentsInParticleArray(string) -> int
        C++: int GetNumberOfComponentsInParticleArray(const char *arrName)
        """
        ...
    
    def GetNumberOfComponentsInPointArray(self, p_int):
        """
        V.GetNumberOfComponentsInPointArray(int) -> int
        C++: int GetNumberOfComponentsInPointArray(int arr)
        V.GetNumberOfComponentsInPointArray(string) -> int
        C++: int GetNumberOfComponentsInPointArray(const char *arrName)
        
        These methods allow you to load only selected subsets of the
        nodal variables defined over the mesh.
        """
        ...
    
    def GetNumberOfComponentsInRigidBodyArray(self, p_int):
        """
        V.GetNumberOfComponentsInRigidBodyArray(int) -> int
        C++: int GetNumberOfComponentsInRigidBodyArray(int a)
        V.GetNumberOfComponentsInRigidBodyArray(string) -> int
        C++: int GetNumberOfComponentsInRigidBodyArray(
            const char *arrName)
        """
        ...
    
    def GetNumberOfComponentsInRoadSurfaceArray(self, p_int):
        """
        V.GetNumberOfComponentsInRoadSurfaceArray(int) -> int
        C++: int GetNumberOfComponentsInRoadSurfaceArray(int a)
        V.GetNumberOfComponentsInRoadSurfaceArray(string) -> int
        C++: int GetNumberOfComponentsInRoadSurfaceArray(
            const char *arrName)
        """
        ...
    
    def GetNumberOfComponentsInShellArray(self, p_int):
        """
        V.GetNumberOfComponentsInShellArray(int) -> int
        C++: int GetNumberOfComponentsInShellArray(int a)
        V.GetNumberOfComponentsInShellArray(string) -> int
        C++: int GetNumberOfComponentsInShellArray(const char *arrName)
        """
        ...
    
    def GetNumberOfComponentsInSolidArray(self, p_int):
        """
        V.GetNumberOfComponentsInSolidArray(int) -> int
        C++: int GetNumberOfComponentsInSolidArray(int a)
        V.GetNumberOfComponentsInSolidArray(string) -> int
        C++: int GetNumberOfComponentsInSolidArray(const char *arrName)
        """
        ...
    
    def GetNumberOfComponentsInThickShellArray(self, p_int):
        """
        V.GetNumberOfComponentsInThickShellArray(int) -> int
        C++: int GetNumberOfComponentsInThickShellArray(int a)
        V.GetNumberOfComponentsInThickShellArray(string) -> int
        C++: int GetNumberOfComponentsInThickShellArray(
            const char *arrName)
        """
        ...
    
    def GetNumberOfContinuumCells(self):
        """
        V.GetNumberOfContinuumCells() -> int
        C++: vtkIdType GetNumberOfContinuumCells()
        
        Retrieve the number of cells of a given type in the database.  Do
        not call this function before setting the database directory and
        calling UpdateInformation().
        
        * Note that GetNumberOfContinuumCells() returns the sum of
        * GetNumberOfSolidCells(), GetNumberOfThickShellCells(),
        * GetNumberOfShellCells(), GetNumberOfRigidBodyCells(),
        * GetNumberOfRoadSurfaceCells(), and GetNumberOfBeamCells().
        """
        ...
    
    def GetNumberOfGenerationsFromBase(self, string):
        """
        V.GetNumberOfGenerationsFromBase(string) -> int
        C++: vtkIdType GetNumberOfGenerationsFromBase(const char *type)
            override;
        
        Given a the name of a base class of this class type, return the
        distance of inheritance between this class type and the named
        class (how many generations of inheritance are there between this
        class and the named class). If the named class is not in this
        class's inheritance tree, return a negative value. Valid
        responses will always be nonnegative. This method works in
        combination with vtkTypeMacro found in vtkSetGet.h.
        """
        ...
    
    def GetNumberOfGenerationsFromBaseType(self, string):
        """
        V.GetNumberOfGenerationsFromBaseType(string) -> int
        C++: static vtkIdType GetNumberOfGenerationsFromBaseType(
            const char *type)
        
        Given a the name of a base class of this class type, return the
        distance of inheritance between this class type and the named
        class (how many generations of inheritance are there between this
        class and the named class). If the named class is not in this
        class's inheritance tree, return a negative value. Valid
        responses will always be nonnegative. This method works in
        combination with vtkTypeMacro found in vtkSetGet.h.
        """
        ...
    
    def GetNumberOfNodes(self):
        """
        V.GetNumberOfNodes() -> int
        C++: vtkIdType GetNumberOfNodes()
        
        Retrieve the number of points in the database.  Do not call this
        function before setting the database directory and calling
        UpdateInformation().
        """
        ...
    
    def GetNumberOfPartArrays(self):
        """
        V.GetNumberOfPartArrays() -> int
        C++: int GetNumberOfPartArrays()
        
        These methods allow you to load only selected parts of the input.
        If InputDeck points to a valid keyword file (or summary), then
        part names will be taken from that file. Otherwise, when
        arbitrary material numbering is used, parts will be named "PartXXX
        (MatlYYY)" where XXX is an increasing sequential number and YYY
        is the respective material ID. If no input deck is specified and
        arbitrary arbitrary material numbering is not used, parts will be
        named "PartXXX" where XXX is a sequential material ID.
        """
        ...
    
    def GetNumberOfParticleArrays(self):
        """
        V.GetNumberOfParticleArrays() -> int
        C++: int GetNumberOfParticleArrays()
        
        These methods allow you to load only selected subsets of the cell
        variables defined over the mesh.
        """
        ...
    
    def GetNumberOfParticleCells(self):
        """
        V.GetNumberOfParticleCells() -> int
        C++: vtkIdType GetNumberOfParticleCells()
        
        Retrieve the number of cells of a given type in the database.  Do
        not call this function before setting the database directory and
        calling UpdateInformation().
        """
        ...
    
    def GetNumberOfPointArrays(self):
        """
        V.GetNumberOfPointArrays() -> int
        C++: int GetNumberOfPointArrays()
        
        These methods allow you to load only selected subsets of the
        nodal variables defined over the mesh.
        """
        ...
    
    def GetNumberOfRigidBodyArrays(self):
        """
        V.GetNumberOfRigidBodyArrays() -> int
        C++: int GetNumberOfRigidBodyArrays()
        
        These methods allow you to load only selected subsets of the cell
        variables defined over the mesh.
        """
        ...
    
    def GetNumberOfRigidBodyCells(self):
        """
        V.GetNumberOfRigidBodyCells() -> int
        C++: vtkIdType GetNumberOfRigidBodyCells()
        
        Retrieve the number of cells of a given type in the database.  Do
        not call this function before setting the database directory and
        calling UpdateInformation().
        """
        ...
    
    def GetNumberOfRoadSurfaceArrays(self):
        """
        V.GetNumberOfRoadSurfaceArrays() -> int
        C++: int GetNumberOfRoadSurfaceArrays()
        
        These methods allow you to load only selected subsets of the cell
        variables defined over the mesh.
        """
        ...
    
    def GetNumberOfRoadSurfaceCells(self):
        """
        V.GetNumberOfRoadSurfaceCells() -> int
        C++: vtkIdType GetNumberOfRoadSurfaceCells()
        
        Retrieve the number of cells of a given type in the database.  Do
        not call this function before setting the database directory and
        calling UpdateInformation().
        """
        ...
    
    def GetNumberOfShellArrays(self):
        """
        V.GetNumberOfShellArrays() -> int
        C++: int GetNumberOfShellArrays()
        
        These methods allow you to load only selected subsets of the cell
        variables defined over the mesh.
        """
        ...
    
    def GetNumberOfShellCells(self):
        """
        V.GetNumberOfShellCells() -> int
        C++: vtkIdType GetNumberOfShellCells()
        
        Retrieve the number of cells of a given type in the database.  Do
        not call this function before setting the database directory and
        calling UpdateInformation().
        """
        ...
    
    def GetNumberOfSolidArrays(self):
        """
        V.GetNumberOfSolidArrays() -> int
        C++: int GetNumberOfSolidArrays()
        
        These methods allow you to load only selected subsets of the cell
        variables defined over the mesh.
        """
        ...
    
    def GetNumberOfSolidCells(self):
        """
        V.GetNumberOfSolidCells() -> int
        C++: vtkIdType GetNumberOfSolidCells()
        
        Retrieve the number of cells of a given type in the database.  Do
        not call this function before setting the database directory and
        calling UpdateInformation().
        """
        ...
    
    def GetNumberOfThickShellArrays(self):
        """
        V.GetNumberOfThickShellArrays() -> int
        C++: int GetNumberOfThickShellArrays()
        
        These methods allow you to load only selected subsets of the cell
        variables defined over the mesh.
        """
        ...
    
    def GetNumberOfThickShellCells(self):
        """
        V.GetNumberOfThickShellCells() -> int
        C++: vtkIdType GetNumberOfThickShellCells()
        
        Retrieve the number of cells of a given type in the database.  Do
        not call this function before setting the database directory and
        calling UpdateInformation().
        """
        ...
    
    def GetNumberOfTimeSteps(self):
        """
        V.GetNumberOfTimeSteps() -> int
        C++: vtkIdType GetNumberOfTimeSteps()
        
        Retrieve information about the time extents of the LS-Dyna
        database. Do not call these functions before setting the database
        directory and calling UpdateInformation().
        """
        ...
    
    def GetPartArrayName(self, p_int):
        """
        V.GetPartArrayName(int) -> string
        C++: const char *GetPartArrayName(int)
        
        These methods allow you to load only selected parts of the input.
        If InputDeck points to a valid keyword file (or summary), then
        part names will be taken from that file. Otherwise, when
        arbitrary material numbering is used, parts will be named "PartXXX
        (MatlYYY)" where XXX is an increasing sequential number and YYY
        is the respective material ID. If no input deck is specified and
        arbitrary arbitrary material numbering is not used, parts will be
        named "PartXXX" where XXX is a sequential material ID.
        """
        ...
    
    def GetPartArrayStatus(self, p_int):
        """
        V.GetPartArrayStatus(int) -> int
        C++: int GetPartArrayStatus(int arr)
        V.GetPartArrayStatus(string) -> int
        C++: int GetPartArrayStatus(const char *partName)
        
        These methods allow you to load only selected parts of the input.
        If InputDeck points to a valid keyword file (or summary), then
        part names will be taken from that file. Otherwise, when
        arbitrary material numbering is used, parts will be named "PartXXX
        (MatlYYY)" where XXX is an increasing sequential number and YYY
        is the respective material ID. If no input deck is specified and
        arbitrary arbitrary material numbering is not used, parts will be
        named "PartXXX" where XXX is a sequential material ID.
        """
        ...
    
    def GetParticleArrayName(self, p_int):
        """
        V.GetParticleArrayName(int) -> string
        C++: const char *GetParticleArrayName(int)
        
        These methods allow you to load only selected subsets of the cell
        variables defined over the mesh.
        """
        ...
    
    def GetParticleArrayStatus(self, p_int):
        """
        V.GetParticleArrayStatus(int) -> int
        C++: int GetParticleArrayStatus(int arr)
        V.GetParticleArrayStatus(string) -> int
        C++: int GetParticleArrayStatus(const char *arrName)
        
        These methods allow you to load only selected subsets of the cell
        variables defined over the mesh.
        """
        ...
    
    def GetPointArrayName(self, p_int):
        """
        V.GetPointArrayName(int) -> string
        C++: const char *GetPointArrayName(int)
        
        These methods allow you to load only selected subsets of the
        nodal variables defined over the mesh.
        """
        ...
    
    def GetPointArrayStatus(self, p_int):
        """
        V.GetPointArrayStatus(int) -> int
        C++: int GetPointArrayStatus(int arr)
        V.GetPointArrayStatus(string) -> int
        C++: int GetPointArrayStatus(const char *arrName)
        
        These methods allow you to load only selected subsets of the
        nodal variables defined over the mesh.
        """
        ...
    
    def GetRemoveDeletedCells(self):
        """
        V.GetRemoveDeletedCells() -> int
        C++: virtual vtkTypeBool GetRemoveDeletedCells()
        
        Should dead cells be removed from the mesh?  Cells are marked
        dead by setting the corresponding entry in the cellarray "Death"
        to 0. Cells that are not dead have the corresponding entry in the
        cell array "Death" set to their material ID.  By default, this is
        true but its value is ignored if the cell "Death" array is not
        set to be loaded. It is also ignored if the database's element
        deletion option is set to denote points(not cells) as deleted; in
        that case, "Death" will appear to be a point array.
        """
        ...
    
    def GetRigidBodyArrayName(self, p_int):
        """
        V.GetRigidBodyArrayName(int) -> string
        C++: const char *GetRigidBodyArrayName(int)
        
        These methods allow you to load only selected subsets of the cell
        variables defined over the mesh.
        """
        ...
    
    def GetRigidBodyArrayStatus(self, p_int):
        """
        V.GetRigidBodyArrayStatus(int) -> int
        C++: int GetRigidBodyArrayStatus(int arr)
        V.GetRigidBodyArrayStatus(string) -> int
        C++: int GetRigidBodyArrayStatus(const char *arrName)
        
        These methods allow you to load only selected subsets of the cell
        variables defined over the mesh.
        """
        ...
    
    def GetRoadSurfaceArrayName(self, p_int):
        """
        V.GetRoadSurfaceArrayName(int) -> string
        C++: const char *GetRoadSurfaceArrayName(int)
        
        These methods allow you to load only selected subsets of the cell
        variables defined over the mesh.
        """
        ...
    
    def GetRoadSurfaceArrayStatus(self, p_int):
        """
        V.GetRoadSurfaceArrayStatus(int) -> int
        C++: int GetRoadSurfaceArrayStatus(int arr)
        V.GetRoadSurfaceArrayStatus(string) -> int
        C++: int GetRoadSurfaceArrayStatus(const char *arrName)
        
        These methods allow you to load only selected subsets of the cell
        variables defined over the mesh.
        """
        ...
    
    def GetShellArrayName(self, p_int):
        """
        V.GetShellArrayName(int) -> string
        C++: const char *GetShellArrayName(int)
        
        These methods allow you to load only selected subsets of the cell
        variables defined over the mesh.
        """
        ...
    
    def GetShellArrayStatus(self, p_int):
        """
        V.GetShellArrayStatus(int) -> int
        C++: int GetShellArrayStatus(int arr)
        V.GetShellArrayStatus(string) -> int
        C++: int GetShellArrayStatus(const char *arrName)
        
        These methods allow you to load only selected subsets of the cell
        variables defined over the mesh.
        """
        ...
    
    def GetSolidArrayName(self, p_int):
        """
        V.GetSolidArrayName(int) -> string
        C++: const char *GetSolidArrayName(int)
        
        These methods allow you to load only selected subsets of the cell
        variables defined over the mesh.
        """
        ...
    
    def GetSolidArrayStatus(self, p_int):
        """
        V.GetSolidArrayStatus(int) -> int
        C++: int GetSolidArrayStatus(int arr)
        V.GetSolidArrayStatus(string) -> int
        C++: int GetSolidArrayStatus(const char *arrName)
        
        These methods allow you to load only selected subsets of the cell
        variables defined over the mesh.
        """
        ...
    
    def GetThickShellArrayName(self, p_int):
        """
        V.GetThickShellArrayName(int) -> string
        C++: const char *GetThickShellArrayName(int)
        
        These methods allow you to load only selected subsets of the cell
        variables defined over the mesh.
        """
        ...
    
    def GetThickShellArrayStatus(self, p_int):
        """
        V.GetThickShellArrayStatus(int) -> int
        C++: int GetThickShellArrayStatus(int arr)
        V.GetThickShellArrayStatus(string) -> int
        C++: int GetThickShellArrayStatus(const char *arrName)
        
        These methods allow you to load only selected subsets of the cell
        variables defined over the mesh.
        """
        ...
    
    def GetTimeStep(self):
        """
        V.GetTimeStep() -> int
        C++: vtkIdType GetTimeStep()
        
        Retrieve information about the time extents of the LS-Dyna
        database. Do not call these functions before setting the database
        directory and calling UpdateInformation().
        """
        ...
    
    def GetTimeStepRange(self):
        """
        V.GetTimeStepRange() -> (int, int)
        C++: virtual int *GetTimeStepRange()
        
        Retrieve information about the time extents of the LS-Dyna
        database. Do not call these functions before setting the database
        directory and calling UpdateInformation().
        """
        ...
    
    def GetTimeValue(self, p_int):
        """
        V.GetTimeValue(int) -> float
        C++: double GetTimeValue(vtkIdType)
        
        Retrieve information about the time extents of the LS-Dyna
        database. Do not call these functions before setting the database
        directory and calling UpdateInformation().
        """
        ...
    
    def GetTitle(self):
        """
        V.GetTitle() -> string
        C++: char *GetTitle()
        
        The title of the database is a 40 or 80 character text
        description stored at the front of a d3plot file.  Do not call
        this function before setting the database directory and calling
        UpdateInformation().
        """
        ...
    
    def IsA(self, string):
        """
        V.IsA(string) -> int
        C++: vtkTypeBool IsA(const char *type) override;
        
        Return 1 if this class is the same type of (or a subclass of) the
        named class. Returns 0 otherwise. This method works in
        combination with vtkTypeMacro found in vtkSetGet.h.
        """
        ...
    
    def IsDatabaseValid(self):
        """
        V.IsDatabaseValid() -> int
        C++: int IsDatabaseValid()
        
        Get/Set the directory containing the LS-Dyna database and
        determine whether it is valid.
        """
        ...
    
    def IsTypeOf(self, string):
        """
        V.IsTypeOf(string) -> int
        C++: static vtkTypeBool IsTypeOf(const char *type)
        
        Return 1 if this class type is the same type of (or a subclass
        of) the named class. Returns 0 otherwise. This method works in
        combination with vtkTypeMacro found in vtkSetGet.h.
        """
        ...
    
    def NewInstance(self):
        """
        V.NewInstance() -> vtkLSDynaReader
        C++: vtkLSDynaReader *NewInstance()
        """
        ...
    
    def RemoveDeletedCellsOff(self):
        """
        V.RemoveDeletedCellsOff()
        C++: virtual void RemoveDeletedCellsOff()
        
        Should dead cells be removed from the mesh?  Cells are marked
        dead by setting the corresponding entry in the cellarray "Death"
        to 0. Cells that are not dead have the corresponding entry in the
        cell array "Death" set to their material ID.  By default, this is
        true but its value is ignored if the cell "Death" array is not
        set to be loaded. It is also ignored if the database's element
        deletion option is set to denote points(not cells) as deleted; in
        that case, "Death" will appear to be a point array.
        """
        ...
    
    def RemoveDeletedCellsOn(self):
        """
        V.RemoveDeletedCellsOn()
        C++: virtual void RemoveDeletedCellsOn()
        
        Should dead cells be removed from the mesh?  Cells are marked
        dead by setting the corresponding entry in the cellarray "Death"
        to 0. Cells that are not dead have the corresponding entry in the
        cell array "Death" set to their material ID.  By default, this is
        true but its value is ignored if the cell "Death" array is not
        set to be loaded. It is also ignored if the database's element
        deletion option is set to denote points(not cells) as deleted; in
        that case, "Death" will appear to be a point array.
        """
        ...
    
    def SafeDownCast(self, vtkObjectBase):
        """
        V.SafeDownCast(vtkObjectBase) -> vtkLSDynaReader
        C++: static vtkLSDynaReader *SafeDownCast(vtkObjectBase *o)
        """
        ...
    
    def SetBeamArrayStatus(self, p_int, p_int_1):
        """
        V.SetBeamArrayStatus(int, int)
        C++: virtual void SetBeamArrayStatus(int arr, int status)
        V.SetBeamArrayStatus(string, int)
        C++: virtual void SetBeamArrayStatus(const char *arrName,
            int status)
        
        These methods allow you to load only selected subsets of the cell
        variables defined over the mesh.
        """
        ...
    
    def SetCellArrayStatus(self, p_int, p_int_1, p_int_2):
        """
        V.SetCellArrayStatus(int, int, int)
        C++: virtual void SetCellArrayStatus(int cellType, int arr,
            int status)
        V.SetCellArrayStatus(int, string, int)
        C++: virtual void SetCellArrayStatus(int cellType,
            const char *arrName, int status)
        
        Routines that allow the status of a cell variable to be adjusted
        or queried independent of the output mesh.  The cellType
        parameter should be one of: LS_POINT, LS_BEAM, LS_SHELL,
        LS_THICK_SHELL, LS_SOLID, LS_RIGID_BODY, or LS_ROAD_SURFACE
        """
        ...
    
    def SetDatabaseDirectory(self, string):
        """
        V.SetDatabaseDirectory(string)
        C++: virtual void SetDatabaseDirectory(const std::string &)
        
        Get/Set the directory containing the LS-Dyna database and
        determine whether it is valid.
        """
        ...
    
    def SetDeformedMesh(self, p_int):
        """
        V.SetDeformedMesh(int)
        C++: void SetDeformedMesh(vtkTypeBool)
        
        Should deflected coordinates be used, or should the mesh remain
        undeflected?  By default, this is true but its value is ignored
        if the nodal "Deflected Coordinates" array is not set to be
        loaded.
        """
        ...
    
    def SetDeletedCellsAsGhostArray(self, p_int):
        """
        V.SetDeletedCellsAsGhostArray(int)
        C++: virtual void SetDeletedCellsAsGhostArray(vtkTypeBool _arg)
        
        Instead of removing the cells that are dead, hide them by setting
        the array as the ghost levels arrays
        """
        ...
    
    def SetFileName(self, string):
        """
        V.SetFileName(string)
        C++: virtual void SetFileName(const std::string &)
        
        Get/Set the filename. The Set/GetFileName() routines are actually
        wrappers around the Set/GetDatabaseDirectory() members; the
        actual filename you choose is irrelevant -- only the directory
        name is used. This is done in order to accommodate ParaView.
        """
        ...
    
    def SetInputDeck(self, string):
        """
        V.SetInputDeck(string)
        C++: virtual void SetInputDeck(const char *_arg)
        
        The name of the input deck corresponding to the current database.
        This is used to determine the part names associated with each
        material ID. This file may be in two formats: a valid LSDyna
        input deck or a short XML summary. If the file begins with
        "<?xml" then the summary format is used. Otherwise, the keyword
        format is used and a summary file will be created if write
        permissions exist in the directory containing the keyword file.
        The newly created summary will have ".k" or ".key" stripped from
        the end of the keyword filename and ".lsdyna" appended.
        """
        ...
    
    def SetPartArrayStatus(self, p_int, p_int_1):
        """
        V.SetPartArrayStatus(int, int)
        C++: virtual void SetPartArrayStatus(int arr, int status)
        V.SetPartArrayStatus(string, int)
        C++: virtual void SetPartArrayStatus(const char *partName,
            int status)
        
        These methods allow you to load only selected parts of the input.
        If InputDeck points to a valid keyword file (or summary), then
        part names will be taken from that file. Otherwise, when
        arbitrary material numbering is used, parts will be named "PartXXX
        (MatlYYY)" where XXX is an increasing sequential number and YYY
        is the respective material ID. If no input deck is specified and
        arbitrary arbitrary material numbering is not used, parts will be
        named "PartXXX" where XXX is a sequential material ID.
        """
        ...
    
    def SetParticleArrayStatus(self, p_int, p_int_1):
        """
        V.SetParticleArrayStatus(int, int)
        C++: virtual void SetParticleArrayStatus(int arr, int status)
        V.SetParticleArrayStatus(string, int)
        C++: virtual void SetParticleArrayStatus(const char *arrName,
            int status)
        
        These methods allow you to load only selected subsets of the cell
        variables defined over the mesh.
        """
        ...
    
    def SetPointArrayStatus(self, p_int, p_int_1):
        """
        V.SetPointArrayStatus(int, int)
        C++: virtual void SetPointArrayStatus(int arr, int status)
        V.SetPointArrayStatus(string, int)
        C++: virtual void SetPointArrayStatus(const char *arrName,
            int status)
        
        These methods allow you to load only selected subsets of the
        nodal variables defined over the mesh.
        """
        ...
    
    def SetRemoveDeletedCells(self, p_int):
        """
        V.SetRemoveDeletedCells(int)
        C++: virtual void SetRemoveDeletedCells(vtkTypeBool _arg)
        
        Should dead cells be removed from the mesh?  Cells are marked
        dead by setting the corresponding entry in the cellarray "Death"
        to 0. Cells that are not dead have the corresponding entry in the
        cell array "Death" set to their material ID.  By default, this is
        true but its value is ignored if the cell "Death" array is not
        set to be loaded. It is also ignored if the database's element
        deletion option is set to denote points(not cells) as deleted; in
        that case, "Death" will appear to be a point array.
        """
        ...
    
    def SetRigidBodyArrayStatus(self, p_int, p_int_1):
        """
        V.SetRigidBodyArrayStatus(int, int)
        C++: virtual void SetRigidBodyArrayStatus(int arr, int status)
        V.SetRigidBodyArrayStatus(string, int)
        C++: virtual void SetRigidBodyArrayStatus(const char *arrName,
            int status)
        
        These methods allow you to load only selected subsets of the cell
        variables defined over the mesh.
        """
        ...
    
    def SetRoadSurfaceArrayStatus(self, p_int, p_int_1):
        """
        V.SetRoadSurfaceArrayStatus(int, int)
        C++: virtual void SetRoadSurfaceArrayStatus(int arr, int status)
        V.SetRoadSurfaceArrayStatus(string, int)
        C++: virtual void SetRoadSurfaceArrayStatus(const char *arrName,
            int status)
        
        These methods allow you to load only selected subsets of the cell
        variables defined over the mesh.
        """
        ...
    
    def SetShellArrayStatus(self, p_int, p_int_1):
        """
        V.SetShellArrayStatus(int, int)
        C++: virtual void SetShellArrayStatus(int arr, int status)
        V.SetShellArrayStatus(string, int)
        C++: virtual void SetShellArrayStatus(const char *arrName,
            int status)
        
        These methods allow you to load only selected subsets of the cell
        variables defined over the mesh.
        """
        ...
    
    def SetSolidArrayStatus(self, p_int, p_int_1):
        """
        V.SetSolidArrayStatus(int, int)
        C++: virtual void SetSolidArrayStatus(int arr, int status)
        V.SetSolidArrayStatus(string, int)
        C++: virtual void SetSolidArrayStatus(const char *arrName,
            int status)
        
        These methods allow you to load only selected subsets of the cell
        variables defined over the mesh.
        """
        ...
    
    def SetThickShellArrayStatus(self, p_int, p_int_1):
        """
        V.SetThickShellArrayStatus(int, int)
        C++: virtual void SetThickShellArrayStatus(int arr, int status)
        V.SetThickShellArrayStatus(string, int)
        C++: virtual void SetThickShellArrayStatus(const char *arrName,
            int status)
        
        These methods allow you to load only selected subsets of the cell
        variables defined over the mesh.
        """
        ...
    
    def SetTimeStep(self, p_int):
        """
        V.SetTimeStep(int)
        C++: virtual void SetTimeStep(vtkIdType)
        
        Retrieve information about the time extents of the LS-Dyna
        database. Do not call these functions before setting the database
        directory and calling UpdateInformation().
        """
        ...
    
    def SetTimeStepRange(self, p_int, p_int_1):
        """
        V.SetTimeStepRange(int, int)
        C++: virtual void SetTimeStepRange(int _arg1, int _arg2)
        V.SetTimeStepRange((int, int))
        C++: void SetTimeStepRange(const int _arg[2])
        
        Retrieve information about the time extents of the LS-Dyna
        database. Do not call these functions before setting the database
        directory and calling UpdateInformation().
        """
        ...
    
    def __delattr__(self, *args, **kwargs):
        """ Implement delattr(self, name). """
        ...
    
    def __getattribute__(self, *args, **kwargs):
        """ Return getattr(self, name). """
        ...
    
    def __init__(self, *args, **kwargs) -> None:
        ...
    
    @staticmethod
    def __new__(*args, **kwargs):
        """ Create and return a new object.  See help(type) for accurate signature. """
        ...
    
    def __repr__(self, *args, **kwargs):
        """ Return repr(self). """
        ...
    
    def __setattr__(self, *args, **kwargs):
        """ Implement setattr(self, name, value). """
        ...
    
    def __str__(self, *args, **kwargs) -> str:
        """ Return str(self). """
        ...
    
    __this__ = ...
    __dict__ = ...
    __vtkname__ = ...


class vtkLSDynaSummaryParser(__vtkmodules_vtkIOXMLParser.vtkXMLParser):
    """
    vtkLSDynaSummaryParser - This is a helper class used by
    vtkLSDynaReader to read XML files.
    
    Superclass: vtkXMLParser
    
    @sa
    vtkLSDynaReader
    """
    def GetNumberOfGenerationsFromBase(self, string):
        """
        V.GetNumberOfGenerationsFromBase(string) -> int
        C++: vtkIdType GetNumberOfGenerationsFromBase(const char *type)
            override;
        
        Given a the name of a base class of this class type, return the
        distance of inheritance between this class type and the named
        class (how many generations of inheritance are there between this
        class and the named class). If the named class is not in this
        class's inheritance tree, return a negative value. Valid
        responses will always be nonnegative. This method works in
        combination with vtkTypeMacro found in vtkSetGet.h.
        """
        ...
    
    def GetNumberOfGenerationsFromBaseType(self, string):
        """
        V.GetNumberOfGenerationsFromBaseType(string) -> int
        C++: static vtkIdType GetNumberOfGenerationsFromBaseType(
            const char *type)
        
        Given a the name of a base class of this class type, return the
        distance of inheritance between this class type and the named
        class (how many generations of inheritance are there between this
        class and the named class). If the named class is not in this
        class's inheritance tree, return a negative value. Valid
        responses will always be nonnegative. This method works in
        combination with vtkTypeMacro found in vtkSetGet.h.
        """
        ...
    
    def IsA(self, string):
        """
        V.IsA(string) -> int
        C++: vtkTypeBool IsA(const char *type) override;
        
        Return 1 if this class is the same type of (or a subclass of) the
        named class. Returns 0 otherwise. This method works in
        combination with vtkTypeMacro found in vtkSetGet.h.
        """
        ...
    
    def IsTypeOf(self, string):
        """
        V.IsTypeOf(string) -> int
        C++: static vtkTypeBool IsTypeOf(const char *type)
        
        Return 1 if this class type is the same type of (or a subclass
        of) the named class. Returns 0 otherwise. This method works in
        combination with vtkTypeMacro found in vtkSetGet.h.
        """
        ...
    
    def NewInstance(self):
        """
        V.NewInstance() -> vtkLSDynaSummaryParser
        C++: vtkLSDynaSummaryParser *NewInstance()
        """
        ...
    
    def SafeDownCast(self, vtkObjectBase):
        """
        V.SafeDownCast(vtkObjectBase) -> vtkLSDynaSummaryParser
        C++: static vtkLSDynaSummaryParser *SafeDownCast(vtkObjectBase *o)
        """
        ...
    
    def __delattr__(self, *args, **kwargs):
        """ Implement delattr(self, name). """
        ...
    
    def __getattribute__(self, *args, **kwargs):
        """ Return getattr(self, name). """
        ...
    
    def __init__(self, *args, **kwargs) -> None:
        ...
    
    @staticmethod
    def __new__(*args, **kwargs):
        """ Create and return a new object.  See help(type) for accurate signature. """
        ...
    
    def __repr__(self, *args, **kwargs):
        """ Return repr(self). """
        ...
    
    def __setattr__(self, *args, **kwargs):
        """ Implement setattr(self, name, value). """
        ...
    
    def __str__(self, *args, **kwargs) -> str:
        """ Return str(self). """
        ...
    
    __this__ = ...
    __dict__ = ...
    __vtkname__ = ...


__loader__ = ...
__spec__ = ...
