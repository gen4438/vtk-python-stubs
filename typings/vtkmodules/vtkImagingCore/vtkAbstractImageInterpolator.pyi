"""
This type stub file was generated by pyright.
"""

import vtkmodules.vtkCommonCore as __vtkmodules_vtkCommonCore

class vtkAbstractImageInterpolator(__vtkmodules_vtkCommonCore.vtkObject):
    """
    vtkAbstractImageInterpolator - interpolate data values from images
    
    Superclass: vtkObject
    
    vtkAbstractImageInterpolator provides an abstract interface for
    interpolating image data.  You specify the data set you want to
    interpolate values from, then call Interpolate(x,y,z) to interpolate
    the data.@par Thanks: Thanks to David Gobbi at the Seaman Family MR
    Centre and Dept. of Clinical Neurosciences, Foothills Medical Centre,
    Calgary, for providing this class.
    @sa
    vtkImageReslice vtkImageInterpolator vtkImageSincInterpolator
    """
    def CheckBoundsIJK(self, ):
        """
        V.CheckBoundsIJK((float, float, float)) -> bool
        C++: bool CheckBoundsIJK(const double x[3])
        
        Check an x,y,z point to see if it is within the bounds for the
        structured coords of the image.  This is meant to be called prior
        to InterpolateIJK.  The bounds that are checked against are the
        input image extent plus the tolerance.
        """
        ...
    
    def ComputeNumberOfComponents(self, p_int):
        """
        V.ComputeNumberOfComponents(int) -> int
        C++: int ComputeNumberOfComponents(int inputComponents)
        
        Compute the number of output components based on the
        ComponentOffset, ComponentCount, and the number of components in
        the input data.
        """
        ...
    
    def ComputeSupportSize(self, , p_int=..., p_int=..., p_int=...):
        """
        V.ComputeSupportSize((float, float, float, float, float, float,
            float, float, float, float, float, float, float, float, float,
             float), [int, int, int])
        C++: virtual void ComputeSupportSize(const double matrix[16],
            int support[3])
        
        Get the support size for use in computing update extents.  If the
        data will be sampled on a regular grid, then pass a matrix
        describing the structured coordinate transformation between the
        output and the input. Otherwise, pass nullptr as the matrix to
        retrieve the full kernel size.
        """
        ...
    
    def DeepCopy(self, vtkAbstractImageInterpolator):
        """
        V.DeepCopy(vtkAbstractImageInterpolator)
        C++: void DeepCopy(vtkAbstractImageInterpolator *obj)
        
        Copy the interpolator.  It is possible to duplicate an
        interpolator by calling NewInstance() followed by DeepCopy().
        """
        ...
    
    def GetBorderMode(self):
        """
        V.GetBorderMode() -> int
        C++: int GetBorderMode()
        
        The border mode (default: clamp).  This controls how
        out-of-bounds lookups are handled, i.e. how data will be
        extrapolated beyond the bounds of the image.  The default is to
        clamp the lookup point to the bounds.  The other modes wrap
        around to the opposite boundary, or mirror the image at the
        boundary.
        """
        ...
    
    def GetBorderModeAsString(self):
        """
        V.GetBorderModeAsString() -> string
        C++: const char *GetBorderModeAsString()
        
        The border mode (default: clamp).  This controls how
        out-of-bounds lookups are handled, i.e. how data will be
        extrapolated beyond the bounds of the image.  The default is to
        clamp the lookup point to the bounds.  The other modes wrap
        around to the opposite boundary, or mirror the image at the
        boundary.
        """
        ...
    
    def GetComponentCount(self):
        """
        V.GetComponentCount() -> int
        C++: int GetComponentCount()
        """
        ...
    
    def GetComponentOffset(self):
        """
        V.GetComponentOffset() -> int
        C++: int GetComponentOffset()
        """
        ...
    
    def GetExtent(self):
        """
        V.GetExtent() -> (int, int, int, int, int, int)
        C++: virtual int *GetExtent()
        
        Get the extent of the data being interpolated.
        """
        ...
    
    def GetNumberOfComponents(self):
        """
        V.GetNumberOfComponents() -> int
        C++: int GetNumberOfComponents()
        
        Get the number of components that will be returned when
        Interpolate() is called.  This is only valid after
        initialization.  Before then, use ComputeNumberOfComponents
        instead.
        """
        ...
    
    def GetNumberOfGenerationsFromBase(self, string):
        """
        V.GetNumberOfGenerationsFromBase(string) -> int
        C++: vtkIdType GetNumberOfGenerationsFromBase(const char *type)
            override;
        
        Given a the name of a base class of this class type, return the
        distance of inheritance between this class type and the named
        class (how many generations of inheritance are there between this
        class and the named class). If the named class is not in this
        class's inheritance tree, return a negative value. Valid
        responses will always be nonnegative. This method works in
        combination with vtkTypeMacro found in vtkSetGet.h.
        """
        ...
    
    def GetNumberOfGenerationsFromBaseType(self, string):
        """
        V.GetNumberOfGenerationsFromBaseType(string) -> int
        C++: static vtkIdType GetNumberOfGenerationsFromBaseType(
            const char *type)
        
        Given a the name of a base class of this class type, return the
        distance of inheritance between this class type and the named
        class (how many generations of inheritance are there between this
        class and the named class). If the named class is not in this
        class's inheritance tree, return a negative value. Valid
        responses will always be nonnegative. This method works in
        combination with vtkTypeMacro found in vtkSetGet.h.
        """
        ...
    
    def GetOrigin(self):
        """
        V.GetOrigin() -> (float, float, float)
        C++: virtual double *GetOrigin()
        
        Get the origin of the data being interpolated.
        """
        ...
    
    def GetOutValue(self):
        """
        V.GetOutValue() -> float
        C++: double GetOutValue()
        """
        ...
    
    def GetSlidingWindow(self):
        """
        V.GetSlidingWindow() -> bool
        C++: bool GetSlidingWindow()
        """
        ...
    
    def GetSpacing(self):
        """
        V.GetSpacing() -> (float, float, float)
        C++: virtual double *GetSpacing()
        
        Get the spacing of the data being interpolated.
        """
        ...
    
    def GetTolerance(self):
        """
        V.GetTolerance() -> float
        C++: double GetTolerance()
        """
        ...
    
    def GetWholeExtent(self):
        """
        V.GetWholeExtent() -> (int, ...)
        C++: int *GetWholeExtent()
        V.GetWholeExtent([int, int, int, int, int, int])
        C++: void GetWholeExtent(int extent[6])
        
        Get the whole extent of the data being interpolated, including
        parts of the data that are not currently in memory.
        """
        ...
    
    def Initialize(self, vtkDataObject):
        """
        V.Initialize(vtkDataObject)
        C++: virtual void Initialize(vtkDataObject *data)
        
        Initialize the interpolator with the data that you wish to
        interpolate.
        """
        ...
    
    def Interpolate(self, p_float, p_float_1, p_float_2, p_int):
        """
        V.Interpolate(float, float, float, int) -> float
        C++: double Interpolate(double x, double y, double z,
            int component)
        V.Interpolate((float, float, float), [float, ...]) -> bool
        C++: bool Interpolate(const double point[3], double *value)
        
        Get the result of interpolating the specified component of the
        input data, which should be set to zero if there is only one
        component. If the point is not within the bounds of the data set,
        then OutValue will be returned.  This method is primarily meant
        for use by the wrapper languages.
        """
        ...
    
    def InterpolateIJK(self, , *float):
        """
        V.InterpolateIJK((float, float, float), [float, ...])
        C++: void InterpolateIJK(const double point[3], double *value)
        
        A version of Interpolate that takes structured coords instead of
        data coords.  Structured coords are the data coords after
        subtracting the Origin and dividing by the Spacing.
        """
        ...
    
    def IsA(self, string):
        """
        V.IsA(string) -> int
        C++: vtkTypeBool IsA(const char *type) override;
        
        Return 1 if this class is the same type of (or a subclass of) the
        named class. Returns 0 otherwise. This method works in
        combination with vtkTypeMacro found in vtkSetGet.h.
        """
        ...
    
    def IsSeparable(self):
        """
        V.IsSeparable() -> bool
        C++: virtual bool IsSeparable()
        
        True if the interpolation is separable, which means that the
        weights can be precomputed in order to accelerate the
        interpolation.  Any interpolator which is separable will
        implement the methods PrecomputeWeightsForExtent and
        InterpolateRow
        """
        ...
    
    def IsTypeOf(self, string):
        """
        V.IsTypeOf(string) -> int
        C++: static vtkTypeBool IsTypeOf(const char *type)
        
        Return 1 if this class type is the same type of (or a subclass
        of) the named class. Returns 0 otherwise. This method works in
        combination with vtkTypeMacro found in vtkSetGet.h.
        """
        ...
    
    def NewInstance(self):
        """
        V.NewInstance() -> vtkAbstractImageInterpolator
        C++: vtkAbstractImageInterpolator *NewInstance()
        """
        ...
    
    def ReleaseData(self):
        """
        V.ReleaseData()
        C++: virtual void ReleaseData()
        
        Release any data stored by the interpolator.
        """
        ...
    
    def SafeDownCast(self, vtkObjectBase):
        """
        V.SafeDownCast(vtkObjectBase) -> vtkAbstractImageInterpolator
        C++: static vtkAbstractImageInterpolator *SafeDownCast(
            vtkObjectBase *o)
        """
        ...
    
    def SetBorderMode(self, p_int):
        """
        V.SetBorderMode(int)
        C++: void SetBorderMode(int mode)
        
        The border mode (default: clamp).  This controls how
        out-of-bounds lookups are handled, i.e. how data will be
        extrapolated beyond the bounds of the image.  The default is to
        clamp the lookup point to the bounds.  The other modes wrap
        around to the opposite boundary, or mirror the image at the
        boundary.
        """
        ...
    
    def SetBorderModeToClamp(self):
        """
        V.SetBorderModeToClamp()
        C++: void SetBorderModeToClamp()
        
        The border mode (default: clamp).  This controls how
        out-of-bounds lookups are handled, i.e. how data will be
        extrapolated beyond the bounds of the image.  The default is to
        clamp the lookup point to the bounds.  The other modes wrap
        around to the opposite boundary, or mirror the image at the
        boundary.
        """
        ...
    
    def SetBorderModeToMirror(self):
        """
        V.SetBorderModeToMirror()
        C++: void SetBorderModeToMirror()
        
        The border mode (default: clamp).  This controls how
        out-of-bounds lookups are handled, i.e. how data will be
        extrapolated beyond the bounds of the image.  The default is to
        clamp the lookup point to the bounds.  The other modes wrap
        around to the opposite boundary, or mirror the image at the
        boundary.
        """
        ...
    
    def SetBorderModeToRepeat(self):
        """
        V.SetBorderModeToRepeat()
        C++: void SetBorderModeToRepeat()
        
        The border mode (default: clamp).  This controls how
        out-of-bounds lookups are handled, i.e. how data will be
        extrapolated beyond the bounds of the image.  The default is to
        clamp the lookup point to the bounds.  The other modes wrap
        around to the opposite boundary, or mirror the image at the
        boundary.
        """
        ...
    
    def SetComponentCount(self, p_int):
        """
        V.SetComponentCount(int)
        C++: void SetComponentCount(int count)
        
        This method specifies the number of components to extract.  The
        default value is -1, which extracts all available components. 
        When the interpolation is performed, this will be clamped to the
        number of available components.
        """
        ...
    
    def SetComponentOffset(self, p_int):
        """
        V.SetComponentOffset(int)
        C++: void SetComponentOffset(int offset)
        
        This method specifies which component of the input will be
        interpolated, or if ComponentCount is also set, it specifies the
        first component. When the interpolation is performed, it will be
        clamped to the number of available components.
        """
        ...
    
    def SetOutValue(self, p_float):
        """
        V.SetOutValue(float)
        C++: void SetOutValue(double outValue)
        
        The value to return when the point is out of bounds.
        """
        ...
    
    def SetSlidingWindow(self, bool):
        """
        V.SetSlidingWindow(bool)
        C++: void SetSlidingWindow(bool x)
        
        Enable sliding window for separable kernels. When this is
        enabled, the interpolator will cache partial sums in in order to
        accelerate the computation.  It only makes sense to do this if
        the interpolator is used by calling InterpolateRow() while
        incrementing first the Y, and then the Z index with every call.
        """
        ...
    
    def SetTolerance(self, p_float):
        """
        V.SetTolerance(float)
        C++: void SetTolerance(double tol)
        
        The tolerance to apply when checking whether a point is out of
        bounds. This is a fractional distance relative to the voxel size,
        so a tolerance of 1 expands the bounds by one voxel.
        """
        ...
    
    def SlidingWindowOff(self):
        """
        V.SlidingWindowOff()
        C++: void SlidingWindowOff()
        """
        ...
    
    def SlidingWindowOn(self):
        """
        V.SlidingWindowOn()
        C++: void SlidingWindowOn()
        """
        ...
    
    def Update(self):
        """
        V.Update()
        C++: void Update()
        
        Update the interpolator.  If the interpolator has been modified
        by a Set method since Initialize() was called, you must call this
        method to update the interpolator before you can use it.
        """
        ...
    
    def __delattr__(self, *args, **kwargs):
        """ Implement delattr(self, name). """
        ...
    
    def __getattribute__(self, *args, **kwargs):
        """ Return getattr(self, name). """
        ...
    
    def __init__(self, *args, **kwargs) -> None:
        ...
    
    @staticmethod
    def __new__(*args, **kwargs):
        """ Create and return a new object.  See help(type) for accurate signature. """
        ...
    
    def __repr__(self, *args, **kwargs):
        """ Return repr(self). """
        ...
    
    def __setattr__(self, *args, **kwargs):
        """ Implement setattr(self, name, value). """
        ...
    
    def __str__(self, *args, **kwargs) -> str:
        """ Return str(self). """
        ...
    
    __this__ = ...
    __dict__ = ...
    __vtkname__ = ...


