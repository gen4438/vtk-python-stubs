"""
This type stub file was generated by pyright.
"""

from .object import object

class vtkImagePointDataIterator(object):
    """
    vtkImagePointDataIterator - iterate over point data in an image.
    
    This class will iterate over an image.  For each position, it will
    provide the (I,J,K) index, the point Id, and if a stencil is
    supplied, it will report whether the point is inside or outside of
    the stencil.
    
    For efficiency, this class iterates over spans rather than points.
    Each span is one image row or partial row, defined by a start
    position and a size.  Within a span, only the X index and the point
    Id will change. The vtkImagePointDataIterator and related iterators
    are the preferred method of iterating over image data within the VTK
    image filters.
    @sa
    vtkImageData vtkImageStencilData vtkImageProgressIterator
    
    vtkImagePointDataIterator()
    vtkImagePointDataIterator(vtkImageData *image,
        const int extent[6]=nullptr, vtkImageStencilData *stencil=nullptr,
         vtkAlgorithm *algorithm=nullptr, int threadId=0)
    vtkImagePointDataIterator(const &vtkImagePointDataIterator)
    """
    def GetId(self):
        """
        V.GetId() -> int
        C++: vtkIdType GetId()
        
        Get the point Id at the beginning of the current span.
        """
        ...
    
    def GetIndex(self, p_int=..., p_int=..., p_int=...):
        """
        V.GetIndex([int, int, int])
        C++: void GetIndex(int result[3])
        V.GetIndex() -> (int, int, int)
        C++: const int *GetIndex()
        
        Get the index at the beginning of the current span.
        """
        ...
    
    def GetVoidPointer(self, vtkImageData, p_int, *int):
        """
        V.GetVoidPointer(vtkImageData, int, [int, ...]) -> void
        C++: static void *GetVoidPointer(vtkImageData *image,
            vtkIdType i=0, int *pixelIncrement=nullptr)
        V.GetVoidPointer(vtkDataArray, int, [int, ...]) -> void
        C++: static void *GetVoidPointer(vtkDataArray *array,
            vtkIdType i=0, int *pixelIncrement=nullptr)
        
        Get a void pointer and pixel increment for the given point Id.
        The pixel increment is the number of scalar components.
        """
        ...
    
    def Initialize(self, vtkImageData, , vtkImageStencilData, vtkAlgorithm, p_int_6):
        """
        V.Initialize(vtkImageData, (int, int, int, int, int, int),
            vtkImageStencilData, vtkAlgorithm, int)
        C++: void Initialize(vtkImageData *image,
            const int extent[6]=nullptr,
            vtkImageStencilData *stencil=nullptr,
            vtkAlgorithm *algorithm=nullptr, int threadId=0)
        
        Initialize an iterator.  See constructor for more details.
        """
        ...
    
    def IsAtEnd(self):
        """
        V.IsAtEnd() -> bool
        C++: bool IsAtEnd()
        
        Test if the iterator has completed iterating over the entire
        extent.
        """
        ...
    
    def IsInStencil(self):
        """
        V.IsInStencil() -> bool
        C++: bool IsInStencil()
        
        Check if the iterator is within the region specified by the
        stencil. This is updated when NextSpan() is called.
        """
        ...
    
    def NextSpan(self):
        """
        V.NextSpan()
        C++: void NextSpan()
        
        Move the iterator to the beginning of the next span. A span is a
        contiguous region of the image over which nothing but the point
        Id and the X index changes.
        """
        ...
    
    def SpanEndId(self):
        """
        V.SpanEndId() -> int
        C++: vtkIdType SpanEndId()
        
        Get the end of the span.
        """
        ...
    
    def __getattribute__(self, *args, **kwargs):
        """ Return getattr(self, name). """
        ...
    
    def __hash__(self, *args, **kwargs) -> int:
        """ Return hash(self). """
        ...
    
    def __init__(self) -> None:
        ...
    
    @staticmethod
    def __new__(*args, **kwargs):
        """ Create and return a new object.  See help(type) for accurate signature. """
        ...
    
    def __repr__(self, *args, **kwargs):
        """ Return repr(self). """
        ...
    


