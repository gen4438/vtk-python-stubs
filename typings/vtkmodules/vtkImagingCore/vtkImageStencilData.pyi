"""
This type stub file was generated by pyright.
"""

import vtkmodules.vtkCommonDataModel as __vtkmodules_vtkCommonDataModel

class vtkImageStencilData(__vtkmodules_vtkCommonDataModel.vtkDataObject):
    """
    vtkImageStencilData - efficient description of an image stencil
    
    Superclass: vtkDataObject
    
    vtkImageStencilData describes an image stencil in a manner which is
    efficient both in terms of speed and storage space.  The stencil
    extents are stored for each x-row across the image (multiple extents
    per row if necessary) and can be retrieved via the GetNextExtent()
    method.
    @sa
    vtkImageStencilSource vtkImageStencil
    """
    def Add(self, vtkImageStencilData):
        """
        V.Add(vtkImageStencilData)
        C++: virtual void Add(vtkImageStencilData *)
        
        Add merges the stencil supplied as argument into Self.
        """
        ...
    
    def AllocateExtents(self):
        """
        V.AllocateExtents()
        C++: void AllocateExtents()
        
        Allocate space for the sub-extents.  This is called by
        vtkImageStencilSource.
        """
        ...
    
    def Clip(self, p_int=..., p_int=..., p_int=..., p_int=..., p_int=..., p_int=...):
        """
        V.Clip([int, int, int, int, int, int]) -> int
        C++: virtual int Clip(int extent[6])
        
        Clip the stencil with the supplied extents. In other words,
        discard data outside the specified extents. Return 1 if something
        changed.
        """
        ...
    
    def CopyInformationFromPipeline(self, vtkInformation):
        """
        V.CopyInformationFromPipeline(vtkInformation)
        C++: void CopyInformationFromPipeline(vtkInformation *info)
            override;
        
        Override these to handle origin, spacing, scalar type, and scalar
        number of components.  See vtkDataObject for details.
        """
        ...
    
    def CopyInformationToPipeline(self, vtkInformation):
        """
        V.CopyInformationToPipeline(vtkInformation)
        C++: void CopyInformationToPipeline(vtkInformation *info)
            override;
        
        Override these to handle origin, spacing, scalar type, and scalar
        number of components.  See vtkDataObject for details.
        """
        ...
    
    def DeepCopy(self, vtkDataObject):
        """
        V.DeepCopy(vtkDataObject)
        C++: void DeepCopy(vtkDataObject *o) override;
        
        Shallow and Deep copy.  These copy the data, but not any of the
        pipeline connections.
        """
        ...
    
    def Fill(self):
        """
        V.Fill()
        C++: void Fill()
        
        Fill the sub-extents.
        """
        ...
    
    def GetData(self, vtkInformation):
        """
        V.GetData(vtkInformation) -> vtkImageStencilData
        C++: static vtkImageStencilData *GetData(vtkInformation *info)
        V.GetData(vtkInformationVector, int) -> vtkImageStencilData
        C++: static vtkImageStencilData *GetData(vtkInformationVector *v,
            int i=0)
        
        Retrieve an instance of this class from an information object.
        """
        ...
    
    def GetDataObjectType(self):
        """
        V.GetDataObjectType() -> int
        C++: int GetDataObjectType() override;
        
        Get the data type as an integer (this will return VTK_DATA_OBJECT
        for now, maybe a proper type constant will be reserved later).
        """
        ...
    
    def GetExtent(self):
        """
        V.GetExtent() -> (int, int, int, int, int, int)
        C++: virtual int *GetExtent()
        
        Set the extent of the data.  This is should be called only by
        vtkImageStencilSource, as it is part of the basic pipeline
        functionality.
        """
        ...
    
    def GetExtentType(self):
        """
        V.GetExtentType() -> int
        C++: int GetExtentType() override;
        
        The extent type is 3D, just like vtkImageData.
        """
        ...
    
    def GetNextExtent(self, p_int, p_int_1, p_int_2, p_int_3, p_int_4, p_int_5, p_int_6):
        """
        V.GetNextExtent(int, int, int, int, int, int, int) -> int
        C++: int GetNextExtent(int &r1, int &r2, int xMin, int xMax,
            int yIdx, int zIdx, int &iter)
        
        Given the total output x extent [xMin,xMax] and the current y, z
        indices, return each sub-extent [r1,r2] that lies within within
        the unclipped region in sequence.  A value of '0' is returned if
        no more sub-extents are available.  The variable 'iter' must be
        initialized to zero before the first call, unless you want the
        complementary sub-extents in which case you must initialize
        'iter' to -1.  The variable 'iter' is used internally to keep
        track of which sub-extent should be returned next.
        """
        ...
    
    def GetNumberOfGenerationsFromBase(self, string):
        """
        V.GetNumberOfGenerationsFromBase(string) -> int
        C++: vtkIdType GetNumberOfGenerationsFromBase(const char *type)
            override;
        
        Given a the name of a base class of this class type, return the
        distance of inheritance between this class type and the named
        class (how many generations of inheritance are there between this
        class and the named class). If the named class is not in this
        class's inheritance tree, return a negative value. Valid
        responses will always be nonnegative. This method works in
        combination with vtkTypeMacro found in vtkSetGet.h.
        """
        ...
    
    def GetNumberOfGenerationsFromBaseType(self, string):
        """
        V.GetNumberOfGenerationsFromBaseType(string) -> int
        C++: static vtkIdType GetNumberOfGenerationsFromBaseType(
            const char *type)
        
        Given a the name of a base class of this class type, return the
        distance of inheritance between this class type and the named
        class (how many generations of inheritance are there between this
        class and the named class). If the named class is not in this
        class's inheritance tree, return a negative value. Valid
        responses will always be nonnegative. This method works in
        combination with vtkTypeMacro found in vtkSetGet.h.
        """
        ...
    
    def GetOrigin(self):
        """
        V.GetOrigin() -> (float, float, float)
        C++: virtual double *GetOrigin()
        
        Set the desired origin for the stencil. This must be called
        before the stencil is Updated, ideally in the ExecuteInformation
        method of the imaging filter that is using the stencil.
        """
        ...
    
    def GetSpacing(self):
        """
        V.GetSpacing() -> (float, float, float)
        C++: virtual double *GetSpacing()
        
        Set the desired spacing for the stencil. This must be called
        before the stencil is Updated, ideally in the ExecuteInformation
        method of the imaging filter that is using the stencil.
        """
        ...
    
    def Initialize(self):
        """
        V.Initialize()
        C++: void Initialize() override;
        
        Restore data object to initial state,
        """
        ...
    
    def InsertAndMergeExtent(self, p_int, p_int_1, p_int_2, p_int_3):
        """
        V.InsertAndMergeExtent(int, int, int, int)
        C++: void InsertAndMergeExtent(int r1, int r2, int yIdx, int zIdx)
        
        Similar to InsertNextExtent, except that the extent (r1,r2) at
        yIdx, zIdx is merged with other extents, (if any) on that row. So
        a unique extent may not necessarily be added. For instance, if an
        extent [5,11] already exists adding an extent, [7,9] will not
        affect the stencil. Likewise adding [10, 13] will replace the
        existing extent with [5,13].
        """
        ...
    
    def InsertNextExtent(self, p_int, p_int_1, p_int_2, p_int_3):
        """
        V.InsertNextExtent(int, int, int, int)
        C++: void InsertNextExtent(int r1, int r2, int yIdx, int zIdx)
        
        This method is used by vtkImageStencilDataSource to add an x sub
        extent [r1,r2] for the x row (yIdx,zIdx).  The specified sub
        extent must not intersect any other sub extents along the same x
        row. As well, r1 and r2 must both be within the total x extent
        [Extent[0],Extent[1]].
        """
        ...
    
    def InternalImageStencilDataCopy(self, vtkImageStencilData):
        """
        V.InternalImageStencilDataCopy(vtkImageStencilData)
        C++: void InternalImageStencilDataCopy(vtkImageStencilData *s)
        """
        ...
    
    def IsA(self, string):
        """
        V.IsA(string) -> int
        C++: vtkTypeBool IsA(const char *type) override;
        
        Return 1 if this class is the same type of (or a subclass of) the
        named class. Returns 0 otherwise. This method works in
        combination with vtkTypeMacro found in vtkSetGet.h.
        """
        ...
    
    def IsInside(self, p_int, p_int_1, p_int_2):
        """
        V.IsInside(int, int, int) -> int
        C++: int IsInside(int xIdx, int yIdx, int zIdx)
        
        Checks if an image index is inside the stencil. Even though
        GetNextExtent and the vtkImageStencilIterator are faster if every
        voxel in the volume has to be checked, IsInside provides an
        efficient alternative for if just a single voxel has to be
        checked.
        """
        ...
    
    def IsTypeOf(self, string):
        """
        V.IsTypeOf(string) -> int
        C++: static vtkTypeBool IsTypeOf(const char *type)
        
        Return 1 if this class type is the same type of (or a subclass
        of) the named class. Returns 0 otherwise. This method works in
        combination with vtkTypeMacro found in vtkSetGet.h.
        """
        ...
    
    def NewInstance(self):
        """
        V.NewInstance() -> vtkImageStencilData
        C++: vtkImageStencilData *NewInstance()
        """
        ...
    
    def RemoveExtent(self, p_int, p_int_1, p_int_2, p_int_3):
        """
        V.RemoveExtent(int, int, int, int)
        C++: void RemoveExtent(int r1, int r2, int yIdx, int zIdx)
        
        Remove the extent from (r1,r2) at yIdx, zIdx
        """
        ...
    
    def Replace(self, vtkImageStencilData):
        """
        V.Replace(vtkImageStencilData)
        C++: virtual void Replace(vtkImageStencilData *)
        
        Replaces the portion of the stencil, supplied as argument, that
        lies within Self from Self.
        """
        ...
    
    def SafeDownCast(self, vtkObjectBase):
        """
        V.SafeDownCast(vtkObjectBase) -> vtkImageStencilData
        C++: static vtkImageStencilData *SafeDownCast(vtkObjectBase *o)
        """
        ...
    
    def SetExtent(self, ):
        """
        V.SetExtent((int, int, int, int, int, int))
        C++: void SetExtent(const int extent[6])
        V.SetExtent(int, int, int, int, int, int)
        C++: void SetExtent(int x1, int x2, int y1, int y2, int z1,
            int z2)
        
        Set the extent of the data.  This is should be called only by
        vtkImageStencilSource, as it is part of the basic pipeline
        functionality.
        """
        ...
    
    def SetOrigin(self, p_float, p_float_1, p_float_2):
        """
        V.SetOrigin(float, float, float)
        C++: virtual void SetOrigin(double _arg1, double _arg2,
            double _arg3)
        V.SetOrigin((float, float, float))
        C++: virtual void SetOrigin(const double _arg[3])
        
        Set the desired origin for the stencil. This must be called
        before the stencil is Updated, ideally in the ExecuteInformation
        method of the imaging filter that is using the stencil.
        """
        ...
    
    def SetSpacing(self, p_float, p_float_1, p_float_2):
        """
        V.SetSpacing(float, float, float)
        C++: virtual void SetSpacing(double _arg1, double _arg2,
            double _arg3)
        V.SetSpacing((float, float, float))
        C++: virtual void SetSpacing(const double _arg[3])
        
        Set the desired spacing for the stencil. This must be called
        before the stencil is Updated, ideally in the ExecuteInformation
        method of the imaging filter that is using the stencil.
        """
        ...
    
    def ShallowCopy(self, vtkDataObject):
        """
        V.ShallowCopy(vtkDataObject)
        C++: void ShallowCopy(vtkDataObject *f) override;
        
        Shallow and Deep copy.  These copy the data, but not any of the
        pipeline connections.
        """
        ...
    
    def Subtract(self, vtkImageStencilData):
        """
        V.Subtract(vtkImageStencilData)
        C++: virtual void Subtract(vtkImageStencilData *)
        
        Subtract removes the portion of the stencil, supplied as
        argument, that lies within Self from Self.
        """
        ...
    
    def __delattr__(self, *args, **kwargs):
        """ Implement delattr(self, name). """
        ...
    
    def __getattribute__(self, *args, **kwargs):
        """ Return getattr(self, name). """
        ...
    
    def __init__(self, *args, **kwargs) -> None:
        ...
    
    @staticmethod
    def __new__(*args, **kwargs):
        """ Create and return a new object.  See help(type) for accurate signature. """
        ...
    
    def __repr__(self, *args, **kwargs):
        """ Return repr(self). """
        ...
    
    def __setattr__(self, *args, **kwargs):
        """ Implement setattr(self, name, value). """
        ...
    
    def __str__(self, *args, **kwargs) -> str:
        """ Return str(self). """
        ...
    
    __this__ = ...
    __dict__ = ...
    __vtkname__ = ...


