"""
This type stub file was generated by pyright.
"""

import vtkmodules.vtkCommonExecutionModel as __vtkmodules_vtkCommonExecutionModel

class vtkHyperStreamline(__vtkmodules_vtkCommonExecutionModel.vtkPolyDataAlgorithm):
    """
    vtkHyperStreamline - generate hyperstreamline in arbitrary dataset
    
    Superclass: vtkPolyDataAlgorithm
    
    vtkHyperStreamline is a filter that integrates through a tensor field
    to generate a hyperstreamline. The integration is along the maximum
    eigenvector and the cross section of the hyperstreamline is defined
    by the two other eigenvectors. Thus the shape of the hyperstreamline
    is "tube-like", with the cross section being elliptical.
    Hyperstreamlines are used to visualize tensor fields.
    
    The starting point of a hyperstreamline can be defined in one of two
    ways. First, you may specify an initial position. This is a x-y-z
    global coordinate. The second option is to specify a starting
    location. This is cellId, subId, and cell parametric coordinates.
    
    The integration of the hyperstreamline occurs through the major
    eigenvector field. IntegrationStepLength controls the step length
    within each cell (i.e., this is the fraction of the cell length). The
    length of the hyperstreamline is controlled by
    MaximumPropagationDistance. This parameter is the length of the
    hyperstreamline in units of distance. The tube itself is composed of
    many small sub-tubes - NumberOfSides controls the number of sides in
    the tube, and StepLength controls the length of the sub-tubes.
    
    Because hyperstreamlines are often created near regions of
    singularities, it is possible to control the scaling of the tube
    cross section by using a logarithmic scale. Use LogScalingOn to turn
    this capability on. The Radius value controls the initial radius of
    the tube.
    
    @sa
    vtkTensorGlyph
    """
    def GetIntegrationDirection(self):
        """
        V.GetIntegrationDirection() -> int
        C++: virtual int GetIntegrationDirection()
        
        Specify the direction in which to integrate the hyperstreamline.
        """
        ...
    
    def GetIntegrationDirectionMaxValue(self):
        """
        V.GetIntegrationDirectionMaxValue() -> int
        C++: virtual int GetIntegrationDirectionMaxValue()
        
        Specify the direction in which to integrate the hyperstreamline.
        """
        ...
    
    def GetIntegrationDirectionMinValue(self):
        """
        V.GetIntegrationDirectionMinValue() -> int
        C++: virtual int GetIntegrationDirectionMinValue()
        
        Specify the direction in which to integrate the hyperstreamline.
        """
        ...
    
    def GetIntegrationEigenvector(self):
        """
        V.GetIntegrationEigenvector() -> int
        C++: virtual int GetIntegrationEigenvector()
        
        Set / get the eigenvector field through which to ingrate. It is
        possible to integrate using the major, medium or minor
        eigenvector field.  The major eigenvector is the eigenvector
        whose corresponding eigenvalue is closest to positive infinity.
        The minor eigenvector is the eigenvector whose corresponding
        eigenvalue is closest to negative infinity.  The medium
        eigenvector is the eigenvector whose corresponding eigenvalue is
        between the major and minor eigenvalues.
        """
        ...
    
    def GetIntegrationEigenvectorMaxValue(self):
        """
        V.GetIntegrationEigenvectorMaxValue() -> int
        C++: virtual int GetIntegrationEigenvectorMaxValue()
        
        Set / get the eigenvector field through which to ingrate. It is
        possible to integrate using the major, medium or minor
        eigenvector field.  The major eigenvector is the eigenvector
        whose corresponding eigenvalue is closest to positive infinity.
        The minor eigenvector is the eigenvector whose corresponding
        eigenvalue is closest to negative infinity.  The medium
        eigenvector is the eigenvector whose corresponding eigenvalue is
        between the major and minor eigenvalues.
        """
        ...
    
    def GetIntegrationEigenvectorMinValue(self):
        """
        V.GetIntegrationEigenvectorMinValue() -> int
        C++: virtual int GetIntegrationEigenvectorMinValue()
        
        Set / get the eigenvector field through which to ingrate. It is
        possible to integrate using the major, medium or minor
        eigenvector field.  The major eigenvector is the eigenvector
        whose corresponding eigenvalue is closest to positive infinity.
        The minor eigenvector is the eigenvector whose corresponding
        eigenvalue is closest to negative infinity.  The medium
        eigenvector is the eigenvector whose corresponding eigenvalue is
        between the major and minor eigenvalues.
        """
        ...
    
    def GetIntegrationStepLength(self):
        """
        V.GetIntegrationStepLength() -> float
        C++: virtual double GetIntegrationStepLength()
        
        Set / get a nominal integration step size (expressed as a
        fraction of the size of each cell).
        """
        ...
    
    def GetIntegrationStepLengthMaxValue(self):
        """
        V.GetIntegrationStepLengthMaxValue() -> float
        C++: virtual double GetIntegrationStepLengthMaxValue()
        
        Set / get a nominal integration step size (expressed as a
        fraction of the size of each cell).
        """
        ...
    
    def GetIntegrationStepLengthMinValue(self):
        """
        V.GetIntegrationStepLengthMinValue() -> float
        C++: virtual double GetIntegrationStepLengthMinValue()
        
        Set / get a nominal integration step size (expressed as a
        fraction of the size of each cell).
        """
        ...
    
    def GetLogScaling(self):
        """
        V.GetLogScaling() -> int
        C++: virtual vtkTypeBool GetLogScaling()
        
        Turn on/off logarithmic scaling. If scaling is on, the log base
        10 of the computed eigenvalues are used to scale the cross
        section radii.
        """
        ...
    
    def GetMaximumPropagationDistance(self):
        """
        V.GetMaximumPropagationDistance() -> float
        C++: virtual double GetMaximumPropagationDistance()
        
        Set / get the maximum length of the hyperstreamline expressed as
        absolute distance (i.e., arc length) value.
        """
        ...
    
    def GetMaximumPropagationDistanceMaxValue(self):
        """
        V.GetMaximumPropagationDistanceMaxValue() -> float
        C++: virtual double GetMaximumPropagationDistanceMaxValue()
        
        Set / get the maximum length of the hyperstreamline expressed as
        absolute distance (i.e., arc length) value.
        """
        ...
    
    def GetMaximumPropagationDistanceMinValue(self):
        """
        V.GetMaximumPropagationDistanceMinValue() -> float
        C++: virtual double GetMaximumPropagationDistanceMinValue()
        
        Set / get the maximum length of the hyperstreamline expressed as
        absolute distance (i.e., arc length) value.
        """
        ...
    
    def GetNumberOfGenerationsFromBase(self, string):
        """
        V.GetNumberOfGenerationsFromBase(string) -> int
        C++: vtkIdType GetNumberOfGenerationsFromBase(const char *type)
            override;
        
        Given a the name of a base class of this class type, return the
        distance of inheritance between this class type and the named
        class (how many generations of inheritance are there between this
        class and the named class). If the named class is not in this
        class's inheritance tree, return a negative value. Valid
        responses will always be nonnegative. This method works in
        combination with vtkTypeMacro found in vtkSetGet.h.
        """
        ...
    
    def GetNumberOfGenerationsFromBaseType(self, string):
        """
        V.GetNumberOfGenerationsFromBaseType(string) -> int
        C++: static vtkIdType GetNumberOfGenerationsFromBaseType(
            const char *type)
        
        Given a the name of a base class of this class type, return the
        distance of inheritance between this class type and the named
        class (how many generations of inheritance are there between this
        class and the named class). If the named class is not in this
        class's inheritance tree, return a negative value. Valid
        responses will always be nonnegative. This method works in
        combination with vtkTypeMacro found in vtkSetGet.h.
        """
        ...
    
    def GetNumberOfSides(self):
        """
        V.GetNumberOfSides() -> int
        C++: virtual int GetNumberOfSides()
        
        Set / get the number of sides for the hyperstreamlines. At a
        minimum, number of sides is 3.
        """
        ...
    
    def GetNumberOfSidesMaxValue(self):
        """
        V.GetNumberOfSidesMaxValue() -> int
        C++: virtual int GetNumberOfSidesMaxValue()
        
        Set / get the number of sides for the hyperstreamlines. At a
        minimum, number of sides is 3.
        """
        ...
    
    def GetNumberOfSidesMinValue(self):
        """
        V.GetNumberOfSidesMinValue() -> int
        C++: virtual int GetNumberOfSidesMinValue()
        
        Set / get the number of sides for the hyperstreamlines. At a
        minimum, number of sides is 3.
        """
        ...
    
    def GetRadius(self):
        """
        V.GetRadius() -> float
        C++: virtual double GetRadius()
        
        Set / get the initial tube radius. This is the maximum
        "elliptical" radius at the beginning of the tube. Radius varies
        based on ratio of eigenvalues.  Note that tube section is
        actually elliptical and may become a point or line in cross
        section in some cases.
        """
        ...
    
    def GetRadiusMaxValue(self):
        """
        V.GetRadiusMaxValue() -> float
        C++: virtual double GetRadiusMaxValue()
        
        Set / get the initial tube radius. This is the maximum
        "elliptical" radius at the beginning of the tube. Radius varies
        based on ratio of eigenvalues.  Note that tube section is
        actually elliptical and may become a point or line in cross
        section in some cases.
        """
        ...
    
    def GetRadiusMinValue(self):
        """
        V.GetRadiusMinValue() -> float
        C++: virtual double GetRadiusMinValue()
        
        Set / get the initial tube radius. This is the maximum
        "elliptical" radius at the beginning of the tube. Radius varies
        based on ratio of eigenvalues.  Note that tube section is
        actually elliptical and may become a point or line in cross
        section in some cases.
        """
        ...
    
    def GetStartLocation(self, p_int, p_float=..., p_float=..., p_float=...):
        """
        V.GetStartLocation(int, [float, float, float]) -> int
        C++: vtkIdType GetStartLocation(int &subId, double pcoords[3])
        
        Get the starting location of the hyperstreamline in the cell
        coordinate system. Returns the cell that the starting point is
        in.
        """
        ...
    
    def GetStartPosition(self):
        """
        V.GetStartPosition() -> (float, float, float)
        C++: double *GetStartPosition()
        
        Get the start position of the hyperstreamline in global x-y-z
        coordinates.
        """
        ...
    
    def GetStepLength(self):
        """
        V.GetStepLength() -> float
        C++: virtual double GetStepLength()
        
        Set / get the length of a tube segment composing the
        hyperstreamline. The length is specified as a fraction of the
        diagonal length of the input bounding box.
        """
        ...
    
    def GetStepLengthMaxValue(self):
        """
        V.GetStepLengthMaxValue() -> float
        C++: virtual double GetStepLengthMaxValue()
        
        Set / get the length of a tube segment composing the
        hyperstreamline. The length is specified as a fraction of the
        diagonal length of the input bounding box.
        """
        ...
    
    def GetStepLengthMinValue(self):
        """
        V.GetStepLengthMinValue() -> float
        C++: virtual double GetStepLengthMinValue()
        
        Set / get the length of a tube segment composing the
        hyperstreamline. The length is specified as a fraction of the
        diagonal length of the input bounding box.
        """
        ...
    
    def GetTerminalEigenvalue(self):
        """
        V.GetTerminalEigenvalue() -> float
        C++: virtual double GetTerminalEigenvalue()
        
        Set/get terminal eigenvalue.  If major eigenvalue falls below
        this value, hyperstreamline terminates propagation.
        """
        ...
    
    def GetTerminalEigenvalueMaxValue(self):
        """
        V.GetTerminalEigenvalueMaxValue() -> float
        C++: virtual double GetTerminalEigenvalueMaxValue()
        
        Set/get terminal eigenvalue.  If major eigenvalue falls below
        this value, hyperstreamline terminates propagation.
        """
        ...
    
    def GetTerminalEigenvalueMinValue(self):
        """
        V.GetTerminalEigenvalueMinValue() -> float
        C++: virtual double GetTerminalEigenvalueMinValue()
        
        Set/get terminal eigenvalue.  If major eigenvalue falls below
        this value, hyperstreamline terminates propagation.
        """
        ...
    
    def IntegrateMajorEigenvector(self):
        """
        V.IntegrateMajorEigenvector()
        C++: void IntegrateMajorEigenvector()
        
        Use the major eigenvector field as the vector field through which
        to integrate.  The major eigenvector is the eigenvector whose
        corresponding eigenvalue is closest to positive infinity.
        """
        ...
    
    def IntegrateMediumEigenvector(self):
        """
        V.IntegrateMediumEigenvector()
        C++: void IntegrateMediumEigenvector()
        
        Use the medium eigenvector field as the vector field through
        which to integrate. The medium eigenvector is the eigenvector
        whose corresponding eigenvalue is between the major and minor
        eigenvalues.
        """
        ...
    
    def IntegrateMinorEigenvector(self):
        """
        V.IntegrateMinorEigenvector()
        C++: void IntegrateMinorEigenvector()
        
        Use the minor eigenvector field as the vector field through which
        to integrate. The minor eigenvector is the eigenvector whose
        corresponding eigenvalue is closest to negative infinity.
        """
        ...
    
    def IsA(self, string):
        """
        V.IsA(string) -> int
        C++: vtkTypeBool IsA(const char *type) override;
        
        Return 1 if this class is the same type of (or a subclass of) the
        named class. Returns 0 otherwise. This method works in
        combination with vtkTypeMacro found in vtkSetGet.h.
        """
        ...
    
    def IsTypeOf(self, string):
        """
        V.IsTypeOf(string) -> int
        C++: static vtkTypeBool IsTypeOf(const char *type)
        
        Return 1 if this class type is the same type of (or a subclass
        of) the named class. Returns 0 otherwise. This method works in
        combination with vtkTypeMacro found in vtkSetGet.h.
        """
        ...
    
    def LogScalingOff(self):
        """
        V.LogScalingOff()
        C++: virtual void LogScalingOff()
        
        Turn on/off logarithmic scaling. If scaling is on, the log base
        10 of the computed eigenvalues are used to scale the cross
        section radii.
        """
        ...
    
    def LogScalingOn(self):
        """
        V.LogScalingOn()
        C++: virtual void LogScalingOn()
        
        Turn on/off logarithmic scaling. If scaling is on, the log base
        10 of the computed eigenvalues are used to scale the cross
        section radii.
        """
        ...
    
    def NewInstance(self):
        """
        V.NewInstance() -> vtkHyperStreamline
        C++: vtkHyperStreamline *NewInstance()
        """
        ...
    
    def SafeDownCast(self, vtkObjectBase):
        """
        V.SafeDownCast(vtkObjectBase) -> vtkHyperStreamline
        C++: static vtkHyperStreamline *SafeDownCast(vtkObjectBase *o)
        """
        ...
    
    def SetIntegrationDirection(self, p_int):
        """
        V.SetIntegrationDirection(int)
        C++: virtual void SetIntegrationDirection(int _arg)
        
        Specify the direction in which to integrate the hyperstreamline.
        """
        ...
    
    def SetIntegrationDirectionToBackward(self):
        """
        V.SetIntegrationDirectionToBackward()
        C++: void SetIntegrationDirectionToBackward()
        
        Specify the direction in which to integrate the hyperstreamline.
        """
        ...
    
    def SetIntegrationDirectionToForward(self):
        """
        V.SetIntegrationDirectionToForward()
        C++: void SetIntegrationDirectionToForward()
        
        Specify the direction in which to integrate the hyperstreamline.
        """
        ...
    
    def SetIntegrationDirectionToIntegrateBothDirections(self):
        """
        V.SetIntegrationDirectionToIntegrateBothDirections()
        C++: void SetIntegrationDirectionToIntegrateBothDirections()
        
        Specify the direction in which to integrate the hyperstreamline.
        """
        ...
    
    def SetIntegrationEigenvector(self, p_int):
        """
        V.SetIntegrationEigenvector(int)
        C++: virtual void SetIntegrationEigenvector(int _arg)
        
        Set / get the eigenvector field through which to ingrate. It is
        possible to integrate using the major, medium or minor
        eigenvector field.  The major eigenvector is the eigenvector
        whose corresponding eigenvalue is closest to positive infinity.
        The minor eigenvector is the eigenvector whose corresponding
        eigenvalue is closest to negative infinity.  The medium
        eigenvector is the eigenvector whose corresponding eigenvalue is
        between the major and minor eigenvalues.
        """
        ...
    
    def SetIntegrationEigenvectorToMajor(self):
        """
        V.SetIntegrationEigenvectorToMajor()
        C++: void SetIntegrationEigenvectorToMajor()
        
        Set / get the eigenvector field through which to ingrate. It is
        possible to integrate using the major, medium or minor
        eigenvector field.  The major eigenvector is the eigenvector
        whose corresponding eigenvalue is closest to positive infinity.
        The minor eigenvector is the eigenvector whose corresponding
        eigenvalue is closest to negative infinity.  The medium
        eigenvector is the eigenvector whose corresponding eigenvalue is
        between the major and minor eigenvalues.
        """
        ...
    
    def SetIntegrationEigenvectorToMedium(self):
        """
        V.SetIntegrationEigenvectorToMedium()
        C++: void SetIntegrationEigenvectorToMedium()
        
        Set / get the eigenvector field through which to ingrate. It is
        possible to integrate using the major, medium or minor
        eigenvector field.  The major eigenvector is the eigenvector
        whose corresponding eigenvalue is closest to positive infinity.
        The minor eigenvector is the eigenvector whose corresponding
        eigenvalue is closest to negative infinity.  The medium
        eigenvector is the eigenvector whose corresponding eigenvalue is
        between the major and minor eigenvalues.
        """
        ...
    
    def SetIntegrationEigenvectorToMinor(self):
        """
        V.SetIntegrationEigenvectorToMinor()
        C++: void SetIntegrationEigenvectorToMinor()
        
        Set / get the eigenvector field through which to ingrate. It is
        possible to integrate using the major, medium or minor
        eigenvector field.  The major eigenvector is the eigenvector
        whose corresponding eigenvalue is closest to positive infinity.
        The minor eigenvector is the eigenvector whose corresponding
        eigenvalue is closest to negative infinity.  The medium
        eigenvector is the eigenvector whose corresponding eigenvalue is
        between the major and minor eigenvalues.
        """
        ...
    
    def SetIntegrationStepLength(self, p_float):
        """
        V.SetIntegrationStepLength(float)
        C++: virtual void SetIntegrationStepLength(double _arg)
        
        Set / get a nominal integration step size (expressed as a
        fraction of the size of each cell).
        """
        ...
    
    def SetLogScaling(self, p_int):
        """
        V.SetLogScaling(int)
        C++: virtual void SetLogScaling(vtkTypeBool _arg)
        
        Turn on/off logarithmic scaling. If scaling is on, the log base
        10 of the computed eigenvalues are used to scale the cross
        section radii.
        """
        ...
    
    def SetMaximumPropagationDistance(self, p_float):
        """
        V.SetMaximumPropagationDistance(float)
        C++: virtual void SetMaximumPropagationDistance(double _arg)
        
        Set / get the maximum length of the hyperstreamline expressed as
        absolute distance (i.e., arc length) value.
        """
        ...
    
    def SetNumberOfSides(self, p_int):
        """
        V.SetNumberOfSides(int)
        C++: virtual void SetNumberOfSides(int _arg)
        
        Set / get the number of sides for the hyperstreamlines. At a
        minimum, number of sides is 3.
        """
        ...
    
    def SetRadius(self, p_float):
        """
        V.SetRadius(float)
        C++: virtual void SetRadius(double _arg)
        
        Set / get the initial tube radius. This is the maximum
        "elliptical" radius at the beginning of the tube. Radius varies
        based on ratio of eigenvalues.  Note that tube section is
        actually elliptical and may become a point or line in cross
        section in some cases.
        """
        ...
    
    def SetStartLocation(self, p_int, p_int_1, p_float=..., p_float=..., p_float=...):
        """
        V.SetStartLocation(int, int, [float, float, float])
        C++: void SetStartLocation(vtkIdType cellId, int subId,
            double pcoords[3])
        V.SetStartLocation(int, int, float, float, float)
        C++: void SetStartLocation(vtkIdType cellId, int subId, double r,
            double s, double t)
        
        Specify the start of the hyperstreamline in the cell coordinate
        system. That is, cellId and subId (if composite cell), and
        parametric coordinates.
        """
        ...
    
    def SetStartPosition(self, p_float=..., p_float=..., p_float=...):
        """
        V.SetStartPosition([float, float, float])
        C++: void SetStartPosition(double x[3])
        V.SetStartPosition(float, float, float)
        C++: void SetStartPosition(double x, double y, double z)
        
        Specify the start of the hyperstreamline in the global coordinate
        system. Starting from position implies that a search must be
        performed to find initial cell to start integration from.
        """
        ...
    
    def SetStepLength(self, p_float):
        """
        V.SetStepLength(float)
        C++: virtual void SetStepLength(double _arg)
        
        Set / get the length of a tube segment composing the
        hyperstreamline. The length is specified as a fraction of the
        diagonal length of the input bounding box.
        """
        ...
    
    def SetTerminalEigenvalue(self, p_float):
        """
        V.SetTerminalEigenvalue(float)
        C++: virtual void SetTerminalEigenvalue(double _arg)
        
        Set/get terminal eigenvalue.  If major eigenvalue falls below
        this value, hyperstreamline terminates propagation.
        """
        ...
    
    def __delattr__(self, *args, **kwargs):
        """ Implement delattr(self, name). """
        ...
    
    def __getattribute__(self, *args, **kwargs):
        """ Return getattr(self, name). """
        ...
    
    def __init__(self, *args, **kwargs) -> None:
        ...
    
    @staticmethod
    def __new__(*args, **kwargs):
        """ Create and return a new object.  See help(type) for accurate signature. """
        ...
    
    def __repr__(self, *args, **kwargs):
        """ Return repr(self). """
        ...
    
    def __setattr__(self, *args, **kwargs):
        """ Implement setattr(self, name, value). """
        ...
    
    def __str__(self, *args, **kwargs) -> str:
        """ Return str(self). """
        ...
    
    __this__ = ...
    __dict__ = ...
    __vtkname__ = ...


