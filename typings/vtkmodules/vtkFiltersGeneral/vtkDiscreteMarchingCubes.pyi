"""
This type stub file was generated by pyright.
"""

import vtkmodules.vtkFiltersCore as __vtkmodules_vtkFiltersCore

class vtkDiscreteMarchingCubes(__vtkmodules_vtkFiltersCore.vtkMarchingCubes):
    """
    vtkDiscreteMarchingCubes - generate object boundaries from labelled
    volumes
    
    Superclass: vtkMarchingCubes
    
    takes as input a volume (e.g., 3D structured point set) of
    segmentation labels and generates on output one or more models
    representing the boundaries between the specified label and the
    adjacent structures.  One or more label values must be specified to
    generate the models.  The boundary positions are always defined to be
    half-way between adjacent voxels. This filter works best with
    integral scalar values. If ComputeScalars is on (the default), each
    output cell will have cell data that corresponds to the scalar value
    (segmentation label) of the corresponding cube. Note that this
    differs from vtkMarchingCubes, which stores the scalar value as point
    data. The rationale for this difference is that cell vertices may be
    shared between multiple cells. This also means that the resultant
    polydata may be non-manifold (cell faces may be coincident). To
    further process the polydata, users should either: 1) extract cells
    that have a common scalar value using vtkThreshold, or 2) process the
    data with filters that can handle non-manifold polydata (e.g.
    vtkWindowedSincPolyDataFilter). Also note, Normals and Gradients are
    not computed. If ComputeAdjacentScalars is on (default is off), each
    output point will have point data that contains the label value of
    the neighbouring voxel. This allows to remove regions of the
    resulting vtkPolyData that are adjacent to specific label meshes. For
    example, if the input is a label image that was created by running a
    watershed transformation on a distance map followed by masking with
    the original binary segmentation. For further details and images see
    the VTK Journal paper "Providing values of adjacent voxel with
    vtkDiscreteMarchingCubes" by Roman Grothausmann:
    http://hdl.handle.net/10380/3559
    http://www.vtkjournal.org/browse/publication/975
    @warning
    This filter is specialized to volumes. If you are interested in
    contouring other types of data, use the general vtkContourFilter. If
    you want to contour an image (i.e., a volume slice), use
    vtkMarchingSquares.
    @sa
    vtkContourFilter vtkSliceCubes vtkMarchingSquares vtkDividingCubes
    """
    def ComputeAdjacentScalarsOff(self):
        """
        V.ComputeAdjacentScalarsOff()
        C++: virtual void ComputeAdjacentScalarsOff()
        
        Set/Get the computation of neighbouring voxel values.
        """
        ...
    
    def ComputeAdjacentScalarsOn(self):
        """
        V.ComputeAdjacentScalarsOn()
        C++: virtual void ComputeAdjacentScalarsOn()
        
        Set/Get the computation of neighbouring voxel values.
        """
        ...
    
    def GetComputeAdjacentScalars(self):
        """
        V.GetComputeAdjacentScalars() -> int
        C++: virtual vtkTypeBool GetComputeAdjacentScalars()
        
        Set/Get the computation of neighbouring voxel values.
        """
        ...
    
    def GetNumberOfGenerationsFromBase(self, string):
        """
        V.GetNumberOfGenerationsFromBase(string) -> int
        C++: vtkIdType GetNumberOfGenerationsFromBase(const char *type)
            override;
        
        Given a the name of a base class of this class type, return the
        distance of inheritance between this class type and the named
        class (how many generations of inheritance are there between this
        class and the named class). If the named class is not in this
        class's inheritance tree, return a negative value. Valid
        responses will always be nonnegative. This method works in
        combination with vtkTypeMacro found in vtkSetGet.h.
        """
        ...
    
    def GetNumberOfGenerationsFromBaseType(self, string):
        """
        V.GetNumberOfGenerationsFromBaseType(string) -> int
        C++: static vtkIdType GetNumberOfGenerationsFromBaseType(
            const char *type)
        
        Given a the name of a base class of this class type, return the
        distance of inheritance between this class type and the named
        class (how many generations of inheritance are there between this
        class and the named class). If the named class is not in this
        class's inheritance tree, return a negative value. Valid
        responses will always be nonnegative. This method works in
        combination with vtkTypeMacro found in vtkSetGet.h.
        """
        ...
    
    def IsA(self, string):
        """
        V.IsA(string) -> int
        C++: vtkTypeBool IsA(const char *type) override;
        
        Return 1 if this class is the same type of (or a subclass of) the
        named class. Returns 0 otherwise. This method works in
        combination with vtkTypeMacro found in vtkSetGet.h.
        """
        ...
    
    def IsTypeOf(self, string):
        """
        V.IsTypeOf(string) -> int
        C++: static vtkTypeBool IsTypeOf(const char *type)
        
        Return 1 if this class type is the same type of (or a subclass
        of) the named class. Returns 0 otherwise. This method works in
        combination with vtkTypeMacro found in vtkSetGet.h.
        """
        ...
    
    def NewInstance(self):
        """
        V.NewInstance() -> vtkDiscreteMarchingCubes
        C++: vtkDiscreteMarchingCubes *NewInstance()
        """
        ...
    
    def SafeDownCast(self, vtkObjectBase):
        """
        V.SafeDownCast(vtkObjectBase) -> vtkDiscreteMarchingCubes
        C++: static vtkDiscreteMarchingCubes *SafeDownCast(
            vtkObjectBase *o)
        """
        ...
    
    def SetComputeAdjacentScalars(self, p_int):
        """
        V.SetComputeAdjacentScalars(int)
        C++: virtual void SetComputeAdjacentScalars(vtkTypeBool _arg)
        
        Set/Get the computation of neighbouring voxel values.
        """
        ...
    
    def __delattr__(self, *args, **kwargs):
        """ Implement delattr(self, name). """
        ...
    
    def __getattribute__(self, *args, **kwargs):
        """ Return getattr(self, name). """
        ...
    
    def __init__(self, *args, **kwargs) -> None:
        ...
    
    @staticmethod
    def __new__(*args, **kwargs):
        """ Create and return a new object.  See help(type) for accurate signature. """
        ...
    
    def __repr__(self, *args, **kwargs):
        """ Return repr(self). """
        ...
    
    def __setattr__(self, *args, **kwargs):
        """ Implement setattr(self, name, value). """
        ...
    
    def __str__(self, *args, **kwargs) -> str:
        """ Return str(self). """
        ...
    
    __this__ = ...
    __dict__ = ...
    __vtkname__ = ...


