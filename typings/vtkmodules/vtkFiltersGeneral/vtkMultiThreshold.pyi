"""
This type stub file was generated by pyright.
"""

import vtkmodules.vtkCommonExecutionModel as __vtkmodules_vtkCommonExecutionModel

class vtkMultiThreshold(__vtkmodules_vtkCommonExecutionModel.vtkMultiBlockDataSetAlgorithm):
    """
    vtkMultiThreshold - Threshold cells within multiple intervals
    
    Superclass: vtkMultiBlockDataSetAlgorithm
    
    This filter can be substituted for a chain of several vtkThreshold
    filters and can also perform more sophisticated subsetting
    operations. It generates a vtkMultiBlockDataSet as its output. This
    multiblock dataset contains a vtkUnstructuredGrid for each
    thresholded subset you request. A thresholded subset can be a set
    defined by an interval over a point or cell attribute of the mesh;
    these subsets are called IntervalSets. A thresholded subset can also
    be a boolean combination of one or more IntervalSets; these subsets
    are called BooleanSets. BooleanSets allow complex logic since their
    output can depend on multiple intervals over multiple variables
    defined on the input mesh. This is useful because it eliminates the
    need for thresholding several times and then appending the results,
    as can be required with vtkThreshold when one wants to remove some
    range of values (e.g., a notch filter). Cells are not repeated when
    they belong to more than one interval unless those intervals have
    different output grids.
    
    Another advantage this filter provides over vtkThreshold is the
    ability to threshold on non-scalar (i.e., vector, tensor, etc.)
    attributes without first computing an array containing some norm of
    the desired attribute. vtkMultiThreshold provides $L_1 $, $L_2 $, and
    $L_{\infty} $ norms.
    
    This filter makes a distinction between intermediate subsets and
    subsets that will be output to a grid. Each intermediate subset you
    create with AddIntervalSet or AddBooleanSet is given a unique integer
    identifier (via the return values of these member functions). If you
    wish for a given set to be output, you must call OutputSet and pass
    it one of these identifiers. The return of OutputSet is the integer
    index of the output set in the multiblock dataset created by this
    filter.
    
    For example, if an input mesh defined three attributes T, P, and s,
    one might wish to find cells that satisfy "T < 320 [K] && ( P > 101 [kPa] || s < 0.1 [kJ/kg/K]
    )". To accomplish this with a vtkMultiThreshold filter,
    
    vtkMultiThreshold* thr; int intervalSets[3];
    
    intervalSets[0] = thr->AddIntervalSet( vtkMath::NegInf(), 320.,
    vtkMultiThreshold::CLOSED, vtkMultiThreshold::OPEN,
    vtkDataObject::FIELD_ASSOCIATION_POINTS, "T", 0, 1 ); intervalSets[1]
    = thr->AddIntervalSet( 101., vtkMath::Inf(), vtkMultiThreshold::OPEN,
    vtkMultiThreshold::CLOSED,
        vtkDataObject::FIELD_ASSOCIATION_CELLS, "P", 0, 1 );
    intervalSets[2] = thr->AddIntervalSet( vtkMath::NegInf(), 0.1,
    vtkMultiThreshold::CLOSED, vtkMultiThreshold::OPEN,
    vtkDataObject::FIELD_ASSOCIATION_POINTS, "s", 0, 1 );
    
    int intermediate = thr->AddBooleanSet( vtkMultiThreshold::OR, 2,
    &intervalSets[1] );
    
    int intersection[2]; intersection[0] = intervalSets[0];
    intersection[1] = intermediate; int outputSet = thr->AddBooleanSet(
    vtkMultiThreshold::AND, 2, intersection );
    
    int outputGridIndex = thr->OutputSet( outputSet ); thr->Update(); 
    The result of this filter will be a multiblock dataset that contains
    a single child with the desired cells. If we had also called
    thr->OutputSet( intervalSets[0] );, there would be two child meshes
    and one would contain all cells with T < 320 [K]. In that case, the
    output can be represented by this graph
    
    \dot digraph MultiThreshold {
      set0 [shape=rect,style=filled,label="point T(0) in [-Inf,320["]
      set1 [shape=rect,label="cell P(0) in ]101,Inf]"]
      set2 [shape=rect,label="point s(0) in [-Inf,0.1["]
      set3 [shape=rect,label="OR"]
      set4 [shape=rect,style=filled,label="AND"]
      set0 -> set4
      set1 -> set3
      set2 -> set3
      set3 -> set4 }\enddot
    
    The filled rectangles represent sets that are output.
    """
    def AddBandpassIntervalSet(self, p_float, p_float_1, p_int, string, p_int_1, p_int_2):
        """
        V.AddBandpassIntervalSet(float, float, int, string, int, int)
            -> int
        C++: int AddBandpassIntervalSet(double xmin, double xmax,
            int assoc, const char *arrayName, int component,
            int allScalars)
        
        These convenience members make it easy to insert closed
        intervals. The "notch" interval is accomplished by creating a
        bandpass interval and applying a NAND operation. In this case,
        the set ID returned in the NAND operation set ID. Note that you
        can pass xmin == xmax when creating a bandpass threshold to
        retrieve elements matching exactly one value (since the intervals
        created by these routines are closed).
        """
        ...
    
    def AddBooleanSet(self, p_int, p_int_1, *int):
        """
        V.AddBooleanSet(int, int, [int, ...]) -> int
        C++: int AddBooleanSet(int operation, int numInputs, int *inputs)
        
        Create a new mesh subset using boolean operations on pre-existing
        sets.
        """
        ...
    
    def AddHighpassIntervalSet(self, p_float, p_int, string, p_int_1, p_int_2):
        """
        V.AddHighpassIntervalSet(float, int, string, int, int) -> int
        C++: int AddHighpassIntervalSet(double xmin, int assoc,
            const char *arrayName, int component, int allScalars)
        
        These convenience members make it easy to insert closed
        intervals. The "notch" interval is accomplished by creating a
        bandpass interval and applying a NAND operation. In this case,
        the set ID returned in the NAND operation set ID. Note that you
        can pass xmin == xmax when creating a bandpass threshold to
        retrieve elements matching exactly one value (since the intervals
        created by these routines are closed).
        """
        ...
    
    def AddIntervalSet(self, p_float, p_float_1, p_int, p_int_1, p_int_2, string, p_int_3, p_int_4):
        """
        V.AddIntervalSet(float, float, int, int, int, string, int, int)
            -> int
        C++: int AddIntervalSet(double xmin, double xmax, int omin,
            int omax, int assoc, const char *arrayName, int component,
            int allScalars)
        V.AddIntervalSet(float, float, int, int, int, int, int, int)
            -> int
        C++: int AddIntervalSet(double xmin, double xmax, int omin,
            int omax, int assoc, int attribType, int component,
            int allScalars)
        
        Add a mesh subset to be computed by thresholding an attribute of
        the input mesh. The subset can then be added to an output mesh
        with OutputSet() or combined with other sets using AddBooleanSet.
        * If you wish to include all cells with values below some number
          a, call
        * with xmin set to vtkMath::NegInf() and xmax set to a.
        * Similarly, if you wish to include all cells with values above
          some number a,
        * call with xmin set to a and xmax set to vtkMath::Inf().
        * When specifying Inf() or NegInf() for an endpoint, it does not
          matter whether
        * you specify and open or closed endpoint.
        
        * When creating intervals, any integers can be used for the IDs
          of output meshes.
        * All that matters is that the same ID be used if intervals
          should output to the same mesh.
        * The outputs are ordered with ascending IDs in output block 0.
        
        * It is possible to specify an invalid interval, in which case
          these routines will return -1.
        * Invalid intervals occur when
        * - an array does not exist,
        * - center is invalid,
        * - xmin == xmax and omin and/or omax are
          vtkMultiThreshold::OPEN, or
        * - xmin > xmax.
        * - xmin or xmax is not a number (i.e., IEEE NaN). Having both
          xmin and xmax equal NaN is allowed.
        * vtkMath provides a portable way to specify IEEE infinities and
          Nan.
        * Note that specifying an interval completely out of the bounds
          of an attribute is considered valid.
        * In fact, it is occasionally useful to create a closed interval
          with both endpoints set to$\infty $
        * or both endpoints set to $-\infty $ in order to locate cells
          wi ...
         [Truncated]
        """
        ...
    
    def AddLowpassIntervalSet(self, p_float, p_int, string, p_int_1, p_int_2):
        """
        V.AddLowpassIntervalSet(float, int, string, int, int) -> int
        C++: int AddLowpassIntervalSet(double xmax, int assoc,
            const char *arrayName, int component, int allScalars)
        
        These convenience members make it easy to insert closed
        intervals. The "notch" interval is accomplished by creating a
        bandpass interval and applying a NAND operation. In this case,
        the set ID returned in the NAND operation set ID. Note that you
        can pass xmin == xmax when creating a bandpass threshold to
        retrieve elements matching exactly one value (since the intervals
        created by these routines are closed).
        """
        ...
    
    def AddNotchIntervalSet(self, p_float, p_float_1, p_int, string, p_int_1, p_int_2):
        """
        V.AddNotchIntervalSet(float, float, int, string, int, int) -> int
        C++: int AddNotchIntervalSet(double xlo, double xhi, int assoc,
            const char *arrayName, int component, int allScalars)
        
        These convenience members make it easy to insert closed
        intervals. The "notch" interval is accomplished by creating a
        bandpass interval and applying a NAND operation. In this case,
        the set ID returned in the NAND operation set ID. Note that you
        can pass xmin == xmax when creating a bandpass threshold to
        retrieve elements matching exactly one value (since the intervals
        created by these routines are closed).
        """
        ...
    
    def GetNumberOfGenerationsFromBase(self, string):
        """
        V.GetNumberOfGenerationsFromBase(string) -> int
        C++: vtkIdType GetNumberOfGenerationsFromBase(const char *type)
            override;
        
        Given a the name of a base class of this class type, return the
        distance of inheritance between this class type and the named
        class (how many generations of inheritance are there between this
        class and the named class). If the named class is not in this
        class's inheritance tree, return a negative value. Valid
        responses will always be nonnegative. This method works in
        combination with vtkTypeMacro found in vtkSetGet.h.
        """
        ...
    
    def GetNumberOfGenerationsFromBaseType(self, string):
        """
        V.GetNumberOfGenerationsFromBaseType(string) -> int
        C++: static vtkIdType GetNumberOfGenerationsFromBaseType(
            const char *type)
        
        Given a the name of a base class of this class type, return the
        distance of inheritance between this class type and the named
        class (how many generations of inheritance are there between this
        class and the named class). If the named class is not in this
        class's inheritance tree, return a negative value. Valid
        responses will always be nonnegative. This method works in
        combination with vtkTypeMacro found in vtkSetGet.h.
        """
        ...
    
    def IsA(self, string):
        """
        V.IsA(string) -> int
        C++: vtkTypeBool IsA(const char *type) override;
        
        Return 1 if this class is the same type of (or a subclass of) the
        named class. Returns 0 otherwise. This method works in
        combination with vtkTypeMacro found in vtkSetGet.h.
        """
        ...
    
    def IsTypeOf(self, string):
        """
        V.IsTypeOf(string) -> int
        C++: static vtkTypeBool IsTypeOf(const char *type)
        
        Return 1 if this class type is the same type of (or a subclass
        of) the named class. Returns 0 otherwise. This method works in
        combination with vtkTypeMacro found in vtkSetGet.h.
        """
        ...
    
    def NewInstance(self):
        """
        V.NewInstance() -> vtkMultiThreshold
        C++: vtkMultiThreshold *NewInstance()
        """
        ...
    
    def OutputSet(self, p_int):
        """
        V.OutputSet(int) -> int
        C++: int OutputSet(int setId)
        
        Create an output mesh containing a boolean or interval subset of
        the input mesh.
        """
        ...
    
    def Reset(self):
        """
        V.Reset()
        C++: void Reset()
        
        Remove all the intervals currently defined.
        """
        ...
    
    def SafeDownCast(self, vtkObjectBase):
        """
        V.SafeDownCast(vtkObjectBase) -> vtkMultiThreshold
        C++: static vtkMultiThreshold *SafeDownCast(vtkObjectBase *o)
        """
        ...
    
    def __delattr__(self, *args, **kwargs):
        """ Implement delattr(self, name). """
        ...
    
    def __getattribute__(self, *args, **kwargs):
        """ Return getattr(self, name). """
        ...
    
    def __init__(self, *args, **kwargs) -> None:
        ...
    
    @staticmethod
    def __new__(*args, **kwargs):
        """ Create and return a new object.  See help(type) for accurate signature. """
        ...
    
    def __repr__(self, *args, **kwargs):
        """ Return repr(self). """
        ...
    
    def __setattr__(self, *args, **kwargs):
        """ Implement setattr(self, name, value). """
        ...
    
    def __str__(self, *args, **kwargs) -> str:
        """ Return str(self). """
        ...
    
    __this__ = ...
    AND = ...
    CLOSED = ...
    Closure = ...
    L1_NORM = ...
    L2_NORM = ...
    LINFINITY_NORM = ...
    NAND = ...
    Norm = ...
    OPEN = ...
    OR = ...
    SetOperation = ...
    WOR = ...
    XOR = ...
    __dict__ = ...
    __vtkname__ = ...


