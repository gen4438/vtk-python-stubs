"""
This type stub file was generated by pyright.
"""

import vtkmodules.vtkCommonExecutionModel as __vtkmodules_vtkCommonExecutionModel

class vtkIntersectionPolyDataFilter(__vtkmodules_vtkCommonExecutionModel.vtkPolyDataAlgorithm):
    """
    vtkIntersectionPolyDataFilter - vtkIntersectionPolyDataFilter
    computes the intersection between two vtkPolyData objects.
    
    Superclass: vtkPolyDataAlgorithm
    
    The first output is a set of lines that marks the intersection of the
    input vtkPolyData objects. This contains five different attached data
    arrays:
    
    SurfaceID: Point data array that contains information about the
    origin surface of each point
    
    Input0CellID: Cell data array that contains the original cell ID
    number on the first input mesh
    
    Input1CellID: Cell data array that contains the original cell ID
    number on the second input mesh
    
    NewCell0ID: Cell data array that contains information about which
    cells of the remeshed first input surface it touches (If split)
    
    NewCell1ID: Cell data array that contains information about which
    cells on the remeshed second input surface it touches (If split)
    
    The second and third outputs are the first and second input
    vtkPolyData, respectively. Optionally, the two output vtkPolyData can
    be split along the intersection lines by remeshing. Optionally, the
    surface can be cleaned and checked at the end of the remeshing. If
    the meshes are split, The output vtkPolyDatas contain three possible
    data arrays:
    
    IntersectionPoint: This is a boolean indicating whether or not the
    point is on the boundary of the two input objects
    
    BadTriangle: If the surface is cleaned and checked, this is a cell
    data array indicating whether or not the cell has edges with multiple
    neighbors A manifold surface will have 0 everywhere for this array!
    
    FreeEdge: If the surface is cleaned and checked, this is a cell data
    array indicating if the cell has any free edges. A watertight surface
    will have 0 everywhere for this array!
    
    @author Adam Updegrove updega2@gmail.com
    
    @warning This filter is not designed to perform 2D boolean
        operations,
    and in fact relies on the inputs having no co-planar, overlapping
    cells.
    """
    def CheckInputOff(self):
        """
        V.CheckInputOff()
        C++: virtual void CheckInputOff()
        
        If on, the normals of the input will be checked. Default: OFF
        """
        ...
    
    def CheckInputOn(self):
        """
        V.CheckInputOn()
        C++: virtual void CheckInputOn()
        
        If on, the normals of the input will be checked. Default: OFF
        """
        ...
    
    def CheckMeshOff(self):
        """
        V.CheckMeshOff()
        C++: virtual void CheckMeshOff()
        
        If on, the output remeshed surfaces will be checked for bad cells
        and free edges. Default: ON
        """
        ...
    
    def CheckMeshOn(self):
        """
        V.CheckMeshOn()
        C++: virtual void CheckMeshOn()
        
        If on, the output remeshed surfaces will be checked for bad cells
        and free edges. Default: ON
        """
        ...
    
    def CleanAndCheckInput(self, vtkPolyData, p_float):
        """
        V.CleanAndCheckInput(vtkPolyData, float)
        C++: static void CleanAndCheckInput(vtkPolyData *pd,
            double tolerance)
        
        Function to clean and check the inputs
        """
        ...
    
    def CleanAndCheckSurface(self, vtkPolyData, p_float=..., p_float=..., *args, **kwargs):
        """
        V.CleanAndCheckSurface(vtkPolyData, [float, float], float)
        C++: static void CleanAndCheckSurface(vtkPolyData *pd,
            double stats[2], double tolerance)
        
        Function to clean and check the output surfaces for bad triangles
        and free edges
        """
        ...
    
    def ComputeIntersectionPointArrayOff(self):
        """
        V.ComputeIntersectionPointArrayOff()
        C++: virtual void ComputeIntersectionPointArrayOff()
        
        If on, the output split surfaces will contain information about
        which points are on the intersection of the two inputs. Default:
        ON
        """
        ...
    
    def ComputeIntersectionPointArrayOn(self):
        """
        V.ComputeIntersectionPointArrayOn()
        C++: virtual void ComputeIntersectionPointArrayOn()
        
        If on, the output split surfaces will contain information about
        which points are on the intersection of the two inputs. Default:
        ON
        """
        ...
    
    def GetCheckInput(self):
        """
        V.GetCheckInput() -> int
        C++: virtual vtkTypeBool GetCheckInput()
        
        If on, the normals of the input will be checked. Default: OFF
        """
        ...
    
    def GetCheckMesh(self):
        """
        V.GetCheckMesh() -> int
        C++: virtual vtkTypeBool GetCheckMesh()
        
        If on, the output remeshed surfaces will be checked for bad cells
        and free edges. Default: ON
        """
        ...
    
    def GetComputeIntersectionPointArray(self):
        """
        V.GetComputeIntersectionPointArray() -> int
        C++: virtual vtkTypeBool GetComputeIntersectionPointArray()
        
        If on, the output split surfaces will contain information about
        which points are on the intersection of the two inputs. Default:
        ON
        """
        ...
    
    def GetNumberOfGenerationsFromBase(self, string):
        """
        V.GetNumberOfGenerationsFromBase(string) -> int
        C++: vtkIdType GetNumberOfGenerationsFromBase(const char *type)
            override;
        
        Given a the name of a base class of this class type, return the
        distance of inheritance between this class type and the named
        class (how many generations of inheritance are there between this
        class and the named class). If the named class is not in this
        class's inheritance tree, return a negative value. Valid
        responses will always be nonnegative. This method works in
        combination with vtkTypeMacro found in vtkSetGet.h.
        """
        ...
    
    def GetNumberOfGenerationsFromBaseType(self, string):
        """
        V.GetNumberOfGenerationsFromBaseType(string) -> int
        C++: static vtkIdType GetNumberOfGenerationsFromBaseType(
            const char *type)
        
        Given a the name of a base class of this class type, return the
        distance of inheritance between this class type and the named
        class (how many generations of inheritance are there between this
        class and the named class). If the named class is not in this
        class's inheritance tree, return a negative value. Valid
        responses will always be nonnegative. This method works in
        combination with vtkTypeMacro found in vtkSetGet.h.
        """
        ...
    
    def GetNumberOfIntersectionLines(self):
        """
        V.GetNumberOfIntersectionLines() -> int
        C++: virtual int GetNumberOfIntersectionLines()
        
        Integer describing the number of intersection points and lines
        """
        ...
    
    def GetNumberOfIntersectionPoints(self):
        """
        V.GetNumberOfIntersectionPoints() -> int
        C++: virtual int GetNumberOfIntersectionPoints()
        
        Integer describing the number of intersection points and lines
        """
        ...
    
    def GetRelativeSubtriangleArea(self):
        """
        V.GetRelativeSubtriangleArea() -> float
        C++: virtual double GetRelativeSubtriangleArea()
        
        When discretizing polygons, the minimum ratio of the smallest
        acceptable triangle area w.r.t. the area of the polygon
        """
        ...
    
    def GetSplitFirstOutput(self):
        """
        V.GetSplitFirstOutput() -> int
        C++: virtual vtkTypeBool GetSplitFirstOutput()
        
        If on, the second output will be the first input mesh split by
        the intersection with the second input mesh. Defaults to on.
        """
        ...
    
    def GetSplitSecondOutput(self):
        """
        V.GetSplitSecondOutput() -> int
        C++: virtual vtkTypeBool GetSplitSecondOutput()
        
        If on, the third output will be the second input mesh split by
        the intersection with the first input mesh. Defaults to on.
        """
        ...
    
    def GetStatus(self):
        """
        V.GetStatus() -> int
        C++: virtual int GetStatus()
        
        Check the status of the filter after update. If the status is
        zero, there was an error in the operation. If status is one,
        everything went smoothly
        """
        ...
    
    def GetTolerance(self):
        """
        V.GetTolerance() -> float
        C++: virtual double GetTolerance()
        
        The tolerance for geometric tests in the filter
        """
        ...
    
    def IsA(self, string):
        """
        V.IsA(string) -> int
        C++: vtkTypeBool IsA(const char *type) override;
        
        Return 1 if this class is the same type of (or a subclass of) the
        named class. Returns 0 otherwise. This method works in
        combination with vtkTypeMacro found in vtkSetGet.h.
        """
        ...
    
    def IsTypeOf(self, string):
        """
        V.IsTypeOf(string) -> int
        C++: static vtkTypeBool IsTypeOf(const char *type)
        
        Return 1 if this class type is the same type of (or a subclass
        of) the named class. Returns 0 otherwise. This method works in
        combination with vtkTypeMacro found in vtkSetGet.h.
        """
        ...
    
    def NewInstance(self):
        """
        V.NewInstance() -> vtkIntersectionPolyDataFilter
        C++: vtkIntersectionPolyDataFilter *NewInstance()
        """
        ...
    
    def SafeDownCast(self, vtkObjectBase):
        """
        V.SafeDownCast(vtkObjectBase) -> vtkIntersectionPolyDataFilter
        C++: static vtkIntersectionPolyDataFilter *SafeDownCast(
            vtkObjectBase *o)
        """
        ...
    
    def SetCheckInput(self, p_int):
        """
        V.SetCheckInput(int)
        C++: virtual void SetCheckInput(vtkTypeBool _arg)
        
        If on, the normals of the input will be checked. Default: OFF
        """
        ...
    
    def SetCheckMesh(self, p_int):
        """
        V.SetCheckMesh(int)
        C++: virtual void SetCheckMesh(vtkTypeBool _arg)
        
        If on, the output remeshed surfaces will be checked for bad cells
        and free edges. Default: ON
        """
        ...
    
    def SetComputeIntersectionPointArray(self, p_int):
        """
        V.SetComputeIntersectionPointArray(int)
        C++: virtual void SetComputeIntersectionPointArray(
            vtkTypeBool _arg)
        
        If on, the output split surfaces will contain information about
        which points are on the intersection of the two inputs. Default:
        ON
        """
        ...
    
    def SetRelativeSubtriangleArea(self, p_float):
        """
        V.SetRelativeSubtriangleArea(float)
        C++: virtual void SetRelativeSubtriangleArea(double _arg)
        
        When discretizing polygons, the minimum ratio of the smallest
        acceptable triangle area w.r.t. the area of the polygon
        """
        ...
    
    def SetSplitFirstOutput(self, p_int):
        """
        V.SetSplitFirstOutput(int)
        C++: virtual void SetSplitFirstOutput(vtkTypeBool _arg)
        
        If on, the second output will be the first input mesh split by
        the intersection with the second input mesh. Defaults to on.
        """
        ...
    
    def SetSplitSecondOutput(self, p_int):
        """
        V.SetSplitSecondOutput(int)
        C++: virtual void SetSplitSecondOutput(vtkTypeBool _arg)
        
        If on, the third output will be the second input mesh split by
        the intersection with the first input mesh. Defaults to on.
        """
        ...
    
    def SetTolerance(self, p_float):
        """
        V.SetTolerance(float)
        C++: virtual void SetTolerance(double _arg)
        
        The tolerance for geometric tests in the filter
        """
        ...
    
    def SplitFirstOutputOff(self):
        """
        V.SplitFirstOutputOff()
        C++: virtual void SplitFirstOutputOff()
        
        If on, the second output will be the first input mesh split by
        the intersection with the second input mesh. Defaults to on.
        """
        ...
    
    def SplitFirstOutputOn(self):
        """
        V.SplitFirstOutputOn()
        C++: virtual void SplitFirstOutputOn()
        
        If on, the second output will be the first input mesh split by
        the intersection with the second input mesh. Defaults to on.
        """
        ...
    
    def SplitSecondOutputOff(self):
        """
        V.SplitSecondOutputOff()
        C++: virtual void SplitSecondOutputOff()
        
        If on, the third output will be the second input mesh split by
        the intersection with the first input mesh. Defaults to on.
        """
        ...
    
    def SplitSecondOutputOn(self):
        """
        V.SplitSecondOutputOn()
        C++: virtual void SplitSecondOutputOn()
        
        If on, the third output will be the second input mesh split by
        the intersection with the first input mesh. Defaults to on.
        """
        ...
    
    def TriangleTriangleIntersection(self, p_float=..., p_float=..., p_float=..., *args, **kwargs):
        """
        V.TriangleTriangleIntersection([float, float, float], [float,
            float, float], [float, float, float], [float, float, float],
            [float, float, float], [float, float, float], int, [float,
            float, float], [float, float, float], [float, float], float)
            -> int
        C++: static int TriangleTriangleIntersection(double p1[3],
            double q1[3], double r1[3], double p2[3], double q2[3],
            double r2[3], int &coplanar, double pt1[3], double pt2[3],
            double surfaceid[2], double tolerance)
        
        Given two triangles defined by points (p1, q1, r1) and (p2, q2,
        r2), returns whether the two triangles intersect. If they do, the
        endpoints of the line forming the intersection are returned in
        pt1 and pt2. The parameter coplanar is set to 1 if the triangles
        are coplanar and 0 otherwise. The surfaceid array is filled with
        the surface on which the first and second intersection points
        resides, respectively. A geometric tolerance can be specified in
        the last argument.
        """
        ...
    
    def __delattr__(self, *args, **kwargs):
        """ Implement delattr(self, name). """
        ...
    
    def __getattribute__(self, *args, **kwargs):
        """ Return getattr(self, name). """
        ...
    
    def __init__(self, *args, **kwargs) -> None:
        ...
    
    @staticmethod
    def __new__(*args, **kwargs):
        """ Create and return a new object.  See help(type) for accurate signature. """
        ...
    
    def __repr__(self, *args, **kwargs):
        """ Return repr(self). """
        ...
    
    def __setattr__(self, *args, **kwargs):
        """ Implement setattr(self, name, value). """
        ...
    
    def __str__(self, *args, **kwargs) -> str:
        """ Return str(self). """
        ...
    
    __this__ = ...
    __dict__ = ...
    __vtkname__ = ...


