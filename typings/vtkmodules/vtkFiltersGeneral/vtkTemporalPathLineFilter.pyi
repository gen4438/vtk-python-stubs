"""
This type stub file was generated by pyright.
"""

import vtkmodules.vtkCommonExecutionModel as __vtkmodules_vtkCommonExecutionModel

class vtkTemporalPathLineFilter(__vtkmodules_vtkCommonExecutionModel.vtkPolyDataAlgorithm):
    """
    vtkTemporalPathLineFilter - Generate a Polydata Pointset from any
    Dataset.
    
    Superclass: vtkPolyDataAlgorithm
    
    vtkTemporalPathLineFilter takes any dataset as input, it extracts the
    point locations of all cells over time to build up a polyline trail.
    The point number (index) is used as the 'key' if the points are
    randomly changing their respective order in the points list, then you
    should specify a scalar that represents the unique ID. This is
    intended to handle the output of a filter such as the
    vtkParticleTracer.
    
    @sa
    vtkParticleTracer
    
    @par Thanks: John Bidiscombe of CSCS - Swiss National Supercomputing
    Centre for creating and contributing this class.
    """
    def Flush(self):
        """
        V.Flush()
        C++: void Flush()
        
        Flush will wipe any existing data so that traces can be restarted
        from whatever time step is next supplied.
        """
        ...
    
    def GetIdChannelArray(self):
        """
        V.GetIdChannelArray() -> string
        C++: virtual char *GetIdChannelArray()
        
        Specify the name of a scalar array which will be used to fetch
        the index of each point. This is necessary only if the particles
        change position (Id order) on each time step. The Id can be used
        to identify particles at each step and hence track them properly.
        If this array is nullptr, the global point ids are used.  If an
        Id array cannot otherwise be found, the point index is used as
        the ID.
        """
        ...
    
    def GetKeepDeadTrails(self):
        """
        V.GetKeepDeadTrails() -> int
        C++: virtual int GetKeepDeadTrails()
        
        When a particle 'disappears', the trail belonging to it is
        removed from the list. When this flag is enabled, dead trails
        will persist until the next time the list is cleared. Use
        carefully as it may cause excessive memory consumption if left on
        by mistake.
        """
        ...
    
    def GetMaskPoints(self):
        """
        V.GetMaskPoints() -> int
        C++: virtual int GetMaskPoints()
        
        Set the number of particles to track as a ratio of the input
        example: setting MaskPoints to 10 will track every 10th point
        """
        ...
    
    def GetMaxStepDistance(self):
        """
        V.GetMaxStepDistance() -> (float, float, float)
        C++: virtual double *GetMaxStepDistance()
        
        If a particle disappears from one end of a simulation and
        reappears on the other side, the track left will be
        unrepresentative. Set a MaxStepDistance{x,y,z} which acts as a
        threshold above which if a step occurs larger than the value (for
        the dimension), the track will be dropped and restarted after the
        step. (ie the part before the wrap around will be dropped and the
        newer part kept).
        """
        ...
    
    def GetMaxTrackLength(self):
        """
        V.GetMaxTrackLength() -> int
        C++: virtual unsigned int GetMaxTrackLength()
        
        If the Particles being traced animate for a long time, the trails
        or traces will become long and stringy. Setting the
        MaxTraceTimeLength will limit how much of the trace is displayed.
        Tracks longer then the Max will disappear and the trace will
        appear like a snake of fixed length which progresses as the
        particle moves
        """
        ...
    
    def GetNumberOfGenerationsFromBase(self, string):
        """
        V.GetNumberOfGenerationsFromBase(string) -> int
        C++: vtkIdType GetNumberOfGenerationsFromBase(const char *type)
            override;
        
        Standard Type-Macro
        """
        ...
    
    def GetNumberOfGenerationsFromBaseType(self, string):
        """
        V.GetNumberOfGenerationsFromBaseType(string) -> int
        C++: static vtkIdType GetNumberOfGenerationsFromBaseType(
            const char *type)
        
        Standard Type-Macro
        """
        ...
    
    def IsA(self, string):
        """
        V.IsA(string) -> int
        C++: vtkTypeBool IsA(const char *type) override;
        
        Standard Type-Macro
        """
        ...
    
    def IsTypeOf(self, string):
        """
        V.IsTypeOf(string) -> int
        C++: static vtkTypeBool IsTypeOf(const char *type)
        
        Standard Type-Macro
        """
        ...
    
    def NewInstance(self):
        """
        V.NewInstance() -> vtkTemporalPathLineFilter
        C++: vtkTemporalPathLineFilter *NewInstance()
        
        Standard Type-Macro
        """
        ...
    
    def SafeDownCast(self, vtkObjectBase):
        """
        V.SafeDownCast(vtkObjectBase) -> vtkTemporalPathLineFilter
        C++: static vtkTemporalPathLineFilter *SafeDownCast(
            vtkObjectBase *o)
        
        Standard Type-Macro
        """
        ...
    
    def SetIdChannelArray(self, string):
        """
        V.SetIdChannelArray(string)
        C++: virtual void SetIdChannelArray(const char *_arg)
        
        Specify the name of a scalar array which will be used to fetch
        the index of each point. This is necessary only if the particles
        change position (Id order) on each time step. The Id can be used
        to identify particles at each step and hence track them properly.
        If this array is nullptr, the global point ids are used.  If an
        Id array cannot otherwise be found, the point index is used as
        the ID.
        """
        ...
    
    def SetKeepDeadTrails(self, p_int):
        """
        V.SetKeepDeadTrails(int)
        C++: virtual void SetKeepDeadTrails(int _arg)
        
        When a particle 'disappears', the trail belonging to it is
        removed from the list. When this flag is enabled, dead trails
        will persist until the next time the list is cleared. Use
        carefully as it may cause excessive memory consumption if left on
        by mistake.
        """
        ...
    
    def SetMaskPoints(self, p_int):
        """
        V.SetMaskPoints(int)
        C++: virtual void SetMaskPoints(int _arg)
        
        Set the number of particles to track as a ratio of the input
        example: setting MaskPoints to 10 will track every 10th point
        """
        ...
    
    def SetMaxStepDistance(self, p_float, p_float_1, p_float_2):
        """
        V.SetMaxStepDistance(float, float, float)
        C++: virtual void SetMaxStepDistance(double _arg1, double _arg2,
            double _arg3)
        V.SetMaxStepDistance((float, float, float))
        C++: virtual void SetMaxStepDistance(const double _arg[3])
        
        If a particle disappears from one end of a simulation and
        reappears on the other side, the track left will be
        unrepresentative. Set a MaxStepDistance{x,y,z} which acts as a
        threshold above which if a step occurs larger than the value (for
        the dimension), the track will be dropped and restarted after the
        step. (ie the part before the wrap around will be dropped and the
        newer part kept).
        """
        ...
    
    def SetMaxTrackLength(self, p_int):
        """
        V.SetMaxTrackLength(int)
        C++: virtual void SetMaxTrackLength(unsigned int _arg)
        
        If the Particles being traced animate for a long time, the trails
        or traces will become long and stringy. Setting the
        MaxTraceTimeLength will limit how much of the trace is displayed.
        Tracks longer then the Max will disappear and the trace will
        appear like a snake of fixed length which progresses as the
        particle moves
        """
        ...
    
    def SetSelectionConnection(self, vtkAlgorithmOutput):
        """
        V.SetSelectionConnection(vtkAlgorithmOutput)
        C++: void SetSelectionConnection(vtkAlgorithmOutput *algOutput)
        
        Set a second input which is a selection. Particles with the same
        Id in the selection as the primary input will be chosen for
        pathlines Note that you must have the same IdChannelArray in the
        selection as the input
        """
        ...
    
    def SetSelectionData(self, vtkDataSet):
        """
        V.SetSelectionData(vtkDataSet)
        C++: void SetSelectionData(vtkDataSet *input)
        
        Set a second input which is a selection. Particles with the same
        Id in the selection as the primary input will be chosen for
        pathlines Note that you must have the same IdChannelArray in the
        selection as the input
        """
        ...
    
    def __delattr__(self, *args, **kwargs):
        """ Implement delattr(self, name). """
        ...
    
    def __getattribute__(self, *args, **kwargs):
        """ Return getattr(self, name). """
        ...
    
    def __init__(self, *args, **kwargs) -> None:
        ...
    
    @staticmethod
    def __new__(*args, **kwargs):
        """ Create and return a new object.  See help(type) for accurate signature. """
        ...
    
    def __repr__(self, *args, **kwargs):
        """ Return repr(self). """
        ...
    
    def __setattr__(self, *args, **kwargs):
        """ Implement setattr(self, name, value). """
        ...
    
    def __str__(self, *args, **kwargs) -> str:
        """ Return str(self). """
        ...
    
    __this__ = ...
    __dict__ = ...
    __vtkname__ = ...


