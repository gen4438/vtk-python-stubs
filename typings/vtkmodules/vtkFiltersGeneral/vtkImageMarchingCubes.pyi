"""
This type stub file was generated by pyright.
"""

import vtkmodules.vtkCommonExecutionModel as __vtkmodules_vtkCommonExecutionModel

class vtkImageMarchingCubes(__vtkmodules_vtkCommonExecutionModel.vtkPolyDataAlgorithm):
    """
    vtkImageMarchingCubes - generate isosurface(s) from volume/images
    
    Superclass: vtkPolyDataAlgorithm
    
    vtkImageMarchingCubes is a filter that takes as input images (e.g.,
    3D image region) and generates on output one or more isosurfaces. One
    or more contour values must be specified to generate the isosurfaces.
    Alternatively, you can specify a min/max scalar range and the number
    of contours to generate a series of evenly spaced contour values.
    This filter can stream, so that the entire volume need not be loaded
    at once.  Streaming is controlled using the instance variable
    InputMemoryLimit, which has units KBytes.
    
    @warning
    This filter is specialized to volumes. If you are interested in
    contouring other types of data, use the general vtkContourFilter. If
    you want to contour an image (i.e., a volume slice), use
    vtkMarchingSquares.
    @sa
    vtkContourFilter vtkSliceCubes vtkMarchingSquares
    vtkSynchronizedTemplates3D
    """
    def AddLocatorPoint(self, p_int, p_int_1, p_int_2, p_int_3):
        """
        V.AddLocatorPoint(int, int, int, int)
        C++: void AddLocatorPoint(int cellX, int cellY, int edge,
            vtkIdType ptId)
        """
        ...
    
    def ComputeGradientsOff(self):
        """
        V.ComputeGradientsOff()
        C++: virtual void ComputeGradientsOff()
        
        Set/Get the computation of gradients. Gradient computation is
        fairly expensive in both time and storage. Note that if
        ComputeNormals is on, gradients will have to be calculated, but
        will not be stored in the output dataset. If the output data will
        be processed by filters that modify topology or geometry, it may
        be wise to turn Normals and Gradients off.
        """
        ...
    
    def ComputeGradientsOn(self):
        """
        V.ComputeGradientsOn()
        C++: virtual void ComputeGradientsOn()
        
        Set/Get the computation of gradients. Gradient computation is
        fairly expensive in both time and storage. Note that if
        ComputeNormals is on, gradients will have to be calculated, but
        will not be stored in the output dataset. If the output data will
        be processed by filters that modify topology or geometry, it may
        be wise to turn Normals and Gradients off.
        """
        ...
    
    def ComputeNormalsOff(self):
        """
        V.ComputeNormalsOff()
        C++: virtual void ComputeNormalsOff()
        
        Set/Get the computation of normals. Normal computation is fairly
        expensive in both time and storage. If the output data will be
        processed by filters that modify topology or geometry, it may be
        wise to turn Normals and Gradients off.
        """
        ...
    
    def ComputeNormalsOn(self):
        """
        V.ComputeNormalsOn()
        C++: virtual void ComputeNormalsOn()
        
        Set/Get the computation of normals. Normal computation is fairly
        expensive in both time and storage. If the output data will be
        processed by filters that modify topology or geometry, it may be
        wise to turn Normals and Gradients off.
        """
        ...
    
    def ComputeScalarsOff(self):
        """
        V.ComputeScalarsOff()
        C++: virtual void ComputeScalarsOff()
        
        Set/Get the computation of scalars.
        """
        ...
    
    def ComputeScalarsOn(self):
        """
        V.ComputeScalarsOn()
        C++: virtual void ComputeScalarsOn()
        
        Set/Get the computation of scalars.
        """
        ...
    
    def GenerateValues(self, p_int, p_float=..., p_float=...):
        """
        V.GenerateValues(int, [float, float])
        C++: void GenerateValues(int numContours, double range[2])
        V.GenerateValues(int, float, float)
        C++: void GenerateValues(int numContours, double rangeStart,
            double rangeEnd)
        
        Methods to set contour values
        """
        ...
    
    def GetComputeGradients(self):
        """
        V.GetComputeGradients() -> int
        C++: virtual vtkTypeBool GetComputeGradients()
        
        Set/Get the computation of gradients. Gradient computation is
        fairly expensive in both time and storage. Note that if
        ComputeNormals is on, gradients will have to be calculated, but
        will not be stored in the output dataset. If the output data will
        be processed by filters that modify topology or geometry, it may
        be wise to turn Normals and Gradients off.
        """
        ...
    
    def GetComputeNormals(self):
        """
        V.GetComputeNormals() -> int
        C++: virtual vtkTypeBool GetComputeNormals()
        
        Set/Get the computation of normals. Normal computation is fairly
        expensive in both time and storage. If the output data will be
        processed by filters that modify topology or geometry, it may be
        wise to turn Normals and Gradients off.
        """
        ...
    
    def GetComputeScalars(self):
        """
        V.GetComputeScalars() -> int
        C++: virtual vtkTypeBool GetComputeScalars()
        
        Set/Get the computation of scalars.
        """
        ...
    
    def GetInputMemoryLimit(self):
        """
        V.GetInputMemoryLimit() -> int
        C++: virtual vtkIdType GetInputMemoryLimit()
        
        The InputMemoryLimit determines the chunk size (the number of
        slices requested at each iteration).  The units of this limit is
        KiloBytes. For now, only the Z axis is split.
        """
        ...
    
    def GetLocatorPoint(self, p_int, p_int_1, p_int_2):
        """
        V.GetLocatorPoint(int, int, int) -> int
        C++: vtkIdType GetLocatorPoint(int cellX, int cellY, int edge)
        """
        ...
    
    def GetMTime(self):
        """
        V.GetMTime() -> int
        C++: vtkMTimeType GetMTime() override;
        
        Because we delegate to vtkContourValues & refer to
        vtkImplicitFunction
        """
        ...
    
    def GetNumberOfContours(self):
        """
        V.GetNumberOfContours() -> int
        C++: vtkIdType GetNumberOfContours()
        
        Methods to set contour values
        """
        ...
    
    def GetNumberOfGenerationsFromBase(self, string):
        """
        V.GetNumberOfGenerationsFromBase(string) -> int
        C++: vtkIdType GetNumberOfGenerationsFromBase(const char *type)
            override;
        
        Given a the name of a base class of this class type, return the
        distance of inheritance between this class type and the named
        class (how many generations of inheritance are there between this
        class and the named class). If the named class is not in this
        class's inheritance tree, return a negative value. Valid
        responses will always be nonnegative. This method works in
        combination with vtkTypeMacro found in vtkSetGet.h.
        """
        ...
    
    def GetNumberOfGenerationsFromBaseType(self, string):
        """
        V.GetNumberOfGenerationsFromBaseType(string) -> int
        C++: static vtkIdType GetNumberOfGenerationsFromBaseType(
            const char *type)
        
        Given a the name of a base class of this class type, return the
        distance of inheritance between this class type and the named
        class (how many generations of inheritance are there between this
        class and the named class). If the named class is not in this
        class's inheritance tree, return a negative value. Valid
        responses will always be nonnegative. This method works in
        combination with vtkTypeMacro found in vtkSetGet.h.
        """
        ...
    
    def GetValue(self, p_int):
        """
        V.GetValue(int) -> float
        C++: double GetValue(int i)
        
        Methods to set contour values
        """
        ...
    
    def GetValues(self):
        """
        V.GetValues() -> (float, ...)
        C++: double *GetValues()
        V.GetValues([float, ...])
        C++: void GetValues(double *contourValues)
        
        Methods to set contour values
        """
        ...
    
    def IncrementLocatorZ(self):
        """
        V.IncrementLocatorZ()
        C++: void IncrementLocatorZ()
        """
        ...
    
    def IsA(self, string):
        """
        V.IsA(string) -> int
        C++: vtkTypeBool IsA(const char *type) override;
        
        Return 1 if this class is the same type of (or a subclass of) the
        named class. Returns 0 otherwise. This method works in
        combination with vtkTypeMacro found in vtkSetGet.h.
        """
        ...
    
    def IsTypeOf(self, string):
        """
        V.IsTypeOf(string) -> int
        C++: static vtkTypeBool IsTypeOf(const char *type)
        
        Return 1 if this class type is the same type of (or a subclass
        of) the named class. Returns 0 otherwise. This method works in
        combination with vtkTypeMacro found in vtkSetGet.h.
        """
        ...
    
    def NewInstance(self):
        """
        V.NewInstance() -> vtkImageMarchingCubes
        C++: vtkImageMarchingCubes *NewInstance()
        """
        ...
    
    def SafeDownCast(self, vtkObjectBase):
        """
        V.SafeDownCast(vtkObjectBase) -> vtkImageMarchingCubes
        C++: static vtkImageMarchingCubes *SafeDownCast(vtkObjectBase *o)
        """
        ...
    
    def SetComputeGradients(self, p_int):
        """
        V.SetComputeGradients(int)
        C++: virtual void SetComputeGradients(vtkTypeBool _arg)
        
        Set/Get the computation of gradients. Gradient computation is
        fairly expensive in both time and storage. Note that if
        ComputeNormals is on, gradients will have to be calculated, but
        will not be stored in the output dataset. If the output data will
        be processed by filters that modify topology or geometry, it may
        be wise to turn Normals and Gradients off.
        """
        ...
    
    def SetComputeNormals(self, p_int):
        """
        V.SetComputeNormals(int)
        C++: virtual void SetComputeNormals(vtkTypeBool _arg)
        
        Set/Get the computation of normals. Normal computation is fairly
        expensive in both time and storage. If the output data will be
        processed by filters that modify topology or geometry, it may be
        wise to turn Normals and Gradients off.
        """
        ...
    
    def SetComputeScalars(self, p_int):
        """
        V.SetComputeScalars(int)
        C++: virtual void SetComputeScalars(vtkTypeBool _arg)
        
        Set/Get the computation of scalars.
        """
        ...
    
    def SetInputMemoryLimit(self, p_int):
        """
        V.SetInputMemoryLimit(int)
        C++: virtual void SetInputMemoryLimit(vtkIdType _arg)
        
        The InputMemoryLimit determines the chunk size (the number of
        slices requested at each iteration).  The units of this limit is
        KiloBytes. For now, only the Z axis is split.
        """
        ...
    
    def SetNumberOfContours(self, p_int):
        """
        V.SetNumberOfContours(int)
        C++: void SetNumberOfContours(int number)
        
        Methods to set contour values
        """
        ...
    
    def SetValue(self, p_int, p_float):
        """
        V.SetValue(int, float)
        C++: void SetValue(int i, double value)
        
        Methods to set contour values
        """
        ...
    
    def __delattr__(self, *args, **kwargs):
        """ Implement delattr(self, name). """
        ...
    
    def __getattribute__(self, *args, **kwargs):
        """ Return getattr(self, name). """
        ...
    
    def __init__(self, *args, **kwargs) -> None:
        ...
    
    @staticmethod
    def __new__(*args, **kwargs):
        """ Create and return a new object.  See help(type) for accurate signature. """
        ...
    
    def __repr__(self, *args, **kwargs):
        """ Return repr(self). """
        ...
    
    def __setattr__(self, *args, **kwargs):
        """ Implement setattr(self, name, value). """
        ...
    
    def __str__(self, *args, **kwargs) -> str:
        """ Return str(self). """
        ...
    
    __this__ = ...
    __dict__ = ...
    __vtkname__ = ...


