"""
This type stub file was generated by pyright.
"""

import vtkmodules.vtkCommonExecutionModel as __vtkmodules_vtkCommonExecutionModel

class vtkGraphLayoutFilter(__vtkmodules_vtkCommonExecutionModel.vtkPolyDataAlgorithm):
    """
    vtkGraphLayoutFilter - nice layout of undirected graphs in 3D
    
    Superclass: vtkPolyDataAlgorithm
    
    vtkGraphLayoutFilter will reposition a network of nodes, connected by
    lines or polylines, into a more pleasing arrangement. The class
    implements a simple force-directed placement algorithm (Fruchterman &
    Reingold "Graph Drawing by Force-directed Placement"
    Software-Practice and Experience 21(11) 1991).
    
    The input to the filter is a vtkPolyData representing the undirected
    graphs. A graph is represented by a set of polylines and/or lines.
    The output is also a vtkPolyData, where the point positions have been
    modified. To use the filter, specify whether you wish the layout to
    occur in 2D or 3D; the bounds in which the graph should lie (note
    that you can just use automatic bounds computation); and modify the
    cool down rate (controls the final process of simulated annealing).
    """
    def AutomaticBoundsComputationOff(self):
        """
        V.AutomaticBoundsComputationOff()
        C++: virtual void AutomaticBoundsComputationOff()
        
        Turn on/off automatic graph bounds calculation. If this boolean
        is off, then the manually specified GraphBounds is used. If on,
        then the input's bounds us used as the graph bounds.
        """
        ...
    
    def AutomaticBoundsComputationOn(self):
        """
        V.AutomaticBoundsComputationOn()
        C++: virtual void AutomaticBoundsComputationOn()
        
        Turn on/off automatic graph bounds calculation. If this boolean
        is off, then the manually specified GraphBounds is used. If on,
        then the input's bounds us used as the graph bounds.
        """
        ...
    
    def GetAutomaticBoundsComputation(self):
        """
        V.GetAutomaticBoundsComputation() -> int
        C++: virtual vtkTypeBool GetAutomaticBoundsComputation()
        
        Turn on/off automatic graph bounds calculation. If this boolean
        is off, then the manually specified GraphBounds is used. If on,
        then the input's bounds us used as the graph bounds.
        """
        ...
    
    def GetCoolDownRate(self):
        """
        V.GetCoolDownRate() -> float
        C++: virtual double GetCoolDownRate()
        
        Set/Get the Cool-down rate. The higher this number is, the longer
        it will take to "cool-down", and thus, the more the graph will be
        modified.
        """
        ...
    
    def GetCoolDownRateMaxValue(self):
        """
        V.GetCoolDownRateMaxValue() -> float
        C++: virtual double GetCoolDownRateMaxValue()
        
        Set/Get the Cool-down rate. The higher this number is, the longer
        it will take to "cool-down", and thus, the more the graph will be
        modified.
        """
        ...
    
    def GetCoolDownRateMinValue(self):
        """
        V.GetCoolDownRateMinValue() -> float
        C++: virtual double GetCoolDownRateMinValue()
        
        Set/Get the Cool-down rate. The higher this number is, the longer
        it will take to "cool-down", and thus, the more the graph will be
        modified.
        """
        ...
    
    def GetGraphBounds(self):
        """
        V.GetGraphBounds() -> (float, float, float, float, float, float)
        C++: virtual double *GetGraphBounds()
        
        Set / get the region in space in which to place the final graph.
        The GraphBounds only affects the results if
        AutomaticBoundsComputation is off.
        """
        ...
    
    def GetMaxNumberOfIterations(self):
        """
        V.GetMaxNumberOfIterations() -> int
        C++: virtual int GetMaxNumberOfIterations()
        
        Set/Get the maximum number of iterations to be used. The higher
        this number, the more iterations through the algorithm is
        possible, and thus, the more the graph gets modified.
        """
        ...
    
    def GetMaxNumberOfIterationsMaxValue(self):
        """
        V.GetMaxNumberOfIterationsMaxValue() -> int
        C++: virtual int GetMaxNumberOfIterationsMaxValue()
        
        Set/Get the maximum number of iterations to be used. The higher
        this number, the more iterations through the algorithm is
        possible, and thus, the more the graph gets modified.
        """
        ...
    
    def GetMaxNumberOfIterationsMinValue(self):
        """
        V.GetMaxNumberOfIterationsMinValue() -> int
        C++: virtual int GetMaxNumberOfIterationsMinValue()
        
        Set/Get the maximum number of iterations to be used. The higher
        this number, the more iterations through the algorithm is
        possible, and thus, the more the graph gets modified.
        """
        ...
    
    def GetNumberOfGenerationsFromBase(self, string):
        """
        V.GetNumberOfGenerationsFromBase(string) -> int
        C++: vtkIdType GetNumberOfGenerationsFromBase(const char *type)
            override;
        
        Given a the name of a base class of this class type, return the
        distance of inheritance between this class type and the named
        class (how many generations of inheritance are there between this
        class and the named class). If the named class is not in this
        class's inheritance tree, return a negative value. Valid
        responses will always be nonnegative. This method works in
        combination with vtkTypeMacro found in vtkSetGet.h.
        """
        ...
    
    def GetNumberOfGenerationsFromBaseType(self, string):
        """
        V.GetNumberOfGenerationsFromBaseType(string) -> int
        C++: static vtkIdType GetNumberOfGenerationsFromBaseType(
            const char *type)
        
        Given a the name of a base class of this class type, return the
        distance of inheritance between this class type and the named
        class (how many generations of inheritance are there between this
        class and the named class). If the named class is not in this
        class's inheritance tree, return a negative value. Valid
        responses will always be nonnegative. This method works in
        combination with vtkTypeMacro found in vtkSetGet.h.
        """
        ...
    
    def GetThreeDimensionalLayout(self):
        """
        V.GetThreeDimensionalLayout() -> int
        C++: virtual vtkTypeBool GetThreeDimensionalLayout()
        """
        ...
    
    def IsA(self, string):
        """
        V.IsA(string) -> int
        C++: vtkTypeBool IsA(const char *type) override;
        
        Return 1 if this class is the same type of (or a subclass of) the
        named class. Returns 0 otherwise. This method works in
        combination with vtkTypeMacro found in vtkSetGet.h.
        """
        ...
    
    def IsTypeOf(self, string):
        """
        V.IsTypeOf(string) -> int
        C++: static vtkTypeBool IsTypeOf(const char *type)
        
        Return 1 if this class type is the same type of (or a subclass
        of) the named class. Returns 0 otherwise. This method works in
        combination with vtkTypeMacro found in vtkSetGet.h.
        """
        ...
    
    def NewInstance(self):
        """
        V.NewInstance() -> vtkGraphLayoutFilter
        C++: vtkGraphLayoutFilter *NewInstance()
        """
        ...
    
    def SafeDownCast(self, vtkObjectBase):
        """
        V.SafeDownCast(vtkObjectBase) -> vtkGraphLayoutFilter
        C++: static vtkGraphLayoutFilter *SafeDownCast(vtkObjectBase *o)
        """
        ...
    
    def SetAutomaticBoundsComputation(self, p_int):
        """
        V.SetAutomaticBoundsComputation(int)
        C++: virtual void SetAutomaticBoundsComputation(vtkTypeBool _arg)
        
        Turn on/off automatic graph bounds calculation. If this boolean
        is off, then the manually specified GraphBounds is used. If on,
        then the input's bounds us used as the graph bounds.
        """
        ...
    
    def SetCoolDownRate(self, p_float):
        """
        V.SetCoolDownRate(float)
        C++: virtual void SetCoolDownRate(double _arg)
        
        Set/Get the Cool-down rate. The higher this number is, the longer
        it will take to "cool-down", and thus, the more the graph will be
        modified.
        """
        ...
    
    def SetGraphBounds(self, p_float, p_float_1, p_float_2, p_float_3, p_float_4, p_float_5):
        """
        V.SetGraphBounds(float, float, float, float, float, float)
        C++: virtual void SetGraphBounds(double _arg1, double _arg2,
            double _arg3, double _arg4, double _arg5, double _arg6)
        V.SetGraphBounds((float, float, float, float, float, float))
        C++: virtual void SetGraphBounds(const double _arg[6])
        
        Set / get the region in space in which to place the final graph.
        The GraphBounds only affects the results if
        AutomaticBoundsComputation is off.
        """
        ...
    
    def SetMaxNumberOfIterations(self, p_int):
        """
        V.SetMaxNumberOfIterations(int)
        C++: virtual void SetMaxNumberOfIterations(int _arg)
        
        Set/Get the maximum number of iterations to be used. The higher
        this number, the more iterations through the algorithm is
        possible, and thus, the more the graph gets modified.
        """
        ...
    
    def SetThreeDimensionalLayout(self, p_int):
        """
        V.SetThreeDimensionalLayout(int)
        C++: virtual void SetThreeDimensionalLayout(vtkTypeBool _arg)
        """
        ...
    
    def ThreeDimensionalLayoutOff(self):
        """
        V.ThreeDimensionalLayoutOff()
        C++: virtual void ThreeDimensionalLayoutOff()
        """
        ...
    
    def ThreeDimensionalLayoutOn(self):
        """
        V.ThreeDimensionalLayoutOn()
        C++: virtual void ThreeDimensionalLayoutOn()
        """
        ...
    
    def __delattr__(self, *args, **kwargs):
        """ Implement delattr(self, name). """
        ...
    
    def __getattribute__(self, *args, **kwargs):
        """ Return getattr(self, name). """
        ...
    
    def __init__(self, *args, **kwargs) -> None:
        ...
    
    @staticmethod
    def __new__(*args, **kwargs):
        """ Create and return a new object.  See help(type) for accurate signature. """
        ...
    
    def __repr__(self, *args, **kwargs):
        """ Return repr(self). """
        ...
    
    def __setattr__(self, *args, **kwargs):
        """ Implement setattr(self, name, value). """
        ...
    
    def __str__(self, *args, **kwargs) -> str:
        """ Return str(self). """
        ...
    
    __this__ = ...
    __dict__ = ...
    __vtkname__ = ...


