"""
This type stub file was generated by pyright.
"""

import vtkmodules.vtkCommonExecutionModel as __vtkmodules_vtkCommonExecutionModel

VTK_COLOR_BY_SCALAR = ...
VTK_COLOR_BY_SCALE = ...
VTK_COLOR_BY_VECTOR = ...
VTK_DATA_SCALING_OFF = ...
VTK_INDEXING_BY_SCALAR = ...
VTK_INDEXING_BY_VECTOR = ...
VTK_INDEXING_OFF = ...
VTK_SCALE_BY_SCALAR = ...
VTK_SCALE_BY_VECTOR = ...
VTK_SCALE_BY_VECTORCOMPONENTS = ...
VTK_USE_NORMAL = ...
VTK_USE_VECTOR = ...
VTK_VECTOR_ROTATION_OFF = ...
class vtkGenericClip(__vtkmodules_vtkCommonExecutionModel.vtkUnstructuredGridAlgorithm):
    """
    vtkGenericClip - clip any dataset with an implicit function or scalar
    data
    
    Superclass: vtkUnstructuredGridAlgorithm
    
    vtkGenericClip is a filter that any type of dataset using either any
    subclass of vtkImplicitFunction, or the input scalar data. Clipping
    means that it actually "cuts" through the cells of the dataset,
    returning everything inside of the specified implicit function (or
    greater than the scalar value) including "pieces" of a cell. (Compare
    this with vtkExtractGeometry, which pulls out entire, uncut cells.)
    The output of this filter is an unstructured grid.
    
    To use this filter, you must decide if you will be clipping with an
    implicit function, or whether you will be using the input scalar
    data.  If you want to clip with an implicit function, you must:
    1) define an implicit function
    2) set it with the SetClipFunction method
    3) apply the GenerateClipScalarsOn method If a ClipFunction is not
       specified, or GenerateClipScalars is off (the default), then the
       input's scalar data will be used to clip the polydata.
    
    You can also specify a scalar value, which is used to decide what is
    inside and outside of the implicit function. You can also reverse the
    sense of what inside/outside is by setting the InsideOut instance
    variable. (The clipping algorithm proceeds by computing an implicit
    function value or using the input scalar data for each point in the
    dataset. This is compared to the scalar value to determine
    inside/outside.)
    
    This filter can be configured to compute a second output. The second
    output is the part of the cell that is clipped away. Set the
    GenerateClippedData boolean on if you wish to access this output
    data.
    
    This filter has been implemented to operate on generic datasets,
    rather than the typical vtkDataSet (and subclasses).
    vtkGenericDataSet is a more complex cousin of vtkDataSet, typically
    consisting of nonlinear, higher-order cells. To process this type of
    data, generic cells are automatically tessellated into linear cells
    prior to isocontouring.
    
    @sa
    vtkClipDataSet vtkClipPolyData vtkClipVolume vtkImplicitFunction
    vtkGenericDataSet
    """
    def CreateDefaultLocator(self):
        """
        V.CreateDefaultLocator()
        C++: void CreateDefaultLocator()
        
        Create default locator. Used to create one when none is
        specified. The locator is used to merge coincident points.
        """
        ...
    
    def GenerateClippedOutputOff(self):
        """
        V.GenerateClippedOutputOff()
        C++: virtual void GenerateClippedOutputOff()
        
        Control whether a second output is generated. The second output
        contains the polygonal data that's been clipped away.
        """
        ...
    
    def GenerateClippedOutputOn(self):
        """
        V.GenerateClippedOutputOn()
        C++: virtual void GenerateClippedOutputOn()
        
        Control whether a second output is generated. The second output
        contains the polygonal data that's been clipped away.
        """
        ...
    
    def GenerateClipScalarsOff(self):
        """
        V.GenerateClipScalarsOff()
        C++: virtual void GenerateClipScalarsOff()
        
        If this flag is enabled, then the output scalar values will be
        interpolated from the implicit function values, and not the input
        scalar data. If you enable this flag but do not provide an
        implicit function an error will be reported.
        """
        ...
    
    def GenerateClipScalarsOn(self):
        """
        V.GenerateClipScalarsOn()
        C++: virtual void GenerateClipScalarsOn()
        
        If this flag is enabled, then the output scalar values will be
        interpolated from the implicit function values, and not the input
        scalar data. If you enable this flag but do not provide an
        implicit function an error will be reported.
        """
        ...
    
    def GetClipFunction(self):
        """
        V.GetClipFunction() -> vtkImplicitFunction
        C++: virtual vtkImplicitFunction *GetClipFunction()
        
        Specify the implicit function with which to perform the clipping.
        If you do not define an implicit function, then the selected
        input scalar data will be used for clipping.
        """
        ...
    
    def GetClippedOutput(self):
        """
        V.GetClippedOutput() -> vtkUnstructuredGrid
        C++: vtkUnstructuredGrid *GetClippedOutput()
        
        Return the Clipped output.
        """
        ...
    
    def GetGenerateClippedOutput(self):
        """
        V.GetGenerateClippedOutput() -> int
        C++: virtual vtkTypeBool GetGenerateClippedOutput()
        
        Control whether a second output is generated. The second output
        contains the polygonal data that's been clipped away.
        """
        ...
    
    def GetGenerateClipScalars(self):
        """
        V.GetGenerateClipScalars() -> int
        C++: virtual vtkTypeBool GetGenerateClipScalars()
        
        If this flag is enabled, then the output scalar values will be
        interpolated from the implicit function values, and not the input
        scalar data. If you enable this flag but do not provide an
        implicit function an error will be reported.
        """
        ...
    
    def GetInputScalarsSelection(self):
        """
        V.GetInputScalarsSelection() -> string
        C++: virtual char *GetInputScalarsSelection()
        
        If you want to clip by an arbitrary array, then set its name
        here. By default this in nullptr and the filter will use the
        active scalar array.
        """
        ...
    
    def GetInsideOut(self):
        """
        V.GetInsideOut() -> int
        C++: virtual vtkTypeBool GetInsideOut()
        
        Set/Get the InsideOut flag. When off, a vertex is considered
        inside the implicit function if its value is greater than the
        Value ivar. When InsideOutside is turned on, a vertex is
        considered inside the implicit function if its implicit function
        value is less than or equal to the Value ivar.  InsideOut is off
        by default.
        """
        ...
    
    def GetLocator(self):
        """
        V.GetLocator() -> vtkIncrementalPointLocator
        C++: virtual vtkIncrementalPointLocator *GetLocator()
        
        Specify a spatial locator for merging points. By default, an
        instance of vtkMergePoints is used.
        """
        ...
    
    def GetMergeTolerance(self):
        """
        V.GetMergeTolerance() -> float
        C++: virtual double GetMergeTolerance()
        
        Set the tolerance for merging clip intersection points that are
        near the vertices of cells. This tolerance is used to prevent the
        generation of degenerate primitives. Note that only 3D cells
        actually use this instance variable.
        """
        ...
    
    def GetMergeToleranceMaxValue(self):
        """
        V.GetMergeToleranceMaxValue() -> float
        C++: virtual double GetMergeToleranceMaxValue()
        
        Set the tolerance for merging clip intersection points that are
        near the vertices of cells. This tolerance is used to prevent the
        generation of degenerate primitives. Note that only 3D cells
        actually use this instance variable.
        """
        ...
    
    def GetMergeToleranceMinValue(self):
        """
        V.GetMergeToleranceMinValue() -> float
        C++: virtual double GetMergeToleranceMinValue()
        
        Set the tolerance for merging clip intersection points that are
        near the vertices of cells. This tolerance is used to prevent the
        generation of degenerate primitives. Note that only 3D cells
        actually use this instance variable.
        """
        ...
    
    def GetMTime(self):
        """
        V.GetMTime() -> int
        C++: vtkMTimeType GetMTime() override;
        
        Return the mtime also considering the locator and clip function.
        """
        ...
    
    def GetNumberOfGenerationsFromBase(self, string):
        """
        V.GetNumberOfGenerationsFromBase(string) -> int
        C++: vtkIdType GetNumberOfGenerationsFromBase(const char *type)
            override;
        
        Given a the name of a base class of this class type, return the
        distance of inheritance between this class type and the named
        class (how many generations of inheritance are there between this
        class and the named class). If the named class is not in this
        class's inheritance tree, return a negative value. Valid
        responses will always be nonnegative. This method works in
        combination with vtkTypeMacro found in vtkSetGet.h.
        """
        ...
    
    def GetNumberOfGenerationsFromBaseType(self, string):
        """
        V.GetNumberOfGenerationsFromBaseType(string) -> int
        C++: static vtkIdType GetNumberOfGenerationsFromBaseType(
            const char *type)
        
        Given a the name of a base class of this class type, return the
        distance of inheritance between this class type and the named
        class (how many generations of inheritance are there between this
        class and the named class). If the named class is not in this
        class's inheritance tree, return a negative value. Valid
        responses will always be nonnegative. This method works in
        combination with vtkTypeMacro found in vtkSetGet.h.
        """
        ...
    
    def GetNumberOfOutputs(self):
        """
        V.GetNumberOfOutputs() -> int
        C++: virtual int GetNumberOfOutputs()
        
        Return the Clipped output.
        """
        ...
    
    def GetValue(self):
        """
        V.GetValue() -> float
        C++: virtual double GetValue()
        
        Set the clipping value of the implicit function (if clipping with
        implicit function) or scalar value (if clipping with scalars).
        The default value is 0.0.
        """
        ...
    
    def InsideOutOff(self):
        """
        V.InsideOutOff()
        C++: virtual void InsideOutOff()
        
        Set/Get the InsideOut flag. When off, a vertex is considered
        inside the implicit function if its value is greater than the
        Value ivar. When InsideOutside is turned on, a vertex is
        considered inside the implicit function if its implicit function
        value is less than or equal to the Value ivar.  InsideOut is off
        by default.
        """
        ...
    
    def InsideOutOn(self):
        """
        V.InsideOutOn()
        C++: virtual void InsideOutOn()
        
        Set/Get the InsideOut flag. When off, a vertex is considered
        inside the implicit function if its value is greater than the
        Value ivar. When InsideOutside is turned on, a vertex is
        considered inside the implicit function if its implicit function
        value is less than or equal to the Value ivar.  InsideOut is off
        by default.
        """
        ...
    
    def IsA(self, string):
        """
        V.IsA(string) -> int
        C++: vtkTypeBool IsA(const char *type) override;
        
        Return 1 if this class is the same type of (or a subclass of) the
        named class. Returns 0 otherwise. This method works in
        combination with vtkTypeMacro found in vtkSetGet.h.
        """
        ...
    
    def IsTypeOf(self, string):
        """
        V.IsTypeOf(string) -> int
        C++: static vtkTypeBool IsTypeOf(const char *type)
        
        Return 1 if this class type is the same type of (or a subclass
        of) the named class. Returns 0 otherwise. This method works in
        combination with vtkTypeMacro found in vtkSetGet.h.
        """
        ...
    
    def NewInstance(self):
        """
        V.NewInstance() -> vtkGenericClip
        C++: vtkGenericClip *NewInstance()
        """
        ...
    
    def SafeDownCast(self, vtkObjectBase):
        """
        V.SafeDownCast(vtkObjectBase) -> vtkGenericClip
        C++: static vtkGenericClip *SafeDownCast(vtkObjectBase *o)
        """
        ...
    
    def SelectInputScalars(self, string):
        """
        V.SelectInputScalars(string)
        C++: void SelectInputScalars(const char *fieldName)
        
        If you want to clip by an arbitrary array, then set its name
        here. By default this in nullptr and the filter will use the
        active scalar array.
        """
        ...
    
    def SetClipFunction(self, vtkImplicitFunction):
        """
        V.SetClipFunction(vtkImplicitFunction)
        C++: virtual void SetClipFunction(vtkImplicitFunction *)
        
        Specify the implicit function with which to perform the clipping.
        If you do not define an implicit function, then the selected
        input scalar data will be used for clipping.
        """
        ...
    
    def SetGenerateClippedOutput(self, p_int):
        """
        V.SetGenerateClippedOutput(int)
        C++: virtual void SetGenerateClippedOutput(vtkTypeBool _arg)
        
        Control whether a second output is generated. The second output
        contains the polygonal data that's been clipped away.
        """
        ...
    
    def SetGenerateClipScalars(self, p_int):
        """
        V.SetGenerateClipScalars(int)
        C++: virtual void SetGenerateClipScalars(vtkTypeBool _arg)
        
        If this flag is enabled, then the output scalar values will be
        interpolated from the implicit function values, and not the input
        scalar data. If you enable this flag but do not provide an
        implicit function an error will be reported.
        """
        ...
    
    def SetInsideOut(self, p_int):
        """
        V.SetInsideOut(int)
        C++: virtual void SetInsideOut(vtkTypeBool _arg)
        
        Set/Get the InsideOut flag. When off, a vertex is considered
        inside the implicit function if its value is greater than the
        Value ivar. When InsideOutside is turned on, a vertex is
        considered inside the implicit function if its implicit function
        value is less than or equal to the Value ivar.  InsideOut is off
        by default.
        """
        ...
    
    def SetLocator(self, vtkIncrementalPointLocator):
        """
        V.SetLocator(vtkIncrementalPointLocator)
        C++: void SetLocator(vtkIncrementalPointLocator *locator)
        
        Specify a spatial locator for merging points. By default, an
        instance of vtkMergePoints is used.
        """
        ...
    
    def SetMergeTolerance(self, p_float):
        """
        V.SetMergeTolerance(float)
        C++: virtual void SetMergeTolerance(double _arg)
        
        Set the tolerance for merging clip intersection points that are
        near the vertices of cells. This tolerance is used to prevent the
        generation of degenerate primitives. Note that only 3D cells
        actually use this instance variable.
        """
        ...
    
    def SetValue(self, p_float):
        """
        V.SetValue(float)
        C++: virtual void SetValue(double _arg)
        
        Set the clipping value of the implicit function (if clipping with
        implicit function) or scalar value (if clipping with scalars).
        The default value is 0.0.
        """
        ...
    
    def __delattr__(self, *args, **kwargs):
        """ Implement delattr(self, name). """
        ...
    
    def __getattribute__(self, *args, **kwargs):
        """ Return getattr(self, name). """
        ...
    
    def __init__(self, *args, **kwargs) -> None:
        ...
    
    @staticmethod
    def __new__(*args, **kwargs):
        """ Create and return a new object.  See help(type) for accurate signature. """
        ...
    
    def __repr__(self, *args, **kwargs):
        """ Return repr(self). """
        ...
    
    def __setattr__(self, *args, **kwargs):
        """ Implement setattr(self, name, value). """
        ...
    
    def __str__(self, *args, **kwargs) -> str:
        """ Return str(self). """
        ...
    
    __this__ = ...
    __dict__ = ...
    __vtkname__ = ...


class vtkGenericContourFilter(__vtkmodules_vtkCommonExecutionModel.vtkPolyDataAlgorithm):
    """
    vtkGenericContourFilter - generate isocontours from input dataset
    
    Superclass: vtkPolyDataAlgorithm
    
    vtkGenericContourFilter is a filter that takes as input any (generic)
    dataset and generates on output isosurfaces and/or isolines. The
    exact form of the output depends upon the dimensionality of the input
    data. Data consisting of 3D cells will generate isosurfaces, data
    consisting of 2D cells will generate isolines, and data with 1D or 0D
    cells will generate isopoints. Combinations of output type are
    possible if the input dimension is mixed.
    
    To use this filter you must specify one or more contour values. You
    can either use the method SetValue() to specify each contour value,
    or use GenerateValues() to generate a series of evenly spaced
    contours. You can use ComputeNormalsOn to compute the normals without
    the need of a vtkPolyDataNormals
    
    This filter has been implemented to operate on generic datasets,
    rather than the typical vtkDataSet (and subclasses).
    vtkGenericDataSet is a more complex cousin of vtkDataSet, typically
    consisting of nonlinear, higher-order cells. To process this type of
    data, generic cells are automatically tessellated into linear cells
    prior to isocontouring.
    
    @sa
    vtkContourFilter vtkGenericDataSet
    """
    def ComputeGradientsOff(self):
        """
        V.ComputeGradientsOff()
        C++: virtual void ComputeGradientsOff()
        
        Set/Get the computation of gradients. Gradient computation is
        fairly expensive in both time and storage. Note that if
        ComputeNormals is on, gradients will have to be calculated, but
        will not be stored in the output dataset.  If the output data
        will be processed by filters that modify topology or geometry, it
        may be wise to turn Normals and Gradients off.
        """
        ...
    
    def ComputeGradientsOn(self):
        """
        V.ComputeGradientsOn()
        C++: virtual void ComputeGradientsOn()
        
        Set/Get the computation of gradients. Gradient computation is
        fairly expensive in both time and storage. Note that if
        ComputeNormals is on, gradients will have to be calculated, but
        will not be stored in the output dataset.  If the output data
        will be processed by filters that modify topology or geometry, it
        may be wise to turn Normals and Gradients off.
        """
        ...
    
    def ComputeNormalsOff(self):
        """
        V.ComputeNormalsOff()
        C++: virtual void ComputeNormalsOff()
        
        Set/Get the computation of normals. Normal computation is fairly
        expensive in both time and storage. If the output data will be
        processed by filters that modify topology or geometry, it may be
        wise to turn Normals and Gradients off.
        """
        ...
    
    def ComputeNormalsOn(self):
        """
        V.ComputeNormalsOn()
        C++: virtual void ComputeNormalsOn()
        
        Set/Get the computation of normals. Normal computation is fairly
        expensive in both time and storage. If the output data will be
        processed by filters that modify topology or geometry, it may be
        wise to turn Normals and Gradients off.
        """
        ...
    
    def ComputeScalarsOff(self):
        """
        V.ComputeScalarsOff()
        C++: virtual void ComputeScalarsOff()
        
        Set/Get the computation of scalars.
        """
        ...
    
    def ComputeScalarsOn(self):
        """
        V.ComputeScalarsOn()
        C++: virtual void ComputeScalarsOn()
        
        Set/Get the computation of scalars.
        """
        ...
    
    def CreateDefaultLocator(self):
        """
        V.CreateDefaultLocator()
        C++: void CreateDefaultLocator()
        
        Create default locator. Used to create one when none is
        specified. The locator is used to merge coincident points.
        """
        ...
    
    def GenerateValues(self, p_int, p_float=..., p_float=...):
        """
        V.GenerateValues(int, [float, float])
        C++: void GenerateValues(int numContours, double range[2])
        V.GenerateValues(int, float, float)
        C++: void GenerateValues(int numContours, double rangeStart,
            double rangeEnd)
        
        Methods to set / get contour values.
        """
        ...
    
    def GetComputeGradients(self):
        """
        V.GetComputeGradients() -> int
        C++: virtual vtkTypeBool GetComputeGradients()
        
        Set/Get the computation of gradients. Gradient computation is
        fairly expensive in both time and storage. Note that if
        ComputeNormals is on, gradients will have to be calculated, but
        will not be stored in the output dataset.  If the output data
        will be processed by filters that modify topology or geometry, it
        may be wise to turn Normals and Gradients off.
        """
        ...
    
    def GetComputeNormals(self):
        """
        V.GetComputeNormals() -> int
        C++: virtual vtkTypeBool GetComputeNormals()
        
        Set/Get the computation of normals. Normal computation is fairly
        expensive in both time and storage. If the output data will be
        processed by filters that modify topology or geometry, it may be
        wise to turn Normals and Gradients off.
        """
        ...
    
    def GetComputeScalars(self):
        """
        V.GetComputeScalars() -> int
        C++: virtual vtkTypeBool GetComputeScalars()
        
        Set/Get the computation of scalars.
        """
        ...
    
    def GetInputScalarsSelection(self):
        """
        V.GetInputScalarsSelection() -> string
        C++: virtual char *GetInputScalarsSelection()
        
        If you want to contour by an arbitrary scalar attribute, then set
        its name here. By default this in nullptr and the filter will use
        the active scalar array.
        """
        ...
    
    def GetLocator(self):
        """
        V.GetLocator() -> vtkIncrementalPointLocator
        C++: virtual vtkIncrementalPointLocator *GetLocator()
        
        Set / get a spatial locator for merging points. By default, an
        instance of vtkMergePoints is used.
        """
        ...
    
    def GetMTime(self):
        """
        V.GetMTime() -> int
        C++: vtkMTimeType GetMTime() override;
        
        Modified GetMTime Because we delegate to vtkContourValues
        """
        ...
    
    def GetNumberOfContours(self):
        """
        V.GetNumberOfContours() -> int
        C++: vtkIdType GetNumberOfContours()
        
        Methods to set / get contour values.
        """
        ...
    
    def GetNumberOfGenerationsFromBase(self, string):
        """
        V.GetNumberOfGenerationsFromBase(string) -> int
        C++: vtkIdType GetNumberOfGenerationsFromBase(const char *type)
            override;
        
        Given a the name of a base class of this class type, return the
        distance of inheritance between this class type and the named
        class (how many generations of inheritance are there between this
        class and the named class). If the named class is not in this
        class's inheritance tree, return a negative value. Valid
        responses will always be nonnegative. This method works in
        combination with vtkTypeMacro found in vtkSetGet.h.
        """
        ...
    
    def GetNumberOfGenerationsFromBaseType(self, string):
        """
        V.GetNumberOfGenerationsFromBaseType(string) -> int
        C++: static vtkIdType GetNumberOfGenerationsFromBaseType(
            const char *type)
        
        Given a the name of a base class of this class type, return the
        distance of inheritance between this class type and the named
        class (how many generations of inheritance are there between this
        class and the named class). If the named class is not in this
        class's inheritance tree, return a negative value. Valid
        responses will always be nonnegative. This method works in
        combination with vtkTypeMacro found in vtkSetGet.h.
        """
        ...
    
    def GetValue(self, p_int):
        """
        V.GetValue(int) -> float
        C++: double GetValue(int i)
        
        Methods to set / get contour values.
        """
        ...
    
    def GetValues(self):
        """
        V.GetValues() -> (float, ...)
        C++: double *GetValues()
        V.GetValues([float, ...])
        C++: void GetValues(double *contourValues)
        
        Methods to set / get contour values.
        """
        ...
    
    def IsA(self, string):
        """
        V.IsA(string) -> int
        C++: vtkTypeBool IsA(const char *type) override;
        
        Return 1 if this class is the same type of (or a subclass of) the
        named class. Returns 0 otherwise. This method works in
        combination with vtkTypeMacro found in vtkSetGet.h.
        """
        ...
    
    def IsTypeOf(self, string):
        """
        V.IsTypeOf(string) -> int
        C++: static vtkTypeBool IsTypeOf(const char *type)
        
        Return 1 if this class type is the same type of (or a subclass
        of) the named class. Returns 0 otherwise. This method works in
        combination with vtkTypeMacro found in vtkSetGet.h.
        """
        ...
    
    def NewInstance(self):
        """
        V.NewInstance() -> vtkGenericContourFilter
        C++: vtkGenericContourFilter *NewInstance()
        """
        ...
    
    def SafeDownCast(self, vtkObjectBase):
        """
        V.SafeDownCast(vtkObjectBase) -> vtkGenericContourFilter
        C++: static vtkGenericContourFilter *SafeDownCast(
            vtkObjectBase *o)
        """
        ...
    
    def SelectInputScalars(self, string):
        """
        V.SelectInputScalars(string)
        C++: virtual void SelectInputScalars(const char *fieldName)
        
        If you want to contour by an arbitrary scalar attribute, then set
        its name here. By default this in nullptr and the filter will use
        the active scalar array.
        """
        ...
    
    def SetComputeGradients(self, p_int):
        """
        V.SetComputeGradients(int)
        C++: virtual void SetComputeGradients(vtkTypeBool _arg)
        
        Set/Get the computation of gradients. Gradient computation is
        fairly expensive in both time and storage. Note that if
        ComputeNormals is on, gradients will have to be calculated, but
        will not be stored in the output dataset.  If the output data
        will be processed by filters that modify topology or geometry, it
        may be wise to turn Normals and Gradients off.
        """
        ...
    
    def SetComputeNormals(self, p_int):
        """
        V.SetComputeNormals(int)
        C++: virtual void SetComputeNormals(vtkTypeBool _arg)
        
        Set/Get the computation of normals. Normal computation is fairly
        expensive in both time and storage. If the output data will be
        processed by filters that modify topology or geometry, it may be
        wise to turn Normals and Gradients off.
        """
        ...
    
    def SetComputeScalars(self, p_int):
        """
        V.SetComputeScalars(int)
        C++: virtual void SetComputeScalars(vtkTypeBool _arg)
        
        Set/Get the computation of scalars.
        """
        ...
    
    def SetLocator(self, vtkIncrementalPointLocator):
        """
        V.SetLocator(vtkIncrementalPointLocator)
        C++: void SetLocator(vtkIncrementalPointLocator *locator)
        
        Set / get a spatial locator for merging points. By default, an
        instance of vtkMergePoints is used.
        """
        ...
    
    def SetNumberOfContours(self, p_int):
        """
        V.SetNumberOfContours(int)
        C++: void SetNumberOfContours(int number)
        
        Methods to set / get contour values.
        """
        ...
    
    def SetValue(self, p_int, p_float):
        """
        V.SetValue(int, float)
        C++: void SetValue(int i, float value)
        
        Methods to set / get contour values.
        """
        ...
    
    def __delattr__(self, *args, **kwargs):
        """ Implement delattr(self, name). """
        ...
    
    def __getattribute__(self, *args, **kwargs):
        """ Return getattr(self, name). """
        ...
    
    def __init__(self, *args, **kwargs) -> None:
        ...
    
    @staticmethod
    def __new__(*args, **kwargs):
        """ Create and return a new object.  See help(type) for accurate signature. """
        ...
    
    def __repr__(self, *args, **kwargs):
        """ Return repr(self). """
        ...
    
    def __setattr__(self, *args, **kwargs):
        """ Implement setattr(self, name, value). """
        ...
    
    def __str__(self, *args, **kwargs) -> str:
        """ Return str(self). """
        ...
    
    __this__ = ...
    __dict__ = ...
    __vtkname__ = ...


class vtkGenericCutter(__vtkmodules_vtkCommonExecutionModel.vtkPolyDataAlgorithm):
    """
    vtkGenericCutter - cut a vtkGenericDataSet with an implicit function
    or scalar data
    
    Superclass: vtkPolyDataAlgorithm
    
    vtkGenericCutter is a filter to cut through data using any subclass
    of vtkImplicitFunction. That is, a polygonal surface is created
    corresponding to the implicit function F(x,y,z) = value(s), where you
    can specify one or more values used to cut with.
    
    In VTK, cutting means reducing a cell of dimension N to a cut surface
    of dimension N-1. For example, a tetrahedron when cut by a plane
    (i.e., vtkPlane implicit function) will generate triangles. (In
    comparison, clipping takes a N dimensional cell and creates N
    dimension primitives.)
    
    vtkGenericCutter is generally used to "slice-through" a dataset,
    generating a surface that can be visualized. It is also possible to
    use vtkGenericCutter to do a form of volume rendering.
    vtkGenericCutter does this by generating multiple cut surfaces
    (usually planes) which are ordered (and rendered) from back-to-front.
    The surfaces are set translucent to give a volumetric rendering
    effect.
    
    This filter has been implemented to operate on generic datasets,
    rather than the typical vtkDataSet (and subclasses).
    vtkGenericDataSet is a more complex cousin of vtkDataSet, typically
    consisting of nonlinear, higher-order cells. To process this type of
    data, generic cells are automatically tessellated into linear cells
    prior to isocontouring.
    
    @sa
    vtkCutter vtkImplicitFunction vtkClipPolyData vtkGenericDataSet
    """
    def CreateDefaultLocator(self):
        """
        V.CreateDefaultLocator()
        C++: void CreateDefaultLocator()
        
        Create default locator. Used to create one when none is
        specified. The locator is used to merge coincident points.
        """
        ...
    
    def GenerateCutScalarsOff(self):
        """
        V.GenerateCutScalarsOff()
        C++: virtual void GenerateCutScalarsOff()
        
        If this flag is enabled, then the output scalar values will be
        interpolated from the implicit function values, and not the input
        scalar data.
        """
        ...
    
    def GenerateCutScalarsOn(self):
        """
        V.GenerateCutScalarsOn()
        C++: virtual void GenerateCutScalarsOn()
        
        If this flag is enabled, then the output scalar values will be
        interpolated from the implicit function values, and not the input
        scalar data.
        """
        ...
    
    def GenerateValues(self, p_int, p_float=..., p_float=...):
        """
        V.GenerateValues(int, [float, float])
        C++: void GenerateValues(int numContours, double range[2])
        V.GenerateValues(int, float, float)
        C++: void GenerateValues(int numContours, double rangeStart,
            double rangeEnd)
        
        Generate numContours equally spaced contour values between
        specified range. Contour values will include min/max range
        values.
        """
        ...
    
    def GetCutFunction(self):
        """
        V.GetCutFunction() -> vtkImplicitFunction
        C++: virtual vtkImplicitFunction *GetCutFunction()
        
        Specify the implicit function to perform the cutting.
        """
        ...
    
    def GetGenerateCutScalars(self):
        """
        V.GetGenerateCutScalars() -> int
        C++: virtual vtkTypeBool GetGenerateCutScalars()
        
        If this flag is enabled, then the output scalar values will be
        interpolated from the implicit function values, and not the input
        scalar data.
        """
        ...
    
    def GetLocator(self):
        """
        V.GetLocator() -> vtkIncrementalPointLocator
        C++: virtual vtkIncrementalPointLocator *GetLocator()
        
        Specify a spatial locator for merging points. By default, an
        instance of vtkMergePoints is used.
        """
        ...
    
    def GetMTime(self):
        """
        V.GetMTime() -> int
        C++: vtkMTimeType GetMTime() override;
        
        Override GetMTime because we delegate to vtkContourValues and
        refer to vtkImplicitFunction.
        """
        ...
    
    def GetNumberOfContours(self):
        """
        V.GetNumberOfContours() -> int
        C++: vtkIdType GetNumberOfContours()
        
        Get the number of contours in the list of contour values.
        """
        ...
    
    def GetNumberOfGenerationsFromBase(self, string):
        """
        V.GetNumberOfGenerationsFromBase(string) -> int
        C++: vtkIdType GetNumberOfGenerationsFromBase(const char *type)
            override;
        
        Given a the name of a base class of this class type, return the
        distance of inheritance between this class type and the named
        class (how many generations of inheritance are there between this
        class and the named class). If the named class is not in this
        class's inheritance tree, return a negative value. Valid
        responses will always be nonnegative. This method works in
        combination with vtkTypeMacro found in vtkSetGet.h.
        """
        ...
    
    def GetNumberOfGenerationsFromBaseType(self, string):
        """
        V.GetNumberOfGenerationsFromBaseType(string) -> int
        C++: static vtkIdType GetNumberOfGenerationsFromBaseType(
            const char *type)
        
        Given a the name of a base class of this class type, return the
        distance of inheritance between this class type and the named
        class (how many generations of inheritance are there between this
        class and the named class). If the named class is not in this
        class's inheritance tree, return a negative value. Valid
        responses will always be nonnegative. This method works in
        combination with vtkTypeMacro found in vtkSetGet.h.
        """
        ...
    
    def GetValue(self, p_int):
        """
        V.GetValue(int) -> float
        C++: double GetValue(int i)
        
        Get the ith contour value.
        """
        ...
    
    def GetValues(self):
        """
        V.GetValues() -> (float, ...)
        C++: double *GetValues()
        V.GetValues([float, ...])
        C++: void GetValues(double *contourValues)
        
        Get a pointer to an array of contour values. There will be
        GetNumberOfContours() values in the list.
        """
        ...
    
    def IsA(self, string):
        """
        V.IsA(string) -> int
        C++: vtkTypeBool IsA(const char *type) override;
        
        Return 1 if this class is the same type of (or a subclass of) the
        named class. Returns 0 otherwise. This method works in
        combination with vtkTypeMacro found in vtkSetGet.h.
        """
        ...
    
    def IsTypeOf(self, string):
        """
        V.IsTypeOf(string) -> int
        C++: static vtkTypeBool IsTypeOf(const char *type)
        
        Return 1 if this class type is the same type of (or a subclass
        of) the named class. Returns 0 otherwise. This method works in
        combination with vtkTypeMacro found in vtkSetGet.h.
        """
        ...
    
    def NewInstance(self):
        """
        V.NewInstance() -> vtkGenericCutter
        C++: vtkGenericCutter *NewInstance()
        """
        ...
    
    def SafeDownCast(self, vtkObjectBase):
        """
        V.SafeDownCast(vtkObjectBase) -> vtkGenericCutter
        C++: static vtkGenericCutter *SafeDownCast(vtkObjectBase *o)
        """
        ...
    
    def SetCutFunction(self, vtkImplicitFunction):
        """
        V.SetCutFunction(vtkImplicitFunction)
        C++: virtual void SetCutFunction(vtkImplicitFunction *)
        
        Specify the implicit function to perform the cutting.
        """
        ...
    
    def SetGenerateCutScalars(self, p_int):
        """
        V.SetGenerateCutScalars(int)
        C++: virtual void SetGenerateCutScalars(vtkTypeBool _arg)
        
        If this flag is enabled, then the output scalar values will be
        interpolated from the implicit function values, and not the input
        scalar data.
        """
        ...
    
    def SetLocator(self, vtkIncrementalPointLocator):
        """
        V.SetLocator(vtkIncrementalPointLocator)
        C++: void SetLocator(vtkIncrementalPointLocator *locator)
        
        Specify a spatial locator for merging points. By default, an
        instance of vtkMergePoints is used.
        """
        ...
    
    def SetNumberOfContours(self, p_int):
        """
        V.SetNumberOfContours(int)
        C++: void SetNumberOfContours(int number)
        
        Set the number of contours to place into the list. You only
        really need to use this method to reduce list size. The method
        SetValue() will automatically increase list size as needed.
        """
        ...
    
    def SetValue(self, p_int, p_float):
        """
        V.SetValue(int, float)
        C++: void SetValue(int i, double value)
        
        Set a particular contour value at contour number i. The index i
        ranges between 0<=i<NumberOfContours.
        """
        ...
    
    def __delattr__(self, *args, **kwargs):
        """ Implement delattr(self, name). """
        ...
    
    def __getattribute__(self, *args, **kwargs):
        """ Return getattr(self, name). """
        ...
    
    def __init__(self, *args, **kwargs) -> None:
        ...
    
    @staticmethod
    def __new__(*args, **kwargs):
        """ Create and return a new object.  See help(type) for accurate signature. """
        ...
    
    def __repr__(self, *args, **kwargs):
        """ Return repr(self). """
        ...
    
    def __setattr__(self, *args, **kwargs):
        """ Implement setattr(self, name, value). """
        ...
    
    def __str__(self, *args, **kwargs) -> str:
        """ Return str(self). """
        ...
    
    __this__ = ...
    __dict__ = ...
    __vtkname__ = ...


class vtkGenericDataSetTessellator(__vtkmodules_vtkCommonExecutionModel.vtkUnstructuredGridAlgorithm):
    """
    vtkGenericDataSetTessellator - tessellates generic, higher-order
    datasets into linear cells
    
    Superclass: vtkUnstructuredGridAlgorithm
    
    vtkGenericDataSetTessellator is a filter that subdivides a
    vtkGenericDataSet into linear elements (i.e., linear VTK cells).
    Tetrahedras are produced from 3D cells; triangles from 2D cells; and
    lines from 1D cells. The subdivision process depends on the cell
    tessellator associated with the input generic dataset, and its
    associated error metric. (These can be specified by the user if
    necessary.)
    
    This filter is typically used to convert a higher-order, complex
    dataset represented by a vtkGenericDataSet into a conventional
    vtkDataSet that can be operated on by linear VTK graphics filters
    (end of pipeline for rendering).
    
    @sa
    vtkGenericCellTessellator vtkGenericSubdivisionErrorMetric
    """
    def CreateDefaultLocator(self):
        """
        V.CreateDefaultLocator()
        C++: void CreateDefaultLocator()
        
        Create default locator. Used to create one when none is
        specified.
        """
        ...
    
    def GetKeepCellIds(self):
        """
        V.GetKeepCellIds() -> int
        C++: virtual vtkTypeBool GetKeepCellIds()
        
        Turn on/off generation of a cell centered attribute with ids of
        the original cells (as an input cell is tessellated into several
        linear cells). The name of the data array is "OriginalIds". It is
        true by default.
        """
        ...
    
    def GetLocator(self):
        """
        V.GetLocator() -> vtkIncrementalPointLocator
        C++: virtual vtkIncrementalPointLocator *GetLocator()
        
        Set / get a spatial locator for merging points. By default an
        instance of vtkMergePoints is used.
        """
        ...
    
    def GetMerging(self):
        """
        V.GetMerging() -> int
        C++: virtual vtkTypeBool GetMerging()
        
        Turn on/off merging of coincident points. Note that is merging is
        on, points with different point attributes (e.g., normals) are
        merged, which may cause rendering artifacts.
        """
        ...
    
    def GetMTime(self):
        """
        V.GetMTime() -> int
        C++: vtkMTimeType GetMTime() override;
        
        Return the MTime also considering the locator.
        """
        ...
    
    def GetNumberOfGenerationsFromBase(self, string):
        """
        V.GetNumberOfGenerationsFromBase(string) -> int
        C++: vtkIdType GetNumberOfGenerationsFromBase(const char *type)
            override;
        
        Standard VTK methods.
        """
        ...
    
    def GetNumberOfGenerationsFromBaseType(self, string):
        """
        V.GetNumberOfGenerationsFromBaseType(string) -> int
        C++: static vtkIdType GetNumberOfGenerationsFromBaseType(
            const char *type)
        
        Standard VTK methods.
        """
        ...
    
    def IsA(self, string):
        """
        V.IsA(string) -> int
        C++: vtkTypeBool IsA(const char *type) override;
        
        Standard VTK methods.
        """
        ...
    
    def IsTypeOf(self, string):
        """
        V.IsTypeOf(string) -> int
        C++: static vtkTypeBool IsTypeOf(const char *type)
        
        Standard VTK methods.
        """
        ...
    
    def KeepCellIdsOff(self):
        """
        V.KeepCellIdsOff()
        C++: virtual void KeepCellIdsOff()
        
        Turn on/off generation of a cell centered attribute with ids of
        the original cells (as an input cell is tessellated into several
        linear cells). The name of the data array is "OriginalIds". It is
        true by default.
        """
        ...
    
    def KeepCellIdsOn(self):
        """
        V.KeepCellIdsOn()
        C++: virtual void KeepCellIdsOn()
        
        Turn on/off generation of a cell centered attribute with ids of
        the original cells (as an input cell is tessellated into several
        linear cells). The name of the data array is "OriginalIds". It is
        true by default.
        """
        ...
    
    def MergingOff(self):
        """
        V.MergingOff()
        C++: virtual void MergingOff()
        
        Turn on/off merging of coincident points. Note that is merging is
        on, points with different point attributes (e.g., normals) are
        merged, which may cause rendering artifacts.
        """
        ...
    
    def MergingOn(self):
        """
        V.MergingOn()
        C++: virtual void MergingOn()
        
        Turn on/off merging of coincident points. Note that is merging is
        on, points with different point attributes (e.g., normals) are
        merged, which may cause rendering artifacts.
        """
        ...
    
    def NewInstance(self):
        """
        V.NewInstance() -> vtkGenericDataSetTessellator
        C++: vtkGenericDataSetTessellator *NewInstance()
        
        Standard VTK methods.
        """
        ...
    
    def SafeDownCast(self, vtkObjectBase):
        """
        V.SafeDownCast(vtkObjectBase) -> vtkGenericDataSetTessellator
        C++: static vtkGenericDataSetTessellator *SafeDownCast(
            vtkObjectBase *o)
        
        Standard VTK methods.
        """
        ...
    
    def SetKeepCellIds(self, p_int):
        """
        V.SetKeepCellIds(int)
        C++: virtual void SetKeepCellIds(vtkTypeBool _arg)
        
        Turn on/off generation of a cell centered attribute with ids of
        the original cells (as an input cell is tessellated into several
        linear cells). The name of the data array is "OriginalIds". It is
        true by default.
        """
        ...
    
    def SetLocator(self, vtkIncrementalPointLocator):
        """
        V.SetLocator(vtkIncrementalPointLocator)
        C++: void SetLocator(vtkIncrementalPointLocator *locator)
        
        Set / get a spatial locator for merging points. By default an
        instance of vtkMergePoints is used.
        """
        ...
    
    def SetMerging(self, p_int):
        """
        V.SetMerging(int)
        C++: virtual void SetMerging(vtkTypeBool _arg)
        
        Turn on/off merging of coincident points. Note that is merging is
        on, points with different point attributes (e.g., normals) are
        merged, which may cause rendering artifacts.
        """
        ...
    
    def __delattr__(self, *args, **kwargs):
        """ Implement delattr(self, name). """
        ...
    
    def __getattribute__(self, *args, **kwargs):
        """ Return getattr(self, name). """
        ...
    
    def __init__(self, *args, **kwargs) -> None:
        ...
    
    @staticmethod
    def __new__(*args, **kwargs):
        """ Create and return a new object.  See help(type) for accurate signature. """
        ...
    
    def __repr__(self, *args, **kwargs):
        """ Return repr(self). """
        ...
    
    def __setattr__(self, *args, **kwargs):
        """ Implement setattr(self, name, value). """
        ...
    
    def __str__(self, *args, **kwargs) -> str:
        """ Return str(self). """
        ...
    
    __this__ = ...
    __dict__ = ...
    __vtkname__ = ...


class vtkGenericGeometryFilter(__vtkmodules_vtkCommonExecutionModel.vtkPolyDataAlgorithm):
    """
    vtkGenericGeometryFilter - extract geometry from data (or convert
    data to polygonal type)
    
    Superclass: vtkPolyDataAlgorithm
    
    vtkGenericGeometryFilter is a general-purpose filter to extract
    geometry (and associated data) from any type of dataset. Geometry is
    obtained as follows: all 0D, 1D, and 2D cells are extracted. All 2D
    faces that are used by only one 3D cell (i.e., boundary faces) are
    extracted. It also is possible to specify conditions on point ids,
    cell ids, and on bounding box (referred to as "Extent") to control
    the extraction process.
    
    This filter also may be used to convert any type of data to polygonal
    type. The conversion process may be less than satisfactory for some
    3D datasets. For example, this filter will extract the outer surface
    of a volume or structured grid dataset. (For structured data you may
    want to use vtkImageDataGeometryFilter,
    vtkStructuredGridGeometryFilter, vtkExtractUnstructuredGrid,
    vtkRectilinearGridGeometryFilter, or vtkExtractVOI.)
    
    @warning
    When vtkGenericGeometryFilter extracts cells (or boundaries of cells)
    it will (by default) merge duplicate vertices. This may cause
    problems in some cases. For example, if you've run vtkPolyDataNormals
    to generate normals, which may split meshes and create duplicate
    vertices, vtkGenericGeometryFilter will merge these points back
    together. Turn merging off to prevent this from occurring.
    
    @sa
    vtkImageDataGeometryFilter vtkStructuredGridGeometryFilter
    vtkExtractGeometry vtkExtractVOI
    """
    def CellClippingOff(self):
        """
        V.CellClippingOff()
        C++: virtual void CellClippingOff()
        
        Turn on/off selection of geometry by cell id.
        """
        ...
    
    def CellClippingOn(self):
        """
        V.CellClippingOn()
        C++: virtual void CellClippingOn()
        
        Turn on/off selection of geometry by cell id.
        """
        ...
    
    def CreateDefaultLocator(self):
        """
        V.CreateDefaultLocator()
        C++: void CreateDefaultLocator()
        
        Create default locator. Used to create one when none is
        specified.
        """
        ...
    
    def ExtentClippingOff(self):
        """
        V.ExtentClippingOff()
        C++: virtual void ExtentClippingOff()
        
        Turn on/off selection of geometry via bounding box.
        """
        ...
    
    def ExtentClippingOn(self):
        """
        V.ExtentClippingOn()
        C++: virtual void ExtentClippingOn()
        
        Turn on/off selection of geometry via bounding box.
        """
        ...
    
    def GetCellClipping(self):
        """
        V.GetCellClipping() -> int
        C++: virtual vtkTypeBool GetCellClipping()
        
        Turn on/off selection of geometry by cell id.
        """
        ...
    
    def GetCellMaximum(self):
        """
        V.GetCellMaximum() -> int
        C++: virtual vtkIdType GetCellMaximum()
        
        Specify the maximum cell id for point id selection.
        """
        ...
    
    def GetCellMaximumMaxValue(self):
        """
        V.GetCellMaximumMaxValue() -> int
        C++: virtual vtkIdType GetCellMaximumMaxValue()
        
        Specify the maximum cell id for point id selection.
        """
        ...
    
    def GetCellMaximumMinValue(self):
        """
        V.GetCellMaximumMinValue() -> int
        C++: virtual vtkIdType GetCellMaximumMinValue()
        
        Specify the maximum cell id for point id selection.
        """
        ...
    
    def GetCellMinimum(self):
        """
        V.GetCellMinimum() -> int
        C++: virtual vtkIdType GetCellMinimum()
        
        Specify the minimum cell id for point id selection.
        """
        ...
    
    def GetCellMinimumMaxValue(self):
        """
        V.GetCellMinimumMaxValue() -> int
        C++: virtual vtkIdType GetCellMinimumMaxValue()
        
        Specify the minimum cell id for point id selection.
        """
        ...
    
    def GetCellMinimumMinValue(self):
        """
        V.GetCellMinimumMinValue() -> int
        C++: virtual vtkIdType GetCellMinimumMinValue()
        
        Specify the minimum cell id for point id selection.
        """
        ...
    
    def GetExtent(self):
        """
        V.GetExtent() -> (float, ...)
        C++: double *GetExtent()
        
        Set / get a (xmin,xmax, ymin,ymax, zmin,zmax) bounding box to
        clip data.
        """
        ...
    
    def GetExtentClipping(self):
        """
        V.GetExtentClipping() -> int
        C++: virtual vtkTypeBool GetExtentClipping()
        
        Turn on/off selection of geometry via bounding box.
        """
        ...
    
    def GetLocator(self):
        """
        V.GetLocator() -> vtkIncrementalPointLocator
        C++: virtual vtkIncrementalPointLocator *GetLocator()
        
        Set / get a spatial locator for merging points. By default an
        instance of vtkMergePoints is used.
        """
        ...
    
    def GetMerging(self):
        """
        V.GetMerging() -> int
        C++: virtual vtkTypeBool GetMerging()
        
        Turn on/off merging of coincident points. Note that is merging is
        on, points with different point attributes (e.g., normals) are
        merged, which may cause rendering artifacts.
        """
        ...
    
    def GetMTime(self):
        """
        V.GetMTime() -> int
        C++: vtkMTimeType GetMTime() override;
        
        Return the MTime also considering the locator.
        """
        ...
    
    def GetNumberOfGenerationsFromBase(self, string):
        """
        V.GetNumberOfGenerationsFromBase(string) -> int
        C++: vtkIdType GetNumberOfGenerationsFromBase(const char *type)
            override;
        
        Given a the name of a base class of this class type, return the
        distance of inheritance between this class type and the named
        class (how many generations of inheritance are there between this
        class and the named class). If the named class is not in this
        class's inheritance tree, return a negative value. Valid
        responses will always be nonnegative. This method works in
        combination with vtkTypeMacro found in vtkSetGet.h.
        """
        ...
    
    def GetNumberOfGenerationsFromBaseType(self, string):
        """
        V.GetNumberOfGenerationsFromBaseType(string) -> int
        C++: static vtkIdType GetNumberOfGenerationsFromBaseType(
            const char *type)
        
        Given a the name of a base class of this class type, return the
        distance of inheritance between this class type and the named
        class (how many generations of inheritance are there between this
        class and the named class). If the named class is not in this
        class's inheritance tree, return a negative value. Valid
        responses will always be nonnegative. This method works in
        combination with vtkTypeMacro found in vtkSetGet.h.
        """
        ...
    
    def GetPassThroughCellIds(self):
        """
        V.GetPassThroughCellIds() -> int
        C++: virtual vtkTypeBool GetPassThroughCellIds()
        
        If on, the output polygonal dataset will have a celldata array
        that holds the cell index of the original 3D cell that produced
        each output cell. This is useful for cell picking. The default is
        off to conserve memory.
        """
        ...
    
    def GetPointClipping(self):
        """
        V.GetPointClipping() -> int
        C++: virtual vtkTypeBool GetPointClipping()
        
        Turn on/off selection of geometry by point id.
        """
        ...
    
    def GetPointMaximum(self):
        """
        V.GetPointMaximum() -> int
        C++: virtual vtkIdType GetPointMaximum()
        
        Specify the maximum point id for point id selection.
        """
        ...
    
    def GetPointMaximumMaxValue(self):
        """
        V.GetPointMaximumMaxValue() -> int
        C++: virtual vtkIdType GetPointMaximumMaxValue()
        
        Specify the maximum point id for point id selection.
        """
        ...
    
    def GetPointMaximumMinValue(self):
        """
        V.GetPointMaximumMinValue() -> int
        C++: virtual vtkIdType GetPointMaximumMinValue()
        
        Specify the maximum point id for point id selection.
        """
        ...
    
    def GetPointMinimum(self):
        """
        V.GetPointMinimum() -> int
        C++: virtual vtkIdType GetPointMinimum()
        
        Specify the minimum point id for point id selection.
        """
        ...
    
    def GetPointMinimumMaxValue(self):
        """
        V.GetPointMinimumMaxValue() -> int
        C++: virtual vtkIdType GetPointMinimumMaxValue()
        
        Specify the minimum point id for point id selection.
        """
        ...
    
    def GetPointMinimumMinValue(self):
        """
        V.GetPointMinimumMinValue() -> int
        C++: virtual vtkIdType GetPointMinimumMinValue()
        
        Specify the minimum point id for point id selection.
        """
        ...
    
    def IsA(self, string):
        """
        V.IsA(string) -> int
        C++: vtkTypeBool IsA(const char *type) override;
        
        Return 1 if this class is the same type of (or a subclass of) the
        named class. Returns 0 otherwise. This method works in
        combination with vtkTypeMacro found in vtkSetGet.h.
        """
        ...
    
    def IsTypeOf(self, string):
        """
        V.IsTypeOf(string) -> int
        C++: static vtkTypeBool IsTypeOf(const char *type)
        
        Return 1 if this class type is the same type of (or a subclass
        of) the named class. Returns 0 otherwise. This method works in
        combination with vtkTypeMacro found in vtkSetGet.h.
        """
        ...
    
    def MergingOff(self):
        """
        V.MergingOff()
        C++: virtual void MergingOff()
        
        Turn on/off merging of coincident points. Note that is merging is
        on, points with different point attributes (e.g., normals) are
        merged, which may cause rendering artifacts.
        """
        ...
    
    def MergingOn(self):
        """
        V.MergingOn()
        C++: virtual void MergingOn()
        
        Turn on/off merging of coincident points. Note that is merging is
        on, points with different point attributes (e.g., normals) are
        merged, which may cause rendering artifacts.
        """
        ...
    
    def NewInstance(self):
        """
        V.NewInstance() -> vtkGenericGeometryFilter
        C++: vtkGenericGeometryFilter *NewInstance()
        """
        ...
    
    def PassThroughCellIdsOff(self):
        """
        V.PassThroughCellIdsOff()
        C++: virtual void PassThroughCellIdsOff()
        
        If on, the output polygonal dataset will have a celldata array
        that holds the cell index of the original 3D cell that produced
        each output cell. This is useful for cell picking. The default is
        off to conserve memory.
        """
        ...
    
    def PassThroughCellIdsOn(self):
        """
        V.PassThroughCellIdsOn()
        C++: virtual void PassThroughCellIdsOn()
        
        If on, the output polygonal dataset will have a celldata array
        that holds the cell index of the original 3D cell that produced
        each output cell. This is useful for cell picking. The default is
        off to conserve memory.
        """
        ...
    
    def PointClippingOff(self):
        """
        V.PointClippingOff()
        C++: virtual void PointClippingOff()
        
        Turn on/off selection of geometry by point id.
        """
        ...
    
    def PointClippingOn(self):
        """
        V.PointClippingOn()
        C++: virtual void PointClippingOn()
        
        Turn on/off selection of geometry by point id.
        """
        ...
    
    def SafeDownCast(self, vtkObjectBase):
        """
        V.SafeDownCast(vtkObjectBase) -> vtkGenericGeometryFilter
        C++: static vtkGenericGeometryFilter *SafeDownCast(
            vtkObjectBase *o)
        """
        ...
    
    def SetCellClipping(self, p_int):
        """
        V.SetCellClipping(int)
        C++: virtual void SetCellClipping(vtkTypeBool _arg)
        
        Turn on/off selection of geometry by cell id.
        """
        ...
    
    def SetCellMaximum(self, p_int):
        """
        V.SetCellMaximum(int)
        C++: virtual void SetCellMaximum(vtkIdType _arg)
        
        Specify the maximum cell id for point id selection.
        """
        ...
    
    def SetCellMinimum(self, p_int):
        """
        V.SetCellMinimum(int)
        C++: virtual void SetCellMinimum(vtkIdType _arg)
        
        Specify the minimum cell id for point id selection.
        """
        ...
    
    def SetExtent(self, p_float, p_float_1, p_float_2, p_float_3, p_float_4, p_float_5):
        """
        V.SetExtent(float, float, float, float, float, float)
        C++: void SetExtent(double xMin, double xMax, double yMin,
            double yMax, double zMin, double zMax)
        V.SetExtent([float, float, float, float, float, float])
        C++: void SetExtent(double extent[6])
        
        Specify a (xmin,xmax, ymin,ymax, zmin,zmax) bounding box to clip
        data.
        """
        ...
    
    def SetExtentClipping(self, p_int):
        """
        V.SetExtentClipping(int)
        C++: virtual void SetExtentClipping(vtkTypeBool _arg)
        
        Turn on/off selection of geometry via bounding box.
        """
        ...
    
    def SetLocator(self, vtkIncrementalPointLocator):
        """
        V.SetLocator(vtkIncrementalPointLocator)
        C++: void SetLocator(vtkIncrementalPointLocator *locator)
        
        Set / get a spatial locator for merging points. By default an
        instance of vtkMergePoints is used.
        """
        ...
    
    def SetMerging(self, p_int):
        """
        V.SetMerging(int)
        C++: virtual void SetMerging(vtkTypeBool _arg)
        
        Turn on/off merging of coincident points. Note that is merging is
        on, points with different point attributes (e.g., normals) are
        merged, which may cause rendering artifacts.
        """
        ...
    
    def SetPassThroughCellIds(self, p_int):
        """
        V.SetPassThroughCellIds(int)
        C++: virtual void SetPassThroughCellIds(vtkTypeBool _arg)
        
        If on, the output polygonal dataset will have a celldata array
        that holds the cell index of the original 3D cell that produced
        each output cell. This is useful for cell picking. The default is
        off to conserve memory.
        """
        ...
    
    def SetPointClipping(self, p_int):
        """
        V.SetPointClipping(int)
        C++: virtual void SetPointClipping(vtkTypeBool _arg)
        
        Turn on/off selection of geometry by point id.
        """
        ...
    
    def SetPointMaximum(self, p_int):
        """
        V.SetPointMaximum(int)
        C++: virtual void SetPointMaximum(vtkIdType _arg)
        
        Specify the maximum point id for point id selection.
        """
        ...
    
    def SetPointMinimum(self, p_int):
        """
        V.SetPointMinimum(int)
        C++: virtual void SetPointMinimum(vtkIdType _arg)
        
        Specify the minimum point id for point id selection.
        """
        ...
    
    def __delattr__(self, *args, **kwargs):
        """ Implement delattr(self, name). """
        ...
    
    def __getattribute__(self, *args, **kwargs):
        """ Return getattr(self, name). """
        ...
    
    def __init__(self, *args, **kwargs) -> None:
        ...
    
    @staticmethod
    def __new__(*args, **kwargs):
        """ Create and return a new object.  See help(type) for accurate signature. """
        ...
    
    def __repr__(self, *args, **kwargs):
        """ Return repr(self). """
        ...
    
    def __setattr__(self, *args, **kwargs):
        """ Implement setattr(self, name, value). """
        ...
    
    def __str__(self, *args, **kwargs) -> str:
        """ Return str(self). """
        ...
    
    __this__ = ...
    __dict__ = ...
    __vtkname__ = ...


class vtkGenericGlyph3DFilter(__vtkmodules_vtkCommonExecutionModel.vtkPolyDataAlgorithm):
    """
    vtkGenericGlyph3DFilter - copy oriented and scaled glyph geometry to
    every input point
    
    Superclass: vtkPolyDataAlgorithm
    
    vtkGenericGlyph3DFilter is a filter that copies a geometric
    representation (called a glyph) to every point in the input dataset.
    The glyph is defined with polygonal data from a source filter input.
    The glyph may be oriented along the input vectors or normals, and it
    may be scaled according to scalar data or vector magnitude. More than
    one glyph may be used by creating a table of source objects, each
    defining a different glyph. If a table of glyphs is defined, then the
    table can be indexed into by using either scalar value or vector
    magnitude.
    
    To use this object you'll have to provide an input dataset and a
    source to define the glyph. Then decide whether you want to scale the
    glyph and how to scale the glyph (using scalar value or vector
    magnitude). Next decide whether you want to orient the glyph, and
    whether to use the vector data or normal data to orient it. Finally,
    decide whether to use a table of glyphs, or just a single glyph. If
    you use a table of glyphs, you'll have to decide whether to index
    into it with scalar value or with vector magnitude.
    
    @warning
    Contrary to vtkGlyph3D, the only way to specify which attributes will
    be used for scaling, coloring and orienting is through
    SelectInputScalars(), SelectInputVectors() and SelectInputNormals().
    
    @warning
    The scaling of the glyphs is controlled by the ScaleFactor ivar
    multiplied by the scalar value at each point (if VTK_SCALE_BY_SCALAR
    is set), or multiplied by the vector magnitude (if
    VTK_SCALE_BY_VECTOR is set), Alternatively (if
    VTK_SCALE_BY_VECTORCOMPONENTS is set), the scaling may be specified
    for x,y,z using the vector components. The scale factor can be
    further controlled by enabling clamping using the Clamping ivar. If
    clamping is enabled, the scale is normalized by the Range ivar, and
    then multiplied by the scale factor. The normalization process
    includes clamping the scale value between (0,1).
    
    @warning
    Typically this object operates on input data with scalar and/or
    vector data. However, scalar and/or vector aren't necessary, and it
    can be used to copy data from a single source to each point. In this
    case the scale factor can be used to uniformly scale the glyphs.
    
    @warning
    The object uses "vector" data to scale glyphs, orient glyphs, and/or
    index into a table of glyphs. You can choose to use either the vector
    or normal data at each input point. Use the method
    SetVectorModeToUseVector() to use the vector input data, and
    SetVectorModeToUseNormal() to use the normal input data.
    
    @warning
    If you do use a table of glyphs, make sure to set the Range ivar to
    make sure the index into the glyph table is computed correctly.
    
    @warning
    You can turn off scaling of the glyphs completely by using the
    Scaling ivar. You can also turn off scaling due to data (either
    vector or scalar) by using the SetScaleModeToDataScalingOff() method.
    
    @sa
    vtkTensorGlyph
    """
    def ClampingOff(self):
        """
        V.ClampingOff()
        C++: virtual void ClampingOff()
        
        Turn on/off clamping of "scalar" values to range. (Scalar value
        may be vector magnitude if ScaleByVector() is enabled.)
        """
        ...
    
    def ClampingOn(self):
        """
        V.ClampingOn()
        C++: virtual void ClampingOn()
        
        Turn on/off clamping of "scalar" values to range. (Scalar value
        may be vector magnitude if ScaleByVector() is enabled.)
        """
        ...
    
    def GeneratePointIdsOff(self):
        """
        V.GeneratePointIdsOff()
        C++: virtual void GeneratePointIdsOff()
        
        Enable/disable the generation of point ids as part of the output.
        The point ids are the id of the input generating point. The point
        ids are stored in the output point field data and named
        "InputPointIds". Point generation is useful for debugging and
        pick operations.
        """
        ...
    
    def GeneratePointIdsOn(self):
        """
        V.GeneratePointIdsOn()
        C++: virtual void GeneratePointIdsOn()
        
        Enable/disable the generation of point ids as part of the output.
        The point ids are the id of the input generating point. The point
        ids are stored in the output point field data and named
        "InputPointIds". Point generation is useful for debugging and
        pick operations.
        """
        ...
    
    def GetClamping(self):
        """
        V.GetClamping() -> int
        C++: virtual vtkTypeBool GetClamping()
        
        Turn on/off clamping of "scalar" values to range. (Scalar value
        may be vector magnitude if ScaleByVector() is enabled.)
        """
        ...
    
    def GetColorMode(self):
        """
        V.GetColorMode() -> int
        C++: virtual int GetColorMode()
        
        Either color by scale, scalar or by vector/normal magnitude.
        """
        ...
    
    def GetColorModeAsString(self):
        """
        V.GetColorModeAsString() -> string
        C++: const char *GetColorModeAsString()
        
        Either color by scale, scalar or by vector/normal magnitude.
        """
        ...
    
    def GetGeneratePointIds(self):
        """
        V.GetGeneratePointIds() -> int
        C++: virtual vtkTypeBool GetGeneratePointIds()
        
        Enable/disable the generation of point ids as part of the output.
        The point ids are the id of the input generating point. The point
        ids are stored in the output point field data and named
        "InputPointIds". Point generation is useful for debugging and
        pick operations.
        """
        ...
    
    def GetIndexMode(self):
        """
        V.GetIndexMode() -> int
        C++: virtual int GetIndexMode()
        
        Index into table of sources by scalar, by vector/normal
        magnitude, or no indexing. If indexing is turned off, then the
        first source glyph in the table of glyphs is used.
        """
        ...
    
    def GetIndexModeAsString(self):
        """
        V.GetIndexModeAsString() -> string
        C++: const char *GetIndexModeAsString()
        
        Index into table of sources by scalar, by vector/normal
        magnitude, or no indexing. If indexing is turned off, then the
        first source glyph in the table of glyphs is used.
        """
        ...
    
    def GetInputNormalsSelection(self):
        """
        V.GetInputNormalsSelection() -> string
        C++: virtual char *GetInputNormalsSelection()
        
        If you want to use an arbitrary normals array, then set its name
        here. By default this in nullptr and the filter will use the
        active normal array.
        """
        ...
    
    def GetInputScalarsSelection(self):
        """
        V.GetInputScalarsSelection() -> string
        C++: virtual char *GetInputScalarsSelection()
        
        If you want to use an arbitrary scalars array, then set its name
        here. By default this in nullptr and the filter will use the
        active scalar array.
        """
        ...
    
    def GetInputVectorsSelection(self):
        """
        V.GetInputVectorsSelection() -> string
        C++: virtual char *GetInputVectorsSelection()
        
        If you want to use an arbitrary vectors array, then set its name
        here. By default this in nullptr and the filter will use the
        active vector array.
        """
        ...
    
    def GetNumberOfGenerationsFromBase(self, string):
        """
        V.GetNumberOfGenerationsFromBase(string) -> int
        C++: vtkIdType GetNumberOfGenerationsFromBase(const char *type)
            override;
        
        Given a the name of a base class of this class type, return the
        distance of inheritance between this class type and the named
        class (how many generations of inheritance are there between this
        class and the named class). If the named class is not in this
        class's inheritance tree, return a negative value. Valid
        responses will always be nonnegative. This method works in
        combination with vtkTypeMacro found in vtkSetGet.h.
        """
        ...
    
    def GetNumberOfGenerationsFromBaseType(self, string):
        """
        V.GetNumberOfGenerationsFromBaseType(string) -> int
        C++: static vtkIdType GetNumberOfGenerationsFromBaseType(
            const char *type)
        
        Given a the name of a base class of this class type, return the
        distance of inheritance between this class type and the named
        class (how many generations of inheritance are there between this
        class and the named class). If the named class is not in this
        class's inheritance tree, return a negative value. Valid
        responses will always be nonnegative. This method works in
        combination with vtkTypeMacro found in vtkSetGet.h.
        """
        ...
    
    def GetOrient(self):
        """
        V.GetOrient() -> int
        C++: virtual vtkTypeBool GetOrient()
        
        Turn on/off orienting of input geometry along vector/normal.
        """
        ...
    
    def GetPointIdsName(self):
        """
        V.GetPointIdsName() -> string
        C++: virtual char *GetPointIdsName()
        
        Set/Get the name of the PointIds array if generated. By default
        the Ids are named "InputPointIds", but this can be changed with
        this function.
        """
        ...
    
    def GetRange(self):
        """
        V.GetRange() -> (float, float)
        C++: virtual double *GetRange()
        
        Specify range to map scalar values into.
        """
        ...
    
    def GetScaleFactor(self):
        """
        V.GetScaleFactor() -> float
        C++: virtual double GetScaleFactor()
        
        Specify scale factor to scale object by.
        """
        ...
    
    def GetScaleMode(self):
        """
        V.GetScaleMode() -> int
        C++: virtual int GetScaleMode()
        
        Either scale by scalar or by vector/normal magnitude.
        """
        ...
    
    def GetScaleModeAsString(self):
        """
        V.GetScaleModeAsString() -> string
        C++: const char *GetScaleModeAsString()
        
        Either scale by scalar or by vector/normal magnitude.
        """
        ...
    
    def GetScaling(self):
        """
        V.GetScaling() -> int
        C++: virtual vtkTypeBool GetScaling()
        
        Turn on/off scaling of source geometry.
        """
        ...
    
    def GetSource(self, p_int):
        """
        V.GetSource(int) -> vtkPolyData
        C++: vtkPolyData *GetSource(int id=0)
        
        Get a pointer to a source object at a specified table location.
        """
        ...
    
    def GetVectorMode(self):
        """
        V.GetVectorMode() -> int
        C++: virtual int GetVectorMode()
        
        Specify whether to use vector or normal to perform vector
        operations.
        """
        ...
    
    def GetVectorModeAsString(self):
        """
        V.GetVectorModeAsString() -> string
        C++: const char *GetVectorModeAsString()
        
        Specify whether to use vector or normal to perform vector
        operations.
        """
        ...
    
    def IsA(self, string):
        """
        V.IsA(string) -> int
        C++: vtkTypeBool IsA(const char *type) override;
        
        Return 1 if this class is the same type of (or a subclass of) the
        named class. Returns 0 otherwise. This method works in
        combination with vtkTypeMacro found in vtkSetGet.h.
        """
        ...
    
    def IsTypeOf(self, string):
        """
        V.IsTypeOf(string) -> int
        C++: static vtkTypeBool IsTypeOf(const char *type)
        
        Return 1 if this class type is the same type of (or a subclass
        of) the named class. Returns 0 otherwise. This method works in
        combination with vtkTypeMacro found in vtkSetGet.h.
        """
        ...
    
    def NewInstance(self):
        """
        V.NewInstance() -> vtkGenericGlyph3DFilter
        C++: vtkGenericGlyph3DFilter *NewInstance()
        """
        ...
    
    def OrientOff(self):
        """
        V.OrientOff()
        C++: virtual void OrientOff()
        
        Turn on/off orienting of input geometry along vector/normal.
        """
        ...
    
    def OrientOn(self):
        """
        V.OrientOn()
        C++: virtual void OrientOn()
        
        Turn on/off orienting of input geometry along vector/normal.
        """
        ...
    
    def SafeDownCast(self, vtkObjectBase):
        """
        V.SafeDownCast(vtkObjectBase) -> vtkGenericGlyph3DFilter
        C++: static vtkGenericGlyph3DFilter *SafeDownCast(
            vtkObjectBase *o)
        """
        ...
    
    def ScalingOff(self):
        """
        V.ScalingOff()
        C++: virtual void ScalingOff()
        
        Turn on/off scaling of source geometry.
        """
        ...
    
    def ScalingOn(self):
        """
        V.ScalingOn()
        C++: virtual void ScalingOn()
        
        Turn on/off scaling of source geometry.
        """
        ...
    
    def SelectInputNormals(self, string):
        """
        V.SelectInputNormals(string)
        C++: void SelectInputNormals(const char *fieldName)
        
        If you want to use an arbitrary normals array, then set its name
        here. By default this in nullptr and the filter will use the
        active normal array.
        """
        ...
    
    def SelectInputScalars(self, string):
        """
        V.SelectInputScalars(string)
        C++: void SelectInputScalars(const char *fieldName)
        
        If you want to use an arbitrary scalars array, then set its name
        here. By default this in nullptr and the filter will use the
        active scalar array.
        """
        ...
    
    def SelectInputVectors(self, string):
        """
        V.SelectInputVectors(string)
        C++: void SelectInputVectors(const char *fieldName)
        
        If you want to use an arbitrary vectors array, then set its name
        here. By default this in nullptr and the filter will use the
        active vector array.
        """
        ...
    
    def SetClamping(self, p_int):
        """
        V.SetClamping(int)
        C++: virtual void SetClamping(vtkTypeBool _arg)
        
        Turn on/off clamping of "scalar" values to range. (Scalar value
        may be vector magnitude if ScaleByVector() is enabled.)
        """
        ...
    
    def SetColorMode(self, p_int):
        """
        V.SetColorMode(int)
        C++: virtual void SetColorMode(int _arg)
        
        Either color by scale, scalar or by vector/normal magnitude.
        """
        ...
    
    def SetColorModeToColorByScalar(self):
        """
        V.SetColorModeToColorByScalar()
        C++: void SetColorModeToColorByScalar()
        
        Either color by scale, scalar or by vector/normal magnitude.
        """
        ...
    
    def SetColorModeToColorByScale(self):
        """
        V.SetColorModeToColorByScale()
        C++: void SetColorModeToColorByScale()
        
        Either color by scale, scalar or by vector/normal magnitude.
        """
        ...
    
    def SetColorModeToColorByVector(self):
        """
        V.SetColorModeToColorByVector()
        C++: void SetColorModeToColorByVector()
        
        Either color by scale, scalar or by vector/normal magnitude.
        """
        ...
    
    def SetGeneratePointIds(self, p_int):
        """
        V.SetGeneratePointIds(int)
        C++: virtual void SetGeneratePointIds(vtkTypeBool _arg)
        
        Enable/disable the generation of point ids as part of the output.
        The point ids are the id of the input generating point. The point
        ids are stored in the output point field data and named
        "InputPointIds". Point generation is useful for debugging and
        pick operations.
        """
        ...
    
    def SetIndexMode(self, p_int):
        """
        V.SetIndexMode(int)
        C++: virtual void SetIndexMode(int _arg)
        
        Index into table of sources by scalar, by vector/normal
        magnitude, or no indexing. If indexing is turned off, then the
        first source glyph in the table of glyphs is used.
        """
        ...
    
    def SetIndexModeToOff(self):
        """
        V.SetIndexModeToOff()
        C++: void SetIndexModeToOff()
        
        Index into table of sources by scalar, by vector/normal
        magnitude, or no indexing. If indexing is turned off, then the
        first source glyph in the table of glyphs is used.
        """
        ...
    
    def SetIndexModeToScalar(self):
        """
        V.SetIndexModeToScalar()
        C++: void SetIndexModeToScalar()
        
        Index into table of sources by scalar, by vector/normal
        magnitude, or no indexing. If indexing is turned off, then the
        first source glyph in the table of glyphs is used.
        """
        ...
    
    def SetIndexModeToVector(self):
        """
        V.SetIndexModeToVector()
        C++: void SetIndexModeToVector()
        
        Index into table of sources by scalar, by vector/normal
        magnitude, or no indexing. If indexing is turned off, then the
        first source glyph in the table of glyphs is used.
        """
        ...
    
    def SetOrient(self, p_int):
        """
        V.SetOrient(int)
        C++: virtual void SetOrient(vtkTypeBool _arg)
        
        Turn on/off orienting of input geometry along vector/normal.
        """
        ...
    
    def SetPointIdsName(self, string):
        """
        V.SetPointIdsName(string)
        C++: virtual void SetPointIdsName(const char *_arg)
        
        Set/Get the name of the PointIds array if generated. By default
        the Ids are named "InputPointIds", but this can be changed with
        this function.
        """
        ...
    
    def SetRange(self, p_float, p_float_1):
        """
        V.SetRange(float, float)
        C++: virtual void SetRange(double _arg1, double _arg2)
        V.SetRange((float, float))
        C++: void SetRange(const double _arg[2])
        
        Specify range to map scalar values into.
        """
        ...
    
    def SetScaleFactor(self, p_float):
        """
        V.SetScaleFactor(float)
        C++: virtual void SetScaleFactor(double _arg)
        
        Specify scale factor to scale object by.
        """
        ...
    
    def SetScaleMode(self, p_int):
        """
        V.SetScaleMode(int)
        C++: virtual void SetScaleMode(int _arg)
        
        Either scale by scalar or by vector/normal magnitude.
        """
        ...
    
    def SetScaleModeToDataScalingOff(self):
        """
        V.SetScaleModeToDataScalingOff()
        C++: void SetScaleModeToDataScalingOff()
        
        Either scale by scalar or by vector/normal magnitude.
        """
        ...
    
    def SetScaleModeToScaleByScalar(self):
        """
        V.SetScaleModeToScaleByScalar()
        C++: void SetScaleModeToScaleByScalar()
        
        Either scale by scalar or by vector/normal magnitude.
        """
        ...
    
    def SetScaleModeToScaleByVector(self):
        """
        V.SetScaleModeToScaleByVector()
        C++: void SetScaleModeToScaleByVector()
        
        Either scale by scalar or by vector/normal magnitude.
        """
        ...
    
    def SetScaleModeToScaleByVectorComponents(self):
        """
        V.SetScaleModeToScaleByVectorComponents()
        C++: void SetScaleModeToScaleByVectorComponents()
        
        Either scale by scalar or by vector/normal magnitude.
        """
        ...
    
    def SetScaling(self, p_int):
        """
        V.SetScaling(int)
        C++: virtual void SetScaling(vtkTypeBool _arg)
        
        Turn on/off scaling of source geometry.
        """
        ...
    
    def SetSourceData(self, vtkPolyData):
        """
        V.SetSourceData(vtkPolyData)
        C++: void SetSourceData(vtkPolyData *pd)
        V.SetSourceData(int, vtkPolyData)
        C++: void SetSourceData(int id, vtkPolyData *pd)
        
        Set the source to use for the glyph.
        """
        ...
    
    def SetVectorMode(self, p_int):
        """
        V.SetVectorMode(int)
        C++: virtual void SetVectorMode(int _arg)
        
        Specify whether to use vector or normal to perform vector
        operations.
        """
        ...
    
    def SetVectorModeToUseNormal(self):
        """
        V.SetVectorModeToUseNormal()
        C++: void SetVectorModeToUseNormal()
        
        Specify whether to use vector or normal to perform vector
        operations.
        """
        ...
    
    def SetVectorModeToUseVector(self):
        """
        V.SetVectorModeToUseVector()
        C++: void SetVectorModeToUseVector()
        
        Specify whether to use vector or normal to perform vector
        operations.
        """
        ...
    
    def SetVectorModeToVectorRotationOff(self):
        """
        V.SetVectorModeToVectorRotationOff()
        C++: void SetVectorModeToVectorRotationOff()
        
        Specify whether to use vector or normal to perform vector
        operations.
        """
        ...
    
    def __delattr__(self, *args, **kwargs):
        """ Implement delattr(self, name). """
        ...
    
    def __getattribute__(self, *args, **kwargs):
        """ Return getattr(self, name). """
        ...
    
    def __init__(self, *args, **kwargs) -> None:
        ...
    
    @staticmethod
    def __new__(*args, **kwargs):
        """ Create and return a new object.  See help(type) for accurate signature. """
        ...
    
    def __repr__(self, *args, **kwargs):
        """ Return repr(self). """
        ...
    
    def __setattr__(self, *args, **kwargs):
        """ Implement setattr(self, name, value). """
        ...
    
    def __str__(self, *args, **kwargs) -> str:
        """ Return str(self). """
        ...
    
    __this__ = ...
    __dict__ = ...
    __vtkname__ = ...


class vtkGenericOutlineFilter(__vtkmodules_vtkCommonExecutionModel.vtkPolyDataAlgorithm):
    """
    vtkGenericOutlineFilter - create wireframe outline for arbitrary
    generic data set
    
    Superclass: vtkPolyDataAlgorithm
    
    vtkGenericOutlineFilter is a filter that generates a wireframe
    outline of any generic data set. The outline consists of the twelve
    edges of the generic dataset bounding box.
    
    @sa
    vtkGenericDataSet
    """
    def GetNumberOfGenerationsFromBase(self, string):
        """
        V.GetNumberOfGenerationsFromBase(string) -> int
        C++: vtkIdType GetNumberOfGenerationsFromBase(const char *type)
            override;
        
        Given a the name of a base class of this class type, return the
        distance of inheritance between this class type and the named
        class (how many generations of inheritance are there between this
        class and the named class). If the named class is not in this
        class's inheritance tree, return a negative value. Valid
        responses will always be nonnegative. This method works in
        combination with vtkTypeMacro found in vtkSetGet.h.
        """
        ...
    
    def GetNumberOfGenerationsFromBaseType(self, string):
        """
        V.GetNumberOfGenerationsFromBaseType(string) -> int
        C++: static vtkIdType GetNumberOfGenerationsFromBaseType(
            const char *type)
        
        Given a the name of a base class of this class type, return the
        distance of inheritance between this class type and the named
        class (how many generations of inheritance are there between this
        class and the named class). If the named class is not in this
        class's inheritance tree, return a negative value. Valid
        responses will always be nonnegative. This method works in
        combination with vtkTypeMacro found in vtkSetGet.h.
        """
        ...
    
    def IsA(self, string):
        """
        V.IsA(string) -> int
        C++: vtkTypeBool IsA(const char *type) override;
        
        Return 1 if this class is the same type of (or a subclass of) the
        named class. Returns 0 otherwise. This method works in
        combination with vtkTypeMacro found in vtkSetGet.h.
        """
        ...
    
    def IsTypeOf(self, string):
        """
        V.IsTypeOf(string) -> int
        C++: static vtkTypeBool IsTypeOf(const char *type)
        
        Return 1 if this class type is the same type of (or a subclass
        of) the named class. Returns 0 otherwise. This method works in
        combination with vtkTypeMacro found in vtkSetGet.h.
        """
        ...
    
    def NewInstance(self):
        """
        V.NewInstance() -> vtkGenericOutlineFilter
        C++: vtkGenericOutlineFilter *NewInstance()
        """
        ...
    
    def SafeDownCast(self, vtkObjectBase):
        """
        V.SafeDownCast(vtkObjectBase) -> vtkGenericOutlineFilter
        C++: static vtkGenericOutlineFilter *SafeDownCast(
            vtkObjectBase *o)
        """
        ...
    
    def __delattr__(self, *args, **kwargs):
        """ Implement delattr(self, name). """
        ...
    
    def __getattribute__(self, *args, **kwargs):
        """ Return getattr(self, name). """
        ...
    
    def __init__(self, *args, **kwargs) -> None:
        ...
    
    @staticmethod
    def __new__(*args, **kwargs):
        """ Create and return a new object.  See help(type) for accurate signature. """
        ...
    
    def __repr__(self, *args, **kwargs):
        """ Return repr(self). """
        ...
    
    def __setattr__(self, *args, **kwargs):
        """ Implement setattr(self, name, value). """
        ...
    
    def __str__(self, *args, **kwargs) -> str:
        """ Return str(self). """
        ...
    
    __this__ = ...
    __dict__ = ...
    __vtkname__ = ...


class vtkGenericProbeFilter(__vtkmodules_vtkCommonExecutionModel.vtkDataSetAlgorithm):
    """
    vtkGenericProbeFilter - sample data values at specified point
    locations
    
    Superclass: vtkDataSetAlgorithm
    
    vtkGenericProbeFilter is a filter that computes point attributes
    (e.g., scalars, vectors, etc.) at specified point positions. The
    filter has two inputs: the Input and Source. The Input geometric
    structure is passed through the filter. The point attributes are
    computed at the Input point positions by interpolating into the
    source data. For example, we can compute data values on a plane
    (plane specified as Input) from a volume (Source).
    
    This filter can be used to resample data, or convert one dataset form
    into another. For example, a generic dataset can be probed with a
    volume (three-dimensional vtkImageData), and then volume rendering
    techniques can be used to visualize the results. Another example: a
    line or curve can be used to probe data to produce x-y plots along
    that line or curve.
    
    This filter has been implemented to operate on generic datasets,
    rather than the typical vtkDataSet (and subclasses).
    vtkGenericDataSet is a more complex cousin of vtkDataSet, typically
    consisting of nonlinear, higher-order cells. To process this type of
    data, generic cells are automatically tessellated into linear cells
    prior to isocontouring.
    
    @sa
    vtkGenericProbeFilter vtkProbeFilter vtkGenericDataSet
    """
    def GetNumberOfGenerationsFromBase(self, string):
        """
        V.GetNumberOfGenerationsFromBase(string) -> int
        C++: vtkIdType GetNumberOfGenerationsFromBase(const char *type)
            override;
        
        Given a the name of a base class of this class type, return the
        distance of inheritance between this class type and the named
        class (how many generations of inheritance are there between this
        class and the named class). If the named class is not in this
        class's inheritance tree, return a negative value. Valid
        responses will always be nonnegative. This method works in
        combination with vtkTypeMacro found in vtkSetGet.h.
        """
        ...
    
    def GetNumberOfGenerationsFromBaseType(self, string):
        """
        V.GetNumberOfGenerationsFromBaseType(string) -> int
        C++: static vtkIdType GetNumberOfGenerationsFromBaseType(
            const char *type)
        
        Given a the name of a base class of this class type, return the
        distance of inheritance between this class type and the named
        class (how many generations of inheritance are there between this
        class and the named class). If the named class is not in this
        class's inheritance tree, return a negative value. Valid
        responses will always be nonnegative. This method works in
        combination with vtkTypeMacro found in vtkSetGet.h.
        """
        ...
    
    def GetSource(self):
        """
        V.GetSource() -> vtkGenericDataSet
        C++: vtkGenericDataSet *GetSource()
        
        Specify the point locations used to probe input. A generic
        dataset type is assumed.
        """
        ...
    
    def GetValidPoints(self):
        """
        V.GetValidPoints() -> vtkIdTypeArray
        C++: virtual vtkIdTypeArray *GetValidPoints()
        
        Get the list of point ids in the output that contain attribute
        data interpolated from the source.
        """
        ...
    
    def IsA(self, string):
        """
        V.IsA(string) -> int
        C++: vtkTypeBool IsA(const char *type) override;
        
        Return 1 if this class is the same type of (or a subclass of) the
        named class. Returns 0 otherwise. This method works in
        combination with vtkTypeMacro found in vtkSetGet.h.
        """
        ...
    
    def IsTypeOf(self, string):
        """
        V.IsTypeOf(string) -> int
        C++: static vtkTypeBool IsTypeOf(const char *type)
        
        Return 1 if this class type is the same type of (or a subclass
        of) the named class. Returns 0 otherwise. This method works in
        combination with vtkTypeMacro found in vtkSetGet.h.
        """
        ...
    
    def NewInstance(self):
        """
        V.NewInstance() -> vtkGenericProbeFilter
        C++: vtkGenericProbeFilter *NewInstance()
        """
        ...
    
    def SafeDownCast(self, vtkObjectBase):
        """
        V.SafeDownCast(vtkObjectBase) -> vtkGenericProbeFilter
        C++: static vtkGenericProbeFilter *SafeDownCast(vtkObjectBase *o)
        """
        ...
    
    def SetSourceData(self, vtkGenericDataSet):
        """
        V.SetSourceData(vtkGenericDataSet)
        C++: void SetSourceData(vtkGenericDataSet *source)
        
        Specify the point locations used to probe input. A generic
        dataset type is assumed.
        """
        ...
    
    def __delattr__(self, *args, **kwargs):
        """ Implement delattr(self, name). """
        ...
    
    def __getattribute__(self, *args, **kwargs):
        """ Return getattr(self, name). """
        ...
    
    def __init__(self, *args, **kwargs) -> None:
        ...
    
    @staticmethod
    def __new__(*args, **kwargs):
        """ Create and return a new object.  See help(type) for accurate signature. """
        ...
    
    def __repr__(self, *args, **kwargs):
        """ Return repr(self). """
        ...
    
    def __setattr__(self, *args, **kwargs):
        """ Implement setattr(self, name, value). """
        ...
    
    def __str__(self, *args, **kwargs) -> str:
        """ Return str(self). """
        ...
    
    __this__ = ...
    __dict__ = ...
    __vtkname__ = ...


class vtkGenericStreamTracer(__vtkmodules_vtkCommonExecutionModel.vtkPolyDataAlgorithm):
    """
    vtkGenericStreamTracer - Streamline generator
    
    Superclass: vtkPolyDataAlgorithm
    
    vtkGenericStreamTracer is a filter that integrates a vector field to
    generate streamlines. The integration is performed using the provided
    integrator. The default is second order Runge-Kutta.
    
    vtkGenericStreamTracer generate polylines as output. Each cell
    (polyline) corresponds to one streamline. The values associated with
    each streamline are stored in the cell data whereas the values
    associated with points are stored in point data.
    
    Note that vtkGenericStreamTracer can integrate both forward and
    backward. The length of the streamline is controlled by specifying
    either a maximum value in the units of length, cell length or elapsed
    time (the elapsed time is the time each particle would have traveled
    if flow were steady). Otherwise, the integration terminates after
    exiting the dataset or if the particle speed is reduced to a value
    less than the terminal speed or when a maximum number of steps is
    reached. The reason for the termination is stored in a cell array
    named ReasonForTermination.
    
    The quality of integration can be controlled by setting integration
    step (InitialIntegrationStep) and in the case of adaptive solvers the
    maximum error, the minimum integration step and the maximum
    integration step. All of these can have units of length, cell length
    or elapsed time.
    
    The integration time, vorticity, rotation and angular velocity are
    stored in point arrays named "IntegrationTime", "Vorticity",
    "Rotation" and "AngularVelocity" respectively (vorticity, rotation
    and angular velocity are computed only when ComputeVorticity is on).
    All point attributes in the source data set are interpolated on the
    new streamline points.
    
    vtkGenericStreamTracer integrates through any type of dataset. As a
    result, if the dataset contains 2D cells such as polygons or
    triangles, the integration is constrained to lie on the surface
    defined by the 2D cells.
    
    The starting point of traces may be defined in two different ways.
    Starting from global x-y-z "position" allows you to start a single
    trace at a specified x-y-z coordinate. If you specify a source
    object, a trace will be generated for each point in the source that
    is inside the dataset.
    
    @sa
    vtkRibbonFilter vtkRuledSurfaceFilter vtkInitialValueProblemSolver
    vtkRungeKutta2 vtkRungeKutta4 vtkRungeKutta45
    """
    def AddInputData(self, vtkGenericDataSet):
        """
        V.AddInputData(vtkGenericDataSet)
        C++: void AddInputData(vtkGenericDataSet *in)
        
        Add a dataset to the list inputs
        """
        ...
    
    def ComputeVorticityOff(self):
        """
        V.ComputeVorticityOff()
        C++: virtual void ComputeVorticityOff()
        
        Turn on/off calculation of vorticity at streamline points
        (necessary for generating proper streamribbons using the
        vtkRibbonFilter.
        """
        ...
    
    def ComputeVorticityOn(self):
        """
        V.ComputeVorticityOn()
        C++: virtual void ComputeVorticityOn()
        
        Turn on/off calculation of vorticity at streamline points
        (necessary for generating proper streamribbons using the
        vtkRibbonFilter.
        """
        ...
    
    def FillInputPortInformation(self, p_int, vtkInformation):
        """
        V.FillInputPortInformation(int, vtkInformation) -> int
        C++: int FillInputPortInformation(int port, vtkInformation *info)
            override;
        
        Fill the input port information objects for this algorithm.  This
        is invoked by the first call to GetInputPortInformation for each
        port so subclasses can specify what they can handle.
        """
        ...
    
    def GetComputeVorticity(self):
        """
        V.GetComputeVorticity() -> int
        C++: virtual vtkTypeBool GetComputeVorticity()
        
        Turn on/off calculation of vorticity at streamline points
        (necessary for generating proper streamribbons using the
        vtkRibbonFilter.
        """
        ...
    
    def GetInitialIntegrationStep(self):
        """
        V.GetInitialIntegrationStep() -> float
        C++: double GetInitialIntegrationStep()
        
        Specify the initial step used in the integration expressed in one
        of the: TIME_UNIT        = 0 LENGTH_UNIT      = 1
        CELL_LENGTH_UNIT = 2 If the integrator is not adaptive, this is
        the actual step used.
        """
        ...
    
    def GetInitialIntegrationStepUnit(self):
        """
        V.GetInitialIntegrationStepUnit() -> int
        C++: int GetInitialIntegrationStepUnit()
        
        Specify the initial step used in the integration expressed in one
        of the: TIME_UNIT        = 0 LENGTH_UNIT      = 1
        CELL_LENGTH_UNIT = 2 If the integrator is not adaptive, this is
        the actual step used.
        """
        ...
    
    def GetInputVectorsSelection(self):
        """
        V.GetInputVectorsSelection() -> string
        C++: virtual char *GetInputVectorsSelection()
        
        If you want to generate traces using an arbitrary vector array,
        then set its name here. By default this in nullptr and the filter
        will use the active vector array.
        """
        ...
    
    def GetIntegrationDirection(self):
        """
        V.GetIntegrationDirection() -> int
        C++: virtual int GetIntegrationDirection()
        
        Specify whether the streamtrace will be generated in the upstream
        or downstream direction.
        """
        ...
    
    def GetIntegrationDirectionMaxValue(self):
        """
        V.GetIntegrationDirectionMaxValue() -> int
        C++: virtual int GetIntegrationDirectionMaxValue()
        
        Specify whether the streamtrace will be generated in the upstream
        or downstream direction.
        """
        ...
    
    def GetIntegrationDirectionMinValue(self):
        """
        V.GetIntegrationDirectionMinValue() -> int
        C++: virtual int GetIntegrationDirectionMinValue()
        
        Specify whether the streamtrace will be generated in the upstream
        or downstream direction.
        """
        ...
    
    def GetIntegrator(self):
        """
        V.GetIntegrator() -> vtkInitialValueProblemSolver
        C++: virtual vtkInitialValueProblemSolver *GetIntegrator()
        
        Set/get the integrator type to be used in the stream line
        calculation. The object passed is not actually used but is cloned
        with NewInstance in the process of integration (prototype
        pattern). The default is 2nd order Runge Kutta. The integrator
        can also be changed using SetIntegratorType. The recognized
        solvers are: RUNGE_KUTTA2  = 0 RUNGE_KUTTA4  = 1 RUNGE_KUTTA45 =
        2
        """
        ...
    
    def GetIntegratorType(self):
        """
        V.GetIntegratorType() -> int
        C++: int GetIntegratorType()
        
        Set/get the integrator type to be used in the stream line
        calculation. The object passed is not actually used but is cloned
        with NewInstance in the process of integration (prototype
        pattern). The default is 2nd order Runge Kutta. The integrator
        can also be changed using SetIntegratorType. The recognized
        solvers are: RUNGE_KUTTA2  = 0 RUNGE_KUTTA4  = 1 RUNGE_KUTTA45 =
        2
        """
        ...
    
    def GetMaximumError(self):
        """
        V.GetMaximumError() -> float
        C++: virtual double GetMaximumError()
        
        Specify the maximum error in the integration. This value is
        passed to the integrator. Therefore, it's meaning depends on the
        integrator used.
        """
        ...
    
    def GetMaximumIntegrationStep(self):
        """
        V.GetMaximumIntegrationStep() -> float
        C++: double GetMaximumIntegrationStep()
        
        Specify the maximum step used in the integration expressed in one
        of the: TIME_UNIT        = 0 LENGTH_UNIT      = 1
        CELL_LENGTH_UNIT = 2 Only valid when using adaptive integrators.
        """
        ...
    
    def GetMaximumIntegrationStepUnit(self):
        """
        V.GetMaximumIntegrationStepUnit() -> int
        C++: int GetMaximumIntegrationStepUnit()
        
        Specify the maximum step used in the integration expressed in one
        of the: TIME_UNIT        = 0 LENGTH_UNIT      = 1
        CELL_LENGTH_UNIT = 2 Only valid when using adaptive integrators.
        """
        ...
    
    def GetMaximumNumberOfSteps(self):
        """
        V.GetMaximumNumberOfSteps() -> int
        C++: virtual vtkIdType GetMaximumNumberOfSteps()
        
        Specify the maximum number of steps used in the integration.
        """
        ...
    
    def GetMaximumPropagation(self):
        """
        V.GetMaximumPropagation() -> float
        C++: double GetMaximumPropagation()
        
        Specify the maximum length of the streamlines expressed in one of
        the: TIME_UNIT        = 0 LENGTH_UNIT      = 1 CELL_LENGTH_UNIT =
        2
        """
        ...
    
    def GetMaximumPropagationUnit(self):
        """
        V.GetMaximumPropagationUnit() -> int
        C++: int GetMaximumPropagationUnit()
        
        Specify the maximum length of the streamlines expressed in one of
        the: TIME_UNIT        = 0 LENGTH_UNIT      = 1 CELL_LENGTH_UNIT =
        2
        """
        ...
    
    def GetMinimumIntegrationStep(self):
        """
        V.GetMinimumIntegrationStep() -> float
        C++: double GetMinimumIntegrationStep()
        
        Specify the minimum step used in the integration expressed in one
        of the: TIME_UNIT        = 0 LENGTH_UNIT      = 1
        CELL_LENGTH_UNIT = 2 Only valid when using adaptive integrators.
        """
        ...
    
    def GetMinimumIntegrationStepUnit(self):
        """
        V.GetMinimumIntegrationStepUnit() -> int
        C++: int GetMinimumIntegrationStepUnit()
        
        Specify the minimum step used in the integration expressed in one
        of the: TIME_UNIT        = 0 LENGTH_UNIT      = 1
        CELL_LENGTH_UNIT = 2 Only valid when using adaptive integrators.
        """
        ...
    
    def GetNumberOfGenerationsFromBase(self, string):
        """
        V.GetNumberOfGenerationsFromBase(string) -> int
        C++: vtkIdType GetNumberOfGenerationsFromBase(const char *type)
            override;
        
        Given a the name of a base class of this class type, return the
        distance of inheritance between this class type and the named
        class (how many generations of inheritance are there between this
        class and the named class). If the named class is not in this
        class's inheritance tree, return a negative value. Valid
        responses will always be nonnegative. This method works in
        combination with vtkTypeMacro found in vtkSetGet.h.
        """
        ...
    
    def GetNumberOfGenerationsFromBaseType(self, string):
        """
        V.GetNumberOfGenerationsFromBaseType(string) -> int
        C++: static vtkIdType GetNumberOfGenerationsFromBaseType(
            const char *type)
        
        Given a the name of a base class of this class type, return the
        distance of inheritance between this class type and the named
        class (how many generations of inheritance are there between this
        class and the named class). If the named class is not in this
        class's inheritance tree, return a negative value. Valid
        responses will always be nonnegative. This method works in
        combination with vtkTypeMacro found in vtkSetGet.h.
        """
        ...
    
    def GetRotationScale(self):
        """
        V.GetRotationScale() -> float
        C++: virtual double GetRotationScale()
        
        This can be used to scale the rate with which the streamribbons
        twist. The default is 1.
        """
        ...
    
    def GetSource(self):
        """
        V.GetSource() -> vtkDataSet
        C++: vtkDataSet *GetSource()
        
        Specify the source object used to generate starting points.
        """
        ...
    
    def GetStartPosition(self):
        """
        V.GetStartPosition() -> (float, float, float)
        C++: virtual double *GetStartPosition()
        
        Specify the start of the streamline in the global coordinate
        system. Search must be performed to find initial cell to start
        integration from.
        """
        ...
    
    def GetTerminalSpeed(self):
        """
        V.GetTerminalSpeed() -> float
        C++: virtual double GetTerminalSpeed()
        
        If at any point, the speed is below this value, the integration
        is terminated.
        """
        ...
    
    def IsA(self, string):
        """
        V.IsA(string) -> int
        C++: vtkTypeBool IsA(const char *type) override;
        
        Return 1 if this class is the same type of (or a subclass of) the
        named class. Returns 0 otherwise. This method works in
        combination with vtkTypeMacro found in vtkSetGet.h.
        """
        ...
    
    def IsTypeOf(self, string):
        """
        V.IsTypeOf(string) -> int
        C++: static vtkTypeBool IsTypeOf(const char *type)
        
        Return 1 if this class type is the same type of (or a subclass
        of) the named class. Returns 0 otherwise. This method works in
        combination with vtkTypeMacro found in vtkSetGet.h.
        """
        ...
    
    def NewInstance(self):
        """
        V.NewInstance() -> vtkGenericStreamTracer
        C++: vtkGenericStreamTracer *NewInstance()
        """
        ...
    
    def SafeDownCast(self, vtkObjectBase):
        """
        V.SafeDownCast(vtkObjectBase) -> vtkGenericStreamTracer
        C++: static vtkGenericStreamTracer *SafeDownCast(vtkObjectBase *o)
        """
        ...
    
    def SelectInputVectors(self, string):
        """
        V.SelectInputVectors(string)
        C++: void SelectInputVectors(const char *fieldName)
        
        If you want to generate traces using an arbitrary vector array,
        then set its name here. By default this in nullptr and the filter
        will use the active vector array.
        """
        ...
    
    def SetComputeVorticity(self, p_int):
        """
        V.SetComputeVorticity(int)
        C++: virtual void SetComputeVorticity(vtkTypeBool _arg)
        
        Turn on/off calculation of vorticity at streamline points
        (necessary for generating proper streamribbons using the
        vtkRibbonFilter.
        """
        ...
    
    def SetInitialIntegrationStep(self, p_int, p_float):
        """
        V.SetInitialIntegrationStep(int, float)
        C++: void SetInitialIntegrationStep(int unit, double step)
        V.SetInitialIntegrationStep(float)
        C++: void SetInitialIntegrationStep(double step)
        
        Specify the initial step used in the integration expressed in one
        of the: TIME_UNIT        = 0 LENGTH_UNIT      = 1
        CELL_LENGTH_UNIT = 2 If the integrator is not adaptive, this is
        the actual step used.
        """
        ...
    
    def SetInitialIntegrationStepUnit(self, p_int):
        """
        V.SetInitialIntegrationStepUnit(int)
        C++: void SetInitialIntegrationStepUnit(int unit)
        
        Specify the initial step used in the integration expressed in one
        of the: TIME_UNIT        = 0 LENGTH_UNIT      = 1
        CELL_LENGTH_UNIT = 2 If the integrator is not adaptive, this is
        the actual step used.
        """
        ...
    
    def SetInitialIntegrationStepUnitToCellLengthUnit(self):
        """
        V.SetInitialIntegrationStepUnitToCellLengthUnit()
        C++: void SetInitialIntegrationStepUnitToCellLengthUnit()
        
        Specify the initial step used in the integration expressed in one
        of the: TIME_UNIT        = 0 LENGTH_UNIT      = 1
        CELL_LENGTH_UNIT = 2 If the integrator is not adaptive, this is
        the actual step used.
        """
        ...
    
    def SetInitialIntegrationStepUnitToLengthUnit(self):
        """
        V.SetInitialIntegrationStepUnitToLengthUnit()
        C++: void SetInitialIntegrationStepUnitToLengthUnit()
        
        Specify the initial step used in the integration expressed in one
        of the: TIME_UNIT        = 0 LENGTH_UNIT      = 1
        CELL_LENGTH_UNIT = 2 If the integrator is not adaptive, this is
        the actual step used.
        """
        ...
    
    def SetInitialIntegrationStepUnitToTimeUnit(self):
        """
        V.SetInitialIntegrationStepUnitToTimeUnit()
        C++: void SetInitialIntegrationStepUnitToTimeUnit()
        
        Specify the initial step used in the integration expressed in one
        of the: TIME_UNIT        = 0 LENGTH_UNIT      = 1
        CELL_LENGTH_UNIT = 2 If the integrator is not adaptive, this is
        the actual step used.
        """
        ...
    
    def SetIntegrationDirection(self, p_int):
        """
        V.SetIntegrationDirection(int)
        C++: virtual void SetIntegrationDirection(int _arg)
        
        Specify whether the streamtrace will be generated in the upstream
        or downstream direction.
        """
        ...
    
    def SetIntegrationDirectionToBackward(self):
        """
        V.SetIntegrationDirectionToBackward()
        C++: void SetIntegrationDirectionToBackward()
        
        Specify whether the streamtrace will be generated in the upstream
        or downstream direction.
        """
        ...
    
    def SetIntegrationDirectionToBoth(self):
        """
        V.SetIntegrationDirectionToBoth()
        C++: void SetIntegrationDirectionToBoth()
        
        Specify whether the streamtrace will be generated in the upstream
        or downstream direction.
        """
        ...
    
    def SetIntegrationDirectionToForward(self):
        """
        V.SetIntegrationDirectionToForward()
        C++: void SetIntegrationDirectionToForward()
        
        Specify whether the streamtrace will be generated in the upstream
        or downstream direction.
        """
        ...
    
    def SetIntegrationStepUnit(self, p_int):
        """
        V.SetIntegrationStepUnit(int)
        C++: void SetIntegrationStepUnit(int unit)
        
        Simplified API to set an homogeneous unit across Min/Max/Init
        IntegrationStepUnit
        """
        ...
    
    def SetIntegrator(self, vtkInitialValueProblemSolver):
        """
        V.SetIntegrator(vtkInitialValueProblemSolver)
        C++: void SetIntegrator(vtkInitialValueProblemSolver *)
        
        Set/get the integrator type to be used in the stream line
        calculation. The object passed is not actually used but is cloned
        with NewInstance in the process of integration (prototype
        pattern). The default is 2nd order Runge Kutta. The integrator
        can also be changed using SetIntegratorType. The recognized
        solvers are: RUNGE_KUTTA2  = 0 RUNGE_KUTTA4  = 1 RUNGE_KUTTA45 =
        2
        """
        ...
    
    def SetIntegratorType(self, p_int):
        """
        V.SetIntegratorType(int)
        C++: void SetIntegratorType(int type)
        
        Set/get the integrator type to be used in the stream line
        calculation. The object passed is not actually used but is cloned
        with NewInstance in the process of integration (prototype
        pattern). The default is 2nd order Runge Kutta. The integrator
        can also be changed using SetIntegratorType. The recognized
        solvers are: RUNGE_KUTTA2  = 0 RUNGE_KUTTA4  = 1 RUNGE_KUTTA45 =
        2
        """
        ...
    
    def SetIntegratorTypeToRungeKutta2(self):
        """
        V.SetIntegratorTypeToRungeKutta2()
        C++: void SetIntegratorTypeToRungeKutta2()
        
        Set/get the integrator type to be used in the stream line
        calculation. The object passed is not actually used but is cloned
        with NewInstance in the process of integration (prototype
        pattern). The default is 2nd order Runge Kutta. The integrator
        can also be changed using SetIntegratorType. The recognized
        solvers are: RUNGE_KUTTA2  = 0 RUNGE_KUTTA4  = 1 RUNGE_KUTTA45 =
        2
        """
        ...
    
    def SetIntegratorTypeToRungeKutta4(self):
        """
        V.SetIntegratorTypeToRungeKutta4()
        C++: void SetIntegratorTypeToRungeKutta4()
        
        Set/get the integrator type to be used in the stream line
        calculation. The object passed is not actually used but is cloned
        with NewInstance in the process of integration (prototype
        pattern). The default is 2nd order Runge Kutta. The integrator
        can also be changed using SetIntegratorType. The recognized
        solvers are: RUNGE_KUTTA2  = 0 RUNGE_KUTTA4  = 1 RUNGE_KUTTA45 =
        2
        """
        ...
    
    def SetIntegratorTypeToRungeKutta45(self):
        """
        V.SetIntegratorTypeToRungeKutta45()
        C++: void SetIntegratorTypeToRungeKutta45()
        
        Set/get the integrator type to be used in the stream line
        calculation. The object passed is not actually used but is cloned
        with NewInstance in the process of integration (prototype
        pattern). The default is 2nd order Runge Kutta. The integrator
        can also be changed using SetIntegratorType. The recognized
        solvers are: RUNGE_KUTTA2  = 0 RUNGE_KUTTA4  = 1 RUNGE_KUTTA45 =
        2
        """
        ...
    
    def SetInterpolatorPrototype(self, vtkGenericInterpolatedVelocityField):
        """
        V.SetInterpolatorPrototype(vtkGenericInterpolatedVelocityField)
        C++: void SetInterpolatorPrototype(
            vtkGenericInterpolatedVelocityField *ivf)
        
        The object used to interpolate the velocity field during
        integration is of the same class as this prototype.
        """
        ...
    
    def SetMaximumError(self, p_float):
        """
        V.SetMaximumError(float)
        C++: virtual void SetMaximumError(double _arg)
        
        Specify the maximum error in the integration. This value is
        passed to the integrator. Therefore, it's meaning depends on the
        integrator used.
        """
        ...
    
    def SetMaximumIntegrationStep(self, p_int, p_float):
        """
        V.SetMaximumIntegrationStep(int, float)
        C++: void SetMaximumIntegrationStep(int unit, double step)
        V.SetMaximumIntegrationStep(float)
        C++: void SetMaximumIntegrationStep(double step)
        
        Specify the maximum step used in the integration expressed in one
        of the: TIME_UNIT        = 0 LENGTH_UNIT      = 1
        CELL_LENGTH_UNIT = 2 Only valid when using adaptive integrators.
        """
        ...
    
    def SetMaximumIntegrationStepUnit(self, p_int):
        """
        V.SetMaximumIntegrationStepUnit(int)
        C++: void SetMaximumIntegrationStepUnit(int unit)
        
        Specify the maximum step used in the integration expressed in one
        of the: TIME_UNIT        = 0 LENGTH_UNIT      = 1
        CELL_LENGTH_UNIT = 2 Only valid when using adaptive integrators.
        """
        ...
    
    def SetMaximumIntegrationStepUnitToCellLengthUnit(self):
        """
        V.SetMaximumIntegrationStepUnitToCellLengthUnit()
        C++: void SetMaximumIntegrationStepUnitToCellLengthUnit()
        
        Specify the maximum step used in the integration expressed in one
        of the: TIME_UNIT        = 0 LENGTH_UNIT      = 1
        CELL_LENGTH_UNIT = 2 Only valid when using adaptive integrators.
        """
        ...
    
    def SetMaximumIntegrationStepUnitToLengthUnit(self):
        """
        V.SetMaximumIntegrationStepUnitToLengthUnit()
        C++: void SetMaximumIntegrationStepUnitToLengthUnit()
        
        Specify the maximum step used in the integration expressed in one
        of the: TIME_UNIT        = 0 LENGTH_UNIT      = 1
        CELL_LENGTH_UNIT = 2 Only valid when using adaptive integrators.
        """
        ...
    
    def SetMaximumIntegrationStepUnitToTimeUnit(self):
        """
        V.SetMaximumIntegrationStepUnitToTimeUnit()
        C++: void SetMaximumIntegrationStepUnitToTimeUnit()
        
        Specify the maximum step used in the integration expressed in one
        of the: TIME_UNIT        = 0 LENGTH_UNIT      = 1
        CELL_LENGTH_UNIT = 2 Only valid when using adaptive integrators.
        """
        ...
    
    def SetMaximumNumberOfSteps(self, p_int):
        """
        V.SetMaximumNumberOfSteps(int)
        C++: virtual void SetMaximumNumberOfSteps(vtkIdType _arg)
        
        Specify the maximum number of steps used in the integration.
        """
        ...
    
    def SetMaximumPropagation(self, p_int, p_float):
        """
        V.SetMaximumPropagation(int, float)
        C++: void SetMaximumPropagation(int unit, double max)
        V.SetMaximumPropagation(float)
        C++: void SetMaximumPropagation(double max)
        
        Specify the maximum length of the streamlines expressed in one of
        the: TIME_UNIT        = 0 LENGTH_UNIT      = 1 CELL_LENGTH_UNIT =
        2
        """
        ...
    
    def SetMaximumPropagationUnit(self, p_int):
        """
        V.SetMaximumPropagationUnit(int)
        C++: void SetMaximumPropagationUnit(int unit)
        
        Specify the maximum length of the streamlines expressed in one of
        the: TIME_UNIT        = 0 LENGTH_UNIT      = 1 CELL_LENGTH_UNIT =
        2
        """
        ...
    
    def SetMaximumPropagationUnitToCellLengthUnit(self):
        """
        V.SetMaximumPropagationUnitToCellLengthUnit()
        C++: void SetMaximumPropagationUnitToCellLengthUnit()
        
        Specify the maximum length of the streamlines expressed in one of
        the: TIME_UNIT        = 0 LENGTH_UNIT      = 1 CELL_LENGTH_UNIT =
        2
        """
        ...
    
    def SetMaximumPropagationUnitToLengthUnit(self):
        """
        V.SetMaximumPropagationUnitToLengthUnit()
        C++: void SetMaximumPropagationUnitToLengthUnit()
        
        Specify the maximum length of the streamlines expressed in one of
        the: TIME_UNIT        = 0 LENGTH_UNIT      = 1 CELL_LENGTH_UNIT =
        2
        """
        ...
    
    def SetMaximumPropagationUnitToTimeUnit(self):
        """
        V.SetMaximumPropagationUnitToTimeUnit()
        C++: void SetMaximumPropagationUnitToTimeUnit()
        
        Specify the maximum length of the streamlines expressed in one of
        the: TIME_UNIT        = 0 LENGTH_UNIT      = 1 CELL_LENGTH_UNIT =
        2
        """
        ...
    
    def SetMinimumIntegrationStep(self, p_int, p_float):
        """
        V.SetMinimumIntegrationStep(int, float)
        C++: void SetMinimumIntegrationStep(int unit, double step)
        V.SetMinimumIntegrationStep(float)
        C++: void SetMinimumIntegrationStep(double step)
        
        Specify the minimum step used in the integration expressed in one
        of the: TIME_UNIT        = 0 LENGTH_UNIT      = 1
        CELL_LENGTH_UNIT = 2 Only valid when using adaptive integrators.
        """
        ...
    
    def SetMinimumIntegrationStepUnit(self, p_int):
        """
        V.SetMinimumIntegrationStepUnit(int)
        C++: void SetMinimumIntegrationStepUnit(int unit)
        
        Specify the minimum step used in the integration expressed in one
        of the: TIME_UNIT        = 0 LENGTH_UNIT      = 1
        CELL_LENGTH_UNIT = 2 Only valid when using adaptive integrators.
        """
        ...
    
    def SetMinimumIntegrationStepUnitToCellLengthUnit(self):
        """
        V.SetMinimumIntegrationStepUnitToCellLengthUnit()
        C++: void SetMinimumIntegrationStepUnitToCellLengthUnit()
        
        Specify the minimum step used in the integration expressed in one
        of the: TIME_UNIT        = 0 LENGTH_UNIT      = 1
        CELL_LENGTH_UNIT = 2 Only valid when using adaptive integrators.
        """
        ...
    
    def SetMinimumIntegrationStepUnitToLengthUnit(self):
        """
        V.SetMinimumIntegrationStepUnitToLengthUnit()
        C++: void SetMinimumIntegrationStepUnitToLengthUnit()
        
        Specify the minimum step used in the integration expressed in one
        of the: TIME_UNIT        = 0 LENGTH_UNIT      = 1
        CELL_LENGTH_UNIT = 2 Only valid when using adaptive integrators.
        """
        ...
    
    def SetMinimumIntegrationStepUnitToTimeUnit(self):
        """
        V.SetMinimumIntegrationStepUnitToTimeUnit()
        C++: void SetMinimumIntegrationStepUnitToTimeUnit()
        
        Specify the minimum step used in the integration expressed in one
        of the: TIME_UNIT        = 0 LENGTH_UNIT      = 1
        CELL_LENGTH_UNIT = 2 Only valid when using adaptive integrators.
        """
        ...
    
    def SetRotationScale(self, p_float):
        """
        V.SetRotationScale(float)
        C++: virtual void SetRotationScale(double _arg)
        
        This can be used to scale the rate with which the streamribbons
        twist. The default is 1.
        """
        ...
    
    def SetSourceConnection(self, vtkAlgorithmOutput):
        """
        V.SetSourceConnection(vtkAlgorithmOutput)
        C++: void SetSourceConnection(vtkAlgorithmOutput *algOutput)
        
        Specify the source object used to generate starting points
        (seeds). New style.
        """
        ...
    
    def SetSourceData(self, vtkDataSet):
        """
        V.SetSourceData(vtkDataSet)
        C++: void SetSourceData(vtkDataSet *source)
        
        Specify the source object used to generate starting points.
        """
        ...
    
    def SetStartPosition(self, p_float, p_float_1, p_float_2):
        """
        V.SetStartPosition(float, float, float)
        C++: virtual void SetStartPosition(double _arg1, double _arg2,
            double _arg3)
        V.SetStartPosition((float, float, float))
        C++: virtual void SetStartPosition(const double _arg[3])
        
        Specify the start of the streamline in the global coordinate
        system. Search must be performed to find initial cell to start
        integration from.
        """
        ...
    
    def SetTerminalSpeed(self, p_float):
        """
        V.SetTerminalSpeed(float)
        C++: virtual void SetTerminalSpeed(double _arg)
        
        If at any point, the speed is below this value, the integration
        is terminated.
        """
        ...
    
    def __delattr__(self, *args, **kwargs):
        """ Implement delattr(self, name). """
        ...
    
    def __getattribute__(self, *args, **kwargs):
        """ Return getattr(self, name). """
        ...
    
    def __init__(self, *args, **kwargs) -> None:
        ...
    
    @staticmethod
    def __new__(*args, **kwargs):
        """ Create and return a new object.  See help(type) for accurate signature. """
        ...
    
    def __repr__(self, *args, **kwargs):
        """ Return repr(self). """
        ...
    
    def __setattr__(self, *args, **kwargs):
        """ Implement setattr(self, name, value). """
        ...
    
    def __str__(self, *args, **kwargs) -> str:
        """ Return str(self). """
        ...
    
    __this__ = ...
    BACKWARD = ...
    BOTH = ...
    CELL_LENGTH_UNIT = ...
    FORWARD = ...
    LENGTH_UNIT = ...
    NONE = ...
    NOT_INITIALIZED = ...
    OUT_OF_DOMAIN = ...
    OUT_OF_STEPS = ...
    OUT_OF_TIME = ...
    ReasonForTermination = ...
    RUNGE_KUTTA2 = ...
    RUNGE_KUTTA4 = ...
    RUNGE_KUTTA45 = ...
    Solvers = ...
    STAGNATION = ...
    TIME_UNIT = ...
    UNEXPECTED_VALUE = ...
    Units = ...
    UNKNOWN = ...
    __dict__ = ...
    __vtkname__ = ...


__loader__ = ...
__spec__ = ...
