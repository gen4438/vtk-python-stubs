"""
This type stub file was generated by pyright.
"""

import vtkmodules.vtkCommonCore as __vtkmodules_vtkCommonCore

class vtkDataTransferHelper(__vtkmodules_vtkCommonCore.vtkObject):
    """
    vtkDataTransferHelper - is a helper class that aids in transferring
     data between CPU memory and GPU memory.
    
    Superclass: vtkObject
    
    vtkDataTransferHelper is a helper class that aids in transferring
    data
     between the CPU memory and the GPU memory. The data in GPU memory is
     stored as textures which that in CPU memory is stored as
    vtkDataArray.
     vtkDataTransferHelper provides API to transfer only a sub-extent of
    CPU
     structured data to/from the GPU.
    
    @sa
     vtkPixelBufferObject vtkTextureObject vtkOpenGLExtensionManager
    """
    def Download(self):
        """
        V.Download() -> bool
        C++: bool Download()
        
        old comment: Download Extent from GPU data buffer to CPU. GPU
        data size must exactly match Extent. CPU data buffer will be
        resized to match WholeExtent in which only the Extent will be
        filled with the GPU data. new comment: Download GPUExtent from
        GPU texture to CPU vtkDataArray. If Array is not provided, it
        will be created with the size of CPUExtent. But only the tuples
        covered by GPUExtent will be download. In this case, if GPUExtent
        does not cover all GPUExtent, some of the vtkDataArray will be
        uninitialized. Reminder: A=>B <=> !A||B
        \pre texture_exists: texture!=0
        \pre array_not_empty: array==0 || array->GetNumberOfTuples()>0
        \pre valid_cpu_extent: this->GetCPUExtentIsValid()
        \pre valid_cpu_extent_size: array==0 ||
        (CPUExtent[1]-CPUExtent[0]+1)*(CPUExtent[3]-CPUExtent[2]+1)*(CPUEx
        tent[5]-CPUExtent[4]+1)==array->GetNumberOfTuples()
        \pre valid_gpu_extent: this->GetGPUExtentIsValid()
        \pre gpu_extent_in_cpu_extent: CPUExtent[0]<=GPUExtent[0] &&
            GPUExtent[1]<=CPUExtent[1] &&
        CPUExtent[2]<=GPUExtent[2] && GPUExtent[3]<=CPUExtent[3] &&
        CPUExtent[4]<=GPUExtent[4] && GPUExtent[5]<=CPUExtent[5] \pre
        gpu_texture_size: !this->GetTextureExtentIsValid() ||
        (GPUExtent[1]-GPUExtent[0]+1)*(GPUExtent[3]-GPUExtent[2]+1)*(GPUEx
        tent[5]-GPUExtent[4]+1)==(TextureExtent[1]-TextureExtent[0]+1)*(Te
        xtureExtent[3]-TextureExtent[2]+1)*(TextureExtent[5]-TextureExtent
        [4]+1)
        \pre valid_components: array==0 ||
            array->GetNumberOfComponents()<=4
        \pre components_match: array==0 ||
            (texture->GetComponents()==array->GetNumberOfComponents())
        """
        ...
    
    def DownloadAsync1(self):
        """
        V.DownloadAsync1() -> bool
        C++: bool DownloadAsync1()
        
        Splits the download in two operations
        * Asynchronously download from texture memory to PBO
          (DownloadAsync1()).
        * Copy from pbo to user array (DownloadAsync2()).
        """
        ...
    
    def DownloadAsync2(self):
        """
        V.DownloadAsync2() -> bool
        C++: bool DownloadAsync2()
        
        Splits the download in two operations
        * Asynchronously download from texture memory to PBO
          (DownloadAsync1()).
        * Copy from pbo to user array (DownloadAsync2()).
        """
        ...
    
    def GetArray(self):
        """
        V.GetArray() -> vtkDataArray
        C++: virtual vtkDataArray *GetArray()
        
        Get/Set the CPU data buffer. Initial value is 0.
        """
        ...
    
    def GetContext(self):
        """
        V.GetContext() -> vtkRenderWindow
        C++: vtkRenderWindow *GetContext()
        
        Get/Set the context. Context must be a vtkOpenGLRenderWindow.
        This does not increase the reference count of the context to
        avoid reference loops. SetContext() may raise an error is the
        OpenGL context does not support the required OpenGL extensions.
        """
        ...
    
    def GetCPUExtent(self):
        """
        V.GetCPUExtent() -> (int, int, int, int, int, int)
        C++: virtual int *GetCPUExtent()
        
        Set the CPU data extent. The extent matches the vtkDataArray
        size. If the vtkDataArray comes from an vtkImageData and it is
        part of the point data, it is usually the vtkImageData extent. It
        can be on cell data too, but in this case it does not match the
        vtkImageData extent. If the vtkDataArray comes from a vtkDataSet,
        just set it to a one-dimenstional extent equal to the number of
        tuples. Initial value is (0,0,0,0,0,0), a valid one tuple array.
        """
        ...
    
    def GetCPUExtentIsValid(self):
        """
        V.GetCPUExtentIsValid() -> bool
        C++: bool GetCPUExtentIsValid()
        
        Tells if CPUExtent is valid. True if min extent<=max extent.
        """
        ...
    
    def GetExtentIsValid(self, *int):
        """
        V.GetExtentIsValid([int, ...]) -> bool
        C++: bool GetExtentIsValid(int *extent)
        
        Tells if the given extent (6 int) is valid. True if min
        extent<=max extent.
        \pre extent_exists: extent!=0
        """
        ...
    
    def GetGPUExtent(self):
        """
        V.GetGPUExtent() -> (int, int, int, int, int, int)
        C++: virtual int *GetGPUExtent()
        
        Set the GPU data extent. This is the sub-extent to copy from or
        to the GPU. This extent matches the size of the data to transfer.
        GPUExtent and TextureExtent don't have to match (GPUExtent can be
        1D whereas TextureExtent is 2D) but the number of elements have
        to match. Initial value is (0,0,0,0,0,0), a valid one tuple
        array.
        """
        ...
    
    def GetGPUExtentIsValid(self):
        """
        V.GetGPUExtentIsValid() -> bool
        C++: bool GetGPUExtentIsValid()
        
        Tells if GPUExtent is valid. True if min extent<=max extent.
        """
        ...
    
    def GetMinTextureDimension(self):
        """
        V.GetMinTextureDimension() -> int
        C++: virtual int GetMinTextureDimension()
        
        Define the minimal dimension of the texture regardless of the
        dimensions of the TextureExtent. Initial value is 1. A texture
        extent can have a given dimension 0D (one value), 1D, 2D or 3D.
        By default 0D and 1D are translated into a 1D texture, 2D is
        translated into a 2D texture, 3D is translated into a 3D texture.
        To make life easier when writing GLSL code and use only one type
        of sampler (ex: sampler2d), the default behavior can be changed
        by forcing a type of texture with this ivar. 1: default behavior.
        Initial value. 2: force 0D and 1D to be in a 2D texture 3: force
        0D, 1D and 2D texture to be in a 3D texture.
        """
        ...
    
    def GetNumberOfGenerationsFromBase(self, string):
        """
        V.GetNumberOfGenerationsFromBase(string) -> int
        C++: vtkIdType GetNumberOfGenerationsFromBase(const char *type)
            override;
        
        Given a the name of a base class of this class type, return the
        distance of inheritance between this class type and the named
        class (how many generations of inheritance are there between this
        class and the named class). If the named class is not in this
        class's inheritance tree, return a negative value. Valid
        responses will always be nonnegative. This method works in
        combination with vtkTypeMacro found in vtkSetGet.h.
        """
        ...
    
    def GetNumberOfGenerationsFromBaseType(self, string):
        """
        V.GetNumberOfGenerationsFromBaseType(string) -> int
        C++: static vtkIdType GetNumberOfGenerationsFromBaseType(
            const char *type)
        
        Given a the name of a base class of this class type, return the
        distance of inheritance between this class type and the named
        class (how many generations of inheritance are there between this
        class and the named class). If the named class is not in this
        class's inheritance tree, return a negative value. Valid
        responses will always be nonnegative. This method works in
        combination with vtkTypeMacro found in vtkSetGet.h.
        """
        ...
    
    def GetShaderSupportsTextureInt(self):
        """
        V.GetShaderSupportsTextureInt() -> bool
        C++: bool GetShaderSupportsTextureInt()
        """
        ...
    
    def GetTexture(self):
        """
        V.GetTexture() -> vtkTextureObject
        C++: virtual vtkTextureObject *GetTexture()
        
        Get/Set the GPU data buffer. Initial value is 0.
        """
        ...
    
    def GetTextureExtent(self):
        """
        V.GetTextureExtent() -> (int, int, int, int, int, int)
        C++: virtual int *GetTextureExtent()
        
        Set the texture data extent. This is the extent of the texture
        image that will receive the data. This extent matches the size of
        the data to transfer. If it is set to an invalid extent,
        GPUExtent is used. See more comment on GPUExtent. Initial value
        is an invalid extent.
        """
        ...
    
    def GetTextureExtentIsValid(self):
        """
        V.GetTextureExtentIsValid() -> bool
        C++: bool GetTextureExtentIsValid()
        
        Tells if TextureExtent is valid. True if min extent<=max extent.
        """
        ...
    
    def IsA(self, string):
        """
        V.IsA(string) -> int
        C++: vtkTypeBool IsA(const char *type) override;
        
        Return 1 if this class is the same type of (or a subclass of) the
        named class. Returns 0 otherwise. This method works in
        combination with vtkTypeMacro found in vtkSetGet.h.
        """
        ...
    
    def IsSupported(self, vtkRenderWindow):
        """
        V.IsSupported(vtkRenderWindow) -> bool
        C++: static bool IsSupported(vtkRenderWindow *renWin)
        
        Returns if the context supports the required extensions.
        """
        ...
    
    def IsTypeOf(self, string):
        """
        V.IsTypeOf(string) -> int
        C++: static vtkTypeBool IsTypeOf(const char *type)
        
        Return 1 if this class type is the same type of (or a subclass
        of) the named class. Returns 0 otherwise. This method works in
        combination with vtkTypeMacro found in vtkSetGet.h.
        """
        ...
    
    def NewInstance(self):
        """
        V.NewInstance() -> vtkDataTransferHelper
        C++: vtkDataTransferHelper *NewInstance()
        """
        ...
    
    def SafeDownCast(self, vtkObjectBase):
        """
        V.SafeDownCast(vtkObjectBase) -> vtkDataTransferHelper
        C++: static vtkDataTransferHelper *SafeDownCast(vtkObjectBase *o)
        """
        ...
    
    def SetArray(self, vtkDataArray):
        """
        V.SetArray(vtkDataArray)
        C++: void SetArray(vtkDataArray *array)
        
        Get/Set the CPU data buffer. Initial value is 0.
        """
        ...
    
    def SetContext(self, vtkRenderWindow):
        """
        V.SetContext(vtkRenderWindow)
        C++: void SetContext(vtkRenderWindow *context)
        
        Get/Set the context. Context must be a vtkOpenGLRenderWindow.
        This does not increase the reference count of the context to
        avoid reference loops. SetContext() may raise an error is the
        OpenGL context does not support the required OpenGL extensions.
        """
        ...
    
    def SetCPUExtent(self, p_int, p_int_1, p_int_2, p_int_3, p_int_4, p_int_5):
        """
        V.SetCPUExtent(int, int, int, int, int, int)
        C++: virtual void SetCPUExtent(int _arg1, int _arg2, int _arg3,
            int _arg4, int _arg5, int _arg6)
        V.SetCPUExtent((int, int, int, int, int, int))
        C++: virtual void SetCPUExtent(const int _arg[6])
        
        Set the CPU data extent. The extent matches the vtkDataArray
        size. If the vtkDataArray comes from an vtkImageData and it is
        part of the point data, it is usually the vtkImageData extent. It
        can be on cell data too, but in this case it does not match the
        vtkImageData extent. If the vtkDataArray comes from a vtkDataSet,
        just set it to a one-dimenstional extent equal to the number of
        tuples. Initial value is (0,0,0,0,0,0), a valid one tuple array.
        """
        ...
    
    def SetGPUExtent(self, p_int, p_int_1, p_int_2, p_int_3, p_int_4, p_int_5):
        """
        V.SetGPUExtent(int, int, int, int, int, int)
        C++: virtual void SetGPUExtent(int _arg1, int _arg2, int _arg3,
            int _arg4, int _arg5, int _arg6)
        V.SetGPUExtent((int, int, int, int, int, int))
        C++: virtual void SetGPUExtent(const int _arg[6])
        
        Set the GPU data extent. This is the sub-extent to copy from or
        to the GPU. This extent matches the size of the data to transfer.
        GPUExtent and TextureExtent don't have to match (GPUExtent can be
        1D whereas TextureExtent is 2D) but the number of elements have
        to match. Initial value is (0,0,0,0,0,0), a valid one tuple
        array.
        """
        ...
    
    def SetMinTextureDimension(self, p_int):
        """
        V.SetMinTextureDimension(int)
        C++: virtual void SetMinTextureDimension(int _arg)
        
        Define the minimal dimension of the texture regardless of the
        dimensions of the TextureExtent. Initial value is 1. A texture
        extent can have a given dimension 0D (one value), 1D, 2D or 3D.
        By default 0D and 1D are translated into a 1D texture, 2D is
        translated into a 2D texture, 3D is translated into a 3D texture.
        To make life easier when writing GLSL code and use only one type
        of sampler (ex: sampler2d), the default behavior can be changed
        by forcing a type of texture with this ivar. 1: default behavior.
        Initial value. 2: force 0D and 1D to be in a 2D texture 3: force
        0D, 1D and 2D texture to be in a 3D texture.
        """
        ...
    
    def SetShaderSupportsTextureInt(self, bool):
        """
        V.SetShaderSupportsTextureInt(bool)
        C++: void SetShaderSupportsTextureInt(bool value)
        """
        ...
    
    def SetTexture(self, vtkTextureObject):
        """
        V.SetTexture(vtkTextureObject)
        C++: void SetTexture(vtkTextureObject *texture)
        
        Get/Set the GPU data buffer. Initial value is 0.
        """
        ...
    
    def SetTextureExtent(self, p_int, p_int_1, p_int_2, p_int_3, p_int_4, p_int_5):
        """
        V.SetTextureExtent(int, int, int, int, int, int)
        C++: virtual void SetTextureExtent(int _arg1, int _arg2,
            int _arg3, int _arg4, int _arg5, int _arg6)
        V.SetTextureExtent((int, int, int, int, int, int))
        C++: virtual void SetTextureExtent(const int _arg[6])
        
        Set the texture data extent. This is the extent of the texture
        image that will receive the data. This extent matches the size of
        the data to transfer. If it is set to an invalid extent,
        GPUExtent is used. See more comment on GPUExtent. Initial value
        is an invalid extent.
        """
        ...
    
    def Upload(self, p_int, *int):
        """
        V.Upload(int, [int, ...]) -> bool
        C++: bool Upload(int components=0, int *componentList=nullptr)
        
        Old comment. Upload Extent from CPU data buffer to GPU. The
        WholeExtent must match the Array size. New comment. Upload
        GPUExtent from CPU vtkDataArray to GPU texture. It is possible to
        send a subset of the components or to specify and order of
        components or both. If components=0, componentList is ignored and
        all components are passed, a texture cannot have more than 4
        components.
        \pre array_exists: array!=0
        \pre array_not_empty: array->GetNumberOfTuples()>0
        \pre valid_cpu_extent: this->GetCPUExtentIsValid()
        \pre valid_cpu_extent_size:
        (CPUExtent[1]-CPUExtent[0]+1)*(CPUExtent[3]-CPUExtent[2]+1)*(CPUEx
        tent[5]-CPUExtent[4]+1)==array->GetNumberOfTuples()
        \pre valid_gpu_extent: this->GetGPUExtentIsValid()
        \pre gpu_extent_in_cpu_extent: CPUExtent[0]<=GPUExtent[0] &&
            GPUExtent[1]<=CPUExtent[1] &&
        CPUExtent[2]<=GPUExtent[2] && GPUExtent[3]<=CPUExtent[3] &&
        CPUExtent[4]<=GPUExtent[4] && GPUExtent[5]<=CPUExtent[5] \pre
        gpu_texture_size: !this->GetTextureExtentIsValid() ||
        (GPUExtent[1]-GPUExtent[0]+1)*(GPUExtent[3]-GPUExtent[2]+1)*(GPUEx
        tent[5]-GPUExtent[4]+1)==(TextureExtent[1]-TextureExtent[0]+1)*(Te
        xtureExtent[3]-TextureExtent[2]+1)*(TextureExtent[5]-TextureExtent
        [4]+1)
        \pre texture_can_exist_or_not: texture==0 || texture!=0
        \pre valid_components: (components==0 && componentList==0 &&
            array->GetNumberOfComponents()<=4)
        || (components>=1 && components<=array->GetNumberOfComponents()
        && components<=4 && componentList!=0)
        """
        ...
    
    def __delattr__(self, *args, **kwargs):
        """ Implement delattr(self, name). """
        ...
    
    def __getattribute__(self, *args, **kwargs):
        """ Return getattr(self, name). """
        ...
    
    def __init__(self, *args, **kwargs) -> None:
        ...
    
    @staticmethod
    def __new__(*args, **kwargs):
        """ Create and return a new object.  See help(type) for accurate signature. """
        ...
    
    def __repr__(self, *args, **kwargs):
        """ Return repr(self). """
        ...
    
    def __setattr__(self, *args, **kwargs):
        """ Implement setattr(self, name, value). """
        ...
    
    def __str__(self, *args, **kwargs) -> str:
        """ Return str(self). """
        ...
    
    __this__ = ...
    __dict__ = ...
    __vtkname__ = ...


