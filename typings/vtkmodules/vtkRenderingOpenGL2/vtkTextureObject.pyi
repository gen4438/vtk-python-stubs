"""
This type stub file was generated by pyright.
"""

import vtkmodules.vtkCommonCore as __vtkmodules_vtkCommonCore

class vtkTextureObject(__vtkmodules_vtkCommonCore.vtkObject):
    """
    vtkTextureObject - abstracts an OpenGL texture object.
    
    Superclass: vtkObject
    
    vtkTextureObject represents an OpenGL texture object. It provides API
    to create textures using data already loaded into pixel buffer
    objects. It can also be used to create textures without uploading any
    data.
    """
    def Activate(self):
        """
        V.Activate()
        C++: virtual void Activate()
        
        Activate and Bind the texture
        """
        ...
    
    def Allocate1D(self, p_int, p_int_1, p_int_2):
        """
        V.Allocate1D(int, int, int) -> bool
        C++: bool Allocate1D(unsigned int width, int numComps,
            int vtkType)
        
        Create a 1D color texture but does not initialize its values.
        Internal format is deduced from numComps and vtkType.
        """
        ...
    
    def Allocate2D(self, p_int, p_int_1, p_int_2, p_int_3, p_int_4):
        """
        V.Allocate2D(int, int, int, int, int) -> bool
        C++: bool Allocate2D(unsigned int width, unsigned int height,
            int numComps, int vtkType, int level=0)
        
        Create a 2D color texture but does not initialize its values.
        Internal format is deduced from numComps and vtkType.
        """
        ...
    
    def Allocate3D(self, p_int, p_int_1, p_int_2, p_int_3, p_int_4):
        """
        V.Allocate3D(int, int, int, int, int) -> bool
        C++: bool Allocate3D(unsigned int width, unsigned int height,
            unsigned int depth, int numComps, int vtkType)
        
        Create a 3D color texture but does not initialize its values.
        Internal format is deduced from numComps and vtkType.
        """
        ...
    
    def AllocateDepth(self, p_int, p_int_1, p_int_2):
        """
        V.AllocateDepth(int, int, int) -> bool
        C++: bool AllocateDepth(unsigned int width, unsigned int height,
            int internalFormat)
        
        Create a 2D depth texture but does not initialize its values.
        """
        ...
    
    def AllocateDepthStencil(self, p_int, p_int_1):
        """
        V.AllocateDepthStencil(int, int) -> bool
        C++: bool AllocateDepthStencil(unsigned int width,
            unsigned int height)
        
        Create a 2D septh stencil texture but does not initialize its
        values.
        """
        ...
    
    def AllocateProxyTexture3D(self, p_int, p_int_1, p_int_2, p_int_3, p_int_4):
        """
        V.AllocateProxyTexture3D(int, int, int, int, int) -> bool
        C++: bool AllocateProxyTexture3D(unsigned int const width,
            unsigned int const height, unsigned int const depth,
            int const numComps, int const dataType)
        
        Create a 3D texture using the GL_PROXY_TEXTURE_3D target.  This
        serves as a pre-allocation step which assists in verifying that
        the size of the texture to be created is supported by the
        implementation and that there is sufficient texture memory
        available for it.
        """
        ...
    
    def AssignToExistingTexture(self, p_int, p_int_1):
        """
        V.AssignToExistingTexture(int, int)
        C++: void AssignToExistingTexture(unsigned int handle,
            unsigned int target)
        
        Assign the TextureObject to a externally provided Handle and
        Target. This class will not delete the texture referenced by the
        handle upon releasing. That is up to whoever created it
        originally. Note that activating and binding will work.
        Properties such as wrap/interpolate will also work. But
        width/height/format etc are left unset.
        """
        ...
    
    def AutoParametersOff(self):
        """
        V.AutoParametersOff()
        C++: virtual void AutoParametersOff()
        
        Get/Set AutoParameters flag. When enabled, SendParameters method
        is called automatically when the texture is bound.
        """
        ...
    
    def AutoParametersOn(self):
        """
        V.AutoParametersOn()
        C++: virtual void AutoParametersOn()
        
        Get/Set AutoParameters flag. When enabled, SendParameters method
        is called automatically when the texture is bound.
        """
        ...
    
    def Bind(self):
        """
        V.Bind()
        C++: void Bind()
        
        Bind the texture, must have been created using Create(). A side
        affect is that tex parameters are sent. RenderWindow must be set
        before calling this.
        """
        ...
    
    def CopyFromFrameBuffer(self, p_int, p_int_1, p_int_2, p_int_3, p_int_4, p_int_5):
        """
        V.CopyFromFrameBuffer(int, int, int, int, int, int)
        C++: void CopyFromFrameBuffer(int srcXmin, int srcYmin,
            int dstXmin, int dstYmin, int width, int height)
        
        Copy a sub-part of a logical buffer of the framebuffer (color or
        depth) to the texture object. src is the framebuffer, dst is the
        texture. (srcXmin,srcYmin) is the location of the lower left
        corner of the rectangle in the framebuffer. (dstXmin,dstYmin) is
        the location of the lower left corner of the rectangle in the
        texture. width and height specifies the size of the rectangle in
        pixels. If the logical buffer is a color buffer, it has to be
        selected first with glReadBuffer().
        \pre is2D: GetNumberOfDimensions()==2
        """
        ...
    
    def CopyToFrameBuffer(self, vtkShaderProgram, vtkOpenGLVertexArrayObject):
        """
        V.CopyToFrameBuffer(vtkShaderProgram, vtkOpenGLVertexArrayObject)
        C++: void CopyToFrameBuffer(vtkShaderProgram *program,
            vtkOpenGLVertexArrayObject *vao)
        V.CopyToFrameBuffer(int, int, int, int, int, int, int, int, int,
            int, vtkShaderProgram, vtkOpenGLVertexArrayObject)
        C++: void CopyToFrameBuffer(int srcXmin, int srcYmin, int srcXmax,
             int srcYmax, int dstXmin, int dstYmin, int dstXmax,
            int dstYmax, int dstSizeX, int dstSizeY,
            vtkShaderProgram *program, vtkOpenGLVertexArrayObject *vao)
        V.CopyToFrameBuffer(int, int, int, int, int, int, int, int,
            vtkShaderProgram, vtkOpenGLVertexArrayObject)
        C++: void CopyToFrameBuffer(int srcXmin, int srcYmin, int srcXmax,
             int srcYmax, int dstXmin, int dstYmin, int dstSizeX,
            int dstSizeY, vtkShaderProgram *program,
            vtkOpenGLVertexArrayObject *vao)
        V.CopyToFrameBuffer([float, ...], [float, ...], vtkShaderProgram,
            vtkOpenGLVertexArrayObject)
        C++: void CopyToFrameBuffer(float *tcoords, float *verts,
            vtkShaderProgram *program, vtkOpenGLVertexArrayObject *vao)
        
        Copy the texture (src) in the current framebuffer.  A variety of
        signatures based on what you want to do Copy the entire texture
        to the entire current viewport
        """
        ...
    
    def Create1D(self, p_int, vtkPixelBufferObject, bool):
        """
        V.Create1D(int, vtkPixelBufferObject, bool) -> bool
        C++: bool Create1D(int numComps, vtkPixelBufferObject *pbo,
            bool shaderSupportsTextureInt)
        
        Create a 1D texture using the PBO. Eventually we may start
        supporting creating a texture from subset of data in the PBO, but
        for simplicity we'll begin with entire PBO data. numComps must be
        in [1-4]. shaderSupportsTextureInt is true if the shader has an
        alternate implementation supporting sampler with integer values.
        Even if the card supports texture int, it does not mean that the
        implementor of the shader made a version that supports texture
        int.
        """
        ...
    
    def Create1DFromRaw(self, p_int, p_int_1, p_int_2, void):
        """
        V.Create1DFromRaw(int, int, int, void) -> bool
        C++: bool Create1DFromRaw(unsigned int width, int numComps,
            int dataType, void *data)
        
        Create 1D texture from client memory
        """
        ...
    
    def Create2D(self, p_int, p_int_1, p_int_2, vtkPixelBufferObject, bool):
        """
        V.Create2D(int, int, int, vtkPixelBufferObject, bool) -> bool
        C++: bool Create2D(unsigned int width, unsigned int height,
            int numComps, vtkPixelBufferObject *pbo,
            bool shaderSupportsTextureInt)
        V.Create2D(int, int, int, int, bool) -> bool
        C++: bool Create2D(unsigned int width, unsigned int height,
            int numComps, int vtktype, bool)
        
        Create a 2D texture using the PBO. Eventually we may start
        supporting creating a texture from subset of data in the PBO, but
        for simplicity we'll begin with entire PBO data. numComps must be
        in [1-4].
        """
        ...
    
    def Create2DFromRaw(self, p_int, p_int_1, p_int_2, p_int_3, void):
        """
        V.Create2DFromRaw(int, int, int, int, void) -> bool
        C++: bool Create2DFromRaw(unsigned int width, unsigned int height,
             int numComps, int dataType, void *data)
        
        Create a 2D texture from client memory numComps must be in [1-4].
        """
        ...
    
    def Create3D(self, p_int, p_int_1, p_int_2, p_int_3, vtkPixelBufferObject, bool):
        """
        V.Create3D(int, int, int, int, vtkPixelBufferObject, bool) -> bool
        C++: bool Create3D(unsigned int width, unsigned int height,
            unsigned int depth, int numComps, vtkPixelBufferObject *pbo,
            bool shaderSupportsTextureInt)
        V.Create3D(int, int, int, int, int, bool) -> bool
        C++: bool Create3D(unsigned int width, unsigned int height,
            unsigned int depth, int numComps, int vtktype, bool)
        
        Create a 3D texture using the PBO. Eventually we may start
        supporting creating a texture from subset of data in the PBO, but
        for simplicity we'll begin with entire PBO data. numComps must be
        in [1-4].
        """
        ...
    
    def Create3DFromRaw(self, p_int, p_int_1, p_int_2, p_int_3, p_int_4, void):
        """
        V.Create3DFromRaw(int, int, int, int, int, void) -> bool
        C++: bool Create3DFromRaw(unsigned int width, unsigned int height,
             unsigned int depth, int numComps, int dataType, void *data)
        
        Create a 3D texture from client memory numComps must be in [1-4].
        """
        ...
    
    def CreateDepth(self, p_int, p_int_1, p_int_2, vtkPixelBufferObject):
        """
        V.CreateDepth(int, int, int, vtkPixelBufferObject) -> bool
        C++: bool CreateDepth(unsigned int width, unsigned int height,
            int internalFormat, vtkPixelBufferObject *pbo)
        
        Create a 2D depth texture using a PBO.
        \pre: valid_internalFormat: internalFormat>=0 &&
            internalFormat<NumberOfDepthFormats
        """
        ...
    
    def CreateDepthFromRaw(self, p_int, p_int_1, p_int_2, p_int_3, void):
        """
        V.CreateDepthFromRaw(int, int, int, int, void) -> bool
        C++: bool CreateDepthFromRaw(unsigned int width,
            unsigned int height, int internalFormat, int rawType,
            void *raw)
        
        Create a 2D depth texture using a raw pointer. This is a blocking
        call. If you can, use PBO instead. raw can be null in order to
        allocate texture without initialization.
        """
        ...
    
    def CreateTextureBuffer(self, p_int, p_int_1, p_int_2, vtkOpenGLBufferObject):
        """
        V.CreateTextureBuffer(int, int, int, vtkOpenGLBufferObject)
            -> bool
        C++: bool CreateTextureBuffer(unsigned int numValues,
            int numComps, int dataType, vtkOpenGLBufferObject *bo)
        
        Create a texture buffer basically a 1D texture that can be very
        large for passing data into the fragment shader
        """
        ...
    
    def Deactivate(self):
        """
        V.Deactivate()
        C++: void Deactivate()
        
        Deactivate and UnBind the texture
        """
        ...
    
    def Download(self):
        """
        V.Download() -> vtkPixelBufferObject
        C++: vtkPixelBufferObject *Download()
        V.Download(int, int) -> vtkPixelBufferObject
        C++: vtkPixelBufferObject *Download(unsigned int target,
            unsigned int level)
        
        This is used to download raw data from the texture into a pixel
        buffer. The pixel buffer API can then be used to download the
        pixel buffer data to CPU arrays. The caller takes on the
        responsibility of deleting the returns vtkPixelBufferObject once
        it done with it.
        """
        ...
    
    def GetAutoParameters(self):
        """
        V.GetAutoParameters() -> int
        C++: virtual int GetAutoParameters()
        
        Get/Set AutoParameters flag. When enabled, SendParameters method
        is called automatically when the texture is bound.
        """
        ...
    
    def GetBaseLevel(self):
        """
        V.GetBaseLevel() -> int
        C++: virtual int GetBaseLevel()
        
        Level of detail of the first texture image. A texture object is a
        list of texture images. It is a non-negative integer value.
        Initial value is 0, as in OpenGL spec.
        """
        ...
    
    def GetBorderColor(self):
        """
        V.GetBorderColor() -> (float, float, float, float)
        C++: virtual float *GetBorderColor()
        
        Border Color (RGBA). The values can be any valid float value, if
        the gpu supports it. Initial value is (0.0f, 0.0f, 0.0f, 0.0f),
        as in the OpenGL spec.
        """
        ...
    
    def GetComponents(self):
        """
        V.GetComponents() -> int
        C++: virtual int GetComponents()
        
        Get the texture dimensions. These are the properties of the
        OpenGL texture this instance represents.
        """
        ...
    
    def GetContext(self):
        """
        V.GetContext() -> vtkOpenGLRenderWindow
        C++: vtkOpenGLRenderWindow *GetContext()
        
        Get/Set the context. This does not increase the reference count
        of the context to avoid reference loops.
        
        * {
        * this->TextureObject = vtkTextureObject::New();
        * }SetContext() may raise an error is the OpenGL context does not
        support the
        * required OpenGL extensions.
        """
        ...
    
    def GetDataType(self, p_int):
        """
        V.GetDataType(int) -> int
        C++: int GetDataType(int vtk_scalar_type)
        
        Get the data type for the texture as GLenum type.
        """
        ...
    
    def GetDefaultDataType(self, p_int):
        """
        V.GetDefaultDataType(int) -> int
        C++: int GetDefaultDataType(int vtk_scalar_type)
        
        Get the data type for the texture as GLenum type.
        """
        ...
    
    def GetDefaultFormat(self, p_int, p_int_1, bool):
        """
        V.GetDefaultFormat(int, int, bool) -> int
        C++: unsigned int GetDefaultFormat(int vtktype, int numComps,
            bool shaderSupportsTextureInt)
        
        Get/Set format (OpenGL internal format) that should be used.
        (https://www.opengl.org/sdk/docs/man2/xhtml/glTexImage2D.xml)
        """
        ...
    
    def GetDefaultInternalFormat(self, p_int, p_int_1, bool):
        """
        V.GetDefaultInternalFormat(int, int, bool) -> int
        C++: unsigned int GetDefaultInternalFormat(int vtktype,
            int numComps, bool shaderSupportsTextureInt)
        
        Get/Set internal format (OpenGL internal format) that should be
        used.
        (https://www.opengl.org/sdk/docs/man2/xhtml/glTexImage2D.xml)
        """
        ...
    
    def GetDepth(self):
        """
        V.GetDepth() -> int
        C++: virtual unsigned int GetDepth()
        
        Get the texture dimensions. These are the properties of the
        OpenGL texture this instance represents.
        """
        ...
    
    def GetDepthTextureCompare(self):
        """
        V.GetDepthTextureCompare() -> bool
        C++: virtual bool GetDepthTextureCompare()
        
        Tells if the output of a texture unit with a depth texture uses
        comparison or not. Comparison happens between D_t the depth
        texture value in the range [0,1] and with R the interpolated
        third texture coordinate clamped to range [0,1]. The result of
        the comparison is noted `r'. If this flag is false, r=D_t.
        Initial value is false, as in OpenGL spec. Ignored if the texture
        object is not a depth texture.
        """
        ...
    
    def GetDepthTextureCompareFunction(self):
        """
        V.GetDepthTextureCompareFunction() -> int
        C++: virtual int GetDepthTextureCompareFunction()
        
        In case DepthTextureCompare is true, specify the comparison
        function in use. The result of the comparison is noted `r'. Valid
        values are:
        - Value
        - Lequal: r=R<=Dt ? 1.0 : 0.0
        - Gequal: r=R>=Dt ? 1.0 : 0.0
        - Less: r=R<D_t ? 1.0 : 0.0
        - Greater: r=R>Dt ? 1.0 : 0.0
        - Equal: r=R==Dt ? 1.0 : 0.0
        - NotEqual: r=R!=Dt ? 1.0 : 0.0
        - AlwaysTrue: r=1.0
        - Never: r=0.0 If the magnification of minification factor are
          not nearest, percentage closer filtering (PCF) is used: R is
          compared to several D_t and r is the average of the comparisons
        (it is NOT the average of D_t compared once to R). Initial value
          is Lequal, as in OpenGL spec. Ignored if the texture object is
          not a depth texture.
        """
        ...
    
    def GetFormat(self, p_int, p_int_1, bool):
        """
        V.GetFormat(int, int, bool) -> int
        C++: unsigned int GetFormat(int vtktype, int numComps,
            bool shaderSupportsTextureInt)
        
        Get/Set format (OpenGL internal format) that should be used.
        (https://www.opengl.org/sdk/docs/man2/xhtml/glTexImage2D.xml)
        """
        ...
    
    def GetGenerateMipmap(self):
        """
        V.GetGenerateMipmap() -> bool
        C++: virtual bool GetGenerateMipmap()
        
        Tells the hardware to generate mipmap textures from the first
        texture image at BaseLevel. Initial value is false, as in OpenGL
        spec.
        """
        ...
    
    def GetHandle(self):
        """
        V.GetHandle() -> int
        C++: virtual unsigned int GetHandle()
        
        Returns the OpenGL handle.
        """
        ...
    
    def GetHeight(self):
        """
        V.GetHeight() -> int
        C++: virtual unsigned int GetHeight()
        
        Get the texture dimensions. These are the properties of the
        OpenGL texture this instance represents.
        """
        ...
    
    def GetInternalFormat(self, p_int, p_int_1, bool):
        """
        V.GetInternalFormat(int, int, bool) -> int
        C++: unsigned int GetInternalFormat(int vtktype, int numComps,
            bool shaderSupportsTextureInt)
        
        Get/Set internal format (OpenGL internal format) that should be
        used.
        (https://www.opengl.org/sdk/docs/man2/xhtml/glTexImage2D.xml)
        """
        ...
    
    def GetLinearMagnification(self):
        """
        V.GetLinearMagnification() -> bool
        C++: bool GetLinearMagnification()
        """
        ...
    
    def GetMagnificationFilter(self):
        """
        V.GetMagnificationFilter() -> int
        C++: virtual int GetMagnificationFilter()
        
        Magnification filter mode. Valid values are:
        - Nearest
        - Linear Initial value is Nearest
        """
        ...
    
    def GetMagnificationFilterMode(self, p_int):
        """
        V.GetMagnificationFilterMode(int) -> int
        C++: unsigned int GetMagnificationFilterMode(int vtktype)
        """
        ...
    
    def GetMaximumAnisotropicFiltering(self):
        """
        V.GetMaximumAnisotropicFiltering() -> float
        C++: virtual float GetMaximumAnisotropicFiltering()
        
        Set/Get the maximum anisotropic filtering to use. 1.0 means use
        no anisotropic filtering. The default value is 1.0 and a high
        value would be 16. This might not be supported on all machines.
        """
        ...
    
    def GetMaximumTextureSize(self, vtkOpenGLRenderWindow):
        """
        V.GetMaximumTextureSize(vtkOpenGLRenderWindow) -> int
        C++: static int GetMaximumTextureSize(
            vtkOpenGLRenderWindow *context)
        
        Query and return maximum texture size (dimension) supported by
        the OpenGL driver for a particular context. It should be noted
        that this size does not consider the internal format of the
        texture and therefore there is no guarantee that a texture of
        this size will be allocated by the driver. Also, the method does
        not make the context current so if the passed context is not
        valid or current, a value of -1 will be returned.
        """
        ...
    
    def GetMaximumTextureSize3D(self, vtkOpenGLRenderWindow):
        """
        V.GetMaximumTextureSize3D(vtkOpenGLRenderWindow) -> int
        C++: static int GetMaximumTextureSize3D(
            vtkOpenGLRenderWindow *context)
        V.GetMaximumTextureSize3D() -> int
        C++: int GetMaximumTextureSize3D()
        
        Query and return maximum texture size (dimension) supported by
        the OpenGL driver for a particular context. It should be noted
        that this size does not consider the internal format of the
        texture and therefore there is no guarantee that a texture of
        this size will be allocated by the driver. Also, the method does
        not make the context current so if the passed context is not
        valid or current, a value of -1 will be returned.
        """
        ...
    
    def GetMaxLevel(self):
        """
        V.GetMaxLevel() -> int
        C++: virtual int GetMaxLevel()
        
        Level of detail of the first texture image. A texture object is a
        list of texture images. It is a non-negative integer value.
        Initial value is 1000, as in OpenGL spec.
        """
        ...
    
    def GetMaxLOD(self):
        """
        V.GetMaxLOD() -> float
        C++: virtual float GetMaxLOD()
        
        Upper-clamp the computed LOD against this value. Any float value
        is valid. Initial value is 1000.0f, as in OpenGL spec.
        """
        ...
    
    def GetMinificationFilter(self):
        """
        V.GetMinificationFilter() -> int
        C++: virtual int GetMinificationFilter()
        
        Minification filter mode. Valid values are:
        - Nearest
        - Linear
        - NearestMipmapNearest
        - NearestMipmapLinear
        - LinearMipmapNearest
        - LinearMipmapLinear Initial value is Nearest (note initial value
        in OpenGL spec is NearestMipMapLinear but this is error-prone
          because it makes the texture object incomplete. ).
        """
        ...
    
    def GetMinificationFilterMode(self, p_int):
        """
        V.GetMinificationFilterMode(int) -> int
        C++: unsigned int GetMinificationFilterMode(int vtktype)
        """
        ...
    
    def GetMinLOD(self):
        """
        V.GetMinLOD() -> float
        C++: virtual float GetMinLOD()
        
        Lower-clamp the computed LOD against this value. Any float value
        is valid. Initial value is -1000.0f, as in OpenGL spec.
        """
        ...
    
    def GetNumberOfDimensions(self):
        """
        V.GetNumberOfDimensions() -> int
        C++: virtual int GetNumberOfDimensions()
        """
        ...
    
    def GetNumberOfGenerationsFromBase(self, string):
        """
        V.GetNumberOfGenerationsFromBase(string) -> int
        C++: vtkIdType GetNumberOfGenerationsFromBase(const char *type)
            override;
        
        Given a the name of a base class of this class type, return the
        distance of inheritance between this class type and the named
        class (how many generations of inheritance are there between this
        class and the named class). If the named class is not in this
        class's inheritance tree, return a negative value. Valid
        responses will always be nonnegative. This method works in
        combination with vtkTypeMacro found in vtkSetGet.h.
        """
        ...
    
    def GetNumberOfGenerationsFromBaseType(self, string):
        """
        V.GetNumberOfGenerationsFromBaseType(string) -> int
        C++: static vtkIdType GetNumberOfGenerationsFromBaseType(
            const char *type)
        
        Given a the name of a base class of this class type, return the
        distance of inheritance between this class type and the named
        class (how many generations of inheritance are there between this
        class and the named class). If the named class is not in this
        class's inheritance tree, return a negative value. Valid
        responses will always be nonnegative. This method works in
        combination with vtkTypeMacro found in vtkSetGet.h.
        """
        ...
    
    def GetRequireDepthBufferFloat(self):
        """
        V.GetRequireDepthBufferFloat() -> bool
        C++: virtual bool GetRequireDepthBufferFloat()
        
        Optional, require support for floating point depth buffer
        formats. If supported extensions will be loaded, however loading
        will fail if the extension is required but not available.
        """
        ...
    
    def GetRequireTextureFloat(self):
        """
        V.GetRequireTextureFloat() -> bool
        C++: virtual bool GetRequireTextureFloat()
        
        Optional, require support for floating point texture formats. If
        supported extensions will be loaded, however loading will fail if
        the extension is required but not available.
        """
        ...
    
    def GetRequireTextureInteger(self):
        """
        V.GetRequireTextureInteger() -> bool
        C++: virtual bool GetRequireTextureInteger()
        
        Optional, require support for integer texture formats. If
        supported extensions will be loaded, however loading will fail if
        the extension is required but not available.
        """
        ...
    
    def GetSamples(self):
        """
        V.GetSamples() -> int
        C++: virtual unsigned int GetSamples()
        
        Get the texture dimensions. These are the properties of the
        OpenGL texture this instance represents.
        """
        ...
    
    def GetShiftAndScale(self, p_float, p_float_1):
        """
        V.GetShiftAndScale(float, float)
        C++: void GetShiftAndScale(float &shift, float &scale)
        
        Get the shift and scale required in the shader to return the
        texture values to their original range. This is useful when for
        example you have unsigned char data and it is being accessed
        using the floating point texture calls. In that case OpenGL maps
        the uchar range to a different floating point range under the
        hood. Applying the shift and scale will return the data to its
        original values in the shader. The texture's internal format must
        be set before calling these routines. Creating the texture does
        set it.
        """
        ...
    
    def GetSupportsDepthBufferFloat(self):
        """
        V.GetSupportsDepthBufferFloat() -> bool
        C++: virtual bool GetSupportsDepthBufferFloat()
        
        Optional, require support for floating point depth buffer
        formats. If supported extensions will be loaded, however loading
        will fail if the extension is required but not available.
        """
        ...
    
    def GetSupportsTextureFloat(self):
        """
        V.GetSupportsTextureFloat() -> bool
        C++: virtual bool GetSupportsTextureFloat()
        
        Optional, require support for floating point texture formats. If
        supported extensions will be loaded, however loading will fail if
        the extension is required but not available.
        """
        ...
    
    def GetSupportsTextureInteger(self):
        """
        V.GetSupportsTextureInteger() -> bool
        C++: virtual bool GetSupportsTextureInteger()
        
        Optional, require support for integer texture formats. If
        supported extensions will be loaded, however loading will fail if
        the extension is required but not available.
        """
        ...
    
    def GetTarget(self):
        """
        V.GetTarget() -> int
        C++: virtual unsigned int GetTarget()
        
        Returns OpenGL texture target to which the texture is/can be
        bound.
        """
        ...
    
    def GetTextureUnit(self):
        """
        V.GetTextureUnit() -> int
        C++: int GetTextureUnit()
        
        Return the texture unit used for this texture
        """
        ...
    
    def GetTuples(self):
        """
        V.GetTuples() -> int
        C++: unsigned int GetTuples()
        
        Get the texture dimensions. These are the properties of the
        OpenGL texture this instance represents.
        """
        ...
    
    def GetUseSRGBColorSpace(self):
        """
        V.GetUseSRGBColorSpace() -> bool
        C++: virtual bool GetUseSRGBColorSpace()
        
        Is this texture using the sRGB color space. If you are using a
        sRGB framebuffer or window then you probably also want to be
        using sRGB color textures for proper handling of gamma and
        associated color mixing.
        """
        ...
    
    def GetVTKDataType(self):
        """
        V.GetVTKDataType() -> int
        C++: int GetVTKDataType()
        
        Get the data type for the texture as a vtk type int i.e. VTK_INT
        etc.
        """
        ...
    
    def GetWidth(self):
        """
        V.GetWidth() -> int
        C++: virtual unsigned int GetWidth()
        
        Get the texture dimensions. These are the properties of the
        OpenGL texture this instance represents.
        """
        ...
    
    def GetWrapR(self):
        """
        V.GetWrapR() -> int
        C++: virtual int GetWrapR()
        
        Wrap mode for the first texture coordinate "r" Valid values are:
        - Clamp
        - ClampToEdge
        - Repeat
        - ClampToBorder
        - MirroredRepeat Initial value is Repeat (as in OpenGL spec)
        """
        ...
    
    def GetWrapRMode(self, p_int):
        """
        V.GetWrapRMode(int) -> int
        C++: unsigned int GetWrapRMode(int vtktype)
        """
        ...
    
    def GetWrapS(self):
        """
        V.GetWrapS() -> int
        C++: virtual int GetWrapS()
        
        Wrap mode for the first texture coordinate "s" Valid values are:
        - Clamp
        - ClampToEdge
        - Repeat
        - ClampToBorder
        - MirroredRepeat Initial value is Repeat (as in OpenGL spec)
        """
        ...
    
    def GetWrapSMode(self, p_int):
        """
        V.GetWrapSMode(int) -> int
        C++: unsigned int GetWrapSMode(int vtktype)
        """
        ...
    
    def GetWrapT(self):
        """
        V.GetWrapT() -> int
        C++: virtual int GetWrapT()
        
        Wrap mode for the first texture coordinate "t" Valid values are:
        - Clamp
        - ClampToEdge
        - Repeat
        - ClampToBorder
        - MirroredRepeat Initial value is Repeat (as in OpenGL spec)
        """
        ...
    
    def GetWrapTMode(self, p_int):
        """
        V.GetWrapTMode(int) -> int
        C++: unsigned int GetWrapTMode(int vtktype)
        """
        ...
    
    def IsA(self, string):
        """
        V.IsA(string) -> int
        C++: vtkTypeBool IsA(const char *type) override;
        
        Return 1 if this class is the same type of (or a subclass of) the
        named class. Returns 0 otherwise. This method works in
        combination with vtkTypeMacro found in vtkSetGet.h.
        """
        ...
    
    def IsBound(self):
        """
        V.IsBound() -> bool
        C++: bool IsBound()
        
        Tells if the texture object is bound to the active texture image
        unit. (a texture object can be bound to multiple texture image
        unit).
        """
        ...
    
    def IsSupported(self, vtkOpenGLRenderWindow, bool, bool_1, bool_2):
        """
        V.IsSupported(vtkOpenGLRenderWindow, bool, bool, bool) -> bool
        C++: static bool IsSupported(vtkOpenGLRenderWindow *, bool, bool,
            bool)
        V.IsSupported(vtkOpenGLRenderWindow) -> bool
        C++: static bool IsSupported(vtkOpenGLRenderWindow *)
        
        Returns if the context supports the required extensions. If flags
        for optional extensions are set then the test fails when support
        for them is not found.
        """
        ...
    
    def IsTypeOf(self, string):
        """
        V.IsTypeOf(string) -> int
        C++: static vtkTypeBool IsTypeOf(const char *type)
        
        Return 1 if this class type is the same type of (or a subclass
        of) the named class. Returns 0 otherwise. This method works in
        combination with vtkTypeMacro found in vtkSetGet.h.
        """
        ...
    
    def NewInstance(self):
        """
        V.NewInstance() -> vtkTextureObject
        C++: vtkTextureObject *NewInstance()
        """
        ...
    
    def ReleaseGraphicsResources(self, vtkWindow):
        """
        V.ReleaseGraphicsResources(vtkWindow)
        C++: virtual void ReleaseGraphicsResources(vtkWindow *win)
        
        Deactivate and UnBind the texture
        """
        ...
    
    def ResetFormatAndType(self):
        """
        V.ResetFormatAndType()
        C++: void ResetFormatAndType()
        
        Reset format, internal format, and type of the texture.
        
        * This method is useful when a texture is reused in a
        * context same as the previous render call. In such
        * cases, texture destruction does not happen and therefore
        * previous set values are used.
        """
        ...
    
    def Resize(self, p_int, p_int_1):
        """
        V.Resize(int, int)
        C++: void Resize(unsigned int width, unsigned int height)
        """
        ...
    
    def SafeDownCast(self, vtkObjectBase):
        """
        V.SafeDownCast(vtkObjectBase) -> vtkTextureObject
        C++: static vtkTextureObject *SafeDownCast(vtkObjectBase *o)
        """
        ...
    
    def SendParameters(self):
        """
        V.SendParameters()
        C++: void SendParameters()
        
        Send all the texture object parameters to the hardware if not
        done yet. Parameters are automatically sent as a side affect of
        Bind. Disable this by setting AutoParameters 0.
        \pre is_bound: IsBound()
        """
        ...
    
    def SetAutoParameters(self, p_int):
        """
        V.SetAutoParameters(int)
        C++: virtual void SetAutoParameters(int _arg)
        
        Get/Set AutoParameters flag. When enabled, SendParameters method
        is called automatically when the texture is bound.
        """
        ...
    
    def SetBaseLevel(self, p_int):
        """
        V.SetBaseLevel(int)
        C++: virtual void SetBaseLevel(int _arg)
        
        Level of detail of the first texture image. A texture object is a
        list of texture images. It is a non-negative integer value.
        Initial value is 0, as in OpenGL spec.
        """
        ...
    
    def SetBorderColor(self, p_float, p_float_1, p_float_2, p_float_3):
        """
        V.SetBorderColor(float, float, float, float)
        C++: virtual void SetBorderColor(float _arg1, float _arg2,
            float _arg3, float _arg4)
        V.SetBorderColor((float, float, float, float))
        C++: virtual void SetBorderColor(const float _arg[4])
        
        Border Color (RGBA). The values can be any valid float value, if
        the gpu supports it. Initial value is (0.0f, 0.0f, 0.0f, 0.0f),
        as in the OpenGL spec.
        """
        ...
    
    def SetContext(self, vtkOpenGLRenderWindow):
        """
        V.SetContext(vtkOpenGLRenderWindow)
        C++: void SetContext(vtkOpenGLRenderWindow *)
        
        Get/Set the context. This does not increase the reference count
        of the context to avoid reference loops.
        
        * {
        * this->TextureObject = vtkTextureObject::New();
        * }SetContext() may raise an error is the OpenGL context does not
        support the
        * required OpenGL extensions.
        """
        ...
    
    def SetDataType(self, p_int):
        """
        V.SetDataType(int)
        C++: void SetDataType(unsigned int glType)
        
        Get the data type for the texture as GLenum type.
        """
        ...
    
    def SetDepthTextureCompare(self, bool):
        """
        V.SetDepthTextureCompare(bool)
        C++: virtual void SetDepthTextureCompare(bool _arg)
        
        Tells if the output of a texture unit with a depth texture uses
        comparison or not. Comparison happens between D_t the depth
        texture value in the range [0,1] and with R the interpolated
        third texture coordinate clamped to range [0,1]. The result of
        the comparison is noted `r'. If this flag is false, r=D_t.
        Initial value is false, as in OpenGL spec. Ignored if the texture
        object is not a depth texture.
        """
        ...
    
    def SetDepthTextureCompareFunction(self, p_int):
        """
        V.SetDepthTextureCompareFunction(int)
        C++: virtual void SetDepthTextureCompareFunction(int _arg)
        
        In case DepthTextureCompare is true, specify the comparison
        function in use. The result of the comparison is noted `r'. Valid
        values are:
        - Value
        - Lequal: r=R<=Dt ? 1.0 : 0.0
        - Gequal: r=R>=Dt ? 1.0 : 0.0
        - Less: r=R<D_t ? 1.0 : 0.0
        - Greater: r=R>Dt ? 1.0 : 0.0
        - Equal: r=R==Dt ? 1.0 : 0.0
        - NotEqual: r=R!=Dt ? 1.0 : 0.0
        - AlwaysTrue: r=1.0
        - Never: r=0.0 If the magnification of minification factor are
          not nearest, percentage closer filtering (PCF) is used: R is
          compared to several D_t and r is the average of the comparisons
        (it is NOT the average of D_t compared once to R). Initial value
          is Lequal, as in OpenGL spec. Ignored if the texture object is
          not a depth texture.
        """
        ...
    
    def SetFormat(self, p_int):
        """
        V.SetFormat(int)
        C++: void SetFormat(unsigned int glFormat)
        
        Get/Set format (OpenGL internal format) that should be used.
        (https://www.opengl.org/sdk/docs/man2/xhtml/glTexImage2D.xml)
        """
        ...
    
    def SetGenerateMipmap(self, bool):
        """
        V.SetGenerateMipmap(bool)
        C++: virtual void SetGenerateMipmap(bool _arg)
        
        Tells the hardware to generate mipmap textures from the first
        texture image at BaseLevel. Initial value is false, as in OpenGL
        spec.
        """
        ...
    
    def SetInternalFormat(self, p_int):
        """
        V.SetInternalFormat(int)
        C++: void SetInternalFormat(unsigned int glInternalFormat)
        
        Get/Set internal format (OpenGL internal format) that should be
        used.
        (https://www.opengl.org/sdk/docs/man2/xhtml/glTexImage2D.xml)
        """
        ...
    
    def SetLinearMagnification(self, bool):
        """
        V.SetLinearMagnification(bool)
        C++: void SetLinearMagnification(bool val)
        
        Tells if the magnification mode is linear (true) or nearest
        (false). Initial value is false (initial value in OpenGL spec is
        true).
        """
        ...
    
    def SetMagnificationFilter(self, p_int):
        """
        V.SetMagnificationFilter(int)
        C++: virtual void SetMagnificationFilter(int _arg)
        
        Magnification filter mode. Valid values are:
        - Nearest
        - Linear Initial value is Nearest
        """
        ...
    
    def SetMaximumAnisotropicFiltering(self, p_float):
        """
        V.SetMaximumAnisotropicFiltering(float)
        C++: virtual void SetMaximumAnisotropicFiltering(float _arg)
        
        Set/Get the maximum anisotropic filtering to use. 1.0 means use
        no anisotropic filtering. The default value is 1.0 and a high
        value would be 16. This might not be supported on all machines.
        """
        ...
    
    def SetMaxLevel(self, p_int):
        """
        V.SetMaxLevel(int)
        C++: virtual void SetMaxLevel(int _arg)
        
        Level of detail of the first texture image. A texture object is a
        list of texture images. It is a non-negative integer value.
        Initial value is 1000, as in OpenGL spec.
        """
        ...
    
    def SetMaxLOD(self, p_float):
        """
        V.SetMaxLOD(float)
        C++: virtual void SetMaxLOD(float _arg)
        
        Upper-clamp the computed LOD against this value. Any float value
        is valid. Initial value is 1000.0f, as in OpenGL spec.
        """
        ...
    
    def SetMinificationFilter(self, p_int):
        """
        V.SetMinificationFilter(int)
        C++: virtual void SetMinificationFilter(int _arg)
        
        Minification filter mode. Valid values are:
        - Nearest
        - Linear
        - NearestMipmapNearest
        - NearestMipmapLinear
        - LinearMipmapNearest
        - LinearMipmapLinear Initial value is Nearest (note initial value
        in OpenGL spec is NearestMipMapLinear but this is error-prone
          because it makes the texture object incomplete. ).
        """
        ...
    
    def SetMinLOD(self, p_float):
        """
        V.SetMinLOD(float)
        C++: virtual void SetMinLOD(float _arg)
        
        Lower-clamp the computed LOD against this value. Any float value
        is valid. Initial value is -1000.0f, as in OpenGL spec.
        """
        ...
    
    def SetRequireDepthBufferFloat(self, bool):
        """
        V.SetRequireDepthBufferFloat(bool)
        C++: virtual void SetRequireDepthBufferFloat(bool _arg)
        
        Optional, require support for floating point depth buffer
        formats. If supported extensions will be loaded, however loading
        will fail if the extension is required but not available.
        """
        ...
    
    def SetRequireTextureFloat(self, bool):
        """
        V.SetRequireTextureFloat(bool)
        C++: virtual void SetRequireTextureFloat(bool _arg)
        
        Optional, require support for floating point texture formats. If
        supported extensions will be loaded, however loading will fail if
        the extension is required but not available.
        """
        ...
    
    def SetRequireTextureInteger(self, bool):
        """
        V.SetRequireTextureInteger(bool)
        C++: virtual void SetRequireTextureInteger(bool _arg)
        
        Optional, require support for integer texture formats. If
        supported extensions will be loaded, however loading will fail if
        the extension is required but not available.
        """
        ...
    
    def SetSamples(self, p_int):
        """
        V.SetSamples(int)
        C++: virtual void SetSamples(unsigned int _arg)
        """
        ...
    
    def SetUseSRGBColorSpace(self, bool):
        """
        V.SetUseSRGBColorSpace(bool)
        C++: virtual void SetUseSRGBColorSpace(bool _arg)
        
        Is this texture using the sRGB color space. If you are using a
        sRGB framebuffer or window then you probably also want to be
        using sRGB color textures for proper handling of gamma and
        associated color mixing.
        """
        ...
    
    def SetWrapR(self, p_int):
        """
        V.SetWrapR(int)
        C++: virtual void SetWrapR(int _arg)
        
        Wrap mode for the first texture coordinate "r" Valid values are:
        - Clamp
        - ClampToEdge
        - Repeat
        - ClampToBorder
        - MirroredRepeat Initial value is Repeat (as in OpenGL spec)
        """
        ...
    
    def SetWrapS(self, p_int):
        """
        V.SetWrapS(int)
        C++: virtual void SetWrapS(int _arg)
        
        Wrap mode for the first texture coordinate "s" Valid values are:
        - Clamp
        - ClampToEdge
        - Repeat
        - ClampToBorder
        - MirroredRepeat Initial value is Repeat (as in OpenGL spec)
        """
        ...
    
    def SetWrapT(self, p_int):
        """
        V.SetWrapT(int)
        C++: virtual void SetWrapT(int _arg)
        
        Wrap mode for the first texture coordinate "t" Valid values are:
        - Clamp
        - ClampToEdge
        - Repeat
        - ClampToBorder
        - MirroredRepeat Initial value is Repeat (as in OpenGL spec)
        """
        ...
    
    def UseSRGBColorSpaceOff(self):
        """
        V.UseSRGBColorSpaceOff()
        C++: virtual void UseSRGBColorSpaceOff()
        
        Is this texture using the sRGB color space. If you are using a
        sRGB framebuffer or window then you probably also want to be
        using sRGB color textures for proper handling of gamma and
        associated color mixing.
        """
        ...
    
    def UseSRGBColorSpaceOn(self):
        """
        V.UseSRGBColorSpaceOn()
        C++: virtual void UseSRGBColorSpaceOn()
        
        Is this texture using the sRGB color space. If you are using a
        sRGB framebuffer or window then you probably also want to be
        using sRGB color textures for proper handling of gamma and
        associated color mixing.
        """
        ...
    
    def __delattr__(self, *args, **kwargs):
        """ Implement delattr(self, name). """
        ...
    
    def __getattribute__(self, *args, **kwargs):
        """ Return getattr(self, name). """
        ...
    
    def __init__(self, *args, **kwargs) -> None:
        ...
    
    @staticmethod
    def __new__(*args, **kwargs):
        """ Create and return a new object.  See help(type) for accurate signature. """
        ...
    
    def __repr__(self, *args, **kwargs):
        """ Return repr(self). """
        ...
    
    def __setattr__(self, *args, **kwargs):
        """ Implement setattr(self, name, value). """
        ...
    
    def __str__(self, *args, **kwargs) -> str:
        """ Return str(self). """
        ...
    
    __this__ = ...
    AlwaysTrue = ...
    ClampToBorder = ...
    ClampToEdge = ...
    Equal = ...
    Fixed16 = ...
    Fixed24 = ...
    Fixed32 = ...
    Fixed8 = ...
    Float16 = ...
    Float32 = ...
    Gequal = ...
    Greater = ...
    Lequal = ...
    Less = ...
    Linear = ...
    LinearMipmapLinear = ...
    LinearMipmapNearest = ...
    MirroredRepeat = ...
    Native = ...
    Nearest = ...
    NearestMipmapLinear = ...
    NearestMipmapNearest = ...
    Never = ...
    NotEqual = ...
    NumberOfDepthFormats = ...
    NumberOfDepthTextureCompareFunctions = ...
    NumberOfMinificationModes = ...
    NumberOfWrapModes = ...
    Repeat = ...
    __dict__ = ...
    __vtkname__ = ...


