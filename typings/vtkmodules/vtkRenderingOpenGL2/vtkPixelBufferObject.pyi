"""
This type stub file was generated by pyright.
"""

import vtkmodules.vtkCommonCore as __vtkmodules_vtkCommonCore

class vtkPixelBufferObject(__vtkmodules_vtkCommonCore.vtkObject):
    """
    vtkPixelBufferObject - abstracts an OpenGL pixel buffer object.
    
    Superclass: vtkObject
    
    Provides low-level access to PBO mapped memory. Used to transfer raw
    data to/from PBO mapped memory and the application. Once data is
    transferred to the PBO it can then be transferred to the GPU (eg
    texture memory). Data may be uploaded from the application into a
    pixel buffer or downloaded from the pixel buffer to the application.
    The vtkTextureObject is used to transfer data from/to the PBO to/from
    texture memory on the GPU.
    @sa
    OpenGL Pixel Buffer Object Extension Spec (ARB_pixel_buffer_object):
    http://www.opengl.org/registry/specs/ARB/pixel_buffer_object.txt
    @warning
    Since most PBO mapped don't support double format all double data is
    converted to float and then uploaded.
    """
    def Allocate(self, p_int, p_int_1, p_int_2, BufferType):
        """
        V.Allocate(int, int, int, BufferType)
        C++: void Allocate(int vtkType, unsigned int numtuples, int comps,
             BufferType mode)
        V.Allocate(int, BufferType)
        C++: void Allocate(unsigned int nbytes, BufferType mode)
        
        Allocate PACKED/UNPACKED memory to hold numTuples*numComponents
        of vtkType.
        """
        ...
    
    def Bind(self, BufferType):
        """
        V.Bind(BufferType)
        C++: void Bind(BufferType buffer)
        
        Make the buffer active.
        """
        ...
    
    def BindToPackedBuffer(self):
        """
        V.BindToPackedBuffer()
        C++: void BindToPackedBuffer()
        
        Convenience methods for binding.
        """
        ...
    
    def BindToUnPackedBuffer(self):
        """
        V.BindToUnPackedBuffer()
        C++: void BindToUnPackedBuffer()
        """
        ...
    
    def Download1D(self, p_int, void, p_int_1, p_int_2, p_int_3):
        """
        V.Download1D(int, void, int, int, int) -> bool
        C++: bool Download1D(int type, void *data, unsigned int dim,
            int numcomps, vtkIdType increment)
        
        Download data from pixel buffer to the 1D array. The length of
        the array must be equal to the size of the data in the memory.
        """
        ...
    
    def Download2D(self, p_int, void, p_int=..., p_int=..., *args, **kwargs):
        """
        V.Download2D(int, void, [int, int], int, [int, int]) -> bool
        C++: bool Download2D(int type, void *data, unsigned int dims[2],
            int numcomps, vtkIdType increments[2])
        
        Download data from pixel buffer to the 2D array. (lengthx *
        lengthy) must be equal to the size of the data in the memory.
        """
        ...
    
    def Download3D(self, p_int, void, p_int=..., p_int=..., p_int=..., *args, **kwargs):
        """
        V.Download3D(int, void, [int, int, int], int, [int, int, int])
            -> bool
        C++: bool Download3D(int type, void *data, unsigned int dims[3],
            int numcomps, vtkIdType increments[3])
        
        Download data from pixel buffer to the 3D array. (lengthx *
        lengthy * lengthz) must be equal to the size of the data in the
        memory.
        """
        ...
    
    def GetComponents(self):
        """
        V.GetComponents() -> int
        C++: virtual int GetComponents()
        
        Get the number of components used to initialize the buffer.
        """
        ...
    
    def GetContext(self):
        """
        V.GetContext() -> vtkRenderWindow
        C++: vtkRenderWindow *GetContext()
        
        Get/Set the context. Context must be a vtkOpenGLRenderWindow.
        This does not increase the reference count of the context to
        avoid reference loops. SetContext() may raise an error is the
        OpenGL context does not support the required OpenGL extensions.
        """
        ...
    
    def GetHandle(self):
        """
        V.GetHandle() -> int
        C++: virtual unsigned int GetHandle()
        
        Get the openGL buffer handle.
        """
        ...
    
    def GetNumberOfGenerationsFromBase(self, string):
        """
        V.GetNumberOfGenerationsFromBase(string) -> int
        C++: vtkIdType GetNumberOfGenerationsFromBase(const char *type)
            override;
        
        Given a the name of a base class of this class type, return the
        distance of inheritance between this class type and the named
        class (how many generations of inheritance are there between this
        class and the named class). If the named class is not in this
        class's inheritance tree, return a negative value. Valid
        responses will always be nonnegative. This method works in
        combination with vtkTypeMacro found in vtkSetGet.h.
        """
        ...
    
    def GetNumberOfGenerationsFromBaseType(self, string):
        """
        V.GetNumberOfGenerationsFromBaseType(string) -> int
        C++: static vtkIdType GetNumberOfGenerationsFromBaseType(
            const char *type)
        
        Given a the name of a base class of this class type, return the
        distance of inheritance between this class type and the named
        class (how many generations of inheritance are there between this
        class and the named class). If the named class is not in this
        class's inheritance tree, return a negative value. Valid
        responses will always be nonnegative. This method works in
        combination with vtkTypeMacro found in vtkSetGet.h.
        """
        ...
    
    def GetSize(self):
        """
        V.GetSize() -> int
        C++: virtual unsigned int GetSize()
        
        Get the size of the data loaded into the PBO mapped memory. Size
        is in the number of elements of the uploaded Type.
        """
        ...
    
    def GetType(self):
        """
        V.GetType() -> int
        C++: virtual int GetType()
        
        Get the type with which the data is loaded into the PBO mapped.
        eg. VTK_FLOAT for float32, VTK_CHAR for byte, VTK_UNSIGNED_CHAR
        for unsigned byte etc.
        """
        ...
    
    def GetUsage(self):
        """
        V.GetUsage() -> int
        C++: virtual int GetUsage()
        
        Usage is a performance hint. Valid values are:
        - StreamDraw specified once by A, used few times S
        - StreamRead specified once by R, queried a few times by A
        - StreamCopy specified once by R, used a few times S
        - StaticDraw specified once by A, used many times S
        - StaticRead specified once by R, queried many times by A
        - StaticCopy specified once by R, used many times S
        - DynamicDraw respecified repeatedly by A, used many times S
        - DynamicRead respecified repeatedly by R, queried many times by
          A
        - DynamicCopy respecified repeatedly by R, used many times S A:
          the application S: as the source for GL drawing and image
          specification commands. R: reading data from the GL Initial
          value is StaticDraw, as in OpenGL spec.
        """
        ...
    
    def IsA(self, string):
        """
        V.IsA(string) -> int
        C++: vtkTypeBool IsA(const char *type) override;
        
        Return 1 if this class is the same type of (or a subclass of) the
        named class. Returns 0 otherwise. This method works in
        combination with vtkTypeMacro found in vtkSetGet.h.
        """
        ...
    
    def IsSupported(self, vtkRenderWindow):
        """
        V.IsSupported(vtkRenderWindow) -> bool
        C++: static bool IsSupported(vtkRenderWindow *renWin)
        
        Returns if the context supports the required extensions.
        Extension will be loaded when the context is set.
        """
        ...
    
    def IsTypeOf(self, string):
        """
        V.IsTypeOf(string) -> int
        C++: static vtkTypeBool IsTypeOf(const char *type)
        
        Return 1 if this class type is the same type of (or a subclass
        of) the named class. Returns 0 otherwise. This method works in
        combination with vtkTypeMacro found in vtkSetGet.h.
        """
        ...
    
    def MapBuffer(self, p_int, p_int_1, p_int_2, BufferType):
        """
        V.MapBuffer(int, int, int, BufferType) -> void
        C++: void *MapBuffer(int type, unsigned int numtuples, int comps,
            BufferType mode)
        V.MapBuffer(int, BufferType) -> void
        C++: void *MapBuffer(unsigned int numbytes, BufferType mode)
        V.MapBuffer(BufferType) -> void
        C++: void *MapBuffer(BufferType mode)
        
        Map the buffer to our addresspace. Returns a pointer to the
        mapped memory for read/write access. If type, tuples and
        components are specified new buffer data will be allocated, else
        the current allocation is mapped. When finished call UnmapBuffer.
        """
        ...
    
    def MapPackedBuffer(self):
        """
        V.MapPackedBuffer() -> void
        C++: void *MapPackedBuffer()
        V.MapPackedBuffer(int, int, int) -> void
        C++: void *MapPackedBuffer(int type, unsigned int numtuples,
            int comps)
        V.MapPackedBuffer(int) -> void
        C++: void *MapPackedBuffer(unsigned int numbytes)
        
        Convenience api for mapping buffers to app address space. See
        also MapBuffer.
        """
        ...
    
    def MapUnpackedBuffer(self):
        """
        V.MapUnpackedBuffer() -> void
        C++: void *MapUnpackedBuffer()
        V.MapUnpackedBuffer(int, int, int) -> void
        C++: void *MapUnpackedBuffer(int type, unsigned int numtuples,
            int comps)
        V.MapUnpackedBuffer(int) -> void
        C++: void *MapUnpackedBuffer(unsigned int numbytes)
        """
        ...
    
    def NewInstance(self):
        """
        V.NewInstance() -> vtkPixelBufferObject
        C++: vtkPixelBufferObject *NewInstance()
        """
        ...
    
    def ReleaseMemory(self):
        """
        V.ReleaseMemory()
        C++: void ReleaseMemory()
        
        Release the memory allocated without destroying the PBO handle.
        """
        ...
    
    def SafeDownCast(self, vtkObjectBase):
        """
        V.SafeDownCast(vtkObjectBase) -> vtkPixelBufferObject
        C++: static vtkPixelBufferObject *SafeDownCast(vtkObjectBase *o)
        """
        ...
    
    def SetComponents(self, p_int):
        """
        V.SetComponents(int)
        C++: virtual void SetComponents(int _arg)
        
        Get the number of components used to initialize the buffer.
        """
        ...
    
    def SetContext(self, vtkRenderWindow):
        """
        V.SetContext(vtkRenderWindow)
        C++: void SetContext(vtkRenderWindow *context)
        
        Get/Set the context. Context must be a vtkOpenGLRenderWindow.
        This does not increase the reference count of the context to
        avoid reference loops. SetContext() may raise an error is the
        OpenGL context does not support the required OpenGL extensions.
        """
        ...
    
    def SetSize(self, p_int):
        """
        V.SetSize(int)
        C++: virtual void SetSize(unsigned int _arg)
        V.SetSize(int, int)
        C++: void SetSize(unsigned int nTups, int nComps)
        
        Get the size of the data loaded into the PBO mapped memory. Size
        is in the number of elements of the uploaded Type.
        """
        ...
    
    def SetType(self, p_int):
        """
        V.SetType(int)
        C++: virtual void SetType(int _arg)
        
        Get the type with which the data is loaded into the PBO mapped.
        eg. VTK_FLOAT for float32, VTK_CHAR for byte, VTK_UNSIGNED_CHAR
        for unsigned byte etc.
        """
        ...
    
    def SetUsage(self, p_int):
        """
        V.SetUsage(int)
        C++: virtual void SetUsage(int _arg)
        
        Usage is a performance hint. Valid values are:
        - StreamDraw specified once by A, used few times S
        - StreamRead specified once by R, queried a few times by A
        - StreamCopy specified once by R, used a few times S
        - StaticDraw specified once by A, used many times S
        - StaticRead specified once by R, queried many times by A
        - StaticCopy specified once by R, used many times S
        - DynamicDraw respecified repeatedly by A, used many times S
        - DynamicRead respecified repeatedly by R, queried many times by
          A
        - DynamicCopy respecified repeatedly by R, used many times S A:
          the application S: as the source for GL drawing and image
          specification commands. R: reading data from the GL Initial
          value is StaticDraw, as in OpenGL spec.
        """
        ...
    
    def UnBind(self):
        """
        V.UnBind()
        C++: void UnBind()
        
        Deactivate the buffer.
        """
        ...
    
    def UnmapBuffer(self, BufferType):
        """
        V.UnmapBuffer(BufferType)
        C++: void UnmapBuffer(BufferType mode)
        
        Un-map the buffer from our address space, OpenGL can then
        use/reclaim the buffer contents.
        """
        ...
    
    def UnmapPackedBuffer(self):
        """
        V.UnmapPackedBuffer()
        C++: void UnmapPackedBuffer()
        """
        ...
    
    def UnmapUnpackedBuffer(self):
        """
        V.UnmapUnpackedBuffer()
        C++: void UnmapUnpackedBuffer()
        
        Convenience api for unmapping buffers from app address space. See
        also UnmapBuffer.
        """
        ...
    
    def Upload1D(self, p_int, void, p_int_1, p_int_2, p_int_3):
        """
        V.Upload1D(int, void, int, int, int) -> bool
        C++: bool Upload1D(int type, void *data, unsigned int numtuples,
            int comps, vtkIdType increment)
        
        Upload data to PBO mapped. The input data can be freed after this
        call. The data ptr is treated as an 1D array with the given
        number of tuples and given number of components in each tuple to
        be copied to the PBO mapped. increment is the offset added after
        the last component in each tuple is transferred. Look at the
        documentation for ContinuousIncrements in vtkImageData for
        details about how increments are specified.
        """
        ...
    
    def Upload2D(self, p_int, void, p_int=..., p_int=..., *args, **kwargs):
        """
        V.Upload2D(int, void, [int, int], int, [int, int]) -> bool
        C++: bool Upload2D(int type, void *data, unsigned int dims[2],
            int comps, vtkIdType increments[2])
        
        Update data to PBO mapped sourcing it from a 2D array. The input
        data can be freed after this call. The data ptr is treated as a
        2D array with increments indicating how to iterate over the data.
        Look at the documentation for ContinuousIncrements in
        vtkImageData for details about how increments are specified.
        """
        ...
    
    def Upload3D(self, p_int, void, p_int=..., p_int=..., p_int=..., *args, **kwargs):
        """
        V.Upload3D(int, void, [int, int, int], int, [int, int, int], int,
            [int, ...]) -> bool
        C++: bool Upload3D(int type, void *data, unsigned int dims[3],
            int comps, vtkIdType increments[3], int components,
            int *componentList)
        
        Update data to PBO mapped sourcing it from a 3D array. The input
        data can be freed after this call. The data ptr is treated as a
        3D array with increments indicating how to iterate over the data.
        Look at the documentation for ContinuousIncrements in
        vtkImageData for details about how increments are specified.
        """
        ...
    
    def __delattr__(self, *args, **kwargs):
        """ Implement delattr(self, name). """
        ...
    
    def __getattribute__(self, *args, **kwargs):
        """ Return getattr(self, name). """
        ...
    
    def __init__(self, *args, **kwargs) -> None:
        ...
    
    @staticmethod
    def __new__(*args, **kwargs):
        """ Create and return a new object.  See help(type) for accurate signature. """
        ...
    
    def __repr__(self, *args, **kwargs):
        """ Return repr(self). """
        ...
    
    def __setattr__(self, *args, **kwargs):
        """ Implement setattr(self, name, value). """
        ...
    
    def __str__(self, *args, **kwargs) -> str:
        """ Return str(self). """
        ...
    
    __this__ = ...
    BufferType = ...
    DynamicCopy = ...
    DynamicDraw = ...
    DynamicRead = ...
    NumberOfUsages = ...
    PACKED_BUFFER = ...
    StaticCopy = ...
    StaticDraw = ...
    StaticRead = ...
    StreamCopy = ...
    StreamDraw = ...
    StreamRead = ...
    UNPACKED_BUFFER = ...
    __dict__ = ...
    __vtkname__ = ...


