"""
This type stub file was generated by pyright.
"""

import vtkmodules.vtkCommonCore as __vtkmodules_vtkCommonCore

def vtkQuaternion(*args, **kwargs):
    """
    vtkQuaterniond - Double quaternion type.
    
    Superclass: vtkTuple[T,4]
    
    This class is uses vtkQuaternion with double type data. For further
    description, seethe templated class vtkQuaternion.
    @sa vtkQuaternionf vtkQuaternion
    
    
    Provided Types:
    
      vtkQuaternion[float64] => vtkQuaternion<double>
      vtkQuaternion[float32] => vtkQuaternion<float>
    """
    ...

def vtkTuple(*args, **kwargs):
    """
    vtkTuple - templated base type for containers of constant size.
    
    This class is a templated data type for storing and manipulating
    tuples.
    
    
    Provided Types:
    
      vtkTuple[float64,4] => vtkTuple<double, 4>
      vtkTuple[float32,4] => vtkTuple<float, 4>
      vtkTuple[uint8,2] => vtkTuple<unsigned char, 2>
      vtkTuple[uint8,3] => vtkTuple<unsigned char, 3>
      vtkTuple[uint8,4] => vtkTuple<unsigned char, 4>
      vtkTuple[int32,2] => vtkTuple<int, 2>
      vtkTuple[int32,3] => vtkTuple<int, 3>
      vtkTuple[int32,4] => vtkTuple<int, 4>
      vtkTuple[float32,2] => vtkTuple<float, 2>
      vtkTuple[float32,3] => vtkTuple<float, 3>
      vtkTuple[float64,2] => vtkTuple<double, 2>
      vtkTuple[float64,3] => vtkTuple<double, 3>
    """
    ...

class vtkAmoebaMinimizer(__vtkmodules_vtkCommonCore.vtkObject):
    """
    vtkAmoebaMinimizer - nonlinear optimization with a simplex
    
    Superclass: vtkObject
    
    vtkAmoebaMinimizer will modify a set of parameters in order to find
    the minimum of a specified function.  The method used is commonly
    known as the amoeba method, it constructs an n-dimensional simplex in
    parameter space (i.e. a tetrahedron if the number or parameters is 3)
    and moves the vertices around parameter space until a local minimum
    is found.  The amoeba method is robust, reasonably efficient, but is
    not guaranteed to find the global minimum if several local minima
    exist.
    """
    def EvaluateFunction(self):
        """
        V.EvaluateFunction()
        C++: void EvaluateFunction()
        
        Evaluate the function.  This is usually called internally by the
        minimization code, but it is provided here as a public method.
        """
        ...
    
    def GetContractionRatio(self):
        """
        V.GetContractionRatio() -> float
        C++: virtual double GetContractionRatio()
        
        Set the amoeba contraction ratio.  The default value of 0.5 gives
        fast convergence, but larger values such as 0.6 or 0.7 provide
        greater stability.
        """
        ...
    
    def GetContractionRatioMaxValue(self):
        """
        V.GetContractionRatioMaxValue() -> float
        C++: virtual double GetContractionRatioMaxValue()
        
        Set the amoeba contraction ratio.  The default value of 0.5 gives
        fast convergence, but larger values such as 0.6 or 0.7 provide
        greater stability.
        """
        ...
    
    def GetContractionRatioMinValue(self):
        """
        V.GetContractionRatioMinValue() -> float
        C++: virtual double GetContractionRatioMinValue()
        
        Set the amoeba contraction ratio.  The default value of 0.5 gives
        fast convergence, but larger values such as 0.6 or 0.7 provide
        greater stability.
        """
        ...
    
    def GetExpansionRatio(self):
        """
        V.GetExpansionRatio() -> float
        C++: virtual double GetExpansionRatio()
        
        Set the amoeba expansion ratio.  The default value is 2.0, which
        provides rapid expansion.  Values between 1.1 and 2.0 are valid.
        """
        ...
    
    def GetExpansionRatioMaxValue(self):
        """
        V.GetExpansionRatioMaxValue() -> float
        C++: virtual double GetExpansionRatioMaxValue()
        
        Set the amoeba expansion ratio.  The default value is 2.0, which
        provides rapid expansion.  Values between 1.1 and 2.0 are valid.
        """
        ...
    
    def GetExpansionRatioMinValue(self):
        """
        V.GetExpansionRatioMinValue() -> float
        C++: virtual double GetExpansionRatioMinValue()
        
        Set the amoeba expansion ratio.  The default value is 2.0, which
        provides rapid expansion.  Values between 1.1 and 2.0 are valid.
        """
        ...
    
    def GetFunctionEvaluations(self):
        """
        V.GetFunctionEvaluations() -> int
        C++: virtual int GetFunctionEvaluations()
        
        Return the number of times that the function has been evaluated.
        """
        ...
    
    def GetFunctionValue(self):
        """
        V.GetFunctionValue() -> float
        C++: double GetFunctionValue()
        
        Get the function value resulting from the minimization.
        """
        ...
    
    def GetIterations(self):
        """
        V.GetIterations() -> int
        C++: virtual int GetIterations()
        
        Return the number of iterations that have been performed.  This
        is not necessarily the same as the number of function
        evaluations.
        """
        ...
    
    def GetMaxIterations(self):
        """
        V.GetMaxIterations() -> int
        C++: virtual int GetMaxIterations()
        
        Specify the maximum number of iterations to try before giving up.
        """
        ...
    
    def GetNumberOfGenerationsFromBase(self, string):
        """
        V.GetNumberOfGenerationsFromBase(string) -> int
        C++: vtkIdType GetNumberOfGenerationsFromBase(const char *type)
            override;
        
        Given a the name of a base class of this class type, return the
        distance of inheritance between this class type and the named
        class (how many generations of inheritance are there between this
        class and the named class). If the named class is not in this
        class's inheritance tree, return a negative value. Valid
        responses will always be nonnegative. This method works in
        combination with vtkTypeMacro found in vtkSetGet.h.
        """
        ...
    
    def GetNumberOfGenerationsFromBaseType(self, string):
        """
        V.GetNumberOfGenerationsFromBaseType(string) -> int
        C++: static vtkIdType GetNumberOfGenerationsFromBaseType(
            const char *type)
        
        Given a the name of a base class of this class type, return the
        distance of inheritance between this class type and the named
        class (how many generations of inheritance are there between this
        class and the named class). If the named class is not in this
        class's inheritance tree, return a negative value. Valid
        responses will always be nonnegative. This method works in
        combination with vtkTypeMacro found in vtkSetGet.h.
        """
        ...
    
    def GetNumberOfParameters(self):
        """
        V.GetNumberOfParameters() -> int
        C++: int GetNumberOfParameters()
        
        Get the number of parameters that have been set.
        """
        ...
    
    def GetParameterName(self, p_int):
        """
        V.GetParameterName(int) -> string
        C++: const char *GetParameterName(int i)
        
        For completeness, an unchecked method to get the name for
        particular parameter (the result will be nullptr if no name was
        set).
        """
        ...
    
    def GetParameterScale(self, string):
        """
        V.GetParameterScale(string) -> float
        C++: double GetParameterScale(const char *name)
        V.GetParameterScale(int) -> float
        C++: double GetParameterScale(int i)
        
        Set the scale to use when modifying a parameter, i.e. the initial
        amount by which the parameter will be modified during the search
        for the minimum.  It is preferable to identify scalars by name
        rather than by number.
        """
        ...
    
    def GetParameterTolerance(self):
        """
        V.GetParameterTolerance() -> float
        C++: virtual double GetParameterTolerance()
        
        Specify the parameter tolerance to aim for during the
        minimization.
        """
        ...
    
    def GetParameterValue(self, string):
        """
        V.GetParameterValue(string) -> float
        C++: double GetParameterValue(const char *name)
        V.GetParameterValue(int) -> float
        C++: double GetParameterValue(int i)
        
        Get the value of a parameter at the current stage of the
        minimization. Call this method within the function that you are
        minimizing in order to get the current parameter values.  It is
        preferable to specify parameters by name rather than by index.
        """
        ...
    
    def GetTolerance(self):
        """
        V.GetTolerance() -> float
        C++: virtual double GetTolerance()
        
        Specify the value tolerance to aim for during the minimization.
        """
        ...
    
    def Initialize(self):
        """
        V.Initialize()
        C++: void Initialize()
        
        Initialize the minimizer.  This will reset the number of
        parameters to zero so that the minimizer can be reused.
        """
        ...
    
    def IsA(self, string):
        """
        V.IsA(string) -> int
        C++: vtkTypeBool IsA(const char *type) override;
        
        Return 1 if this class is the same type of (or a subclass of) the
        named class. Returns 0 otherwise. This method works in
        combination with vtkTypeMacro found in vtkSetGet.h.
        """
        ...
    
    def IsTypeOf(self, string):
        """
        V.IsTypeOf(string) -> int
        C++: static vtkTypeBool IsTypeOf(const char *type)
        
        Return 1 if this class type is the same type of (or a subclass
        of) the named class. Returns 0 otherwise. This method works in
        combination with vtkTypeMacro found in vtkSetGet.h.
        """
        ...
    
    def Iterate(self):
        """
        V.Iterate() -> int
        C++: virtual int Iterate()
        
        Perform one iteration of minimization.  Returns zero if the
        tolerance stopping criterion has been met.
        """
        ...
    
    def Minimize(self):
        """
        V.Minimize()
        C++: virtual void Minimize()
        
        Iterate until the minimum is found to within the specified
        tolerance, or until the MaxIterations has been reached.
        """
        ...
    
    def NewInstance(self):
        """
        V.NewInstance() -> vtkAmoebaMinimizer
        C++: vtkAmoebaMinimizer *NewInstance()
        """
        ...
    
    def SafeDownCast(self, vtkObjectBase):
        """
        V.SafeDownCast(vtkObjectBase) -> vtkAmoebaMinimizer
        C++: static vtkAmoebaMinimizer *SafeDownCast(vtkObjectBase *o)
        """
        ...
    
    def SetContractionRatio(self, p_float):
        """
        V.SetContractionRatio(float)
        C++: virtual void SetContractionRatio(double _arg)
        
        Set the amoeba contraction ratio.  The default value of 0.5 gives
        fast convergence, but larger values such as 0.6 or 0.7 provide
        greater stability.
        """
        ...
    
    def SetExpansionRatio(self, p_float):
        """
        V.SetExpansionRatio(float)
        C++: virtual void SetExpansionRatio(double _arg)
        
        Set the amoeba expansion ratio.  The default value is 2.0, which
        provides rapid expansion.  Values between 1.1 and 2.0 are valid.
        """
        ...
    
    def SetFunction(self, function):
        """
        V.SetFunction(function)
        C++: void SetFunction(void (*f)(void *), void *arg)
        
        Specify the function to be minimized.  When this function is
        called, it must get the parameter values by calling
        GetParameterValue() for each parameter, and then must call
        SetFunctionValue() to tell the minimizer what the result of the
        function evaluation was.  The number of function evaluations used
        for the minimization can be retrieved using
        GetFunctionEvaluations().
        """
        ...
    
    def SetFunctionValue(self, p_float):
        """
        V.SetFunctionValue(float)
        C++: virtual void SetFunctionValue(double _arg)
        
        Get the function value resulting from the minimization.
        """
        ...
    
    def SetMaxIterations(self, p_int):
        """
        V.SetMaxIterations(int)
        C++: virtual void SetMaxIterations(int _arg)
        
        Specify the maximum number of iterations to try before giving up.
        """
        ...
    
    def SetParameterScale(self, string, p_float):
        """
        V.SetParameterScale(string, float)
        C++: void SetParameterScale(const char *name, double scale)
        V.SetParameterScale(int, float)
        C++: void SetParameterScale(int i, double scale)
        
        Set the scale to use when modifying a parameter, i.e. the initial
        amount by which the parameter will be modified during the search
        for the minimum.  It is preferable to identify scalars by name
        rather than by number.
        """
        ...
    
    def SetParameterTolerance(self, p_float):
        """
        V.SetParameterTolerance(float)
        C++: virtual void SetParameterTolerance(double _arg)
        
        Specify the parameter tolerance to aim for during the
        minimization.
        """
        ...
    
    def SetParameterValue(self, string, p_float):
        """
        V.SetParameterValue(string, float)
        C++: void SetParameterValue(const char *name, double value)
        V.SetParameterValue(int, float)
        C++: void SetParameterValue(int i, double value)
        
        Set the initial value for the specified parameter.  Calling this
        function for any parameter will reset the Iterations and the
        FunctionEvaluations counts to zero.  You must also use
        SetParameterScale() to specify the step size by which the
        parameter will be modified during the minimization.  It is
        preferable to specify parameters by name, rather than by number.
        """
        ...
    
    def SetTolerance(self, p_float):
        """
        V.SetTolerance(float)
        C++: virtual void SetTolerance(double _arg)
        
        Specify the value tolerance to aim for during the minimization.
        """
        ...
    
    def __delattr__(self, *args, **kwargs):
        """ Implement delattr(self, name). """
        ...
    
    def __getattribute__(self, *args, **kwargs):
        """ Return getattr(self, name). """
        ...
    
    def __init__(self, *args, **kwargs) -> None:
        ...
    
    @staticmethod
    def __new__(*args, **kwargs):
        """ Create and return a new object.  See help(type) for accurate signature. """
        ...
    
    def __repr__(self, *args, **kwargs):
        """ Return repr(self). """
        ...
    
    def __setattr__(self, *args, **kwargs):
        """ Implement setattr(self, name, value). """
        ...
    
    def __str__(self, *args, **kwargs) -> str:
        """ Return str(self). """
        ...
    
    __this__ = ...
    __dict__ = ...
    __vtkname__ = ...


class vtkFunctionSet(__vtkmodules_vtkCommonCore.vtkObject):
    """
    vtkFunctionSet - Abstract interface for sets of functions
    
    Superclass: vtkObject
    
    vtkFunctionSet specifies an abstract interface for set of functions
    of the form F_i = F_i(x_j) where F (with i=1..m) are the functions
    and x (with j=1..n) are the independent variables. The only supported
    operation is the function evaluation at x_j.
    
    @sa
    vtkImplicitDataSet vtkInterpolatedVelocityField
    vtkInitialValueProblemSolver
    """
    def FunctionValues(self, *float, **kwargs):
        """
        V.FunctionValues([float, ...], [float, ...]) -> int
        C++: virtual int FunctionValues(double *x, double *f)
        V.FunctionValues([float, ...], [float, ...], void) -> int
        C++: virtual int FunctionValues(double *x, double *f,
            void *userData)
        
        Evaluate functions at x_j. x and f have to point to valid double
        arrays of appropriate sizes obtained with GetNumberOfFunctions()
        and GetNumberOfIndependentVariables. If you inherit this class,
        make sure to reimplement at least one of the two FunctionValues
        signatures.
        """
        ...
    
    def GetNumberOfFunctions(self):
        """
        V.GetNumberOfFunctions() -> int
        C++: virtual int GetNumberOfFunctions()
        
        Return the number of functions. Note that this is constant for a
        given type of set of functions and can not be changed at run
        time.
        """
        ...
    
    def GetNumberOfGenerationsFromBase(self, string):
        """
        V.GetNumberOfGenerationsFromBase(string) -> int
        C++: vtkIdType GetNumberOfGenerationsFromBase(const char *type)
            override;
        
        Given a the name of a base class of this class type, return the
        distance of inheritance between this class type and the named
        class (how many generations of inheritance are there between this
        class and the named class). If the named class is not in this
        class's inheritance tree, return a negative value. Valid
        responses will always be nonnegative. This method works in
        combination with vtkTypeMacro found in vtkSetGet.h.
        """
        ...
    
    def GetNumberOfGenerationsFromBaseType(self, string):
        """
        V.GetNumberOfGenerationsFromBaseType(string) -> int
        C++: static vtkIdType GetNumberOfGenerationsFromBaseType(
            const char *type)
        
        Given a the name of a base class of this class type, return the
        distance of inheritance between this class type and the named
        class (how many generations of inheritance are there between this
        class and the named class). If the named class is not in this
        class's inheritance tree, return a negative value. Valid
        responses will always be nonnegative. This method works in
        combination with vtkTypeMacro found in vtkSetGet.h.
        """
        ...
    
    def GetNumberOfIndependentVariables(self):
        """
        V.GetNumberOfIndependentVariables() -> int
        C++: virtual int GetNumberOfIndependentVariables()
        
        Return the number of independent variables. Note that this is
        constant for a given type of set of functions and can not be
        changed at run time.
        """
        ...
    
    def IsA(self, string):
        """
        V.IsA(string) -> int
        C++: vtkTypeBool IsA(const char *type) override;
        
        Return 1 if this class is the same type of (or a subclass of) the
        named class. Returns 0 otherwise. This method works in
        combination with vtkTypeMacro found in vtkSetGet.h.
        """
        ...
    
    def IsTypeOf(self, string):
        """
        V.IsTypeOf(string) -> int
        C++: static vtkTypeBool IsTypeOf(const char *type)
        
        Return 1 if this class type is the same type of (or a subclass
        of) the named class. Returns 0 otherwise. This method works in
        combination with vtkTypeMacro found in vtkSetGet.h.
        """
        ...
    
    def NewInstance(self):
        """
        V.NewInstance() -> vtkFunctionSet
        C++: vtkFunctionSet *NewInstance()
        """
        ...
    
    def SafeDownCast(self, vtkObjectBase):
        """
        V.SafeDownCast(vtkObjectBase) -> vtkFunctionSet
        C++: static vtkFunctionSet *SafeDownCast(vtkObjectBase *o)
        """
        ...
    
    def __delattr__(self, *args, **kwargs):
        """ Implement delattr(self, name). """
        ...
    
    def __getattribute__(self, *args, **kwargs):
        """ Return getattr(self, name). """
        ...
    
    def __init__(self, *args, **kwargs) -> None:
        ...
    
    @staticmethod
    def __new__(*args, **kwargs):
        """ Create and return a new object.  See help(type) for accurate signature. """
        ...
    
    def __repr__(self, *args, **kwargs):
        """ Return repr(self). """
        ...
    
    def __setattr__(self, *args, **kwargs):
        """ Implement setattr(self, name, value). """
        ...
    
    def __str__(self, *args, **kwargs) -> str:
        """ Return str(self). """
        ...
    
    __this__ = ...
    __dict__ = ...
    __vtkname__ = ...


class vtkInitialValueProblemSolver(__vtkmodules_vtkCommonCore.vtkObject):
    """
    vtkInitialValueProblemSolver - Integrate a set of ordinary
    differential equations (initial value problem) in time.
    
    Superclass: vtkObject
    
    Given a vtkFunctionSet which returns dF_i(x_j, t)/dt given x_j and t,
    vtkInitialValueProblemSolver computes the value of F_i at t+deltat.
    
    @warning
    vtkInitialValueProblemSolver and it's subclasses are not thread-safe.
    You should create a new integrator for each thread.
    
    @sa
    vtkRungeKutta2 vtkRungeKutta4
    """
    def ComputeNextStep(self, *float, **kwargs):
        """
        V.ComputeNextStep([float, ...], [float, ...], float, float, float,
             float) -> int
        C++: virtual int ComputeNextStep(double *xprev, double *xnext,
            double t, double &delT, double maxError, double &error)
        V.ComputeNextStep([float, ...], [float, ...], float, float, float,
             float, void) -> int
        C++: virtual int ComputeNextStep(double *xprev, double *xnext,
            double t, double &delT, double maxError, double &error,
            void *userData)
        V.ComputeNextStep([float, ...], [float, ...], [float, ...], float,
             float, float, float) -> int
        C++: virtual int ComputeNextStep(double *xprev, double *dxprev,
            double *xnext, double t, double &delT, double maxError,
            double &error)
        V.ComputeNextStep([float, ...], [float, ...], [float, ...], float,
             float, float, float, void) -> int
        C++: virtual int ComputeNextStep(double *xprev, double *dxprev,
            double *xnext, double t, double &delT, double maxError,
            double &error, void *userData)
        V.ComputeNextStep([float, ...], [float, ...], float, float, float,
             float, float, float, float) -> int
        C++: virtual int ComputeNextStep(double *xprev, double *xnext,
            double t, double &delT, double &delTActual, double minStep,
            double maxStep, double maxError, double &error)
        V.ComputeNextStep([float, ...], [float, ...], float, float, float,
             float, float, float, float, void) -> int
        C++: virtual int ComputeNextStep(double *xprev, double *xnext,
            double t, double &delT, double &delTActual, double minStep,
            double maxStep, double maxError, double &error,
            void *userData)
        V.ComputeNextStep([float, ...], [float, ...], [float, ...], float,
             float, float, float, float, float, float) -> int
        C++: virtual int ComputeNextStep(double *xprev, double *dxprev,
            double *xnext, double t, double &delT, double &delTActual,
            double minStep, double maxStep, double maxError,
            double &error)
        
        Given initial values, xprev , initial time, t and a requested
        time interval, delT calculate values of x at t+delTA ...
         [Truncated]
        """
        ...
    
    def GetFunctionSet(self):
        """
        V.GetFunctionSet() -> vtkFunctionSet
        C++: virtual vtkFunctionSet *GetFunctionSet()
        
        Set / get the dataset used for the implicit function evaluation.
        """
        ...
    
    def GetNumberOfGenerationsFromBase(self, string):
        """
        V.GetNumberOfGenerationsFromBase(string) -> int
        C++: vtkIdType GetNumberOfGenerationsFromBase(const char *type)
            override;
        
        Given a the name of a base class of this class type, return the
        distance of inheritance between this class type and the named
        class (how many generations of inheritance are there between this
        class and the named class). If the named class is not in this
        class's inheritance tree, return a negative value. Valid
        responses will always be nonnegative. This method works in
        combination with vtkTypeMacro found in vtkSetGet.h.
        """
        ...
    
    def GetNumberOfGenerationsFromBaseType(self, string):
        """
        V.GetNumberOfGenerationsFromBaseType(string) -> int
        C++: static vtkIdType GetNumberOfGenerationsFromBaseType(
            const char *type)
        
        Given a the name of a base class of this class type, return the
        distance of inheritance between this class type and the named
        class (how many generations of inheritance are there between this
        class and the named class). If the named class is not in this
        class's inheritance tree, return a negative value. Valid
        responses will always be nonnegative. This method works in
        combination with vtkTypeMacro found in vtkSetGet.h.
        """
        ...
    
    def IsA(self, string):
        """
        V.IsA(string) -> int
        C++: vtkTypeBool IsA(const char *type) override;
        
        Return 1 if this class is the same type of (or a subclass of) the
        named class. Returns 0 otherwise. This method works in
        combination with vtkTypeMacro found in vtkSetGet.h.
        """
        ...
    
    def IsAdaptive(self):
        """
        V.IsAdaptive() -> int
        C++: virtual vtkTypeBool IsAdaptive()
        
        Returns 1 if the solver uses adaptive stepsize control, 0
        otherwise
        """
        ...
    
    def IsTypeOf(self, string):
        """
        V.IsTypeOf(string) -> int
        C++: static vtkTypeBool IsTypeOf(const char *type)
        
        Return 1 if this class type is the same type of (or a subclass
        of) the named class. Returns 0 otherwise. This method works in
        combination with vtkTypeMacro found in vtkSetGet.h.
        """
        ...
    
    def NewInstance(self):
        """
        V.NewInstance() -> vtkInitialValueProblemSolver
        C++: vtkInitialValueProblemSolver *NewInstance()
        """
        ...
    
    def SafeDownCast(self, vtkObjectBase):
        """
        V.SafeDownCast(vtkObjectBase) -> vtkInitialValueProblemSolver
        C++: static vtkInitialValueProblemSolver *SafeDownCast(
            vtkObjectBase *o)
        """
        ...
    
    def SetFunctionSet(self, vtkFunctionSet):
        """
        V.SetFunctionSet(vtkFunctionSet)
        C++: virtual void SetFunctionSet(vtkFunctionSet *functionset)
        
        Set / get the dataset used for the implicit function evaluation.
        """
        ...
    
    def __delattr__(self, *args, **kwargs):
        """ Implement delattr(self, name). """
        ...
    
    def __getattribute__(self, *args, **kwargs):
        """ Return getattr(self, name). """
        ...
    
    def __init__(self, *args, **kwargs) -> None:
        ...
    
    @staticmethod
    def __new__(*args, **kwargs):
        """ Create and return a new object.  See help(type) for accurate signature. """
        ...
    
    def __repr__(self, *args, **kwargs):
        """ Return repr(self). """
        ...
    
    def __setattr__(self, *args, **kwargs):
        """ Implement setattr(self, name, value). """
        ...
    
    def __str__(self, *args, **kwargs) -> str:
        """ Return str(self). """
        ...
    
    __this__ = ...
    ErrorCodes = ...
    NOT_INITIALIZED = ...
    OUT_OF_DOMAIN = ...
    UNEXPECTED_VALUE = ...
    __dict__ = ...
    __vtkname__ = ...


class vtkMatrix3x3(__vtkmodules_vtkCommonCore.vtkObject):
    """
    vtkMatrix3x3 - represent and manipulate 3x3 transformation matrices
    
    Superclass: vtkObject
    
    vtkMatrix3x3 is a class to represent and manipulate 3x3 matrices.
    Specifically, it is designed to work on 3x3 transformation matrices
    found in 2D rendering using homogeneous coordinates [x y w].
    
    @sa
    vtkTransform2D
    """
    def Adjoint(self, vtkMatrix3x3, vtkMatrix3x3_1):
        """
        V.Adjoint(vtkMatrix3x3, vtkMatrix3x3)
        C++: void Adjoint(vtkMatrix3x3 *in, vtkMatrix3x3 *out)
        V.Adjoint((float, float, float, float, float, float, float, float,
             float), [float, float, float, float, float, float, float,
            float, float])
        C++: static void Adjoint(const double inElements[9],
            double outElements[9])
        
        Compute adjoint of the matrix and put it into out.
        """
        ...
    
    def DeepCopy(self, vtkMatrix3x3):
        """
        V.DeepCopy(vtkMatrix3x3)
        C++: void DeepCopy(vtkMatrix3x3 *source)
        V.DeepCopy([float, float, float, float, float, float, float,
            float, float], vtkMatrix3x3)
        C++: static void DeepCopy(double elements[9],
            vtkMatrix3x3 *source)
        V.DeepCopy([float, float, float, float, float, float, float,
            float, float], (float, float, float, float, float, float,
            float, float, float))
        C++: static void DeepCopy(double elements[9],
            const double newElements[9])
        V.DeepCopy((float, float, float, float, float, float, float,
            float, float))
        C++: void DeepCopy(const double elements[9])
        
        Set the elements of the matrix to the same values as the elements
        of the source Matrix.
        """
        ...
    
    def Determinant(self):
        """
        V.Determinant() -> float
        C++: double Determinant()
        V.Determinant((float, float, float, float, float, float, float,
            float, float)) -> float
        C++: static double Determinant(const double elements[9])
        
        Compute the determinant of the matrix and return it.
        """
        ...
    
    def GetData(self):
        """
        V.GetData() -> (float, ...)
        C++: double *GetData()
        
        Return a pointer to the first element of the matrix (double[9]).
        """
        ...
    
    def GetElement(self, p_int, p_int_1):
        """
        V.GetElement(int, int) -> float
        C++: double GetElement(int i, int j)
        
        Returns the element i,j from the matrix.
        """
        ...
    
    def GetNumberOfGenerationsFromBase(self, string):
        """
        V.GetNumberOfGenerationsFromBase(string) -> int
        C++: vtkIdType GetNumberOfGenerationsFromBase(const char *type)
            override;
        
        Given a the name of a base class of this class type, return the
        distance of inheritance between this class type and the named
        class (how many generations of inheritance are there between this
        class and the named class). If the named class is not in this
        class's inheritance tree, return a negative value. Valid
        responses will always be nonnegative. This method works in
        combination with vtkTypeMacro found in vtkSetGet.h.
        """
        ...
    
    def GetNumberOfGenerationsFromBaseType(self, string):
        """
        V.GetNumberOfGenerationsFromBaseType(string) -> int
        C++: static vtkIdType GetNumberOfGenerationsFromBaseType(
            const char *type)
        
        Given a the name of a base class of this class type, return the
        distance of inheritance between this class type and the named
        class (how many generations of inheritance are there between this
        class and the named class). If the named class is not in this
        class's inheritance tree, return a negative value. Valid
        responses will always be nonnegative. This method works in
        combination with vtkTypeMacro found in vtkSetGet.h.
        """
        ...
    
    def Identity(self):
        """
        V.Identity()
        C++: void Identity()
        V.Identity([float, float, float, float, float, float, float,
            float, float])
        C++: static void Identity(double elements[9])
        
        Set equal to Identity matrix
        """
        ...
    
    def Invert(self, vtkMatrix3x3, vtkMatrix3x3_1):
        """
        V.Invert(vtkMatrix3x3, vtkMatrix3x3)
        C++: static void Invert(vtkMatrix3x3 *in, vtkMatrix3x3 *out)
        V.Invert()
        C++: void Invert()
        V.Invert((float, float, float, float, float, float, float, float,
            float), [float, float, float, float, float, float, float,
            float, float])
        C++: static void Invert(const double inElements[9],
            double outElements[9])
        
        Matrix Inversion (adapted from Richard Carling in "Graphics
        Gems," Academic Press, 1990).
        """
        ...
    
    def IsA(self, string):
        """
        V.IsA(string) -> int
        C++: vtkTypeBool IsA(const char *type) override;
        
        Return 1 if this class is the same type of (or a subclass of) the
        named class. Returns 0 otherwise. This method works in
        combination with vtkTypeMacro found in vtkSetGet.h.
        """
        ...
    
    def IsIdentity(self):
        """
        V.IsIdentity() -> bool
        C++: bool IsIdentity()
        """
        ...
    
    def IsTypeOf(self, string):
        """
        V.IsTypeOf(string) -> int
        C++: static vtkTypeBool IsTypeOf(const char *type)
        
        Return 1 if this class type is the same type of (or a subclass
        of) the named class. Returns 0 otherwise. This method works in
        combination with vtkTypeMacro found in vtkSetGet.h.
        """
        ...
    
    def Multiply3x3(self, vtkMatrix3x3, vtkMatrix3x3_1, vtkMatrix3x3_2):
        """
        V.Multiply3x3(vtkMatrix3x3, vtkMatrix3x3, vtkMatrix3x3)
        C++: static void Multiply3x3(vtkMatrix3x3 *a, vtkMatrix3x3 *b,
            vtkMatrix3x3 *c)
        V.Multiply3x3((float, float, float, float, float, float, float,
            float, float), (float, float, float, float, float, float,
            float, float, float), [float, float, float, float, float,
            float, float, float, float])
        C++: static void Multiply3x3(const double a[9], const double b[9],
             double c[9])
        
        Multiplies matrices a and b and stores the result in c (c=a*b).
        """
        ...
    
    def MultiplyPoint(self, , p_float=..., p_float=..., p_float=...):
        """
        V.MultiplyPoint((float, float, float), [float, float, float])
        C++: void MultiplyPoint(const double in[3], double out[3])
        V.MultiplyPoint((float, float, float, float, float, float, float,
            float, float), (float, float, float), [float, float, float])
        C++: static void MultiplyPoint(const double elements[9],
            const double in[3], double out[3])
        """
        ...
    
    def NewInstance(self):
        """
        V.NewInstance() -> vtkMatrix3x3
        C++: vtkMatrix3x3 *NewInstance()
        """
        ...
    
    def SafeDownCast(self, vtkObjectBase):
        """
        V.SafeDownCast(vtkObjectBase) -> vtkMatrix3x3
        C++: static vtkMatrix3x3 *SafeDownCast(vtkObjectBase *o)
        """
        ...
    
    def SetElement(self, p_int, p_int_1, p_float):
        """
        V.SetElement(int, int, float)
        C++: void SetElement(int i, int j, double value)
        
        Sets the element i,j in the matrix.
        """
        ...
    
    def Transpose(self, vtkMatrix3x3, vtkMatrix3x3_1):
        """
        V.Transpose(vtkMatrix3x3, vtkMatrix3x3)
        C++: static void Transpose(vtkMatrix3x3 *in, vtkMatrix3x3 *out)
        V.Transpose()
        C++: void Transpose()
        V.Transpose((float, float, float, float, float, float, float,
            float, float), [float, float, float, float, float, float,
            float, float, float])
        C++: static void Transpose(const double inElements[9],
            double outElements[9])
        
        Transpose the matrix and put it into out.
        """
        ...
    
    def Zero(self):
        """
        V.Zero()
        C++: void Zero()
        V.Zero([float, float, float, float, float, float, float, float,
            float])
        C++: static void Zero(double elements[9])
        
        Set all of the elements to zero.
        """
        ...
    
    def __delattr__(self, *args, **kwargs):
        """ Implement delattr(self, name). """
        ...
    
    def __getattribute__(self, *args, **kwargs):
        """ Return getattr(self, name). """
        ...
    
    def __init__(self, *args, **kwargs) -> None:
        ...
    
    @staticmethod
    def __new__(*args, **kwargs):
        """ Create and return a new object.  See help(type) for accurate signature. """
        ...
    
    def __repr__(self, *args, **kwargs):
        """ Return repr(self). """
        ...
    
    def __setattr__(self, *args, **kwargs):
        """ Implement setattr(self, name, value). """
        ...
    
    def __str__(self, *args, **kwargs) -> str:
        """ Return str(self). """
        ...
    
    __this__ = ...
    __dict__ = ...
    __vtkname__ = ...


class vtkMatrix4x4(__vtkmodules_vtkCommonCore.vtkObject):
    """
    vtkMatrix4x4 - represent and manipulate 4x4 transformation matrices
    
    Superclass: vtkObject
    
    vtkMatrix4x4 is a class to represent and manipulate 4x4 matrices.
    Specifically, it is designed to work on 4x4 transformation matrices
    found in 3D rendering using homogeneous coordinates [x y z w]. Many
    of the methods take an array of 16 doubles in row-major format. Note
    that OpenGL stores matrices in column-major format, so the matrix
    contents must be transposed when they are moved between OpenGL and
    VTK.
    @sa
    vtkTransform
    """
    def Adjoint(self, vtkMatrix4x4, vtkMatrix4x4_1):
        """
        V.Adjoint(vtkMatrix4x4, vtkMatrix4x4)
        C++: void Adjoint(const vtkMatrix4x4 *in, vtkMatrix4x4 *out)
        V.Adjoint((float, float, float, float, float, float, float, float,
             float, float, float, float, float, float, float, float),
            [float, float, float, float, float, float, float, float,
            float, float, float, float, float, float, float, float])
        C++: static void Adjoint(const double inElements[16],
            double outElements[16])
        
        Compute adjoint of the matrix and put it into out.
        """
        ...
    
    def DeepCopy(self, vtkMatrix4x4):
        """
        V.DeepCopy(vtkMatrix4x4)
        C++: void DeepCopy(const vtkMatrix4x4 *source)
        V.DeepCopy([float, float, float, float, float, float, float,
            float, float, float, float, float, float, float, float,
            float], vtkMatrix4x4)
        C++: static void DeepCopy(double destination[16],
            const vtkMatrix4x4 *source)
        V.DeepCopy([float, float, float, float, float, float, float,
            float, float, float, float, float, float, float, float,
            float], (float, float, float, float, float, float, float,
            float, float, float, float, float, float, float, float, float)
            )
        C++: static void DeepCopy(double destination[16],
            const double source[16])
        V.DeepCopy((float, float, float, float, float, float, float,
            float, float, float, float, float, float, float, float, float)
            )
        C++: void DeepCopy(const double elements[16])
        
        Set the elements of the matrix to the same values as the elements
        of the given source matrix.
        """
        ...
    
    def Determinant(self):
        """
        V.Determinant() -> float
        C++: double Determinant()
        V.Determinant((float, float, float, float, float, float, float,
            float, float, float, float, float, float, float, float, float)
            ) -> float
        C++: static double Determinant(const double elements[16])
        
        Compute the determinant of the matrix and return it.
        """
        ...
    
    def GetData(self):
        """
        V.GetData() -> (float, ...)
        C++: double *GetData()
        
        Returns the raw double array holding the matrix.
        """
        ...
    
    def GetElement(self, p_int, p_int_1):
        """
        V.GetElement(int, int) -> float
        C++: double GetElement(int i, int j)
        
        Returns the element i,j from the matrix.
        """
        ...
    
    def GetNumberOfGenerationsFromBase(self, string):
        """
        V.GetNumberOfGenerationsFromBase(string) -> int
        C++: vtkIdType GetNumberOfGenerationsFromBase(const char *type)
            override;
        
        Given a the name of a base class of this class type, return the
        distance of inheritance between this class type and the named
        class (how many generations of inheritance are there between this
        class and the named class). If the named class is not in this
        class's inheritance tree, return a negative value. Valid
        responses will always be nonnegative. This method works in
        combination with vtkTypeMacro found in vtkSetGet.h.
        """
        ...
    
    def GetNumberOfGenerationsFromBaseType(self, string):
        """
        V.GetNumberOfGenerationsFromBaseType(string) -> int
        C++: static vtkIdType GetNumberOfGenerationsFromBaseType(
            const char *type)
        
        Given a the name of a base class of this class type, return the
        distance of inheritance between this class type and the named
        class (how many generations of inheritance are there between this
        class and the named class). If the named class is not in this
        class's inheritance tree, return a negative value. Valid
        responses will always be nonnegative. This method works in
        combination with vtkTypeMacro found in vtkSetGet.h.
        """
        ...
    
    def Identity(self):
        """
        V.Identity()
        C++: void Identity()
        V.Identity([float, float, float, float, float, float, float,
            float, float, float, float, float, float, float, float,
            float])
        C++: static void Identity(double elements[16])
        
        Set equal to Identity matrix
        """
        ...
    
    def Invert(self, vtkMatrix4x4, vtkMatrix4x4_1):
        """
        V.Invert(vtkMatrix4x4, vtkMatrix4x4)
        C++: static void Invert(const vtkMatrix4x4 *in, vtkMatrix4x4 *out)
        V.Invert()
        C++: void Invert()
        V.Invert((float, float, float, float, float, float, float, float,
            float, float, float, float, float, float, float, float),
            [float, float, float, float, float, float, float, float,
            float, float, float, float, float, float, float, float])
        C++: static void Invert(const double inElements[16],
            double outElements[16])
        
        Matrix Inversion (adapted from Richard Carling in "Graphics
        Gems," Academic Press, 1990).
        """
        ...
    
    def IsA(self, string):
        """
        V.IsA(string) -> int
        C++: vtkTypeBool IsA(const char *type) override;
        
        Return 1 if this class is the same type of (or a subclass of) the
        named class. Returns 0 otherwise. This method works in
        combination with vtkTypeMacro found in vtkSetGet.h.
        """
        ...
    
    def IsIdentity(self):
        """
        V.IsIdentity() -> bool
        C++: bool IsIdentity()
        
        Returns true if this matrix is equal to the identity matrix.
        """
        ...
    
    def IsTypeOf(self, string):
        """
        V.IsTypeOf(string) -> int
        C++: static vtkTypeBool IsTypeOf(const char *type)
        
        Return 1 if this class type is the same type of (or a subclass
        of) the named class. Returns 0 otherwise. This method works in
        combination with vtkTypeMacro found in vtkSetGet.h.
        """
        ...
    
    def Multiply4x4(self, vtkMatrix4x4, vtkMatrix4x4_1, vtkMatrix4x4_2):
        """
        V.Multiply4x4(vtkMatrix4x4, vtkMatrix4x4, vtkMatrix4x4)
        C++: static void Multiply4x4(const vtkMatrix4x4 *a,
            const vtkMatrix4x4 *b, vtkMatrix4x4 *c)
        V.Multiply4x4((float, float, float, float, float, float, float,
            float, float, float, float, float, float, float, float, float)
            , (float, float, float, float, float, float, float, float,
            float, float, float, float, float, float, float, float),
            [float, float, float, float, float, float, float, float,
            float, float, float, float, float, float, float, float])
        C++: static void Multiply4x4(const double a[16],
            const double b[16], double c[16])
        
        Multiplies matrices a and b and stores the result in c.
        """
        ...
    
    def MultiplyDoublePoint(self, ):
        """
        V.MultiplyDoublePoint((float, float, float, float)) -> (float,
            float, float, float)
        C++: double *MultiplyDoublePoint(const double in[4])
        """
        ...
    
    def MultiplyFloatPoint(self, ):
        """
        V.MultiplyFloatPoint((float, float, float, float)) -> (float,
            float, float, float)
        C++: float *MultiplyFloatPoint(const float in[4])
        """
        ...
    
    def MultiplyPoint(self, , p_float=..., p_float=..., p_float=..., p_float=...):
        """
        V.MultiplyPoint((float, float, float, float), [float, float,
            float, float])
        C++: void MultiplyPoint(const double in[4], double out[4])
        V.MultiplyPoint((float, float, float, float, float, float, float,
            float, float, float, float, float, float, float, float, float)
            , (float, float, float, float), [float, float, float, float])
        C++: static void MultiplyPoint(const double elements[16],
            const double in[4], double out[4])
        V.MultiplyPoint((float, float, float, float)) -> (float, float,
            float, float)
        C++: double *MultiplyPoint(const double in[4])
        """
        ...
    
    def NewInstance(self):
        """
        V.NewInstance() -> vtkMatrix4x4
        C++: vtkMatrix4x4 *NewInstance()
        """
        ...
    
    def SafeDownCast(self, vtkObjectBase):
        """
        V.SafeDownCast(vtkObjectBase) -> vtkMatrix4x4
        C++: static vtkMatrix4x4 *SafeDownCast(vtkObjectBase *o)
        """
        ...
    
    def SetElement(self, p_int, p_int_1, p_float):
        """
        V.SetElement(int, int, float)
        C++: void SetElement(int i, int j, double value)
        
        Sets the element i,j in the matrix.
        """
        ...
    
    def Transpose(self, vtkMatrix4x4, vtkMatrix4x4_1):
        """
        V.Transpose(vtkMatrix4x4, vtkMatrix4x4)
        C++: static void Transpose(const vtkMatrix4x4 *in,
            vtkMatrix4x4 *out)
        V.Transpose()
        C++: void Transpose()
        V.Transpose((float, float, float, float, float, float, float,
            float, float, float, float, float, float, float, float, float)
            , [float, float, float, float, float, float, float, float,
            float, float, float, float, float, float, float, float])
        C++: static void Transpose(const double inElements[16],
            double outElements[16])
        
        Transpose the matrix and put it into out.
        """
        ...
    
    def Zero(self):
        """
        V.Zero()
        C++: void Zero()
        V.Zero([float, float, float, float, float, float, float, float,
            float, float, float, float, float, float, float, float])
        C++: static void Zero(double elements[16])
        
        Set all of the elements to zero.
        """
        ...
    
    def __delattr__(self, *args, **kwargs):
        """ Implement delattr(self, name). """
        ...
    
    def __getattribute__(self, *args, **kwargs):
        """ Return getattr(self, name). """
        ...
    
    def __init__(self, *args, **kwargs) -> None:
        ...
    
    @staticmethod
    def __new__(*args, **kwargs):
        """ Create and return a new object.  See help(type) for accurate signature. """
        ...
    
    def __repr__(self, *args, **kwargs):
        """ Return repr(self). """
        ...
    
    def __setattr__(self, *args, **kwargs):
        """ Implement setattr(self, name, value). """
        ...
    
    def __str__(self, *args, **kwargs) -> str:
        """ Return str(self). """
        ...
    
    __this__ = ...
    __dict__ = ...
    __vtkname__ = ...


class vtkPolynomialSolversUnivariate(__vtkmodules_vtkCommonCore.vtkObject):
    """
    vtkPolynomialSolversUnivariate - polynomial solvers
    
    Superclass: vtkObject
    
    vtkPolynomialSolversUnivariate provides solvers for univariate
    polynomial equations with real coefficients. The Tartaglia-Cardan and
    Ferrari solvers work on polynomials of fixed degree 3 and 4,
    respectively. The Lin-Bairstow and Sturm solvers work on polynomials
    of arbitrary degree. The Sturm solver is the most robust solver but
    only reports roots within an interval and does not report
    multiplicities. The Lin-Bairstow solver reports multiplicities.
    
    For difficult polynomials, you may wish to use FilterRoots to
    eliminate some of the roots reported by the Sturm solver. FilterRoots
    evaluates the derivatives near each root to eliminate cases where a
    local minimum or maximum is close to zero.
    
    @par Thanks: Thanks to Philippe Pebay, Korben Rusek, David Thompson,
    and Maurice Rojas for implementing these solvers.
    """
    def FerrariSolve(self, *float, **kwargs):
        """
        V.FerrariSolve([float, ...], [float, ...], [int, ...], float)
            -> int
        C++: static int FerrariSolve(double *c, double *r, int *m,
            double tol)
        
        Algebraically extracts REAL roots of the quartic polynomial with
        REAL coefficients X^4 + c[0] X^3 + c[1] X^2 + c[2] X + c[3] and
        stores them (when they exist) and their respective multiplicities
        in the r and m arrays, based on Ferrari's method. Some numerical
        noise can be filtered by the use of a tolerance tol instead of
        equality with 0 (one can use, e.g., VTK_DBL_EPSILON). Returns the
        number of roots. Warning: it is the user's responsibility to pass
        a non-negative tol.
        """
        ...
    
    def FilterRoots(self, *float, **kwargs):
        """
        V.FilterRoots([float, ...], int, [float, ...], int, float) -> int
        C++: static int FilterRoots(double *P, int d, double *upperBnds,
            int rootcount, double diameter)
        
        This uses the derivative sequence to filter possible roots of a
        polynomial. First it sorts the roots and removes any duplicates.
        If the number of sign changes of the derivative sequence at a
        root at upperBnds[i] == that at upperBnds[i]  - diameter then the
        i^th value is removed from upperBnds. It returns the new number
        of roots.
        """
        ...
    
    def GetDivisionTolerance(self):
        """
        V.GetDivisionTolerance() -> float
        C++: static double GetDivisionTolerance()
        
        Set/get the tolerance used when performing polynomial Euclidean
        division to find polynomial roots. This tolerance is used to
        decide whether the coefficient(s) of a polynomial remainder are
        close enough to zero to be neglected.
        """
        ...
    
    def GetNumberOfGenerationsFromBase(self, string):
        """
        V.GetNumberOfGenerationsFromBase(string) -> int
        C++: vtkIdType GetNumberOfGenerationsFromBase(const char *type)
            override;
        
        Given a the name of a base class of this class type, return the
        distance of inheritance between this class type and the named
        class (how many generations of inheritance are there between this
        class and the named class). If the named class is not in this
        class's inheritance tree, return a negative value. Valid
        responses will always be nonnegative. This method works in
        combination with vtkTypeMacro found in vtkSetGet.h.
        """
        ...
    
    def GetNumberOfGenerationsFromBaseType(self, string):
        """
        V.GetNumberOfGenerationsFromBaseType(string) -> int
        C++: static vtkIdType GetNumberOfGenerationsFromBaseType(
            const char *type)
        
        Given a the name of a base class of this class type, return the
        distance of inheritance between this class type and the named
        class (how many generations of inheritance are there between this
        class and the named class). If the named class is not in this
        class's inheritance tree, return a negative value. Valid
        responses will always be nonnegative. This method works in
        combination with vtkTypeMacro found in vtkSetGet.h.
        """
        ...
    
    def HabichtBisectionSolve(self, *float, **kwargs):
        """
        V.HabichtBisectionSolve([float, ...], int, [float, ...], [float,
            ...], float) -> int
        C++: static int HabichtBisectionSolve(double *P, int d, double *a,
             double *upperBnds, double tol)
        V.HabichtBisectionSolve([float, ...], int, [float, ...], [float,
            ...], float, int) -> int
        C++: static int HabichtBisectionSolve(double *P, int d, double *a,
             double *upperBnds, double tol, int intervalType)
        V.HabichtBisectionSolve([float, ...], int, [float, ...], [float,
            ...], float, int, bool) -> int
        C++: static int HabichtBisectionSolve(double *P, int d, double *a,
             double *upperBnds, double tol, int intervalType,
            bool divideGCD)
        
        Finds all REAL roots (within tolerance tol) of the d -th degree
        polynomial\[ P[0] X^d + ... + P[d-1] X + P[d]\] in ] a[0] ; a[1]]
        using the Habicht sequence (polynomial coefficients are REAL) and
        returns the count nr. All roots are bracketed in the
        
        r first ] upperBnds[i] - tol ; upperBnds[i]] intervals. Returns
        -1 if anything went wrong (such as: polynomial does not have
        degree d, the interval provided by the other is absurd, etc.).
        
        * intervalType specifies the search interval as follows:
        * 0 = 00 = ]a,b[
        * 1 = 10 = [a,b[
        * 2 = 01 = ]a,b]
        * 3 = 11 = [a,b]
        * This defaults to 0.
        
        * The last non-zero item in the Habicht sequence is the gcd of P
          and P'. The
        * parameter divideGCD specifies whether the program should
          attempt to divide
        * by the gcd and run again. It works better with polynomials
          known to have
        * high multiplicities. When divideGCD != 0 then it attempts to
          divide by the
        * GCD, if applicable. This defaults to 0.
        
        * Compared to the Sturm solver the Habicht solver is slower,
        * although both are O(d^2). The Habicht solver has the added
          benefit
        * that it has a built in mechanism to keep the leading
          coefficients of the
        * result from polynomial division bounded above and below in
          absolute value.
        * This will tend to keep the coefficients of the polynomials in
          the sequence
        * from zeroi ...
         [Truncated]
        """
        ...
    
    def IsA(self, string):
        """
        V.IsA(string) -> int
        C++: vtkTypeBool IsA(const char *type) override;
        
        Return 1 if this class is the same type of (or a subclass of) the
        named class. Returns 0 otherwise. This method works in
        combination with vtkTypeMacro found in vtkSetGet.h.
        """
        ...
    
    def IsTypeOf(self, string):
        """
        V.IsTypeOf(string) -> int
        C++: static vtkTypeBool IsTypeOf(const char *type)
        
        Return 1 if this class type is the same type of (or a subclass
        of) the named class. Returns 0 otherwise. This method works in
        combination with vtkTypeMacro found in vtkSetGet.h.
        """
        ...
    
    def LinBairstowSolve(self, *float, **kwargs):
        """
        V.LinBairstowSolve([float, ...], int, [float, ...], float) -> int
        C++: static int LinBairstowSolve(double *c, int d, double *r,
            double &tolerance)
        
        Seeks all REAL roots of the d -th degree polynomial c[0] X^d +
        ... + c[d-1] X + c[d] = 0 equation Lin-Bairstow's method (
        polynomial coefficients are REAL ) and stores the nr roots found
        ( multiple roots are multiply stored ) in r.tolerance is the
        user-defined solver tolerance; this variable may be relaxed by
        the iterative solver if needed. Returns nr. Warning: it is the
        user's responsibility to make sure the r array is large enough to
        contain the maximal number of expected roots.
        """
        ...
    
    def NewInstance(self):
        """
        V.NewInstance() -> vtkPolynomialSolversUnivariate
        C++: vtkPolynomialSolversUnivariate *NewInstance()
        """
        ...
    
    def SafeDownCast(self, vtkObjectBase):
        """
        V.SafeDownCast(vtkObjectBase) -> vtkPolynomialSolversUnivariate
        C++: static vtkPolynomialSolversUnivariate *SafeDownCast(
            vtkObjectBase *o)
        """
        ...
    
    def SetDivisionTolerance(self, p_float):
        """
        V.SetDivisionTolerance(float)
        C++: static void SetDivisionTolerance(double tol)
        
        Set/get the tolerance used when performing polynomial Euclidean
        division to find polynomial roots. This tolerance is used to
        decide whether the coefficient(s) of a polynomial remainder are
        close enough to zero to be neglected.
        """
        ...
    
    def SolveCubic(self, p_float, p_float_1, p_float_2, p_float_3):
        """
        V.SolveCubic(float, float, float, float) -> (float, ...)
        C++: static double *SolveCubic(double c0, double c1, double c2,
            double c3)
        V.SolveCubic(float, float, float, float, [float, ...], [float,
            ...], [float, ...], [int, ...]) -> int
        C++: static int SolveCubic(double c0, double c1, double c2,
            double c3, double *r1, double *r2, double *r3, int *num_roots)
        
        Solves a cubic equation c0*t^3 + c1*t^2 + c2*t + c3 = 0 when c0,
        c1, c2, and c3 are REAL.  Solution is motivated by Numerical
        Recipes In C 2nd Ed.  Return array contains number of (real)
        roots (counting multiple roots as one) followed by roots
        themselves. The value in roots[4] is a integer giving further
        information about the roots (see return codes for int
        SolveCubic() ).
        """
        ...
    
    def SolveLinear(self, p_float, p_float_1):
        """
        V.SolveLinear(float, float) -> (float, ...)
        C++: static double *SolveLinear(double c0, double c1)
        V.SolveLinear(float, float, [float, ...], [int, ...]) -> int
        C++: static int SolveLinear(double c0, double c1, double *r1,
            int *num_roots)
        
        Solves a linear equation c0*t  + c1 = 0 when c0 and c1 are REAL.
        Solution is motivated by Numerical Recipes In C 2nd Ed. Return
        array contains number of roots followed by roots themselves.
        """
        ...
    
    def SolveQuadratic(self, p_float, p_float_1, p_float_2):
        """
        V.SolveQuadratic(float, float, float) -> (float, ...)
        C++: static double *SolveQuadratic(double c0, double c1,
            double c2)
        V.SolveQuadratic(float, float, float, [float, ...], [float, ...],
            [int, ...]) -> int
        C++: static int SolveQuadratic(double c0, double c1, double c2,
            double *r1, double *r2, int *num_roots)
        V.SolveQuadratic([float, ...], [float, ...], [int, ...]) -> int
        C++: static int SolveQuadratic(double *c, double *r, int *m)
        
        Solves a quadratic equation c0*t^2 + c1*t + c2 = 0 when c0, c1,
        and c2 are REAL.  Solution is motivated by Numerical Recipes In C
        2nd Ed. Return array contains number of (real) roots (counting
        multiple roots as one) followed by roots themselves. Note that
        roots[3] contains a return code further describing solution - see
        documentation for SolveCubic() for meaning of return codes.
        """
        ...
    
    def SturmBisectionSolve(self, *float, **kwargs):
        """
        V.SturmBisectionSolve([float, ...], int, [float, ...], [float,
            ...], float) -> int
        C++: static int SturmBisectionSolve(double *P, int d, double *a,
            double *upperBnds, double tol)
        V.SturmBisectionSolve([float, ...], int, [float, ...], [float,
            ...], float, int) -> int
        C++: static int SturmBisectionSolve(double *P, int d, double *a,
            double *upperBnds, double tol, int intervalType)
        V.SturmBisectionSolve([float, ...], int, [float, ...], [float,
            ...], float, int, bool) -> int
        C++: static int SturmBisectionSolve(double *P, int d, double *a,
            double *upperBnds, double tol, int intervalType,
            bool divideGCD)
        
        Finds all REAL roots (within tolerance tol) of the d -th degree
        polynomial P[0] X^d + ... + P[d-1] X + P[d] in ] a[0] ; a[1]]
        using Sturm's theorem ( polynomial coefficients are REAL ) and
        returns the count nr. All roots are bracketed in the
        
        r first ] upperBnds[i] - tol ; upperBnds[i]] intervals. Returns
        -1 if anything went wrong (such as: polynomial does not have
        degree d, the interval provided by the other is absurd, etc.).
        
        * intervalType specifies the search interval as follows:
        * 0 = 00 = ]a,b[
        * 1 = 10 = [a,b[
        * 2 = 01 = ]a,b]
        * 3 = 11 = [a,b]
        * This defaults to 0.
        
        * The last non-zero item in the Sturm sequence is the gcd of P
          and P'. The
        * parameter divideGCD specifies whether the program should
          attempt to divide
        * by the gcd and run again. It works better with polynomials
          known to have
        * high multiplicities. When divideGCD != 0 then it attempts to
          divide by the
        * GCD, if applicable. This defaults to 0.
        
        * Constructing the Sturm sequence is O(d^2) in both time and
          space.
        
        * Warning: it is the user's responsibility to make sure the
          upperBnds
        * array is large enough to contain the maximal number of expected
        roots.
        * Note that nr is smaller or equal to the actual number of roots
          in
        * ] a[0] ; a[1]] since roots within \tol are lumped in the same
          bracket.
        * array is large enough to contain the ma ...
         [Truncated]
        """
        ...
    
    def TartagliaCardanSolve(self, *float, **kwargs):
        """
        V.TartagliaCardanSolve([float, ...], [float, ...], [int, ...],
            float) -> int
        C++: static int TartagliaCardanSolve(double *c, double *r, int *m,
             double tol)
        
        Algebraically extracts REAL roots of the cubic polynomial with
        REAL coefficients X^3 + c[0] X^2 + c[1] X + c[2] and stores them
        (when they exist) and their respective multiplicities in the r
        and m arrays. Some numerical noise can be filtered by the use of
        a tolerance tol instead of equality with 0 (one can use, e.g.,
        VTK_DBL_EPSILON). The main differences with SolveCubic are that
        (1) the polynomial must have unit leading coefficient, (2)
        complex roots are discarded upfront, (3) non-simple roots are
        stored only once, along with their respective multiplicities, and
        (4) some numerical noise is filtered by the use of relative
        tolerance instead of equality with 0. Returns the number of
        roots. In memoriam Niccolo Tartaglia (1500 - 1559), unfairly
        forgotten.
        """
        ...
    
    def __delattr__(self, *args, **kwargs):
        """ Implement delattr(self, name). """
        ...
    
    def __getattribute__(self, *args, **kwargs):
        """ Return getattr(self, name). """
        ...
    
    def __init__(self, *args, **kwargs) -> None:
        ...
    
    @staticmethod
    def __new__(*args, **kwargs):
        """ Create and return a new object.  See help(type) for accurate signature. """
        ...
    
    def __repr__(self, *args, **kwargs):
        """ Return repr(self). """
        ...
    
    def __setattr__(self, *args, **kwargs):
        """ Implement setattr(self, name, value). """
        ...
    
    def __str__(self, *args, **kwargs) -> str:
        """ Return str(self). """
        ...
    
    __this__ = ...
    __dict__ = ...
    __vtkname__ = ...


class vtkTuple_IdLi4EE(object):
    """
    vtkTuple<double, 4> - templated base type for containers of constant
    size.
    
    This class is a templated data type for storing and manipulating
    tuples.
    
    vtkTuple()
    explicit vtkTuple(const double &scalar)
    explicit vtkTuple(const double *init)
    vtkTuple(const &vtkTuple<double, 4>)
    """
    def Compare(self, vtkTuple_IdLi4EE, p_float):
        """
        V.Compare(vtkTuple_IdLi4EE, float) -> bool
        C++: bool Compare(const vtkTuple<double, 4> &other,
            const double &tol)
        
        Equality operator with a tolerance to allow fuzzy comparisons.
        """
        ...
    
    def GetData(self):
        """
        V.GetData() -> (float, ...)
        C++: double *GetData()
        
        Get a pointer to the underlying data of the tuple.
        """
        ...
    
    def GetSize(self):
        """
        V.GetSize() -> int
        C++: int GetSize()
        
        Get the size of the tuple.
        """
        ...
    
    def __delitem__(self, *args, **kwargs):
        """ Delete self[key]. """
        ...
    
    def __getattribute__(self, *args, **kwargs):
        """ Return getattr(self, name). """
        ...
    
    def __getitem__(self, *args, **kwargs):
        """ Return self[key]. """
        ...
    
    def __hash__(self, *args, **kwargs) -> int:
        """ Return hash(self). """
        ...
    
    def __init__(self, *args, **kwargs) -> None:
        ...
    
    def __len__(self, *args, **kwargs):
        """ Return len(self). """
        ...
    
    @staticmethod
    def __new__(*args, **kwargs):
        """ Create and return a new object.  See help(type) for accurate signature. """
        ...
    
    def __repr__(self, *args, **kwargs):
        """ Return repr(self). """
        ...
    
    def __setitem__(self, *args, **kwargs):
        """ Set self[key] to value. """
        ...
    
    def __str__(self, *args, **kwargs) -> str:
        """ Return str(self). """
        ...
    


class vtkQuaternion_IdE(vtkTuple_IdLi4EE):
    """
    vtkQuaternion- templated base type for storage of quaternions.
    
    Superclass: vtkTuple[float64,4]
    
    This class is a templated data type for storing and manipulating
    quaternions. The quaternions have the form [w, x, y, z]. Given a
    rotation of angle theta and axis v, the corresponding quaternion is
    [w, x, y, z] = [cos(theta/2), v*sin(theta/2)]
    
    This class implements the Spherical Linear interpolation (SLERP) and
    the Spherical Spline Quaternion interpolation (SQUAD). It is advised
    to use the vtkQuaternionInterpolator when dealing with multiple
    quaternions and or interpolations.
    
    @sa
    vtkQuaternionInterpolator
    
    vtkQuaternion()
    explicit vtkQuaternion(const double &scalar)
    explicit vtkQuaternion(const double *init)
    vtkQuaternion(const double &w, const double &x, const double &y,
        const double &z)
    vtkQuaternion(const &vtkQuaternion<double>)
    """
    def Conjugate(self):
        """
        V.Conjugate()
        C++: void Conjugate()
        
        Conjugate the quaternion in place.
        """
        ...
    
    def Conjugated(self):
        """
        V.Conjugated() -> vtkQuaternion_IdE
        C++: vtkQuaternion<double> Conjugated()
        
        Return the conjugate form of this quaternion.
        """
        ...
    
    def FromMatrix3x3(self, , , ):
        """
        V.FromMatrix3x3(((float, float, float), (float, float, float), (
            float, float, float)))
        C++: void FromMatrix3x3(const double A[3][3])
        
        Convert a 3x3 matrix into a quaternion.  This will provide the
        best possible answer even if the matrix is not a pure rotation
        matrix. The method used is that of B.K.P. Horn.
        @sa ToMatrix3x3()
        """
        ...
    
    def Get(self, p_float=..., p_float=..., p_float=..., p_float=...):
        """
        V.Get([float, float, float, float])
        C++: void Get(double quat[4])
        
        Set/Get the w, x, y and z components of the quaternion.
        """
        ...
    
    def GetRotationAngleAndAxis(self, p_float=..., p_float=..., p_float=...):
        """
        V.GetRotationAngleAndAxis([float, float, float]) -> float
        C++: double GetRotationAngleAndAxis(double axis[3])
        
        Set/Get the angle (in radians) and the axis corresponding to the
        axis-angle rotation of this quaternion.
        """
        ...
    
    def GetW(self):
        """
        V.GetW() -> float
        C++: const double &GetW()
        
        Set/Get the w component of the quaternion, i.e. element 0.
        """
        ...
    
    def GetX(self):
        """
        V.GetX() -> float
        C++: const double &GetX()
        
        Set/Get the x component of the quaternion, i.e. element 1.
        """
        ...
    
    def GetY(self):
        """
        V.GetY() -> float
        C++: const double &GetY()
        
        Set/Get the y component of the quaternion, i.e. element 2.
        """
        ...
    
    def GetZ(self):
        """
        V.GetZ() -> float
        C++: const double &GetZ()
        
        Set/Get the y component of the quaternion, i.e. element 3.
        """
        ...
    
    def Identity(self):
        """
        V.Identity() -> vtkQuaternion_IdE
        C++: static vtkQuaternion<double> Identity()
        
        Return the identity quaternion. Note that the default constructor
        also creates an identity quaternion.
        """
        ...
    
    def InnerPoint(self, vtkQuaternion_IdE, vtkQuaternion_IdE_1):
        """
        V.InnerPoint(vtkQuaternion_IdE, vtkQuaternion_IdE)
            -> vtkQuaternion_IdE
        C++: vtkQuaternion<double> InnerPoint(
            const vtkQuaternion<double> &q1,
            const vtkQuaternion<double> &q2)
        
        Interpolates between quaternions, using spherical quadrangle
        interpolation.
        @sa vtkQuaternionInterpolator
        """
        ...
    
    def Inverse(self):
        """
        V.Inverse() -> vtkQuaternion_IdE
        C++: vtkQuaternion<double> Inverse()
        
        Return the inverted form of this quaternion.
        """
        ...
    
    def Invert(self):
        """
        V.Invert()
        C++: void Invert()
        
        Invert the quaternion in place. This is equivalent to conjugate
        the quaternion and then divide it by its squared norm.
        """
        ...
    
    def Norm(self):
        """
        V.Norm() -> float
        C++: double Norm()
        
        Get the norm of the quaternion, i.e. its length.
        """
        ...
    
    def Normalize(self):
        """
        V.Normalize() -> float
        C++: double Normalize()
        
        Normalize the quaternion in place. Return the norm of the
        quaternion.
        """
        ...
    
    def Normalized(self):
        """
        V.Normalized() -> vtkQuaternion_IdE
        C++: vtkQuaternion<double> Normalized()
        
        Return the normalized form of this quaternion.
        """
        ...
    
    def NormalizedWithAngleInDegrees(self):
        """
        V.NormalizedWithAngleInDegrees() -> vtkQuaternion_IdE
        C++: vtkQuaternion<double> NormalizedWithAngleInDegrees()
        
        Returns a quaternion normalized and transformed so its angle is
        in degrees and its axis normalized.
        """
        ...
    
    def NormalizeWithAngleInDegrees(self):
        """
        V.NormalizeWithAngleInDegrees()
        C++: void NormalizeWithAngleInDegrees()
        
        Normalize a quaternion in place and transform it to so its angle
        is in degrees and its axis normalized.
        """
        ...
    
    def Set(self, p_float, p_float_1, p_float_2, p_float_3):
        """
        V.Set(float, float, float, float)
        C++: void Set(const double &w, const double &x, const double &y,
            const double &z)
        V.Set([float, float, float, float])
        C++: void Set(double quat[4])
        
        Set/Get the w, x, y and z components of the quaternion.
        """
        ...
    
    def SetRotationAngleAndAxis(self, p_float, p_float=..., p_float=..., p_float=...):
        """
        V.SetRotationAngleAndAxis(float, [float, float, float])
        C++: void SetRotationAngleAndAxis(double angle, double axis[3])
        V.SetRotationAngleAndAxis(float, float, float, float)
        C++: void SetRotationAngleAndAxis(const double &angle,
            const double &x, const double &y, const double &z)
        
        Set/Get the angle (in radians) and the axis corresponding to the
        axis-angle rotation of this quaternion.
        """
        ...
    
    def SetW(self, p_float):
        """
        V.SetW(float)
        C++: void SetW(const double &w)
        
        Set/Get the w component of the quaternion, i.e. element 0.
        """
        ...
    
    def SetX(self, p_float):
        """
        V.SetX(float)
        C++: void SetX(const double &x)
        
        Set/Get the x component of the quaternion, i.e. element 1.
        """
        ...
    
    def SetY(self, p_float):
        """
        V.SetY(float)
        C++: void SetY(const double &y)
        
        Set/Get the y component of the quaternion, i.e. element 2.
        """
        ...
    
    def SetZ(self, p_float):
        """
        V.SetZ(float)
        C++: void SetZ(const double &z)
        
        Set/Get the y component of the quaternion, i.e. element 3.
        """
        ...
    
    def Slerp(self, p_float, vtkQuaternion_IdE):
        """
        V.Slerp(float, vtkQuaternion_IdE) -> vtkQuaternion_IdE
        C++: vtkQuaternion<double> Slerp(double t,
            const vtkQuaternion<double> &q)
        
        Interpolate quaternions using spherical linear interpolation
        between this quaternion and q1 to produce the output. The
        parametric coordinate t belongs to [0,1] and lies between
        (this,q1).
        @sa vtkQuaternionInterpolator
        """
        ...
    
    def SquaredNorm(self):
        """
        V.SquaredNorm() -> float
        C++: double SquaredNorm()
        
        Get the squared norm of the quaternion.
        """
        ...
    
    def ToIdentity(self):
        """
        V.ToIdentity()
        C++: void ToIdentity()
        
        Set the quaternion to identity in place.
        """
        ...
    
    def ToMatrix3x3(self, *args, **kwargs):
        """
        V.ToMatrix3x3([[float, float, float], [float, float, float],
            [float, float, float]])
        C++: void ToMatrix3x3(double A[3][3])
        
        Convert a quaternion to a 3x3 rotation matrix. The quaternion
        does not have to be normalized beforehand.
        @sa FromMatrix3x3()
        """
        ...
    
    def ToUnitExp(self):
        """
        V.ToUnitExp()
        C++: void ToUnitExp()
        
        Convert this quaternion to a unit exponential quaternion. The
        unit exponential quaternion is defined by: [w, x, y, z] = 
        [cos(theta), v*sin(theta)].
        """
        ...
    
    def ToUnitLog(self):
        """
        V.ToUnitLog()
        C++: void ToUnitLog()
        
        Convert this quaternion to a unit log quaternion. The unit log
        quaternion is defined by: [w, x, y, z] =  [0.0, v*theta].
        """
        ...
    
    def UnitExp(self):
        """
        V.UnitExp() -> vtkQuaternion_IdE
        C++: vtkQuaternion<double> UnitExp()
        
        Return the unit exponential version of this quaternion. The unit
        exponential quaternion is defined by: [w, x, y, z] = 
        [cos(theta), v*sin(theta)].
        """
        ...
    
    def UnitLog(self):
        """
        V.UnitLog() -> vtkQuaternion_IdE
        C++: vtkQuaternion<double> UnitLog()
        
        Return the unit log version of this quaternion. The unit log
        quaternion is defined by: [w, x, y, z] =  [0.0, v*theta].
        """
        ...
    
    def __getattribute__(self, *args, **kwargs):
        """ Return getattr(self, name). """
        ...
    
    def __hash__(self, *args, **kwargs) -> int:
        """ Return hash(self). """
        ...
    
    def __init__(self, *args, **kwargs) -> None:
        ...
    
    @staticmethod
    def __new__(*args, **kwargs):
        """ Create and return a new object.  See help(type) for accurate signature. """
        ...
    
    def __repr__(self, *args, **kwargs):
        """ Return repr(self). """
        ...
    


class vtkQuaterniond(vtkQuaternion_IdE):
    """
    vtkQuaterniond - no description provided.
    
    Superclass: vtkQuaternion[float64]
    
    vtkQuaterniond()
    explicit vtkQuaterniond(double w, double x, double y, double z)
    explicit vtkQuaterniond(double scalar)
    explicit vtkQuaterniond(const double *init)
    vtkQuaterniond(const &vtkQuaterniond)
    """
    def Conjugated(self):
        """
        V.Conjugated() -> vtkQuaterniond
        C++: vtkQuaterniond Conjugated()
        
        Return the conjugate form of this quaternion.
        """
        ...
    
    def Identity(self):
        """
        V.Identity() -> vtkQuaterniond
        C++: vtkQuaterniond Identity()
        
        Return the identity quaternion. Note that the default constructor
        also creates an identity quaternion.
        """
        ...
    
    def InnerPoint(self, vtkQuaterniond, vtkQuaterniond_1):
        """
        V.InnerPoint(vtkQuaterniond, vtkQuaterniond) -> vtkQuaterniond
        C++: vtkQuaterniond InnerPoint(const vtkQuaterniond &q1,
            const vtkQuaterniond &q2)
        """
        ...
    
    def Inverse(self):
        """
        V.Inverse() -> vtkQuaterniond
        C++: vtkQuaterniond Inverse()
        
        Return the inverted form of this quaternion.
        """
        ...
    
    def Normalized(self):
        """
        V.Normalized() -> vtkQuaterniond
        C++: vtkQuaterniond Normalized()
        
        Return the normalized form of this quaternion.
        """
        ...
    
    def NormalizedWithAngleInDegrees(self):
        """
        V.NormalizedWithAngleInDegrees() -> vtkQuaterniond
        C++: vtkQuaterniond NormalizedWithAngleInDegrees()
        
        Returns a quaternion normalized and transformed so its angle is
        in degrees and its axis normalized.
        """
        ...
    
    def Slerp(self, p_float, vtkQuaterniond):
        """
        V.Slerp(float, vtkQuaterniond) -> vtkQuaterniond
        C++: vtkQuaterniond Slerp(double t, const vtkQuaterniond &q)
        """
        ...
    
    def UnitExp(self):
        """
        V.UnitExp() -> vtkQuaterniond
        C++: vtkQuaterniond UnitExp()
        
        Return the unit exponential version of this quaternion. The unit
        exponential quaternion is defined by: [w, x, y, z] = 
        [cos(theta), v*sin(theta)].
        """
        ...
    
    def UnitLog(self):
        """
        V.UnitLog() -> vtkQuaterniond
        C++: vtkQuaterniond UnitLog()
        
        Return the unit log version of this quaternion. The unit log
        quaternion is defined by: [w, x, y, z] =  [0.0, v*theta].
        """
        ...
    
    def __getattribute__(self, *args, **kwargs):
        """ Return getattr(self, name). """
        ...
    
    def __hash__(self, *args, **kwargs) -> int:
        """ Return hash(self). """
        ...
    
    def __init__(self) -> None:
        ...
    
    @staticmethod
    def __new__(*args, **kwargs):
        """ Create and return a new object.  See help(type) for accurate signature. """
        ...
    
    def __repr__(self, *args, **kwargs):
        """ Return repr(self). """
        ...
    


class vtkTuple_IfLi4EE(object):
    """
    vtkTuple<float, 4> - templated base type for containers of constant
    size.
    
    This class is a templated data type for storing and manipulating
    tuples.
    
    vtkTuple()
    explicit vtkTuple(const float &scalar)
    explicit vtkTuple(const float *init)
    vtkTuple(const &vtkTuple<float, 4>)
    """
    def Compare(self, vtkTuple_IfLi4EE, p_float):
        """
        V.Compare(vtkTuple_IfLi4EE, float) -> bool
        C++: bool Compare(const vtkTuple<float, 4> &other,
            const float &tol)
        
        Equality operator with a tolerance to allow fuzzy comparisons.
        """
        ...
    
    def GetData(self):
        """
        V.GetData() -> (float, ...)
        C++: float *GetData()
        
        Get a pointer to the underlying data of the tuple.
        """
        ...
    
    def GetSize(self):
        """
        V.GetSize() -> int
        C++: int GetSize()
        
        Get the size of the tuple.
        """
        ...
    
    def __delitem__(self, *args, **kwargs):
        """ Delete self[key]. """
        ...
    
    def __getattribute__(self, *args, **kwargs):
        """ Return getattr(self, name). """
        ...
    
    def __getitem__(self, *args, **kwargs):
        """ Return self[key]. """
        ...
    
    def __hash__(self, *args, **kwargs) -> int:
        """ Return hash(self). """
        ...
    
    def __init__(self, *args, **kwargs) -> None:
        ...
    
    def __len__(self, *args, **kwargs):
        """ Return len(self). """
        ...
    
    @staticmethod
    def __new__(*args, **kwargs):
        """ Create and return a new object.  See help(type) for accurate signature. """
        ...
    
    def __repr__(self, *args, **kwargs):
        """ Return repr(self). """
        ...
    
    def __setitem__(self, *args, **kwargs):
        """ Set self[key] to value. """
        ...
    
    def __str__(self, *args, **kwargs) -> str:
        """ Return str(self). """
        ...
    


class vtkQuaternion_IfE(vtkTuple_IfLi4EE):
    """
    vtkQuaternion- templated base type for storage of quaternions.
    
    Superclass: vtkTuple[float32,4]
    
    This class is a templated data type for storing and manipulating
    quaternions. The quaternions have the form [w, x, y, z]. Given a
    rotation of angle theta and axis v, the corresponding quaternion is
    [w, x, y, z] = [cos(theta/2), v*sin(theta/2)]
    
    This class implements the Spherical Linear interpolation (SLERP) and
    the Spherical Spline Quaternion interpolation (SQUAD). It is advised
    to use the vtkQuaternionInterpolator when dealing with multiple
    quaternions and or interpolations.
    
    @sa
    vtkQuaternionInterpolator
    
    vtkQuaternion()
    explicit vtkQuaternion(const float &scalar)
    explicit vtkQuaternion(const float *init)
    vtkQuaternion(const float &w, const float &x, const float &y,
        const float &z)
    vtkQuaternion(const &vtkQuaternion<float>)
    """
    def Conjugate(self):
        """
        V.Conjugate()
        C++: void Conjugate()
        
        Conjugate the quaternion in place.
        """
        ...
    
    def Conjugated(self):
        """
        V.Conjugated() -> vtkQuaternion_IfE
        C++: vtkQuaternion<float> Conjugated()
        
        Return the conjugate form of this quaternion.
        """
        ...
    
    def FromMatrix3x3(self, , , ):
        """
        V.FromMatrix3x3(((float, float, float), (float, float, float), (
            float, float, float)))
        C++: void FromMatrix3x3(const float A[3][3])
        
        Convert a 3x3 matrix into a quaternion.  This will provide the
        best possible answer even if the matrix is not a pure rotation
        matrix. The method used is that of B.K.P. Horn.
        @sa ToMatrix3x3()
        """
        ...
    
    def Get(self, p_float=..., p_float=..., p_float=..., p_float=...):
        """
        V.Get([float, float, float, float])
        C++: void Get(float quat[4])
        
        Set/Get the w, x, y and z components of the quaternion.
        """
        ...
    
    def GetRotationAngleAndAxis(self, p_float=..., p_float=..., p_float=...):
        """
        V.GetRotationAngleAndAxis([float, float, float]) -> float
        C++: float GetRotationAngleAndAxis(float axis[3])
        
        Set/Get the angle (in radians) and the axis corresponding to the
        axis-angle rotation of this quaternion.
        """
        ...
    
    def GetW(self):
        """
        V.GetW() -> float
        C++: const float &GetW()
        
        Set/Get the w component of the quaternion, i.e. element 0.
        """
        ...
    
    def GetX(self):
        """
        V.GetX() -> float
        C++: const float &GetX()
        
        Set/Get the x component of the quaternion, i.e. element 1.
        """
        ...
    
    def GetY(self):
        """
        V.GetY() -> float
        C++: const float &GetY()
        
        Set/Get the y component of the quaternion, i.e. element 2.
        """
        ...
    
    def GetZ(self):
        """
        V.GetZ() -> float
        C++: const float &GetZ()
        
        Set/Get the y component of the quaternion, i.e. element 3.
        """
        ...
    
    def Identity(self):
        """
        V.Identity() -> vtkQuaternion_IfE
        C++: static vtkQuaternion<float> Identity()
        
        Return the identity quaternion. Note that the default constructor
        also creates an identity quaternion.
        """
        ...
    
    def InnerPoint(self, vtkQuaternion_IfE, vtkQuaternion_IfE_1):
        """
        V.InnerPoint(vtkQuaternion_IfE, vtkQuaternion_IfE)
            -> vtkQuaternion_IfE
        C++: vtkQuaternion<float> InnerPoint(
            const vtkQuaternion<float> &q1,
            const vtkQuaternion<float> &q2)
        
        Interpolates between quaternions, using spherical quadrangle
        interpolation.
        @sa vtkQuaternionInterpolator
        """
        ...
    
    def Inverse(self):
        """
        V.Inverse() -> vtkQuaternion_IfE
        C++: vtkQuaternion<float> Inverse()
        
        Return the inverted form of this quaternion.
        """
        ...
    
    def Invert(self):
        """
        V.Invert()
        C++: void Invert()
        
        Invert the quaternion in place. This is equivalent to conjugate
        the quaternion and then divide it by its squared norm.
        """
        ...
    
    def Norm(self):
        """
        V.Norm() -> float
        C++: float Norm()
        
        Get the norm of the quaternion, i.e. its length.
        """
        ...
    
    def Normalize(self):
        """
        V.Normalize() -> float
        C++: float Normalize()
        
        Normalize the quaternion in place. Return the norm of the
        quaternion.
        """
        ...
    
    def Normalized(self):
        """
        V.Normalized() -> vtkQuaternion_IfE
        C++: vtkQuaternion<float> Normalized()
        
        Return the normalized form of this quaternion.
        """
        ...
    
    def NormalizedWithAngleInDegrees(self):
        """
        V.NormalizedWithAngleInDegrees() -> vtkQuaternion_IfE
        C++: vtkQuaternion<float> NormalizedWithAngleInDegrees()
        
        Returns a quaternion normalized and transformed so its angle is
        in degrees and its axis normalized.
        """
        ...
    
    def NormalizeWithAngleInDegrees(self):
        """
        V.NormalizeWithAngleInDegrees()
        C++: void NormalizeWithAngleInDegrees()
        
        Normalize a quaternion in place and transform it to so its angle
        is in degrees and its axis normalized.
        """
        ...
    
    def Set(self, p_float, p_float_1, p_float_2, p_float_3):
        """
        V.Set(float, float, float, float)
        C++: void Set(const float &w, const float &x, const float &y,
            const float &z)
        V.Set([float, float, float, float])
        C++: void Set(float quat[4])
        
        Set/Get the w, x, y and z components of the quaternion.
        """
        ...
    
    def SetRotationAngleAndAxis(self, p_float, p_float=..., p_float=..., p_float=...):
        """
        V.SetRotationAngleAndAxis(float, [float, float, float])
        C++: void SetRotationAngleAndAxis(float angle, float axis[3])
        V.SetRotationAngleAndAxis(float, float, float, float)
        C++: void SetRotationAngleAndAxis(const float &angle,
            const float &x, const float &y, const float &z)
        
        Set/Get the angle (in radians) and the axis corresponding to the
        axis-angle rotation of this quaternion.
        """
        ...
    
    def SetW(self, p_float):
        """
        V.SetW(float)
        C++: void SetW(const float &w)
        
        Set/Get the w component of the quaternion, i.e. element 0.
        """
        ...
    
    def SetX(self, p_float):
        """
        V.SetX(float)
        C++: void SetX(const float &x)
        
        Set/Get the x component of the quaternion, i.e. element 1.
        """
        ...
    
    def SetY(self, p_float):
        """
        V.SetY(float)
        C++: void SetY(const float &y)
        
        Set/Get the y component of the quaternion, i.e. element 2.
        """
        ...
    
    def SetZ(self, p_float):
        """
        V.SetZ(float)
        C++: void SetZ(const float &z)
        
        Set/Get the y component of the quaternion, i.e. element 3.
        """
        ...
    
    def Slerp(self, p_float, vtkQuaternion_IfE):
        """
        V.Slerp(float, vtkQuaternion_IfE) -> vtkQuaternion_IfE
        C++: vtkQuaternion<float> Slerp(float t,
            const vtkQuaternion<float> &q)
        
        Interpolate quaternions using spherical linear interpolation
        between this quaternion and q1 to produce the output. The
        parametric coordinate t belongs to [0,1] and lies between
        (this,q1).
        @sa vtkQuaternionInterpolator
        """
        ...
    
    def SquaredNorm(self):
        """
        V.SquaredNorm() -> float
        C++: float SquaredNorm()
        
        Get the squared norm of the quaternion.
        """
        ...
    
    def ToIdentity(self):
        """
        V.ToIdentity()
        C++: void ToIdentity()
        
        Set the quaternion to identity in place.
        """
        ...
    
    def ToMatrix3x3(self, *args, **kwargs):
        """
        V.ToMatrix3x3([[float, float, float], [float, float, float],
            [float, float, float]])
        C++: void ToMatrix3x3(float A[3][3])
        
        Convert a quaternion to a 3x3 rotation matrix. The quaternion
        does not have to be normalized beforehand.
        @sa FromMatrix3x3()
        """
        ...
    
    def ToUnitExp(self):
        """
        V.ToUnitExp()
        C++: void ToUnitExp()
        
        Convert this quaternion to a unit exponential quaternion. The
        unit exponential quaternion is defined by: [w, x, y, z] = 
        [cos(theta), v*sin(theta)].
        """
        ...
    
    def ToUnitLog(self):
        """
        V.ToUnitLog()
        C++: void ToUnitLog()
        
        Convert this quaternion to a unit log quaternion. The unit log
        quaternion is defined by: [w, x, y, z] =  [0.0, v*theta].
        """
        ...
    
    def UnitExp(self):
        """
        V.UnitExp() -> vtkQuaternion_IfE
        C++: vtkQuaternion<float> UnitExp()
        
        Return the unit exponential version of this quaternion. The unit
        exponential quaternion is defined by: [w, x, y, z] = 
        [cos(theta), v*sin(theta)].
        """
        ...
    
    def UnitLog(self):
        """
        V.UnitLog() -> vtkQuaternion_IfE
        C++: vtkQuaternion<float> UnitLog()
        
        Return the unit log version of this quaternion. The unit log
        quaternion is defined by: [w, x, y, z] =  [0.0, v*theta].
        """
        ...
    
    def __getattribute__(self, *args, **kwargs):
        """ Return getattr(self, name). """
        ...
    
    def __hash__(self, *args, **kwargs) -> int:
        """ Return hash(self). """
        ...
    
    def __init__(self, *args, **kwargs) -> None:
        ...
    
    @staticmethod
    def __new__(*args, **kwargs):
        """ Create and return a new object.  See help(type) for accurate signature. """
        ...
    
    def __repr__(self, *args, **kwargs):
        """ Return repr(self). """
        ...
    


class vtkQuaternionf(vtkQuaternion_IfE):
    """
    vtkQuaternionf - no description provided.
    
    Superclass: vtkQuaternion[float32]
    
    vtkQuaternionf()
    explicit vtkQuaternionf(float w, float x, float y, float z)
    explicit vtkQuaternionf(float scalar)
    explicit vtkQuaternionf(const float *init)
    vtkQuaternionf(const &vtkQuaternionf)
    """
    def Conjugated(self):
        """
        V.Conjugated() -> vtkQuaternionf
        C++: vtkQuaternionf Conjugated()
        
        Return the conjugate form of this quaternion.
        """
        ...
    
    def Identity(self):
        """
        V.Identity() -> vtkQuaternionf
        C++: vtkQuaternionf Identity()
        
        Return the identity quaternion. Note that the default constructor
        also creates an identity quaternion.
        """
        ...
    
    def InnerPoint(self, vtkQuaternionf, vtkQuaternionf_1):
        """
        V.InnerPoint(vtkQuaternionf, vtkQuaternionf) -> vtkQuaternionf
        C++: vtkQuaternionf InnerPoint(const vtkQuaternionf &q1,
            const vtkQuaternionf &q2)
        """
        ...
    
    def Inverse(self):
        """
        V.Inverse() -> vtkQuaternionf
        C++: vtkQuaternionf Inverse()
        
        Return the inverted form of this quaternion.
        """
        ...
    
    def Normalized(self):
        """
        V.Normalized() -> vtkQuaternionf
        C++: vtkQuaternionf Normalized()
        
        Return the normalized form of this quaternion.
        """
        ...
    
    def NormalizedWithAngleInDegrees(self):
        """
        V.NormalizedWithAngleInDegrees() -> vtkQuaternionf
        C++: vtkQuaternionf NormalizedWithAngleInDegrees()
        
        Returns a quaternion normalized and transformed so its angle is
        in degrees and its axis normalized.
        """
        ...
    
    def Slerp(self, p_float, vtkQuaternionf):
        """
        V.Slerp(float, vtkQuaternionf) -> vtkQuaternionf
        C++: vtkQuaternionf Slerp(float t, const vtkQuaternionf &q)
        """
        ...
    
    def UnitExp(self):
        """
        V.UnitExp() -> vtkQuaternionf
        C++: vtkQuaternionf UnitExp()
        
        Return the unit exponential version of this quaternion. The unit
        exponential quaternion is defined by: [w, x, y, z] = 
        [cos(theta), v*sin(theta)].
        """
        ...
    
    def UnitLog(self):
        """
        V.UnitLog() -> vtkQuaternionf
        C++: vtkQuaternionf UnitLog()
        
        Return the unit log version of this quaternion. The unit log
        quaternion is defined by: [w, x, y, z] =  [0.0, v*theta].
        """
        ...
    
    def __getattribute__(self, *args, **kwargs):
        """ Return getattr(self, name). """
        ...
    
    def __hash__(self, *args, **kwargs) -> int:
        """ Return hash(self). """
        ...
    
    def __init__(self) -> None:
        ...
    
    @staticmethod
    def __new__(*args, **kwargs):
        """ Create and return a new object.  See help(type) for accurate signature. """
        ...
    
    def __repr__(self, *args, **kwargs):
        """ Return repr(self). """
        ...
    


class vtkQuaternionInterpolator(__vtkmodules_vtkCommonCore.vtkObject):
    """
    vtkQuaternionInterpolator - interpolate a quaternion
    
    Superclass: vtkObject
    
    This class is used to interpolate a series of quaternions
    representing the rotations of a 3D object.  The interpolation may be
    linear in form (using spherical linear interpolation SLERP), or via
    spline interpolation (using SQUAD). In either case the interpolation
    is specialized to quaternions since the interpolation occurs on the
    surface of the unit quaternion sphere.
    
    To use this class, specify at least two pairs of (t,q[4]) with the
    AddQuaternion() method.  Next interpolate the tuples with the
    InterpolateQuaternion(t,q[4]) method, where "t" must be in the range
    of (t_min,t_max) parameter values specified by the AddQuaternion()
    method (t is clamped otherwise), and q[4] is filled in by the method.
    
    There are several important background references. Ken Shoemake
    described the practical application of quaternions for the
    interpolation of rotation (K. Shoemake, "Animating rotation with quaternion
    curves", Computer Graphics (Siggraph '85) 19(3):245--254, 1985).
    Another fine reference (available on-line) is E. B. Dam, M. Koch, and
    M. Lillholm, Technical Report DIKU-TR-98/5, Dept. of Computer
    Science, University of Copenhagen, Denmark.
    
    @warning
    Note that for two or less quaternions, Slerp (linear) interpolation
    is performed even if spline interpolation is requested. Also, the
    tangents to the first and last segments of spline interpolation are
    (arbitrarily) defined by repeating the first and last quaternions.
    
    @warning
    There are several methods particular to quaternions (norms, products,
    etc.) implemented interior to this class. These may be moved to a
    separate quaternion class at some point.
    
    @sa
    vtkQuaternion
    """
    def AddQuaternion(self, p_float, vtkQuaterniond):
        """
        V.AddQuaternion(float, vtkQuaterniond)
        C++: void AddQuaternion(double t, const vtkQuaterniond &q)
        V.AddQuaternion(float, [float, float, float, float])
        C++: void AddQuaternion(double t, double q[4])
        
        Add another quaternion to the list of quaternions to be
        interpolated. Note that using the same time t value more than
        once replaces the previous quaternion at t. At least one
        quaternions must be added to define an interpolation functions.
        """
        ...
    
    def GetInterpolationType(self):
        """
        V.GetInterpolationType() -> int
        C++: virtual int GetInterpolationType()
        
        Specify which type of function to use for interpolation. By
        default (SetInterpolationFunctionToSpline()), cubic spline
        interpolation using a modified Kochanek basis is employed.
        Otherwise, if SetInterpolationFunctionToLinear() is invoked,
        linear spherical interpolation is used between each pair of
        quaternions.
        """
        ...
    
    def GetInterpolationTypeMaxValue(self):
        """
        V.GetInterpolationTypeMaxValue() -> int
        C++: virtual int GetInterpolationTypeMaxValue()
        
        Specify which type of function to use for interpolation. By
        default (SetInterpolationFunctionToSpline()), cubic spline
        interpolation using a modified Kochanek basis is employed.
        Otherwise, if SetInterpolationFunctionToLinear() is invoked,
        linear spherical interpolation is used between each pair of
        quaternions.
        """
        ...
    
    def GetInterpolationTypeMinValue(self):
        """
        V.GetInterpolationTypeMinValue() -> int
        C++: virtual int GetInterpolationTypeMinValue()
        
        Specify which type of function to use for interpolation. By
        default (SetInterpolationFunctionToSpline()), cubic spline
        interpolation using a modified Kochanek basis is employed.
        Otherwise, if SetInterpolationFunctionToLinear() is invoked,
        linear spherical interpolation is used between each pair of
        quaternions.
        """
        ...
    
    def GetMaximumT(self):
        """
        V.GetMaximumT() -> float
        C++: double GetMaximumT()
        
        Obtain some information about the interpolation range. The
        numbers returned (corresponding to parameter t, usually thought
        of as time) are undefined if the list of transforms is empty.
        This is a convenience method for interpolation.
        """
        ...
    
    def GetMinimumT(self):
        """
        V.GetMinimumT() -> float
        C++: double GetMinimumT()
        
        Obtain some information about the interpolation range. The
        numbers returned (corresponding to parameter t, usually thought
        of as time) are undefined if the list of transforms is empty.
        This is a convenience method for interpolation.
        """
        ...
    
    def GetNumberOfGenerationsFromBase(self, string):
        """
        V.GetNumberOfGenerationsFromBase(string) -> int
        C++: vtkIdType GetNumberOfGenerationsFromBase(const char *type)
            override;
        
        Given a the name of a base class of this class type, return the
        distance of inheritance between this class type and the named
        class (how many generations of inheritance are there between this
        class and the named class). If the named class is not in this
        class's inheritance tree, return a negative value. Valid
        responses will always be nonnegative. This method works in
        combination with vtkTypeMacro found in vtkSetGet.h.
        """
        ...
    
    def GetNumberOfGenerationsFromBaseType(self, string):
        """
        V.GetNumberOfGenerationsFromBaseType(string) -> int
        C++: static vtkIdType GetNumberOfGenerationsFromBaseType(
            const char *type)
        
        Given a the name of a base class of this class type, return the
        distance of inheritance between this class type and the named
        class (how many generations of inheritance are there between this
        class and the named class). If the named class is not in this
        class's inheritance tree, return a negative value. Valid
        responses will always be nonnegative. This method works in
        combination with vtkTypeMacro found in vtkSetGet.h.
        """
        ...
    
    def GetNumberOfQuaternions(self):
        """
        V.GetNumberOfQuaternions() -> int
        C++: int GetNumberOfQuaternions()
        
        Return the number of quaternions in the list of quaternions to be
        interpolated.
        """
        ...
    
    def Initialize(self):
        """
        V.Initialize()
        C++: void Initialize()
        
        Reset the class so that it contains no data; i.e., the array of
        (t,q[4]) information is discarded.
        """
        ...
    
    def InterpolateQuaternion(self, p_float, vtkQuaterniond):
        """
        V.InterpolateQuaternion(float, vtkQuaterniond)
        C++: void InterpolateQuaternion(double t, vtkQuaterniond &q)
        V.InterpolateQuaternion(float, [float, float, float, float])
        C++: void InterpolateQuaternion(double t, double q[4])
        
        Interpolate the list of quaternions and determine a new
        quaternion (i.e., fill in the quaternion provided). If t is
        outside the range of (min,max) values, then t is clamped to lie
        within the range.
        """
        ...
    
    def IsA(self, string):
        """
        V.IsA(string) -> int
        C++: vtkTypeBool IsA(const char *type) override;
        
        Return 1 if this class is the same type of (or a subclass of) the
        named class. Returns 0 otherwise. This method works in
        combination with vtkTypeMacro found in vtkSetGet.h.
        """
        ...
    
    def IsTypeOf(self, string):
        """
        V.IsTypeOf(string) -> int
        C++: static vtkTypeBool IsTypeOf(const char *type)
        
        Return 1 if this class type is the same type of (or a subclass
        of) the named class. Returns 0 otherwise. This method works in
        combination with vtkTypeMacro found in vtkSetGet.h.
        """
        ...
    
    def NewInstance(self):
        """
        V.NewInstance() -> vtkQuaternionInterpolator
        C++: vtkQuaternionInterpolator *NewInstance()
        """
        ...
    
    def RemoveQuaternion(self, p_float):
        """
        V.RemoveQuaternion(float)
        C++: void RemoveQuaternion(double t)
        
        Delete the quaternion at a particular parameter t. If there is no
        quaternion tuple defined at t, then the method does nothing.
        """
        ...
    
    def SafeDownCast(self, vtkObjectBase):
        """
        V.SafeDownCast(vtkObjectBase) -> vtkQuaternionInterpolator
        C++: static vtkQuaternionInterpolator *SafeDownCast(
            vtkObjectBase *o)
        """
        ...
    
    def SetInterpolationType(self, p_int):
        """
        V.SetInterpolationType(int)
        C++: virtual void SetInterpolationType(int _arg)
        
        Specify which type of function to use for interpolation. By
        default (SetInterpolationFunctionToSpline()), cubic spline
        interpolation using a modified Kochanek basis is employed.
        Otherwise, if SetInterpolationFunctionToLinear() is invoked,
        linear spherical interpolation is used between each pair of
        quaternions.
        """
        ...
    
    def SetInterpolationTypeToLinear(self):
        """
        V.SetInterpolationTypeToLinear()
        C++: void SetInterpolationTypeToLinear()
        
        Specify which type of function to use for interpolation. By
        default (SetInterpolationFunctionToSpline()), cubic spline
        interpolation using a modified Kochanek basis is employed.
        Otherwise, if SetInterpolationFunctionToLinear() is invoked,
        linear spherical interpolation is used between each pair of
        quaternions.
        """
        ...
    
    def SetInterpolationTypeToSpline(self):
        """
        V.SetInterpolationTypeToSpline()
        C++: void SetInterpolationTypeToSpline()
        
        Specify which type of function to use for interpolation. By
        default (SetInterpolationFunctionToSpline()), cubic spline
        interpolation using a modified Kochanek basis is employed.
        Otherwise, if SetInterpolationFunctionToLinear() is invoked,
        linear spherical interpolation is used between each pair of
        quaternions.
        """
        ...
    
    def __delattr__(self, *args, **kwargs):
        """ Implement delattr(self, name). """
        ...
    
    def __getattribute__(self, *args, **kwargs):
        """ Return getattr(self, name). """
        ...
    
    def __init__(self, *args, **kwargs) -> None:
        ...
    
    @staticmethod
    def __new__(*args, **kwargs):
        """ Create and return a new object.  See help(type) for accurate signature. """
        ...
    
    def __repr__(self, *args, **kwargs):
        """ Return repr(self). """
        ...
    
    def __setattr__(self, *args, **kwargs):
        """ Implement setattr(self, name, value). """
        ...
    
    def __str__(self, *args, **kwargs) -> str:
        """ Return str(self). """
        ...
    
    __this__ = ...
    INTERPOLATION_TYPE_LINEAR = ...
    INTERPOLATION_TYPE_SPLINE = ...
    __dict__ = ...
    __vtkname__ = ...


class vtkRungeKutta2(vtkInitialValueProblemSolver):
    """
    vtkRungeKutta2 - Integrate an initial value problem using 2nd order
    Runge-Kutta method.
    
    Superclass: vtkInitialValueProblemSolver
    
    This is a concrete sub-class of vtkInitialValueProblemSolver. It uses
    a 2nd order Runge-Kutta method to obtain the values of a set of
    functions at the next time step.
    
    @sa
    vtkInitialValueProblemSolver vtkRungeKutta4 vtkRungeKutta45
    vtkFunctionSet
    """
    def ComputeNextStep(self, *float, **kwargs):
        """
        V.ComputeNextStep([float, ...], [float, ...], float, float, float,
             float, void) -> int
        C++: int ComputeNextStep(double *xprev, double *xnext, double t,
            double &delT, double maxError, double &error, void *userData)
            override;
        V.ComputeNextStep([float, ...], [float, ...], [float, ...], float,
             float, float, float, void) -> int
        C++: int ComputeNextStep(double *xprev, double *dxprev,
            double *xnext, double t, double &delT, double maxError,
            double &error, void *userData) override;
        V.ComputeNextStep([float, ...], [float, ...], float, float, float,
             float, float, float, float, void) -> int
        C++: int ComputeNextStep(double *xprev, double *xnext, double t,
            double &delT, double &delTActual, double minStep,
            double maxStep, double maxError, double &error,
            void *userData) override;
        V.ComputeNextStep([float, ...], [float, ...], [float, ...], float,
             float, float, float, float, float, float, void) -> int
        C++: int ComputeNextStep(double *xprev, double *dxprev,
            double *xnext, double t, double &delT, double &delTActual,
            double minStep, double maxStep, double maxError,
            double &error, void *userData) override;
        V.ComputeNextStep([float, ...], [float, ...], float, float, float,
             float) -> int
        C++: virtual int ComputeNextStep(double *xprev, double *xnext,
            double t, double &delT, double maxError, double &error)
        V.ComputeNextStep([float, ...], [float, ...], [float, ...], float,
             float, float, float) -> int
        C++: virtual int ComputeNextStep(double *xprev, double *dxprev,
            double *xnext, double t, double &delT, double maxError,
            double &error)
        V.ComputeNextStep([float, ...], [float, ...], float, float, float,
             float, float, float, float) -> int
        C++: virtual int ComputeNextStep(double *xprev, double *xnext,
            double t, double &delT, double &delTActual, double minStep,
            double maxStep, double maxError, double &error)
        
        Given initial values, xprev , initial time, t and a requested
        time interval, delT ca ...
         [Truncated]
        """
        ...
    
    def GetNumberOfGenerationsFromBase(self, string):
        """
        V.GetNumberOfGenerationsFromBase(string) -> int
        C++: vtkIdType GetNumberOfGenerationsFromBase(const char *type)
            override;
        
        Given a the name of a base class of this class type, return the
        distance of inheritance between this class type and the named
        class (how many generations of inheritance are there between this
        class and the named class). If the named class is not in this
        class's inheritance tree, return a negative value. Valid
        responses will always be nonnegative. This method works in
        combination with vtkTypeMacro found in vtkSetGet.h.
        """
        ...
    
    def GetNumberOfGenerationsFromBaseType(self, string):
        """
        V.GetNumberOfGenerationsFromBaseType(string) -> int
        C++: static vtkIdType GetNumberOfGenerationsFromBaseType(
            const char *type)
        
        Given a the name of a base class of this class type, return the
        distance of inheritance between this class type and the named
        class (how many generations of inheritance are there between this
        class and the named class). If the named class is not in this
        class's inheritance tree, return a negative value. Valid
        responses will always be nonnegative. This method works in
        combination with vtkTypeMacro found in vtkSetGet.h.
        """
        ...
    
    def IsA(self, string):
        """
        V.IsA(string) -> int
        C++: vtkTypeBool IsA(const char *type) override;
        
        Return 1 if this class is the same type of (or a subclass of) the
        named class. Returns 0 otherwise. This method works in
        combination with vtkTypeMacro found in vtkSetGet.h.
        """
        ...
    
    def IsTypeOf(self, string):
        """
        V.IsTypeOf(string) -> int
        C++: static vtkTypeBool IsTypeOf(const char *type)
        
        Return 1 if this class type is the same type of (or a subclass
        of) the named class. Returns 0 otherwise. This method works in
        combination with vtkTypeMacro found in vtkSetGet.h.
        """
        ...
    
    def NewInstance(self):
        """
        V.NewInstance() -> vtkRungeKutta2
        C++: vtkRungeKutta2 *NewInstance()
        """
        ...
    
    def SafeDownCast(self, vtkObjectBase):
        """
        V.SafeDownCast(vtkObjectBase) -> vtkRungeKutta2
        C++: static vtkRungeKutta2 *SafeDownCast(vtkObjectBase *o)
        """
        ...
    
    def __delattr__(self, *args, **kwargs):
        """ Implement delattr(self, name). """
        ...
    
    def __getattribute__(self, *args, **kwargs):
        """ Return getattr(self, name). """
        ...
    
    def __init__(self, *args, **kwargs) -> None:
        ...
    
    @staticmethod
    def __new__(*args, **kwargs):
        """ Create and return a new object.  See help(type) for accurate signature. """
        ...
    
    def __repr__(self, *args, **kwargs):
        """ Return repr(self). """
        ...
    
    def __setattr__(self, *args, **kwargs):
        """ Implement setattr(self, name, value). """
        ...
    
    def __str__(self, *args, **kwargs) -> str:
        """ Return str(self). """
        ...
    
    __this__ = ...
    __dict__ = ...
    __vtkname__ = ...


class vtkRungeKutta4(vtkInitialValueProblemSolver):
    """
    vtkRungeKutta4 - Integrate an initial value problem using 4th order
    Runge-Kutta method.
    
    Superclass: vtkInitialValueProblemSolver
    
    This is a concrete sub-class of vtkInitialValueProblemSolver. It uses
    a 4th order Runge-Kutta method to obtain the values of a set of
    functions at the next time step.
    
    @sa
    vtkInitialValueProblemSolver vtkRungeKutta45 vtkRungeKutta2
    vtkFunctionSet
    """
    def ComputeNextStep(self, *float, **kwargs):
        """
        V.ComputeNextStep([float, ...], [float, ...], float, float, float,
             float, void) -> int
        C++: int ComputeNextStep(double *xprev, double *xnext, double t,
            double &delT, double maxError, double &error, void *userData)
            override;
        V.ComputeNextStep([float, ...], [float, ...], [float, ...], float,
             float, float, float, void) -> int
        C++: int ComputeNextStep(double *xprev, double *dxprev,
            double *xnext, double t, double &delT, double maxError,
            double &error, void *userData) override;
        V.ComputeNextStep([float, ...], [float, ...], float, float, float,
             float, float, float, float, void) -> int
        C++: int ComputeNextStep(double *xprev, double *xnext, double t,
            double &delT, double &delTActual, double minStep,
            double maxStep, double maxError, double &error,
            void *userData) override;
        V.ComputeNextStep([float, ...], [float, ...], [float, ...], float,
             float, float, float, float, float, float, void) -> int
        C++: int ComputeNextStep(double *xprev, double *dxprev,
            double *xnext, double t, double &delT, double &delTActual,
            double minStep, double maxStep, double maxError,
            double &error, void *userData) override;
        V.ComputeNextStep([float, ...], [float, ...], float, float, float,
             float) -> int
        C++: virtual int ComputeNextStep(double *xprev, double *xnext,
            double t, double &delT, double maxError, double &error)
        V.ComputeNextStep([float, ...], [float, ...], [float, ...], float,
             float, float, float) -> int
        C++: virtual int ComputeNextStep(double *xprev, double *dxprev,
            double *xnext, double t, double &delT, double maxError,
            double &error)
        V.ComputeNextStep([float, ...], [float, ...], float, float, float,
             float, float, float, float) -> int
        C++: virtual int ComputeNextStep(double *xprev, double *xnext,
            double t, double &delT, double &delTActual, double minStep,
            double maxStep, double maxError, double &error)
        
        Given initial values, xprev , initial time, t and a requested
        time interval, delT ca ...
         [Truncated]
        """
        ...
    
    def GetNumberOfGenerationsFromBase(self, string):
        """
        V.GetNumberOfGenerationsFromBase(string) -> int
        C++: vtkIdType GetNumberOfGenerationsFromBase(const char *type)
            override;
        
        Given a the name of a base class of this class type, return the
        distance of inheritance between this class type and the named
        class (how many generations of inheritance are there between this
        class and the named class). If the named class is not in this
        class's inheritance tree, return a negative value. Valid
        responses will always be nonnegative. This method works in
        combination with vtkTypeMacro found in vtkSetGet.h.
        """
        ...
    
    def GetNumberOfGenerationsFromBaseType(self, string):
        """
        V.GetNumberOfGenerationsFromBaseType(string) -> int
        C++: static vtkIdType GetNumberOfGenerationsFromBaseType(
            const char *type)
        
        Given a the name of a base class of this class type, return the
        distance of inheritance between this class type and the named
        class (how many generations of inheritance are there between this
        class and the named class). If the named class is not in this
        class's inheritance tree, return a negative value. Valid
        responses will always be nonnegative. This method works in
        combination with vtkTypeMacro found in vtkSetGet.h.
        """
        ...
    
    def IsA(self, string):
        """
        V.IsA(string) -> int
        C++: vtkTypeBool IsA(const char *type) override;
        
        Return 1 if this class is the same type of (or a subclass of) the
        named class. Returns 0 otherwise. This method works in
        combination with vtkTypeMacro found in vtkSetGet.h.
        """
        ...
    
    def IsTypeOf(self, string):
        """
        V.IsTypeOf(string) -> int
        C++: static vtkTypeBool IsTypeOf(const char *type)
        
        Return 1 if this class type is the same type of (or a subclass
        of) the named class. Returns 0 otherwise. This method works in
        combination with vtkTypeMacro found in vtkSetGet.h.
        """
        ...
    
    def NewInstance(self):
        """
        V.NewInstance() -> vtkRungeKutta4
        C++: vtkRungeKutta4 *NewInstance()
        """
        ...
    
    def SafeDownCast(self, vtkObjectBase):
        """
        V.SafeDownCast(vtkObjectBase) -> vtkRungeKutta4
        C++: static vtkRungeKutta4 *SafeDownCast(vtkObjectBase *o)
        """
        ...
    
    def __delattr__(self, *args, **kwargs):
        """ Implement delattr(self, name). """
        ...
    
    def __getattribute__(self, *args, **kwargs):
        """ Return getattr(self, name). """
        ...
    
    def __init__(self, *args, **kwargs) -> None:
        ...
    
    @staticmethod
    def __new__(*args, **kwargs):
        """ Create and return a new object.  See help(type) for accurate signature. """
        ...
    
    def __repr__(self, *args, **kwargs):
        """ Return repr(self). """
        ...
    
    def __setattr__(self, *args, **kwargs):
        """ Implement setattr(self, name, value). """
        ...
    
    def __str__(self, *args, **kwargs) -> str:
        """ Return str(self). """
        ...
    
    __this__ = ...
    __dict__ = ...
    __vtkname__ = ...


class vtkRungeKutta45(vtkInitialValueProblemSolver):
    """
    vtkRungeKutta45 - Integrate an initial value problem using 5th order
    Runge-Kutta method with adaptive stepsize control.
    
    Superclass: vtkInitialValueProblemSolver
    
    This is a concrete sub-class of vtkInitialValueProblemSolver. It uses
    a 5th order Runge-Kutta method with stepsize control to obtain the
    values of a set of functions at the next time step. The stepsize is
    adjusted by calculating an estimated error using an embedded 4th
    order Runge-Kutta formula: Press, W. H. et al., 1992, Numerical
    Recipes in Fortran, Second Edition, Cambridge University Press Cash,
    J.R. and Karp, A.H. 1990, ACM Transactions on Mathematical Software,
    vol 16, pp 201-222
    
    @sa
    vtkInitialValueProblemSolver vtkRungeKutta4 vtkRungeKutta2
    vtkFunctionSet
    """
    def ComputeNextStep(self, *float, **kwargs):
        """
        V.ComputeNextStep([float, ...], [float, ...], float, float, float,
             float, void) -> int
        C++: int ComputeNextStep(double *xprev, double *xnext, double t,
            double &delT, double maxError, double &error, void *userData)
            override;
        V.ComputeNextStep([float, ...], [float, ...], [float, ...], float,
             float, float, float, void) -> int
        C++: int ComputeNextStep(double *xprev, double *dxprev,
            double *xnext, double t, double &delT, double maxError,
            double &error, void *userData) override;
        V.ComputeNextStep([float, ...], [float, ...], float, float, float,
             float, float, float, float, void) -> int
        C++: int ComputeNextStep(double *xprev, double *xnext, double t,
            double &delT, double &delTActual, double minStep,
            double maxStep, double maxError, double &error,
            void *userData) override;
        V.ComputeNextStep([float, ...], [float, ...], [float, ...], float,
             float, float, float, float, float, float, void) -> int
        C++: int ComputeNextStep(double *xprev, double *dxprev,
            double *xnext, double t, double &delT, double &delTActual,
            double minStep, double maxStep, double maxError,
            double &error, void *userData) override;
        V.ComputeNextStep([float, ...], [float, ...], float, float, float,
             float) -> int
        C++: virtual int ComputeNextStep(double *xprev, double *xnext,
            double t, double &delT, double maxError, double &error)
        V.ComputeNextStep([float, ...], [float, ...], [float, ...], float,
             float, float, float) -> int
        C++: virtual int ComputeNextStep(double *xprev, double *dxprev,
            double *xnext, double t, double &delT, double maxError,
            double &error)
        V.ComputeNextStep([float, ...], [float, ...], float, float, float,
             float, float, float, float) -> int
        C++: virtual int ComputeNextStep(double *xprev, double *xnext,
            double t, double &delT, double &delTActual, double minStep,
            double maxStep, double maxError, double &error)
        
        Given initial values, xprev , initial time, t and a requested
        time interval, delT ca ...
         [Truncated]
        """
        ...
    
    def GetNumberOfGenerationsFromBase(self, string):
        """
        V.GetNumberOfGenerationsFromBase(string) -> int
        C++: vtkIdType GetNumberOfGenerationsFromBase(const char *type)
            override;
        
        Given a the name of a base class of this class type, return the
        distance of inheritance between this class type and the named
        class (how many generations of inheritance are there between this
        class and the named class). If the named class is not in this
        class's inheritance tree, return a negative value. Valid
        responses will always be nonnegative. This method works in
        combination with vtkTypeMacro found in vtkSetGet.h.
        """
        ...
    
    def GetNumberOfGenerationsFromBaseType(self, string):
        """
        V.GetNumberOfGenerationsFromBaseType(string) -> int
        C++: static vtkIdType GetNumberOfGenerationsFromBaseType(
            const char *type)
        
        Given a the name of a base class of this class type, return the
        distance of inheritance between this class type and the named
        class (how many generations of inheritance are there between this
        class and the named class). If the named class is not in this
        class's inheritance tree, return a negative value. Valid
        responses will always be nonnegative. This method works in
        combination with vtkTypeMacro found in vtkSetGet.h.
        """
        ...
    
    def IsA(self, string):
        """
        V.IsA(string) -> int
        C++: vtkTypeBool IsA(const char *type) override;
        
        Return 1 if this class is the same type of (or a subclass of) the
        named class. Returns 0 otherwise. This method works in
        combination with vtkTypeMacro found in vtkSetGet.h.
        """
        ...
    
    def IsTypeOf(self, string):
        """
        V.IsTypeOf(string) -> int
        C++: static vtkTypeBool IsTypeOf(const char *type)
        
        Return 1 if this class type is the same type of (or a subclass
        of) the named class. Returns 0 otherwise. This method works in
        combination with vtkTypeMacro found in vtkSetGet.h.
        """
        ...
    
    def NewInstance(self):
        """
        V.NewInstance() -> vtkRungeKutta45
        C++: vtkRungeKutta45 *NewInstance()
        """
        ...
    
    def SafeDownCast(self, vtkObjectBase):
        """
        V.SafeDownCast(vtkObjectBase) -> vtkRungeKutta45
        C++: static vtkRungeKutta45 *SafeDownCast(vtkObjectBase *o)
        """
        ...
    
    def __delattr__(self, *args, **kwargs):
        """ Implement delattr(self, name). """
        ...
    
    def __getattribute__(self, *args, **kwargs):
        """ Return getattr(self, name). """
        ...
    
    def __init__(self, *args, **kwargs) -> None:
        ...
    
    @staticmethod
    def __new__(*args, **kwargs):
        """ Create and return a new object.  See help(type) for accurate signature. """
        ...
    
    def __repr__(self, *args, **kwargs):
        """ Return repr(self). """
        ...
    
    def __setattr__(self, *args, **kwargs):
        """ Implement setattr(self, name, value). """
        ...
    
    def __str__(self, *args, **kwargs) -> str:
        """ Return str(self). """
        ...
    
    __this__ = ...
    __dict__ = ...
    __vtkname__ = ...


class vtkTuple_IdLi2EE(object):
    """
    vtkTuple<double, 2> - templated base type for containers of constant
    size.
    
    This class is a templated data type for storing and manipulating
    tuples.
    
    vtkTuple()
    explicit vtkTuple(const double &scalar)
    explicit vtkTuple(const double *init)
    vtkTuple(const &vtkTuple<double, 2>)
    """
    def Compare(self, vtkTuple_IdLi2EE, p_float):
        """
        V.Compare(vtkTuple_IdLi2EE, float) -> bool
        C++: bool Compare(const vtkTuple<double, 2> &other,
            const double &tol)
        
        Equality operator with a tolerance to allow fuzzy comparisons.
        """
        ...
    
    def GetData(self):
        """
        V.GetData() -> (float, ...)
        C++: double *GetData()
        
        Get a pointer to the underlying data of the tuple.
        """
        ...
    
    def GetSize(self):
        """
        V.GetSize() -> int
        C++: int GetSize()
        
        Get the size of the tuple.
        """
        ...
    
    def __delitem__(self, *args, **kwargs):
        """ Delete self[key]. """
        ...
    
    def __getattribute__(self, *args, **kwargs):
        """ Return getattr(self, name). """
        ...
    
    def __getitem__(self, *args, **kwargs):
        """ Return self[key]. """
        ...
    
    def __hash__(self, *args, **kwargs) -> int:
        """ Return hash(self). """
        ...
    
    def __init__(self, *args, **kwargs) -> None:
        ...
    
    def __len__(self, *args, **kwargs):
        """ Return len(self). """
        ...
    
    @staticmethod
    def __new__(*args, **kwargs):
        """ Create and return a new object.  See help(type) for accurate signature. """
        ...
    
    def __repr__(self, *args, **kwargs):
        """ Return repr(self). """
        ...
    
    def __setitem__(self, *args, **kwargs):
        """ Set self[key] to value. """
        ...
    
    def __str__(self, *args, **kwargs) -> str:
        """ Return str(self). """
        ...
    


class vtkTuple_IdLi3EE(object):
    """
    vtkTuple<double, 3> - templated base type for containers of constant
    size.
    
    This class is a templated data type for storing and manipulating
    tuples.
    
    vtkTuple()
    explicit vtkTuple(const double &scalar)
    explicit vtkTuple(const double *init)
    vtkTuple(const &vtkTuple<double, 3>)
    """
    def Compare(self, vtkTuple_IdLi3EE, p_float):
        """
        V.Compare(vtkTuple_IdLi3EE, float) -> bool
        C++: bool Compare(const vtkTuple<double, 3> &other,
            const double &tol)
        
        Equality operator with a tolerance to allow fuzzy comparisons.
        """
        ...
    
    def GetData(self):
        """
        V.GetData() -> (float, ...)
        C++: double *GetData()
        
        Get a pointer to the underlying data of the tuple.
        """
        ...
    
    def GetSize(self):
        """
        V.GetSize() -> int
        C++: int GetSize()
        
        Get the size of the tuple.
        """
        ...
    
    def __delitem__(self, *args, **kwargs):
        """ Delete self[key]. """
        ...
    
    def __getattribute__(self, *args, **kwargs):
        """ Return getattr(self, name). """
        ...
    
    def __getitem__(self, *args, **kwargs):
        """ Return self[key]. """
        ...
    
    def __hash__(self, *args, **kwargs) -> int:
        """ Return hash(self). """
        ...
    
    def __init__(self, *args, **kwargs) -> None:
        ...
    
    def __len__(self, *args, **kwargs):
        """ Return len(self). """
        ...
    
    @staticmethod
    def __new__(*args, **kwargs):
        """ Create and return a new object.  See help(type) for accurate signature. """
        ...
    
    def __repr__(self, *args, **kwargs):
        """ Return repr(self). """
        ...
    
    def __setitem__(self, *args, **kwargs):
        """ Set self[key] to value. """
        ...
    
    def __str__(self, *args, **kwargs) -> str:
        """ Return str(self). """
        ...
    


class vtkTuple_IfLi2EE(object):
    """
    vtkTuple<float, 2> - templated base type for containers of constant
    size.
    
    This class is a templated data type for storing and manipulating
    tuples.
    
    vtkTuple()
    explicit vtkTuple(const float &scalar)
    explicit vtkTuple(const float *init)
    vtkTuple(const &vtkTuple<float, 2>)
    """
    def Compare(self, vtkTuple_IfLi2EE, p_float):
        """
        V.Compare(vtkTuple_IfLi2EE, float) -> bool
        C++: bool Compare(const vtkTuple<float, 2> &other,
            const float &tol)
        
        Equality operator with a tolerance to allow fuzzy comparisons.
        """
        ...
    
    def GetData(self):
        """
        V.GetData() -> (float, ...)
        C++: float *GetData()
        
        Get a pointer to the underlying data of the tuple.
        """
        ...
    
    def GetSize(self):
        """
        V.GetSize() -> int
        C++: int GetSize()
        
        Get the size of the tuple.
        """
        ...
    
    def __delitem__(self, *args, **kwargs):
        """ Delete self[key]. """
        ...
    
    def __getattribute__(self, *args, **kwargs):
        """ Return getattr(self, name). """
        ...
    
    def __getitem__(self, *args, **kwargs):
        """ Return self[key]. """
        ...
    
    def __hash__(self, *args, **kwargs) -> int:
        """ Return hash(self). """
        ...
    
    def __init__(self, *args, **kwargs) -> None:
        ...
    
    def __len__(self, *args, **kwargs):
        """ Return len(self). """
        ...
    
    @staticmethod
    def __new__(*args, **kwargs):
        """ Create and return a new object.  See help(type) for accurate signature. """
        ...
    
    def __repr__(self, *args, **kwargs):
        """ Return repr(self). """
        ...
    
    def __setitem__(self, *args, **kwargs):
        """ Set self[key] to value. """
        ...
    
    def __str__(self, *args, **kwargs) -> str:
        """ Return str(self). """
        ...
    


class vtkTuple_IfLi3EE(object):
    """
    vtkTuple<float, 3> - templated base type for containers of constant
    size.
    
    This class is a templated data type for storing and manipulating
    tuples.
    
    vtkTuple()
    explicit vtkTuple(const float &scalar)
    explicit vtkTuple(const float *init)
    vtkTuple(const &vtkTuple<float, 3>)
    """
    def Compare(self, vtkTuple_IfLi3EE, p_float):
        """
        V.Compare(vtkTuple_IfLi3EE, float) -> bool
        C++: bool Compare(const vtkTuple<float, 3> &other,
            const float &tol)
        
        Equality operator with a tolerance to allow fuzzy comparisons.
        """
        ...
    
    def GetData(self):
        """
        V.GetData() -> (float, ...)
        C++: float *GetData()
        
        Get a pointer to the underlying data of the tuple.
        """
        ...
    
    def GetSize(self):
        """
        V.GetSize() -> int
        C++: int GetSize()
        
        Get the size of the tuple.
        """
        ...
    
    def __delitem__(self, *args, **kwargs):
        """ Delete self[key]. """
        ...
    
    def __getattribute__(self, *args, **kwargs):
        """ Return getattr(self, name). """
        ...
    
    def __getitem__(self, *args, **kwargs):
        """ Return self[key]. """
        ...
    
    def __hash__(self, *args, **kwargs) -> int:
        """ Return hash(self). """
        ...
    
    def __init__(self, *args, **kwargs) -> None:
        ...
    
    def __len__(self, *args, **kwargs):
        """ Return len(self). """
        ...
    
    @staticmethod
    def __new__(*args, **kwargs):
        """ Create and return a new object.  See help(type) for accurate signature. """
        ...
    
    def __repr__(self, *args, **kwargs):
        """ Return repr(self). """
        ...
    
    def __setitem__(self, *args, **kwargs):
        """ Set self[key] to value. """
        ...
    
    def __str__(self, *args, **kwargs) -> str:
        """ Return str(self). """
        ...
    


class vtkTuple_IhLi2EE(object):
    """
    vtkTuple<unsigned char, 2> - templated base type for containers of
    constant size.
    
    This class is a templated data type for storing and manipulating
    tuples.
    
    vtkTuple()
    explicit vtkTuple(const unsigned char &scalar)
    explicit vtkTuple(const unsigned char *init)
    vtkTuple(const &vtkTuple<unsigned char, 2>)
    """
    def Compare(self, vtkTuple_IhLi2EE, p_int):
        """
        V.Compare(vtkTuple_IhLi2EE, int) -> bool
        C++: bool Compare(const vtkTuple<unsigned char, 2> &other,
            const unsigned char &tol)
        
        Equality operator with a tolerance to allow fuzzy comparisons.
        """
        ...
    
    def GetData(self):
        """
        V.GetData() -> (int, ...)
        C++: unsigned char *GetData()
        
        Get a pointer to the underlying data of the tuple.
        """
        ...
    
    def GetSize(self):
        """
        V.GetSize() -> int
        C++: int GetSize()
        
        Get the size of the tuple.
        """
        ...
    
    def __delitem__(self, *args, **kwargs):
        """ Delete self[key]. """
        ...
    
    def __getattribute__(self, *args, **kwargs):
        """ Return getattr(self, name). """
        ...
    
    def __getitem__(self, *args, **kwargs):
        """ Return self[key]. """
        ...
    
    def __hash__(self, *args, **kwargs) -> int:
        """ Return hash(self). """
        ...
    
    def __init__(self, *args, **kwargs) -> None:
        ...
    
    def __len__(self, *args, **kwargs):
        """ Return len(self). """
        ...
    
    @staticmethod
    def __new__(*args, **kwargs):
        """ Create and return a new object.  See help(type) for accurate signature. """
        ...
    
    def __repr__(self, *args, **kwargs):
        """ Return repr(self). """
        ...
    
    def __setitem__(self, *args, **kwargs):
        """ Set self[key] to value. """
        ...
    
    def __str__(self, *args, **kwargs) -> str:
        """ Return str(self). """
        ...
    


class vtkTuple_IhLi3EE(object):
    """
    vtkTuple<unsigned char, 3> - templated base type for containers of
    constant size.
    
    This class is a templated data type for storing and manipulating
    tuples.
    
    vtkTuple()
    explicit vtkTuple(const unsigned char &scalar)
    explicit vtkTuple(const unsigned char *init)
    vtkTuple(const &vtkTuple<unsigned char, 3>)
    """
    def Compare(self, vtkTuple_IhLi3EE, p_int):
        """
        V.Compare(vtkTuple_IhLi3EE, int) -> bool
        C++: bool Compare(const vtkTuple<unsigned char, 3> &other,
            const unsigned char &tol)
        
        Equality operator with a tolerance to allow fuzzy comparisons.
        """
        ...
    
    def GetData(self):
        """
        V.GetData() -> (int, ...)
        C++: unsigned char *GetData()
        
        Get a pointer to the underlying data of the tuple.
        """
        ...
    
    def GetSize(self):
        """
        V.GetSize() -> int
        C++: int GetSize()
        
        Get the size of the tuple.
        """
        ...
    
    def __delitem__(self, *args, **kwargs):
        """ Delete self[key]. """
        ...
    
    def __getattribute__(self, *args, **kwargs):
        """ Return getattr(self, name). """
        ...
    
    def __getitem__(self, *args, **kwargs):
        """ Return self[key]. """
        ...
    
    def __hash__(self, *args, **kwargs) -> int:
        """ Return hash(self). """
        ...
    
    def __init__(self, *args, **kwargs) -> None:
        ...
    
    def __len__(self, *args, **kwargs):
        """ Return len(self). """
        ...
    
    @staticmethod
    def __new__(*args, **kwargs):
        """ Create and return a new object.  See help(type) for accurate signature. """
        ...
    
    def __repr__(self, *args, **kwargs):
        """ Return repr(self). """
        ...
    
    def __setitem__(self, *args, **kwargs):
        """ Set self[key] to value. """
        ...
    
    def __str__(self, *args, **kwargs) -> str:
        """ Return str(self). """
        ...
    


class vtkTuple_IhLi4EE(object):
    """
    vtkTuple<unsigned char, 4> - templated base type for containers of
    constant size.
    
    This class is a templated data type for storing and manipulating
    tuples.
    
    vtkTuple()
    explicit vtkTuple(const unsigned char &scalar)
    explicit vtkTuple(const unsigned char *init)
    vtkTuple(const &vtkTuple<unsigned char, 4>)
    """
    def Compare(self, vtkTuple_IhLi4EE, p_int):
        """
        V.Compare(vtkTuple_IhLi4EE, int) -> bool
        C++: bool Compare(const vtkTuple<unsigned char, 4> &other,
            const unsigned char &tol)
        
        Equality operator with a tolerance to allow fuzzy comparisons.
        """
        ...
    
    def GetData(self):
        """
        V.GetData() -> (int, ...)
        C++: unsigned char *GetData()
        
        Get a pointer to the underlying data of the tuple.
        """
        ...
    
    def GetSize(self):
        """
        V.GetSize() -> int
        C++: int GetSize()
        
        Get the size of the tuple.
        """
        ...
    
    def __delitem__(self, *args, **kwargs):
        """ Delete self[key]. """
        ...
    
    def __getattribute__(self, *args, **kwargs):
        """ Return getattr(self, name). """
        ...
    
    def __getitem__(self, *args, **kwargs):
        """ Return self[key]. """
        ...
    
    def __hash__(self, *args, **kwargs) -> int:
        """ Return hash(self). """
        ...
    
    def __init__(self, *args, **kwargs) -> None:
        ...
    
    def __len__(self, *args, **kwargs):
        """ Return len(self). """
        ...
    
    @staticmethod
    def __new__(*args, **kwargs):
        """ Create and return a new object.  See help(type) for accurate signature. """
        ...
    
    def __repr__(self, *args, **kwargs):
        """ Return repr(self). """
        ...
    
    def __setitem__(self, *args, **kwargs):
        """ Set self[key] to value. """
        ...
    
    def __str__(self, *args, **kwargs) -> str:
        """ Return str(self). """
        ...
    


class vtkTuple_IiLi2EE(object):
    """
    vtkTuple<int, 2> - templated base type for containers of constant
    size.
    
    This class is a templated data type for storing and manipulating
    tuples.
    
    vtkTuple()
    explicit vtkTuple(const int &scalar)
    explicit vtkTuple(const int *init)
    vtkTuple(const &vtkTuple<int, 2>)
    """
    def Compare(self, vtkTuple_IiLi2EE, p_int):
        """
        V.Compare(vtkTuple_IiLi2EE, int) -> bool
        C++: bool Compare(const vtkTuple<int, 2> &other, const int &tol)
        
        Equality operator with a tolerance to allow fuzzy comparisons.
        """
        ...
    
    def GetData(self):
        """
        V.GetData() -> (int, ...)
        C++: int *GetData()
        
        Get a pointer to the underlying data of the tuple.
        """
        ...
    
    def GetSize(self):
        """
        V.GetSize() -> int
        C++: int GetSize()
        
        Get the size of the tuple.
        """
        ...
    
    def __delitem__(self, *args, **kwargs):
        """ Delete self[key]. """
        ...
    
    def __getattribute__(self, *args, **kwargs):
        """ Return getattr(self, name). """
        ...
    
    def __getitem__(self, *args, **kwargs):
        """ Return self[key]. """
        ...
    
    def __hash__(self, *args, **kwargs) -> int:
        """ Return hash(self). """
        ...
    
    def __init__(self, *args, **kwargs) -> None:
        ...
    
    def __len__(self, *args, **kwargs):
        """ Return len(self). """
        ...
    
    @staticmethod
    def __new__(*args, **kwargs):
        """ Create and return a new object.  See help(type) for accurate signature. """
        ...
    
    def __repr__(self, *args, **kwargs):
        """ Return repr(self). """
        ...
    
    def __setitem__(self, *args, **kwargs):
        """ Set self[key] to value. """
        ...
    
    def __str__(self, *args, **kwargs) -> str:
        """ Return str(self). """
        ...
    


class vtkTuple_IiLi3EE(object):
    """
    vtkTuple<int, 3> - templated base type for containers of constant
    size.
    
    This class is a templated data type for storing and manipulating
    tuples.
    
    vtkTuple()
    explicit vtkTuple(const int &scalar)
    explicit vtkTuple(const int *init)
    vtkTuple(const &vtkTuple<int, 3>)
    """
    def Compare(self, vtkTuple_IiLi3EE, p_int):
        """
        V.Compare(vtkTuple_IiLi3EE, int) -> bool
        C++: bool Compare(const vtkTuple<int, 3> &other, const int &tol)
        
        Equality operator with a tolerance to allow fuzzy comparisons.
        """
        ...
    
    def GetData(self):
        """
        V.GetData() -> (int, ...)
        C++: int *GetData()
        
        Get a pointer to the underlying data of the tuple.
        """
        ...
    
    def GetSize(self):
        """
        V.GetSize() -> int
        C++: int GetSize()
        
        Get the size of the tuple.
        """
        ...
    
    def __delitem__(self, *args, **kwargs):
        """ Delete self[key]. """
        ...
    
    def __getattribute__(self, *args, **kwargs):
        """ Return getattr(self, name). """
        ...
    
    def __getitem__(self, *args, **kwargs):
        """ Return self[key]. """
        ...
    
    def __hash__(self, *args, **kwargs) -> int:
        """ Return hash(self). """
        ...
    
    def __init__(self, *args, **kwargs) -> None:
        ...
    
    def __len__(self, *args, **kwargs):
        """ Return len(self). """
        ...
    
    @staticmethod
    def __new__(*args, **kwargs):
        """ Create and return a new object.  See help(type) for accurate signature. """
        ...
    
    def __repr__(self, *args, **kwargs):
        """ Return repr(self). """
        ...
    
    def __setitem__(self, *args, **kwargs):
        """ Set self[key] to value. """
        ...
    
    def __str__(self, *args, **kwargs) -> str:
        """ Return str(self). """
        ...
    


class vtkTuple_IiLi4EE(object):
    """
    vtkTuple<int, 4> - templated base type for containers of constant
    size.
    
    This class is a templated data type for storing and manipulating
    tuples.
    
    vtkTuple()
    explicit vtkTuple(const int &scalar)
    explicit vtkTuple(const int *init)
    vtkTuple(const &vtkTuple<int, 4>)
    """
    def Compare(self, vtkTuple_IiLi4EE, p_int):
        """
        V.Compare(vtkTuple_IiLi4EE, int) -> bool
        C++: bool Compare(const vtkTuple<int, 4> &other, const int &tol)
        
        Equality operator with a tolerance to allow fuzzy comparisons.
        """
        ...
    
    def GetData(self):
        """
        V.GetData() -> (int, ...)
        C++: int *GetData()
        
        Get a pointer to the underlying data of the tuple.
        """
        ...
    
    def GetSize(self):
        """
        V.GetSize() -> int
        C++: int GetSize()
        
        Get the size of the tuple.
        """
        ...
    
    def __delitem__(self, *args, **kwargs):
        """ Delete self[key]. """
        ...
    
    def __getattribute__(self, *args, **kwargs):
        """ Return getattr(self, name). """
        ...
    
    def __getitem__(self, *args, **kwargs):
        """ Return self[key]. """
        ...
    
    def __hash__(self, *args, **kwargs) -> int:
        """ Return hash(self). """
        ...
    
    def __init__(self, *args, **kwargs) -> None:
        ...
    
    def __len__(self, *args, **kwargs):
        """ Return len(self). """
        ...
    
    @staticmethod
    def __new__(*args, **kwargs):
        """ Create and return a new object.  See help(type) for accurate signature. """
        ...
    
    def __repr__(self, *args, **kwargs):
        """ Return repr(self). """
        ...
    
    def __setitem__(self, *args, **kwargs):
        """ Set self[key] to value. """
        ...
    
    def __str__(self, *args, **kwargs) -> str:
        """ Return str(self). """
        ...
    


__loader__ = ...
__spec__ = ...
