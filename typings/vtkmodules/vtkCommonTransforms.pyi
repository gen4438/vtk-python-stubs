"""
This type stub file was generated by pyright.
"""

import vtkmodules.vtkCommonCore as __vtkmodules_vtkCommonCore

VTK_LANDMARK_AFFINE = ...
VTK_LANDMARK_RIGIDBODY = ...
VTK_LANDMARK_SIMILARITY = ...
VTK_RBF_CUSTOM = ...
VTK_RBF_R = ...
VTK_RBF_R2LOGR = ...
class vtkAbstractTransform(__vtkmodules_vtkCommonCore.vtkObject):
    """
    vtkTransformConcatenationStack - Store a stack of concatenations.
    
    Superclass: vtkObject
    
    A helper class (not derived from vtkObject) to store a stack of
    concatenations.
    """
    def CircuitCheck(self, vtkAbstractTransform):
        """
        V.CircuitCheck(vtkAbstractTransform) -> int
        C++: virtual int CircuitCheck(vtkAbstractTransform *transform)
        
        Check for self-reference.  Will return true if concatenating with
        the specified transform, setting it to be our inverse, or setting
        it to be our input will create a circular reference. CircuitCheck
        is automatically called by SetInput(), SetInverse(), and
        Concatenate(vtkXTransform *).  Avoid using this function, it is
        experimental.
        """
        ...
    
    def DeepCopy(self, vtkAbstractTransform):
        """
        V.DeepCopy(vtkAbstractTransform)
        C++: void DeepCopy(vtkAbstractTransform *)
        
        Copy this transform from another of the same type.
        """
        ...
    
    def GetInverse(self):
        """
        V.GetInverse() -> vtkAbstractTransform
        C++: vtkAbstractTransform *GetInverse()
        
        Get the inverse of this transform.  If you modify this transform,
        the returned inverse transform will automatically update.  If you
        want the inverse of a vtkTransform, you might want to use
        GetLinearInverse() instead which will type cast the result from
        vtkAbstractTransform to vtkLinearTransform.
        """
        ...
    
    def GetMTime(self):
        """
        V.GetMTime() -> int
        C++: vtkMTimeType GetMTime() override;
        
        Override GetMTime necessary because of inverse transforms.
        """
        ...
    
    def GetNumberOfGenerationsFromBase(self, string):
        """
        V.GetNumberOfGenerationsFromBase(string) -> int
        C++: vtkIdType GetNumberOfGenerationsFromBase(const char *type)
            override;
        
        Given a the name of a base class of this class type, return the
        distance of inheritance between this class type and the named
        class (how many generations of inheritance are there between this
        class and the named class). If the named class is not in this
        class's inheritance tree, return a negative value. Valid
        responses will always be nonnegative. This method works in
        combination with vtkTypeMacro found in vtkSetGet.h.
        """
        ...
    
    def GetNumberOfGenerationsFromBaseType(self, string):
        """
        V.GetNumberOfGenerationsFromBaseType(string) -> int
        C++: static vtkIdType GetNumberOfGenerationsFromBaseType(
            const char *type)
        
        Given a the name of a base class of this class type, return the
        distance of inheritance between this class type and the named
        class (how many generations of inheritance are there between this
        class and the named class). If the named class is not in this
        class's inheritance tree, return a negative value. Valid
        responses will always be nonnegative. This method works in
        combination with vtkTypeMacro found in vtkSetGet.h.
        """
        ...
    
    def InternalTransformDerivative(self, , p_float=..., p_float=..., p_float=..., *args, **kwargs):
        """
        V.InternalTransformDerivative((float, float, float), [float,
            float, float], [[float, float, float], [float, float, float],
            [float, float, float]])
        C++: virtual void InternalTransformDerivative(const double in[3],
            double out[3], double derivative[3][3])
        
        This will transform a point and, at the same time, calculate a
        3x3 Jacobian matrix that provides the partial derivatives of the
        transformation at that point.  This method does not call Update.
        Meant for use only within other VTK classes.
        """
        ...
    
    def InternalTransformPoint(self, , p_float=..., p_float=..., p_float=...):
        """
        V.InternalTransformPoint((float, float, float), [float, float,
            float])
        C++: virtual void InternalTransformPoint(const double in[3],
            double out[3])
        
        This will calculate the transformation without calling Update.
        Meant for use only within other VTK classes.
        """
        ...
    
    def Inverse(self):
        """
        V.Inverse()
        C++: virtual void Inverse()
        
        Invert the transformation.
        """
        ...
    
    def IsA(self, string):
        """
        V.IsA(string) -> int
        C++: vtkTypeBool IsA(const char *type) override;
        
        Return 1 if this class is the same type of (or a subclass of) the
        named class. Returns 0 otherwise. This method works in
        combination with vtkTypeMacro found in vtkSetGet.h.
        """
        ...
    
    def IsTypeOf(self, string):
        """
        V.IsTypeOf(string) -> int
        C++: static vtkTypeBool IsTypeOf(const char *type)
        
        Return 1 if this class type is the same type of (or a subclass
        of) the named class. Returns 0 otherwise. This method works in
        combination with vtkTypeMacro found in vtkSetGet.h.
        """
        ...
    
    def MakeTransform(self):
        """
        V.MakeTransform() -> vtkAbstractTransform
        C++: virtual vtkAbstractTransform *MakeTransform()
        
        Make another transform of the same type.
        """
        ...
    
    def NewInstance(self):
        """
        V.NewInstance() -> vtkAbstractTransform
        C++: vtkAbstractTransform *NewInstance()
        """
        ...
    
    def SafeDownCast(self, vtkObjectBase):
        """
        V.SafeDownCast(vtkObjectBase) -> vtkAbstractTransform
        C++: static vtkAbstractTransform *SafeDownCast(vtkObjectBase *o)
        """
        ...
    
    def SetInverse(self, vtkAbstractTransform):
        """
        V.SetInverse(vtkAbstractTransform)
        C++: void SetInverse(vtkAbstractTransform *transform)
        
        Set a transformation that this transform will be the inverse of.
        This transform will automatically update to agree with the
        inverse transform that you set.
        """
        ...
    
    def TransformDoubleNormalAtPoint(self, , ):
        """
        V.TransformDoubleNormalAtPoint((float, float, float), (float,
            float, float)) -> (float, float, float)
        C++: double *TransformDoubleNormalAtPoint(const double point[3],
            const double normal[3])
        
        Apply the transformation to a double-precision normal at the
        specified vertex.  If the transformation is a vtkLinearTransform,
        you can use TransformDoubleNormal() instead.
        """
        ...
    
    def TransformDoublePoint(self, p_float, p_float_1, p_float_2):
        """
        V.TransformDoublePoint(float, float, float) -> (float, float,
            float)
        C++: double *TransformDoublePoint(double x, double y, double z)
        V.TransformDoublePoint((float, float, float)) -> (float, float,
            float)
        C++: double *TransformDoublePoint(const double point[3])
        
        Apply the transformation to a double-precision (x,y,z)
        coordinate. Use this if you are programming in Python or Java.
        """
        ...
    
    def TransformDoubleVectorAtPoint(self, , ):
        """
        V.TransformDoubleVectorAtPoint((float, float, float), (float,
            float, float)) -> (float, float, float)
        C++: double *TransformDoubleVectorAtPoint(const double point[3],
            const double vector[3])
        
        Apply the transformation to a double-precision vector at the
        specified vertex.  If the transformation is a vtkLinearTransform,
        you can use TransformDoubleVector() instead.
        """
        ...
    
    def TransformFloatNormalAtPoint(self, , ):
        """
        V.TransformFloatNormalAtPoint((float, float, float), (float,
            float, float)) -> (float, float, float)
        C++: float *TransformFloatNormalAtPoint(const float point[3],
            const float normal[3])
        
        Apply the transformation to a single-precision normal at the
        specified vertex.  If the transformation is a vtkLinearTransform,
        you can use TransformFloatNormal() instead.
        """
        ...
    
    def TransformFloatPoint(self, p_float, p_float_1, p_float_2):
        """
        V.TransformFloatPoint(float, float, float) -> (float, float,
            float)
        C++: float *TransformFloatPoint(float x, float y, float z)
        V.TransformFloatPoint((float, float, float)) -> (float, float,
            float)
        C++: float *TransformFloatPoint(const float point[3])
        
        Apply the transformation to an (x,y,z) coordinate. Use this if
        you are programming in Python or Java.
        """
        ...
    
    def TransformFloatVectorAtPoint(self, , ):
        """
        V.TransformFloatVectorAtPoint((float, float, float), (float,
            float, float)) -> (float, float, float)
        C++: float *TransformFloatVectorAtPoint(const float point[3],
            const float vector[3])
        
        Apply the transformation to a single-precision vector at the
        specified vertex.  If the transformation is a vtkLinearTransform,
        you can use TransformFloatVector() instead.
        """
        ...
    
    def TransformNormalAtPoint(self, , , p_float=..., p_float=..., p_float=...):
        """
        V.TransformNormalAtPoint((float, float, float), (float, float,
            float), [float, float, float])
        C++: void TransformNormalAtPoint(const double point[3],
            const double in[3], double out[3])
        V.TransformNormalAtPoint((float, float, float), (float, float,
            float)) -> (float, float, float)
        C++: double *TransformNormalAtPoint(const double point[3],
            const double normal[3])
        
        Apply the transformation to a normal at the specified vertex.  If
        the transformation is a vtkLinearTransform, you can use
        TransformNormal() instead.
        """
        ...
    
    def TransformPoint(self, , p_float=..., p_float=..., p_float=...):
        """
        V.TransformPoint((float, float, float), [float, float, float])
        C++: void TransformPoint(const double in[3], double out[3])
        V.TransformPoint(float, float, float) -> (float, float, float)
        C++: double *TransformPoint(double x, double y, double z)
        V.TransformPoint((float, float, float)) -> (float, float, float)
        C++: double *TransformPoint(const double point[3])
        
        Apply the transformation to a double-precision coordinate. You
        can use the same array to store both the input and output point.
        """
        ...
    
    def TransformPoints(self, vtkPoints, vtkPoints_1):
        """
        V.TransformPoints(vtkPoints, vtkPoints)
        C++: virtual void TransformPoints(vtkPoints *inPts,
            vtkPoints *outPts)
        
        Apply the transformation to a series of points, and append the
        results to outPts.
        """
        ...
    
    def TransformVectorAtPoint(self, , , p_float=..., p_float=..., p_float=...):
        """
        V.TransformVectorAtPoint((float, float, float), (float, float,
            float), [float, float, float])
        C++: void TransformVectorAtPoint(const double point[3],
            const double in[3], double out[3])
        V.TransformVectorAtPoint((float, float, float), (float, float,
            float)) -> (float, float, float)
        C++: double *TransformVectorAtPoint(const double point[3],
            const double vector[3])
        
        Apply the transformation to a vector at the specified vertex.  If
        the transformation is a vtkLinearTransform, you can use
        TransformVector() instead.
        """
        ...
    
    def Update(self):
        """
        V.Update()
        C++: void Update()
        
        Update the transform to account for any changes which have been
        made.  You do not have to call this method yourself, it is called
        automatically whenever the transform needs an update.
        """
        ...
    
    def __delattr__(self, *args, **kwargs):
        """ Implement delattr(self, name). """
        ...
    
    def __getattribute__(self, *args, **kwargs):
        """ Return getattr(self, name). """
        ...
    
    def __init__(self, *args, **kwargs) -> None:
        ...
    
    @staticmethod
    def __new__(*args, **kwargs):
        """ Create and return a new object.  See help(type) for accurate signature. """
        ...
    
    def __repr__(self, *args, **kwargs):
        """ Return repr(self). """
        ...
    
    def __setattr__(self, *args, **kwargs):
        """ Implement setattr(self, name, value). """
        ...
    
    def __str__(self, *args, **kwargs) -> str:
        """ Return str(self). """
        ...
    
    __this__ = ...
    __dict__ = ...
    __vtkname__ = ...


class vtkWarpTransform(vtkAbstractTransform):
    """
    vtkWarpTransform - superclass for nonlinear geometric transformations
    
    Superclass: vtkAbstractTransform
    
    vtkWarpTransform provides a generic interface for nonlinear warp
    transformations.
    @sa
    vtkThinPlateSplineTransform vtkGridTransform vtkGeneralTransform
    """
    def GetInverseFlag(self):
        """
        V.GetInverseFlag() -> int
        C++: virtual int GetInverseFlag()
        
        Get the inverse flag of the transformation.  This flag is set to
        zero when the transformation is first created, and is flipped
        each time Inverse() is called.
        """
        ...
    
    def GetInverseIterations(self):
        """
        V.GetInverseIterations() -> int
        C++: virtual int GetInverseIterations()
        
        Set the maximum number of iterations for the inverse
        transformation.  The default is 500, but usually only 2 to 5
        iterations are used.  The inversion method is fairly robust, and
        it should converge for nearly all smooth transformations that do
        not fold back on themselves.
        """
        ...
    
    def GetInverseTolerance(self):
        """
        V.GetInverseTolerance() -> float
        C++: virtual double GetInverseTolerance()
        
        Set the tolerance for inverse transformation. The default is
        0.001.
        """
        ...
    
    def GetNumberOfGenerationsFromBase(self, string):
        """
        V.GetNumberOfGenerationsFromBase(string) -> int
        C++: vtkIdType GetNumberOfGenerationsFromBase(const char *type)
            override;
        
        Given a the name of a base class of this class type, return the
        distance of inheritance between this class type and the named
        class (how many generations of inheritance are there between this
        class and the named class). If the named class is not in this
        class's inheritance tree, return a negative value. Valid
        responses will always be nonnegative. This method works in
        combination with vtkTypeMacro found in vtkSetGet.h.
        """
        ...
    
    def GetNumberOfGenerationsFromBaseType(self, string):
        """
        V.GetNumberOfGenerationsFromBaseType(string) -> int
        C++: static vtkIdType GetNumberOfGenerationsFromBaseType(
            const char *type)
        
        Given a the name of a base class of this class type, return the
        distance of inheritance between this class type and the named
        class (how many generations of inheritance are there between this
        class and the named class). If the named class is not in this
        class's inheritance tree, return a negative value. Valid
        responses will always be nonnegative. This method works in
        combination with vtkTypeMacro found in vtkSetGet.h.
        """
        ...
    
    def InternalTransformDerivative(self, , p_float=..., p_float=..., p_float=..., *args, **kwargs):
        """
        V.InternalTransformDerivative((float, float, float), [float,
            float, float], [[float, float, float], [float, float, float],
            [float, float, float]])
        C++: void InternalTransformDerivative(const double in[3],
            double out[3], double derivative[3][3]) override;
        
        This will calculate the transformation, as well as its derivative
        without calling Update.  Meant for use only within other VTK
        classes.
        """
        ...
    
    def InternalTransformPoint(self, , p_float=..., p_float=..., p_float=...):
        """
        V.InternalTransformPoint((float, float, float), [float, float,
            float])
        C++: void InternalTransformPoint(const double in[3],
            double out[3]) override;
        
        This will calculate the transformation without calling Update.
        Meant for use only within other VTK classes.
        """
        ...
    
    def Inverse(self):
        """
        V.Inverse()
        C++: void Inverse() override;
        
        Invert the transformation.  Warp transformations are usually
        inverted using an iterative technique such as Newton's method.
        The inverse transform is usually around five or six times as
        computationally expensive as the forward transform.
        """
        ...
    
    def IsA(self, string):
        """
        V.IsA(string) -> int
        C++: vtkTypeBool IsA(const char *type) override;
        
        Return 1 if this class is the same type of (or a subclass of) the
        named class. Returns 0 otherwise. This method works in
        combination with vtkTypeMacro found in vtkSetGet.h.
        """
        ...
    
    def IsTypeOf(self, string):
        """
        V.IsTypeOf(string) -> int
        C++: static vtkTypeBool IsTypeOf(const char *type)
        
        Return 1 if this class type is the same type of (or a subclass
        of) the named class. Returns 0 otherwise. This method works in
        combination with vtkTypeMacro found in vtkSetGet.h.
        """
        ...
    
    def NewInstance(self):
        """
        V.NewInstance() -> vtkWarpTransform
        C++: vtkWarpTransform *NewInstance()
        """
        ...
    
    def SafeDownCast(self, vtkObjectBase):
        """
        V.SafeDownCast(vtkObjectBase) -> vtkWarpTransform
        C++: static vtkWarpTransform *SafeDownCast(vtkObjectBase *o)
        """
        ...
    
    def SetInverseIterations(self, p_int):
        """
        V.SetInverseIterations(int)
        C++: virtual void SetInverseIterations(int _arg)
        
        Set the maximum number of iterations for the inverse
        transformation.  The default is 500, but usually only 2 to 5
        iterations are used.  The inversion method is fairly robust, and
        it should converge for nearly all smooth transformations that do
        not fold back on themselves.
        """
        ...
    
    def SetInverseTolerance(self, p_float):
        """
        V.SetInverseTolerance(float)
        C++: virtual void SetInverseTolerance(double _arg)
        
        Set the tolerance for inverse transformation. The default is
        0.001.
        """
        ...
    
    def TemplateTransformInverse(self, , p_float=..., p_float=..., p_float=...):
        """
        V.TemplateTransformInverse((float, float, float), [float, float,
            float])
        C++: void TemplateTransformInverse(const double in[3],
            double out[3])
        V.TemplateTransformInverse((float, float, float), [float, float,
            float], [[float, float, float], [float, float, float], [float,
             float, float]])
        C++: void TemplateTransformInverse(const double in[3],
            double out[3], double derivative[3][3])
        
        Do not use these methods.  They exists only as a work-around for
        internal templated functions (I really didn't want to make the
        Forward/Inverse methods public, is there a decent work around for
        this sort of thing?)
        """
        ...
    
    def TemplateTransformPoint(self, , p_float=..., p_float=..., p_float=...):
        """
        V.TemplateTransformPoint((float, float, float), [float, float,
            float])
        C++: void TemplateTransformPoint(const double in[3],
            double out[3])
        V.TemplateTransformPoint((float, float, float), [float, float,
            float], [[float, float, float], [float, float, float], [float,
             float, float]])
        C++: void TemplateTransformPoint(const double in[3],
            double out[3], double derivative[3][3])
        
        Do not use these methods.  They exists only as a work-around for
        internal templated functions (I really didn't want to make the
        Forward/Inverse methods public, is there a decent work around for
        this sort of thing?)
        """
        ...
    
    def __delattr__(self, *args, **kwargs):
        """ Implement delattr(self, name). """
        ...
    
    def __getattribute__(self, *args, **kwargs):
        """ Return getattr(self, name). """
        ...
    
    def __init__(self, *args, **kwargs) -> None:
        ...
    
    @staticmethod
    def __new__(*args, **kwargs):
        """ Create and return a new object.  See help(type) for accurate signature. """
        ...
    
    def __repr__(self, *args, **kwargs):
        """ Return repr(self). """
        ...
    
    def __setattr__(self, *args, **kwargs):
        """ Implement setattr(self, name, value). """
        ...
    
    def __str__(self, *args, **kwargs) -> str:
        """ Return str(self). """
        ...
    
    __this__ = ...
    __dict__ = ...
    __vtkname__ = ...


class vtkCylindricalTransform(vtkWarpTransform):
    """
    vtkCylindricalTransform - cylindrical to rectangular coords and back
    
    Superclass: vtkWarpTransform
    
    vtkCylindricalTransform will convert (r,theta,z) coordinates to
    (x,y,z) coordinates and back again.  The angles are given in radians.
    By default, it converts cylindrical coordinates to rectangular, but
    GetInverse() returns a transform that will do the opposite.  The
    equation that is used is x = r*cos(theta), y = r*sin(theta), z = z.
    @warning
    This transform is not well behaved along the line x=y=0 (i.e. along
    the z-axis)
    @sa
    vtkSphericalTransform vtkGeneralTransform
    """
    def GetNumberOfGenerationsFromBase(self, string):
        """
        V.GetNumberOfGenerationsFromBase(string) -> int
        C++: vtkIdType GetNumberOfGenerationsFromBase(const char *type)
            override;
        
        Given a the name of a base class of this class type, return the
        distance of inheritance between this class type and the named
        class (how many generations of inheritance are there between this
        class and the named class). If the named class is not in this
        class's inheritance tree, return a negative value. Valid
        responses will always be nonnegative. This method works in
        combination with vtkTypeMacro found in vtkSetGet.h.
        """
        ...
    
    def GetNumberOfGenerationsFromBaseType(self, string):
        """
        V.GetNumberOfGenerationsFromBaseType(string) -> int
        C++: static vtkIdType GetNumberOfGenerationsFromBaseType(
            const char *type)
        
        Given a the name of a base class of this class type, return the
        distance of inheritance between this class type and the named
        class (how many generations of inheritance are there between this
        class and the named class). If the named class is not in this
        class's inheritance tree, return a negative value. Valid
        responses will always be nonnegative. This method works in
        combination with vtkTypeMacro found in vtkSetGet.h.
        """
        ...
    
    def IsA(self, string):
        """
        V.IsA(string) -> int
        C++: vtkTypeBool IsA(const char *type) override;
        
        Return 1 if this class is the same type of (or a subclass of) the
        named class. Returns 0 otherwise. This method works in
        combination with vtkTypeMacro found in vtkSetGet.h.
        """
        ...
    
    def IsTypeOf(self, string):
        """
        V.IsTypeOf(string) -> int
        C++: static vtkTypeBool IsTypeOf(const char *type)
        
        Return 1 if this class type is the same type of (or a subclass
        of) the named class. Returns 0 otherwise. This method works in
        combination with vtkTypeMacro found in vtkSetGet.h.
        """
        ...
    
    def MakeTransform(self):
        """
        V.MakeTransform() -> vtkAbstractTransform
        C++: vtkAbstractTransform *MakeTransform() override;
        
        Make another transform of the same type.
        """
        ...
    
    def NewInstance(self):
        """
        V.NewInstance() -> vtkCylindricalTransform
        C++: vtkCylindricalTransform *NewInstance()
        """
        ...
    
    def SafeDownCast(self, vtkObjectBase):
        """
        V.SafeDownCast(vtkObjectBase) -> vtkCylindricalTransform
        C++: static vtkCylindricalTransform *SafeDownCast(
            vtkObjectBase *o)
        """
        ...
    
    def __delattr__(self, *args, **kwargs):
        """ Implement delattr(self, name). """
        ...
    
    def __getattribute__(self, *args, **kwargs):
        """ Return getattr(self, name). """
        ...
    
    def __init__(self, *args, **kwargs) -> None:
        ...
    
    @staticmethod
    def __new__(*args, **kwargs):
        """ Create and return a new object.  See help(type) for accurate signature. """
        ...
    
    def __repr__(self, *args, **kwargs):
        """ Return repr(self). """
        ...
    
    def __setattr__(self, *args, **kwargs):
        """ Implement setattr(self, name, value). """
        ...
    
    def __str__(self, *args, **kwargs) -> str:
        """ Return str(self). """
        ...
    
    __this__ = ...
    __dict__ = ...
    __vtkname__ = ...


class vtkGeneralTransform(vtkAbstractTransform):
    """
    vtkGeneralTransform - allows operations on any transforms
    
    Superclass: vtkAbstractTransform
    
    vtkGeneralTransform is like vtkTransform and vtkPerspectiveTransform,
    but it will work with any vtkAbstractTransform as input.  It is not
    as efficient as the other two, however, because arbitrary
    transformations cannot be concatenated by matrix multiplication.
    Transform concatenation is simulated by passing each input point
    through each transform in turn.
    @sa
    vtkTransform vtkPerspectiveTransform
    """
    def CircuitCheck(self, vtkAbstractTransform):
        """
        V.CircuitCheck(vtkAbstractTransform) -> int
        C++: int CircuitCheck(vtkAbstractTransform *transform) override;
        
        Check for self-reference.  Will return true if concatenating with
        the specified transform, setting it to be our inverse, or setting
        it to be our input will create a circular reference. CircuitCheck
        is automatically called by SetInput(), SetInverse(), and
        Concatenate(vtkXTransform *).  Avoid using this function, it is
        experimental.
        """
        ...
    
    def Concatenate(self, vtkMatrix4x4):
        """
        V.Concatenate(vtkMatrix4x4)
        C++: void Concatenate(vtkMatrix4x4 *matrix)
        V.Concatenate((float, float, float, float, float, float, float,
            float, float, float, float, float, float, float, float, float)
            )
        C++: void Concatenate(const double elements[16])
        V.Concatenate(vtkAbstractTransform)
        C++: void Concatenate(vtkAbstractTransform *transform)
        
        Concatenates the matrix with the current transformation according
        to PreMultiply or PostMultiply semantics.
        """
        ...
    
    def GetConcatenatedTransform(self, p_int):
        """
        V.GetConcatenatedTransform(int) -> vtkAbstractTransform
        C++: vtkAbstractTransform *GetConcatenatedTransform(int i)
        
        Get one of the concatenated transformations as a
        vtkAbstractTransform. These transformations are applied, in
        series, every time the transformation of a coordinate occurs. 
        This method is provided to make it possible to decompose a
        transformation into its constituents, for example to save a
        transformation to a file.
        """
        ...
    
    def GetInput(self):
        """
        V.GetInput() -> vtkAbstractTransform
        C++: vtkAbstractTransform *GetInput()
        
        Set the input for this transformation.  This will be used as the
        base transformation if it is set.  This method allows you to
        build a transform pipeline: if the input is modified, then this
        transformation will automatically update accordingly.  Note that
        the InverseFlag, controlled via Inverse(), determines whether
        this transformation will use the Input or the inverse of the
        Input.
        """
        ...
    
    def GetInverseFlag(self):
        """
        V.GetInverseFlag() -> int
        C++: int GetInverseFlag()
        
        Get the inverse flag of the transformation.  This controls
        whether it is the Input or the inverse of the Input that is used
        as the base transformation.  The InverseFlag is flipped every
        time Inverse() is called.  The InverseFlag is off when a
        transform is first created.
        """
        ...
    
    def GetMTime(self):
        """
        V.GetMTime() -> int
        C++: vtkMTimeType GetMTime() override;
        
        Override GetMTime to account for input and concatenation.
        """
        ...
    
    def GetNumberOfConcatenatedTransforms(self):
        """
        V.GetNumberOfConcatenatedTransforms() -> int
        C++: int GetNumberOfConcatenatedTransforms()
        
        Get the total number of transformations that are linked into this
        one via Concatenate() operations or via SetInput().
        """
        ...
    
    def GetNumberOfGenerationsFromBase(self, string):
        """
        V.GetNumberOfGenerationsFromBase(string) -> int
        C++: vtkIdType GetNumberOfGenerationsFromBase(const char *type)
            override;
        
        Given a the name of a base class of this class type, return the
        distance of inheritance between this class type and the named
        class (how many generations of inheritance are there between this
        class and the named class). If the named class is not in this
        class's inheritance tree, return a negative value. Valid
        responses will always be nonnegative. This method works in
        combination with vtkTypeMacro found in vtkSetGet.h.
        """
        ...
    
    def GetNumberOfGenerationsFromBaseType(self, string):
        """
        V.GetNumberOfGenerationsFromBaseType(string) -> int
        C++: static vtkIdType GetNumberOfGenerationsFromBaseType(
            const char *type)
        
        Given a the name of a base class of this class type, return the
        distance of inheritance between this class type and the named
        class (how many generations of inheritance are there between this
        class and the named class). If the named class is not in this
        class's inheritance tree, return a negative value. Valid
        responses will always be nonnegative. This method works in
        combination with vtkTypeMacro found in vtkSetGet.h.
        """
        ...
    
    def Identity(self):
        """
        V.Identity()
        C++: void Identity()
        
        Set this transformation to the identity transformation.  If the
        transform has an Input, then the transformation will be reset so
        that it is the same as the Input.
        """
        ...
    
    def InternalTransformDerivative(self, , p_float=..., p_float=..., p_float=..., *args, **kwargs):
        """
        V.InternalTransformDerivative((float, float, float), [float,
            float, float], [[float, float, float], [float, float, float],
            [float, float, float]])
        C++: void InternalTransformDerivative(const double in[3],
            double out[3], double derivative[3][3]) override;
        
        This will calculate the transformation as well as its derivative
        without calling Update.  Meant for use only within other VTK
        classes.
        """
        ...
    
    def InternalTransformPoint(self, , p_float=..., p_float=..., p_float=...):
        """
        V.InternalTransformPoint((float, float, float), [float, float,
            float])
        C++: void InternalTransformPoint(const double in[3],
            double out[3]) override;
        
        This will calculate the transformation without calling Update.
        Meant for use only within other VTK classes.
        """
        ...
    
    def Inverse(self):
        """
        V.Inverse()
        C++: void Inverse() override;
        
        Invert the transformation.  This will also set a flag so that the
        transformation will use the inverse of its Input, if an Input has
        been set.
        """
        ...
    
    def IsA(self, string):
        """
        V.IsA(string) -> int
        C++: vtkTypeBool IsA(const char *type) override;
        
        Return 1 if this class is the same type of (or a subclass of) the
        named class. Returns 0 otherwise. This method works in
        combination with vtkTypeMacro found in vtkSetGet.h.
        """
        ...
    
    def IsTypeOf(self, string):
        """
        V.IsTypeOf(string) -> int
        C++: static vtkTypeBool IsTypeOf(const char *type)
        
        Return 1 if this class type is the same type of (or a subclass
        of) the named class. Returns 0 otherwise. This method works in
        combination with vtkTypeMacro found in vtkSetGet.h.
        """
        ...
    
    def MakeTransform(self):
        """
        V.MakeTransform() -> vtkAbstractTransform
        C++: vtkAbstractTransform *MakeTransform() override;
        
        Make another transform of the same type.
        """
        ...
    
    def NewInstance(self):
        """
        V.NewInstance() -> vtkGeneralTransform
        C++: vtkGeneralTransform *NewInstance()
        """
        ...
    
    def Pop(self):
        """
        V.Pop()
        C++: void Pop()
        
        Deletes the transformation on the top of the stack and sets the
        top to the next transformation on the stack.
        """
        ...
    
    def PostMultiply(self):
        """
        V.PostMultiply()
        C++: void PostMultiply()
        
        Sets the internal state of the transform to PostMultiply. All
        subsequent operations will occur after those already represented
        in the current transformation.  In homogeneous matrix notation, M
        = A*M where M is the current transformation matrix and A is the
        applied matrix. The default is PreMultiply.
        """
        ...
    
    def PreMultiply(self):
        """
        V.PreMultiply()
        C++: void PreMultiply()
        
        Sets the internal state of the transform to PreMultiply. All
        subsequent operations will occur before those already represented
        in the current transformation.  In homogeneous matrix notation, M
        = M*A where M is the current transformation matrix and A is the
        applied matrix. The default is PreMultiply.
        """
        ...
    
    def Push(self):
        """
        V.Push()
        C++: void Push()
        
        Pushes the current transformation onto the transformation stack.
        """
        ...
    
    def RotateWXYZ(self, p_float, p_float_1, p_float_2, p_float_3):
        """
        V.RotateWXYZ(float, float, float, float)
        C++: void RotateWXYZ(double angle, double x, double y, double z)
        V.RotateWXYZ(float, (float, float, float))
        C++: void RotateWXYZ(double angle, const double axis[3])
        
        Create a rotation matrix and concatenate it with the current
        transformation according to PreMultiply or PostMultiply
        semantics. The angle is in degrees, and (x,y,z) specifies the
        axis that the rotation will be performed around.
        """
        ...
    
    def RotateX(self, p_float):
        """
        V.RotateX(float)
        C++: void RotateX(double angle)
        
        Create a rotation matrix about the X, Y, or Z axis and
        concatenate it with the current transformation according to
        PreMultiply or PostMultiply semantics.  The angle is expressed in
        degrees.
        """
        ...
    
    def RotateY(self, p_float):
        """
        V.RotateY(float)
        C++: void RotateY(double angle)
        
        Create a rotation matrix about the X, Y, or Z axis and
        concatenate it with the current transformation according to
        PreMultiply or PostMultiply semantics.  The angle is expressed in
        degrees.
        """
        ...
    
    def RotateZ(self, p_float):
        """
        V.RotateZ(float)
        C++: void RotateZ(double angle)
        
        Create a rotation matrix about the X, Y, or Z axis and
        concatenate it with the current transformation according to
        PreMultiply or PostMultiply semantics.  The angle is expressed in
        degrees.
        """
        ...
    
    def SafeDownCast(self, vtkObjectBase):
        """
        V.SafeDownCast(vtkObjectBase) -> vtkGeneralTransform
        C++: static vtkGeneralTransform *SafeDownCast(vtkObjectBase *o)
        """
        ...
    
    def Scale(self, p_float, p_float_1, p_float_2):
        """
        V.Scale(float, float, float)
        C++: void Scale(double x, double y, double z)
        V.Scale((float, float, float))
        C++: void Scale(const double s[3])
        
        Create a scale matrix (i.e. set the diagonal elements to x, y, z)
        and concatenate it with the current transformation according to
        PreMultiply or PostMultiply semantics.
        """
        ...
    
    def SetInput(self, vtkAbstractTransform):
        """
        V.SetInput(vtkAbstractTransform)
        C++: void SetInput(vtkAbstractTransform *input)
        
        Set the input for this transformation.  This will be used as the
        base transformation if it is set.  This method allows you to
        build a transform pipeline: if the input is modified, then this
        transformation will automatically update accordingly.  Note that
        the InverseFlag, controlled via Inverse(), determines whether
        this transformation will use the Input or the inverse of the
        Input.
        """
        ...
    
    def Translate(self, p_float, p_float_1, p_float_2):
        """
        V.Translate(float, float, float)
        C++: void Translate(double x, double y, double z)
        V.Translate((float, float, float))
        C++: void Translate(const double x[3])
        
        Create a translation matrix and concatenate it with the current
        transformation according to PreMultiply or PostMultiply
        semantics.
        """
        ...
    
    def __delattr__(self, *args, **kwargs):
        """ Implement delattr(self, name). """
        ...
    
    def __getattribute__(self, *args, **kwargs):
        """ Return getattr(self, name). """
        ...
    
    def __init__(self, *args, **kwargs) -> None:
        ...
    
    @staticmethod
    def __new__(*args, **kwargs):
        """ Create and return a new object.  See help(type) for accurate signature. """
        ...
    
    def __repr__(self, *args, **kwargs):
        """ Return repr(self). """
        ...
    
    def __setattr__(self, *args, **kwargs):
        """ Implement setattr(self, name, value). """
        ...
    
    def __str__(self, *args, **kwargs) -> str:
        """ Return str(self). """
        ...
    
    __this__ = ...
    __dict__ = ...
    __vtkname__ = ...


class vtkHomogeneousTransform(vtkAbstractTransform):
    """
    vtkHomogeneousTransform - superclass for homogeneous transformations
    
    Superclass: vtkAbstractTransform
    
    vtkHomogeneousTransform provides a generic interface for homogeneous
    transformations, i.e. transformations which can be represented by
    multiplying a 4x4 matrix with a homogeneous coordinate.
    @sa
    vtkPerspectiveTransform vtkLinearTransform vtkIdentityTransform
    """
    def GetHomogeneousInverse(self):
        """
        V.GetHomogeneousInverse() -> vtkHomogeneousTransform
        C++: vtkHomogeneousTransform *GetHomogeneousInverse()
        
        Just like GetInverse(), but includes typecast to
        vtkHomogeneousTransform.
        """
        ...
    
    def GetMatrix(self, vtkMatrix4x4):
        """
        V.GetMatrix(vtkMatrix4x4)
        C++: void GetMatrix(vtkMatrix4x4 *m)
        V.GetMatrix() -> vtkMatrix4x4
        C++: vtkMatrix4x4 *GetMatrix()
        
        Get a copy of the internal transformation matrix.  The transform
        is Updated first, to guarantee that the matrix is valid.
        """
        ...
    
    def GetNumberOfGenerationsFromBase(self, string):
        """
        V.GetNumberOfGenerationsFromBase(string) -> int
        C++: vtkIdType GetNumberOfGenerationsFromBase(const char *type)
            override;
        
        Given a the name of a base class of this class type, return the
        distance of inheritance between this class type and the named
        class (how many generations of inheritance are there between this
        class and the named class). If the named class is not in this
        class's inheritance tree, return a negative value. Valid
        responses will always be nonnegative. This method works in
        combination with vtkTypeMacro found in vtkSetGet.h.
        """
        ...
    
    def GetNumberOfGenerationsFromBaseType(self, string):
        """
        V.GetNumberOfGenerationsFromBaseType(string) -> int
        C++: static vtkIdType GetNumberOfGenerationsFromBaseType(
            const char *type)
        
        Given a the name of a base class of this class type, return the
        distance of inheritance between this class type and the named
        class (how many generations of inheritance are there between this
        class and the named class). If the named class is not in this
        class's inheritance tree, return a negative value. Valid
        responses will always be nonnegative. This method works in
        combination with vtkTypeMacro found in vtkSetGet.h.
        """
        ...
    
    def InternalTransformDerivative(self, , p_float=..., p_float=..., p_float=..., *args, **kwargs):
        """
        V.InternalTransformDerivative((float, float, float), [float,
            float, float], [[float, float, float], [float, float, float],
            [float, float, float]])
        C++: void InternalTransformDerivative(const double in[3],
            double out[3], double derivative[3][3]) override;
        
        This will calculate the transformation as well as its derivative
        without calling Update.  Meant for use only within other VTK
        classes.
        """
        ...
    
    def InternalTransformPoint(self, , p_float=..., p_float=..., p_float=...):
        """
        V.InternalTransformPoint((float, float, float), [float, float,
            float])
        C++: void InternalTransformPoint(const double in[3],
            double out[3]) override;
        
        This will calculate the transformation without calling Update.
        Meant for use only within other VTK classes.
        """
        ...
    
    def IsA(self, string):
        """
        V.IsA(string) -> int
        C++: vtkTypeBool IsA(const char *type) override;
        
        Return 1 if this class is the same type of (or a subclass of) the
        named class. Returns 0 otherwise. This method works in
        combination with vtkTypeMacro found in vtkSetGet.h.
        """
        ...
    
    def IsTypeOf(self, string):
        """
        V.IsTypeOf(string) -> int
        C++: static vtkTypeBool IsTypeOf(const char *type)
        
        Return 1 if this class type is the same type of (or a subclass
        of) the named class. Returns 0 otherwise. This method works in
        combination with vtkTypeMacro found in vtkSetGet.h.
        """
        ...
    
    def NewInstance(self):
        """
        V.NewInstance() -> vtkHomogeneousTransform
        C++: vtkHomogeneousTransform *NewInstance()
        """
        ...
    
    def SafeDownCast(self, vtkObjectBase):
        """
        V.SafeDownCast(vtkObjectBase) -> vtkHomogeneousTransform
        C++: static vtkHomogeneousTransform *SafeDownCast(
            vtkObjectBase *o)
        """
        ...
    
    def TransformPoints(self, vtkPoints, vtkPoints_1):
        """
        V.TransformPoints(vtkPoints, vtkPoints)
        C++: void TransformPoints(vtkPoints *inPts, vtkPoints *outPts)
            override;
        
        Apply the transformation to a series of points, and append the
        results to outPts.
        """
        ...
    
    def __delattr__(self, *args, **kwargs):
        """ Implement delattr(self, name). """
        ...
    
    def __getattribute__(self, *args, **kwargs):
        """ Return getattr(self, name). """
        ...
    
    def __init__(self, *args, **kwargs) -> None:
        ...
    
    @staticmethod
    def __new__(*args, **kwargs):
        """ Create and return a new object.  See help(type) for accurate signature. """
        ...
    
    def __repr__(self, *args, **kwargs):
        """ Return repr(self). """
        ...
    
    def __setattr__(self, *args, **kwargs):
        """ Implement setattr(self, name, value). """
        ...
    
    def __str__(self, *args, **kwargs) -> str:
        """ Return str(self). """
        ...
    
    __this__ = ...
    __dict__ = ...
    __vtkname__ = ...


class vtkLinearTransform(vtkHomogeneousTransform):
    """
    vtkLinearTransform - abstract superclass for linear transformations
    
    Superclass: vtkHomogeneousTransform
    
    vtkLinearTransform provides a generic interface for linear (affine or
    12 degree-of-freedom) geometric transformations.
    @sa
    vtkTransform vtkIdentityTransform
    """
    def GetLinearInverse(self):
        """
        V.GetLinearInverse() -> vtkLinearTransform
        C++: vtkLinearTransform *GetLinearInverse()
        
        Just like GetInverse, but it includes a typecast to
        vtkLinearTransform.
        """
        ...
    
    def GetNumberOfGenerationsFromBase(self, string):
        """
        V.GetNumberOfGenerationsFromBase(string) -> int
        C++: vtkIdType GetNumberOfGenerationsFromBase(const char *type)
            override;
        
        Given a the name of a base class of this class type, return the
        distance of inheritance between this class type and the named
        class (how many generations of inheritance are there between this
        class and the named class). If the named class is not in this
        class's inheritance tree, return a negative value. Valid
        responses will always be nonnegative. This method works in
        combination with vtkTypeMacro found in vtkSetGet.h.
        """
        ...
    
    def GetNumberOfGenerationsFromBaseType(self, string):
        """
        V.GetNumberOfGenerationsFromBaseType(string) -> int
        C++: static vtkIdType GetNumberOfGenerationsFromBaseType(
            const char *type)
        
        Given a the name of a base class of this class type, return the
        distance of inheritance between this class type and the named
        class (how many generations of inheritance are there between this
        class and the named class). If the named class is not in this
        class's inheritance tree, return a negative value. Valid
        responses will always be nonnegative. This method works in
        combination with vtkTypeMacro found in vtkSetGet.h.
        """
        ...
    
    def InternalTransformDerivative(self, , p_float=..., p_float=..., p_float=..., *args, **kwargs):
        """
        V.InternalTransformDerivative((float, float, float), [float,
            float, float], [[float, float, float], [float, float, float],
            [float, float, float]])
        C++: void InternalTransformDerivative(const double in[3],
            double out[3], double derivative[3][3]) override;
        
        This will calculate the transformation as well as its derivative
        without calling Update.  Meant for use only within other VTK
        classes.
        """
        ...
    
    def InternalTransformNormal(self, , p_float=..., p_float=..., p_float=...):
        """
        V.InternalTransformNormal((float, float, float), [float, float,
            float])
        C++: virtual void InternalTransformNormal(const double in[3],
            double out[3])
        
        This will calculate the transformation without calling Update.
        Meant for use only within other VTK classes.
        """
        ...
    
    def InternalTransformPoint(self, , p_float=..., p_float=..., p_float=...):
        """
        V.InternalTransformPoint((float, float, float), [float, float,
            float])
        C++: void InternalTransformPoint(const double in[3],
            double out[3]) override;
        
        This will calculate the transformation without calling Update.
        Meant for use only within other VTK classes.
        """
        ...
    
    def InternalTransformVector(self, , p_float=..., p_float=..., p_float=...):
        """
        V.InternalTransformVector((float, float, float), [float, float,
            float])
        C++: virtual void InternalTransformVector(const double in[3],
            double out[3])
        
        This will calculate the transformation without calling Update.
        Meant for use only within other VTK classes.
        """
        ...
    
    def IsA(self, string):
        """
        V.IsA(string) -> int
        C++: vtkTypeBool IsA(const char *type) override;
        
        Return 1 if this class is the same type of (or a subclass of) the
        named class. Returns 0 otherwise. This method works in
        combination with vtkTypeMacro found in vtkSetGet.h.
        """
        ...
    
    def IsTypeOf(self, string):
        """
        V.IsTypeOf(string) -> int
        C++: static vtkTypeBool IsTypeOf(const char *type)
        
        Return 1 if this class type is the same type of (or a subclass
        of) the named class. Returns 0 otherwise. This method works in
        combination with vtkTypeMacro found in vtkSetGet.h.
        """
        ...
    
    def NewInstance(self):
        """
        V.NewInstance() -> vtkLinearTransform
        C++: vtkLinearTransform *NewInstance()
        """
        ...
    
    def SafeDownCast(self, vtkObjectBase):
        """
        V.SafeDownCast(vtkObjectBase) -> vtkLinearTransform
        C++: static vtkLinearTransform *SafeDownCast(vtkObjectBase *o)
        """
        ...
    
    def TransformDoubleNormal(self, p_float, p_float_1, p_float_2):
        """
        V.TransformDoubleNormal(float, float, float) -> (float, float,
            float)
        C++: double *TransformDoubleNormal(double x, double y, double z)
        V.TransformDoubleNormal((float, float, float)) -> (float, float,
            float)
        C++: double *TransformDoubleNormal(const double normal[3])
        
        Apply the transformation to a double-precision (x,y,z) normal.
        Use this if you are programming in python or Java.
        """
        ...
    
    def TransformDoubleVector(self, p_float, p_float_1, p_float_2):
        """
        V.TransformDoubleVector(float, float, float) -> (float, float,
            float)
        C++: double *TransformDoubleVector(double x, double y, double z)
        V.TransformDoubleVector((float, float, float)) -> (float, float,
            float)
        C++: double *TransformDoubleVector(const double vec[3])
        
        Apply the transformation to a double-precision (x,y,z) vector.
        Use this if you are programming in python or Java.
        """
        ...
    
    def TransformFloatNormal(self, p_float, p_float_1, p_float_2):
        """
        V.TransformFloatNormal(float, float, float) -> (float, float,
            float)
        C++: float *TransformFloatNormal(float x, float y, float z)
        V.TransformFloatNormal((float, float, float)) -> (float, float,
            float)
        C++: float *TransformFloatNormal(const float normal[3])
        
        Apply the transformation to an (x,y,z) normal. Use this if you
        are programming in python or Java.
        """
        ...
    
    def TransformFloatVector(self, p_float, p_float_1, p_float_2):
        """
        V.TransformFloatVector(float, float, float) -> (float, float,
            float)
        C++: float *TransformFloatVector(float x, float y, float z)
        V.TransformFloatVector((float, float, float)) -> (float, float,
            float)
        C++: float *TransformFloatVector(const float vec[3])
        
        Apply the transformation to an (x,y,z) vector. Use this if you
        are programming in python or Java.
        """
        ...
    
    def TransformNormal(self, , p_float=..., p_float=..., p_float=...):
        """
        V.TransformNormal((float, float, float), [float, float, float])
        C++: void TransformNormal(const double in[3], double out[3])
        V.TransformNormal(float, float, float) -> (float, float, float)
        C++: double *TransformNormal(double x, double y, double z)
        V.TransformNormal((float, float, float)) -> (float, float, float)
        C++: double *TransformNormal(const double normal[3])
        
        Apply the transformation to a double-precision normal. You can
        use the same array to store both the input and output.
        """
        ...
    
    def TransformNormals(self, vtkDataArray, vtkDataArray_1):
        """
        V.TransformNormals(vtkDataArray, vtkDataArray)
        C++: virtual void TransformNormals(vtkDataArray *inNms,
            vtkDataArray *outNms)
        
        Apply the transformation to a series of normals, and append the
        results to outNms.
        """
        ...
    
    def TransformPoints(self, vtkPoints, vtkPoints_1):
        """
        V.TransformPoints(vtkPoints, vtkPoints)
        C++: void TransformPoints(vtkPoints *inPts, vtkPoints *outPts)
            override;
        
        Apply the transformation to a series of points, and append the
        results to outPts.
        """
        ...
    
    def TransformVector(self, p_float, p_float_1, p_float_2):
        """
        V.TransformVector(float, float, float) -> (float, float, float)
        C++: double *TransformVector(double x, double y, double z)
        V.TransformVector((float, float, float)) -> (float, float, float)
        C++: double *TransformVector(const double normal[3])
        V.TransformVector((float, float, float), [float, float, float])
        C++: void TransformVector(const double in[3], double out[3])
        
        Synonymous with TransformDoubleVector(x,y,z). Use this if you are
        programming in python or Java.
        """
        ...
    
    def TransformVectors(self, vtkDataArray, vtkDataArray_1):
        """
        V.TransformVectors(vtkDataArray, vtkDataArray)
        C++: virtual void TransformVectors(vtkDataArray *inVrs,
            vtkDataArray *outVrs)
        
        Apply the transformation to a series of vectors, and append the
        results to outVrs.
        """
        ...
    
    def __delattr__(self, *args, **kwargs):
        """ Implement delattr(self, name). """
        ...
    
    def __getattribute__(self, *args, **kwargs):
        """ Return getattr(self, name). """
        ...
    
    def __init__(self, *args, **kwargs) -> None:
        ...
    
    @staticmethod
    def __new__(*args, **kwargs):
        """ Create and return a new object.  See help(type) for accurate signature. """
        ...
    
    def __repr__(self, *args, **kwargs):
        """ Return repr(self). """
        ...
    
    def __setattr__(self, *args, **kwargs):
        """ Implement setattr(self, name, value). """
        ...
    
    def __str__(self, *args, **kwargs) -> str:
        """ Return str(self). """
        ...
    
    __this__ = ...
    __dict__ = ...
    __vtkname__ = ...


class vtkIdentityTransform(vtkLinearTransform):
    """
    vtkIdentityTransform - a transform that doesn't do anything
    
    Superclass: vtkLinearTransform
    
    vtkIdentityTransform is a transformation which will simply pass
    coordinate data unchanged.  All other transform types can also do
    this, however, the vtkIdentityTransform does so with much greater
    efficiency.
    @sa
    vtkLinearTransform
    """
    def GetNumberOfGenerationsFromBase(self, string):
        """
        V.GetNumberOfGenerationsFromBase(string) -> int
        C++: vtkIdType GetNumberOfGenerationsFromBase(const char *type)
            override;
        
        Given a the name of a base class of this class type, return the
        distance of inheritance between this class type and the named
        class (how many generations of inheritance are there between this
        class and the named class). If the named class is not in this
        class's inheritance tree, return a negative value. Valid
        responses will always be nonnegative. This method works in
        combination with vtkTypeMacro found in vtkSetGet.h.
        """
        ...
    
    def GetNumberOfGenerationsFromBaseType(self, string):
        """
        V.GetNumberOfGenerationsFromBaseType(string) -> int
        C++: static vtkIdType GetNumberOfGenerationsFromBaseType(
            const char *type)
        
        Given a the name of a base class of this class type, return the
        distance of inheritance between this class type and the named
        class (how many generations of inheritance are there between this
        class and the named class). If the named class is not in this
        class's inheritance tree, return a negative value. Valid
        responses will always be nonnegative. This method works in
        combination with vtkTypeMacro found in vtkSetGet.h.
        """
        ...
    
    def InternalTransformDerivative(self, , p_float=..., p_float=..., p_float=..., *args, **kwargs):
        """
        V.InternalTransformDerivative((float, float, float), [float,
            float, float], [[float, float, float], [float, float, float],
            [float, float, float]])
        C++: void InternalTransformDerivative(const double in[3],
            double out[3], double derivative[3][3]) override;
        
        This will calculate the transformation as well as its derivative
        without calling Update.  Meant for use only within other VTK
        classes.
        """
        ...
    
    def InternalTransformNormal(self, , p_float=..., p_float=..., p_float=...):
        """
        V.InternalTransformNormal((float, float, float), [float, float,
            float])
        C++: void InternalTransformNormal(const double in[3],
            double out[3]) override;
        
        This will calculate the transformation without calling Update.
        Meant for use only within other VTK classes.
        """
        ...
    
    def InternalTransformPoint(self, , p_float=..., p_float=..., p_float=...):
        """
        V.InternalTransformPoint((float, float, float), [float, float,
            float])
        C++: void InternalTransformPoint(const double in[3],
            double out[3]) override;
        
        This will calculate the transformation without calling Update.
        Meant for use only within other VTK classes.
        """
        ...
    
    def InternalTransformVector(self, , p_float=..., p_float=..., p_float=...):
        """
        V.InternalTransformVector((float, float, float), [float, float,
            float])
        C++: void InternalTransformVector(const double in[3],
            double out[3]) override;
        
        This will calculate the transformation without calling Update.
        Meant for use only within other VTK classes.
        """
        ...
    
    def Inverse(self):
        """
        V.Inverse()
        C++: void Inverse() override;
        
        Invert the transformation.
        """
        ...
    
    def IsA(self, string):
        """
        V.IsA(string) -> int
        C++: vtkTypeBool IsA(const char *type) override;
        
        Return 1 if this class is the same type of (or a subclass of) the
        named class. Returns 0 otherwise. This method works in
        combination with vtkTypeMacro found in vtkSetGet.h.
        """
        ...
    
    def IsTypeOf(self, string):
        """
        V.IsTypeOf(string) -> int
        C++: static vtkTypeBool IsTypeOf(const char *type)
        
        Return 1 if this class type is the same type of (or a subclass
        of) the named class. Returns 0 otherwise. This method works in
        combination with vtkTypeMacro found in vtkSetGet.h.
        """
        ...
    
    def MakeTransform(self):
        """
        V.MakeTransform() -> vtkAbstractTransform
        C++: vtkAbstractTransform *MakeTransform() override;
        
        Make a transform of the same type.  This will actually return the
        same transform.
        """
        ...
    
    def NewInstance(self):
        """
        V.NewInstance() -> vtkIdentityTransform
        C++: vtkIdentityTransform *NewInstance()
        """
        ...
    
    def SafeDownCast(self, vtkObjectBase):
        """
        V.SafeDownCast(vtkObjectBase) -> vtkIdentityTransform
        C++: static vtkIdentityTransform *SafeDownCast(vtkObjectBase *o)
        """
        ...
    
    def TransformNormals(self, vtkDataArray, vtkDataArray_1):
        """
        V.TransformNormals(vtkDataArray, vtkDataArray)
        C++: void TransformNormals(vtkDataArray *inNms,
            vtkDataArray *outNms) override;
        
        Apply the transformation to a series of normals, and append the
        results to outNms.
        """
        ...
    
    def TransformPoints(self, vtkPoints, vtkPoints_1):
        """
        V.TransformPoints(vtkPoints, vtkPoints)
        C++: void TransformPoints(vtkPoints *inPts, vtkPoints *outPts)
            override;
        
        Apply the transformation to a series of points, and append the
        results to outPts.
        """
        ...
    
    def TransformVectors(self, vtkDataArray, vtkDataArray_1):
        """
        V.TransformVectors(vtkDataArray, vtkDataArray)
        C++: void TransformVectors(vtkDataArray *inVrs,
            vtkDataArray *outVrs) override;
        
        Apply the transformation to a series of vectors, and append the
        results to outVrs.
        """
        ...
    
    def __delattr__(self, *args, **kwargs):
        """ Implement delattr(self, name). """
        ...
    
    def __getattribute__(self, *args, **kwargs):
        """ Return getattr(self, name). """
        ...
    
    def __init__(self, *args, **kwargs) -> None:
        ...
    
    @staticmethod
    def __new__(*args, **kwargs):
        """ Create and return a new object.  See help(type) for accurate signature. """
        ...
    
    def __repr__(self, *args, **kwargs):
        """ Return repr(self). """
        ...
    
    def __setattr__(self, *args, **kwargs):
        """ Implement setattr(self, name, value). """
        ...
    
    def __str__(self, *args, **kwargs) -> str:
        """ Return str(self). """
        ...
    
    __this__ = ...
    __dict__ = ...
    __vtkname__ = ...


class vtkLandmarkTransform(vtkLinearTransform):
    """
    vtkLandmarkTransform - a linear transform specified by two
    corresponding point sets
    
    Superclass: vtkLinearTransform
    
    A vtkLandmarkTransform is defined by two sets of landmarks, the
    transform computed gives the best fit mapping one onto the other, in
    a least squares sense. The indices are taken to correspond, so point
    1 in the first set will get mapped close to point 1 in the second
    set, etc. Call SetSourceLandmarks and SetTargetLandmarks to specify
    the two sets of landmarks, ensure they have the same number of
    points.
    @warning
    Whenever you add, subtract, or set points you must call Modified() on
    the vtkPoints object, or the transformation might not update.
    @sa
    vtkLinearTransform
    """
    def GetMode(self):
        """
        V.GetMode() -> int
        C++: virtual int GetMode()
        
        Get the current transformation mode.
        """
        ...
    
    def GetModeAsString(self):
        """
        V.GetModeAsString() -> string
        C++: const char *GetModeAsString()
        
        Get the current transformation mode.
        """
        ...
    
    def GetMTime(self):
        """
        V.GetMTime() -> int
        C++: vtkMTimeType GetMTime() override;
        
        Get the MTime.
        """
        ...
    
    def GetNumberOfGenerationsFromBase(self, string):
        """
        V.GetNumberOfGenerationsFromBase(string) -> int
        C++: vtkIdType GetNumberOfGenerationsFromBase(const char *type)
            override;
        
        Given a the name of a base class of this class type, return the
        distance of inheritance between this class type and the named
        class (how many generations of inheritance are there between this
        class and the named class). If the named class is not in this
        class's inheritance tree, return a negative value. Valid
        responses will always be nonnegative. This method works in
        combination with vtkTypeMacro found in vtkSetGet.h.
        """
        ...
    
    def GetNumberOfGenerationsFromBaseType(self, string):
        """
        V.GetNumberOfGenerationsFromBaseType(string) -> int
        C++: static vtkIdType GetNumberOfGenerationsFromBaseType(
            const char *type)
        
        Given a the name of a base class of this class type, return the
        distance of inheritance between this class type and the named
        class (how many generations of inheritance are there between this
        class and the named class). If the named class is not in this
        class's inheritance tree, return a negative value. Valid
        responses will always be nonnegative. This method works in
        combination with vtkTypeMacro found in vtkSetGet.h.
        """
        ...
    
    def GetSourceLandmarks(self):
        """
        V.GetSourceLandmarks() -> vtkPoints
        C++: virtual vtkPoints *GetSourceLandmarks()
        
        Specify the source and target landmark sets. The two sets must
        have the same number of points.  If you add or change points in
        these objects, you must call Modified() on them or the
        transformation might not update.
        """
        ...
    
    def GetTargetLandmarks(self):
        """
        V.GetTargetLandmarks() -> vtkPoints
        C++: virtual vtkPoints *GetTargetLandmarks()
        
        Specify the source and target landmark sets. The two sets must
        have the same number of points.  If you add or change points in
        these objects, you must call Modified() on them or the
        transformation might not update.
        """
        ...
    
    def Inverse(self):
        """
        V.Inverse()
        C++: void Inverse() override;
        
        Invert the transformation.  This is done by switching the source
        and target landmarks.
        """
        ...
    
    def IsA(self, string):
        """
        V.IsA(string) -> int
        C++: vtkTypeBool IsA(const char *type) override;
        
        Return 1 if this class is the same type of (or a subclass of) the
        named class. Returns 0 otherwise. This method works in
        combination with vtkTypeMacro found in vtkSetGet.h.
        """
        ...
    
    def IsTypeOf(self, string):
        """
        V.IsTypeOf(string) -> int
        C++: static vtkTypeBool IsTypeOf(const char *type)
        
        Return 1 if this class type is the same type of (or a subclass
        of) the named class. Returns 0 otherwise. This method works in
        combination with vtkTypeMacro found in vtkSetGet.h.
        """
        ...
    
    def MakeTransform(self):
        """
        V.MakeTransform() -> vtkAbstractTransform
        C++: vtkAbstractTransform *MakeTransform() override;
        
        Make another transform of the same type.
        """
        ...
    
    def NewInstance(self):
        """
        V.NewInstance() -> vtkLandmarkTransform
        C++: vtkLandmarkTransform *NewInstance()
        """
        ...
    
    def SafeDownCast(self, vtkObjectBase):
        """
        V.SafeDownCast(vtkObjectBase) -> vtkLandmarkTransform
        C++: static vtkLandmarkTransform *SafeDownCast(vtkObjectBase *o)
        """
        ...
    
    def SetMode(self, p_int):
        """
        V.SetMode(int)
        C++: virtual void SetMode(int _arg)
        
        Set the number of degrees of freedom to constrain the solution
        to. Rigidbody (VTK_LANDMARK_RIGIDBODY): rotation and translation
        only. Similarity (VTK_LANDMARK_SIMILARITY): rotation, translation
        and isotropic scaling. Affine (VTK_LANDMARK_AFFINE): collinearity
        is preserved. Ratios of distances along a line are preserved. The
        default is similarity.
        """
        ...
    
    def SetModeToAffine(self):
        """
        V.SetModeToAffine()
        C++: void SetModeToAffine()
        
        Set the number of degrees of freedom to constrain the solution
        to. Rigidbody (VTK_LANDMARK_RIGIDBODY): rotation and translation
        only. Similarity (VTK_LANDMARK_SIMILARITY): rotation, translation
        and isotropic scaling. Affine (VTK_LANDMARK_AFFINE): collinearity
        is preserved. Ratios of distances along a line are preserved. The
        default is similarity.
        """
        ...
    
    def SetModeToRigidBody(self):
        """
        V.SetModeToRigidBody()
        C++: void SetModeToRigidBody()
        
        Set the number of degrees of freedom to constrain the solution
        to. Rigidbody (VTK_LANDMARK_RIGIDBODY): rotation and translation
        only. Similarity (VTK_LANDMARK_SIMILARITY): rotation, translation
        and isotropic scaling. Affine (VTK_LANDMARK_AFFINE): collinearity
        is preserved. Ratios of distances along a line are preserved. The
        default is similarity.
        """
        ...
    
    def SetModeToSimilarity(self):
        """
        V.SetModeToSimilarity()
        C++: void SetModeToSimilarity()
        
        Set the number of degrees of freedom to constrain the solution
        to. Rigidbody (VTK_LANDMARK_RIGIDBODY): rotation and translation
        only. Similarity (VTK_LANDMARK_SIMILARITY): rotation, translation
        and isotropic scaling. Affine (VTK_LANDMARK_AFFINE): collinearity
        is preserved. Ratios of distances along a line are preserved. The
        default is similarity.
        """
        ...
    
    def SetSourceLandmarks(self, vtkPoints):
        """
        V.SetSourceLandmarks(vtkPoints)
        C++: void SetSourceLandmarks(vtkPoints *points)
        
        Specify the source and target landmark sets. The two sets must
        have the same number of points.  If you add or change points in
        these objects, you must call Modified() on them or the
        transformation might not update.
        """
        ...
    
    def SetTargetLandmarks(self, vtkPoints):
        """
        V.SetTargetLandmarks(vtkPoints)
        C++: void SetTargetLandmarks(vtkPoints *points)
        
        Specify the source and target landmark sets. The two sets must
        have the same number of points.  If you add or change points in
        these objects, you must call Modified() on them or the
        transformation might not update.
        """
        ...
    
    def __delattr__(self, *args, **kwargs):
        """ Implement delattr(self, name). """
        ...
    
    def __getattribute__(self, *args, **kwargs):
        """ Return getattr(self, name). """
        ...
    
    def __init__(self, *args, **kwargs) -> None:
        ...
    
    @staticmethod
    def __new__(*args, **kwargs):
        """ Create and return a new object.  See help(type) for accurate signature. """
        ...
    
    def __repr__(self, *args, **kwargs):
        """ Return repr(self). """
        ...
    
    def __setattr__(self, *args, **kwargs):
        """ Implement setattr(self, name, value). """
        ...
    
    def __str__(self, *args, **kwargs) -> str:
        """ Return str(self). """
        ...
    
    __this__ = ...
    __dict__ = ...
    __vtkname__ = ...


class vtkMatrixToHomogeneousTransform(vtkHomogeneousTransform):
    """
    vtkMatrixToHomogeneousTransform - convert a matrix to a transform
    
    Superclass: vtkHomogeneousTransform
    
    This is a very simple class which allows a vtkMatrix4x4 to be used in
    place of a vtkHomogeneousTransform or vtkAbstractTransform.  For
    example, if you use it as a proxy between a matrix and
    vtkTransformPolyDataFilter then any modifications to the matrix will
    automatically be reflected in the output of the filter.
    @sa
    vtkPerspectiveTransform vtkMatrix4x4 vtkMatrixToLinearTransform
    """
    def GetInput(self):
        """
        V.GetInput() -> vtkMatrix4x4
        C++: virtual vtkMatrix4x4 *GetInput()
        """
        ...
    
    def GetMTime(self):
        """
        V.GetMTime() -> int
        C++: vtkMTimeType GetMTime() override;
        
        Get the MTime: this is the bit of magic that makes everything
        work.
        """
        ...
    
    def GetNumberOfGenerationsFromBase(self, string):
        """
        V.GetNumberOfGenerationsFromBase(string) -> int
        C++: vtkIdType GetNumberOfGenerationsFromBase(const char *type)
            override;
        
        Given a the name of a base class of this class type, return the
        distance of inheritance between this class type and the named
        class (how many generations of inheritance are there between this
        class and the named class). If the named class is not in this
        class's inheritance tree, return a negative value. Valid
        responses will always be nonnegative. This method works in
        combination with vtkTypeMacro found in vtkSetGet.h.
        """
        ...
    
    def GetNumberOfGenerationsFromBaseType(self, string):
        """
        V.GetNumberOfGenerationsFromBaseType(string) -> int
        C++: static vtkIdType GetNumberOfGenerationsFromBaseType(
            const char *type)
        
        Given a the name of a base class of this class type, return the
        distance of inheritance between this class type and the named
        class (how many generations of inheritance are there between this
        class and the named class). If the named class is not in this
        class's inheritance tree, return a negative value. Valid
        responses will always be nonnegative. This method works in
        combination with vtkTypeMacro found in vtkSetGet.h.
        """
        ...
    
    def Inverse(self):
        """
        V.Inverse()
        C++: void Inverse() override;
        
        The input matrix is left as-is, but the transformation matrix is
        inverted.
        """
        ...
    
    def IsA(self, string):
        """
        V.IsA(string) -> int
        C++: vtkTypeBool IsA(const char *type) override;
        
        Return 1 if this class is the same type of (or a subclass of) the
        named class. Returns 0 otherwise. This method works in
        combination with vtkTypeMacro found in vtkSetGet.h.
        """
        ...
    
    def IsTypeOf(self, string):
        """
        V.IsTypeOf(string) -> int
        C++: static vtkTypeBool IsTypeOf(const char *type)
        
        Return 1 if this class type is the same type of (or a subclass
        of) the named class. Returns 0 otherwise. This method works in
        combination with vtkTypeMacro found in vtkSetGet.h.
        """
        ...
    
    def MakeTransform(self):
        """
        V.MakeTransform() -> vtkAbstractTransform
        C++: vtkAbstractTransform *MakeTransform() override;
        
        Make a new transform of the same type.
        """
        ...
    
    def NewInstance(self):
        """
        V.NewInstance() -> vtkMatrixToHomogeneousTransform
        C++: vtkMatrixToHomogeneousTransform *NewInstance()
        """
        ...
    
    def SafeDownCast(self, vtkObjectBase):
        """
        V.SafeDownCast(vtkObjectBase) -> vtkMatrixToHomogeneousTransform
        C++: static vtkMatrixToHomogeneousTransform *SafeDownCast(
            vtkObjectBase *o)
        """
        ...
    
    def SetInput(self, vtkMatrix4x4):
        """
        V.SetInput(vtkMatrix4x4)
        C++: virtual void SetInput(vtkMatrix4x4 *)
        """
        ...
    
    def __delattr__(self, *args, **kwargs):
        """ Implement delattr(self, name). """
        ...
    
    def __getattribute__(self, *args, **kwargs):
        """ Return getattr(self, name). """
        ...
    
    def __init__(self, *args, **kwargs) -> None:
        ...
    
    @staticmethod
    def __new__(*args, **kwargs):
        """ Create and return a new object.  See help(type) for accurate signature. """
        ...
    
    def __repr__(self, *args, **kwargs):
        """ Return repr(self). """
        ...
    
    def __setattr__(self, *args, **kwargs):
        """ Implement setattr(self, name, value). """
        ...
    
    def __str__(self, *args, **kwargs) -> str:
        """ Return str(self). """
        ...
    
    __this__ = ...
    __dict__ = ...
    __vtkname__ = ...


class vtkMatrixToLinearTransform(vtkLinearTransform):
    """
    vtkMatrixToLinearTransform - convert a matrix to a transform
    
    Superclass: vtkLinearTransform
    
    This is a very simple class which allows a vtkMatrix4x4 to be used in
    place of a vtkLinearTransform or vtkAbstractTransform.  For example,
    if you use it as a proxy between a matrix and
    vtkTransformPolyDataFilter then any modifications to the matrix will
    automatically be reflected in the output of the filter.
    @sa
    vtkTransform vtkMatrix4x4 vtkMatrixToHomogeneousTransform
    """
    def GetInput(self):
        """
        V.GetInput() -> vtkMatrix4x4
        C++: virtual vtkMatrix4x4 *GetInput()
        
        Set the input matrix.  Any modifications to the matrix will be
        reflected in the transformation.
        """
        ...
    
    def GetMTime(self):
        """
        V.GetMTime() -> int
        C++: vtkMTimeType GetMTime() override;
        
        Get the MTime: this is the bit of magic that makes everything
        work.
        """
        ...
    
    def GetNumberOfGenerationsFromBase(self, string):
        """
        V.GetNumberOfGenerationsFromBase(string) -> int
        C++: vtkIdType GetNumberOfGenerationsFromBase(const char *type)
            override;
        
        Given a the name of a base class of this class type, return the
        distance of inheritance between this class type and the named
        class (how many generations of inheritance are there between this
        class and the named class). If the named class is not in this
        class's inheritance tree, return a negative value. Valid
        responses will always be nonnegative. This method works in
        combination with vtkTypeMacro found in vtkSetGet.h.
        """
        ...
    
    def GetNumberOfGenerationsFromBaseType(self, string):
        """
        V.GetNumberOfGenerationsFromBaseType(string) -> int
        C++: static vtkIdType GetNumberOfGenerationsFromBaseType(
            const char *type)
        
        Given a the name of a base class of this class type, return the
        distance of inheritance between this class type and the named
        class (how many generations of inheritance are there between this
        class and the named class). If the named class is not in this
        class's inheritance tree, return a negative value. Valid
        responses will always be nonnegative. This method works in
        combination with vtkTypeMacro found in vtkSetGet.h.
        """
        ...
    
    def Inverse(self):
        """
        V.Inverse()
        C++: void Inverse() override;
        
        The input matrix is left as-is, but the transformation matrix is
        inverted.
        """
        ...
    
    def IsA(self, string):
        """
        V.IsA(string) -> int
        C++: vtkTypeBool IsA(const char *type) override;
        
        Return 1 if this class is the same type of (or a subclass of) the
        named class. Returns 0 otherwise. This method works in
        combination with vtkTypeMacro found in vtkSetGet.h.
        """
        ...
    
    def IsTypeOf(self, string):
        """
        V.IsTypeOf(string) -> int
        C++: static vtkTypeBool IsTypeOf(const char *type)
        
        Return 1 if this class type is the same type of (or a subclass
        of) the named class. Returns 0 otherwise. This method works in
        combination with vtkTypeMacro found in vtkSetGet.h.
        """
        ...
    
    def MakeTransform(self):
        """
        V.MakeTransform() -> vtkAbstractTransform
        C++: vtkAbstractTransform *MakeTransform() override;
        
        Make a new transform of the same type.
        """
        ...
    
    def NewInstance(self):
        """
        V.NewInstance() -> vtkMatrixToLinearTransform
        C++: vtkMatrixToLinearTransform *NewInstance()
        """
        ...
    
    def SafeDownCast(self, vtkObjectBase):
        """
        V.SafeDownCast(vtkObjectBase) -> vtkMatrixToLinearTransform
        C++: static vtkMatrixToLinearTransform *SafeDownCast(
            vtkObjectBase *o)
        """
        ...
    
    def SetInput(self, vtkMatrix4x4):
        """
        V.SetInput(vtkMatrix4x4)
        C++: virtual void SetInput(vtkMatrix4x4 *)
        
        Set the input matrix.  Any modifications to the matrix will be
        reflected in the transformation.
        """
        ...
    
    def __delattr__(self, *args, **kwargs):
        """ Implement delattr(self, name). """
        ...
    
    def __getattribute__(self, *args, **kwargs):
        """ Return getattr(self, name). """
        ...
    
    def __init__(self, *args, **kwargs) -> None:
        ...
    
    @staticmethod
    def __new__(*args, **kwargs):
        """ Create and return a new object.  See help(type) for accurate signature. """
        ...
    
    def __repr__(self, *args, **kwargs):
        """ Return repr(self). """
        ...
    
    def __setattr__(self, *args, **kwargs):
        """ Implement setattr(self, name, value). """
        ...
    
    def __str__(self, *args, **kwargs) -> str:
        """ Return str(self). """
        ...
    
    __this__ = ...
    __dict__ = ...
    __vtkname__ = ...


class vtkPerspectiveTransform(vtkHomogeneousTransform):
    """
    vtkPerspectiveTransform - describes a 4x4 matrix transformation
    
    Superclass: vtkHomogeneousTransform
    
    A vtkPerspectiveTransform can be used to describe the full range of
    homogeneous transformations.  It was designed in particular to
    describe a camera-view of a scene.
    
    The order in which you set up the display coordinates (via
    AdjustZBuffer() and AdjustViewport()), the projection (via
    Perspective(), Frustum(), or Ortho()) and the camera view (via
    SetupCamera()) are important.  If the transform is in PreMultiply
    mode, which is the default, set the Viewport and ZBuffer first, then
    the projection, and finally the camera view.  Once the view is set
    up, the Translate and Rotate methods can be used to move the camera
    around in world coordinates.  If the Oblique() or Stereo() methods
    are used, they should be called just before SetupCamera().
    
    In PostMultiply mode, you must perform all transformations in the
    opposite order.  This is necessary, for example, if you already have
    a perspective transformation set up but must adjust the viewport. 
    Another example is if you have a view transformation, and wish to
    perform translations and rotations in the camera's coordinate system
    rather than in world coordinates.
    
    The SetInput and Concatenate methods can be used to create a
    transformation pipeline with vtkPerspectiveTransform.  See
    vtkTransform for more information on the transformation pipeline.
    @sa
    vtkGeneralTransform vtkTransform vtkMatrix4x4 vtkCamera
    """
    def AdjustViewport(self, p_float, p_float_1, p_float_2, p_float_3, p_float_4, p_float_5, p_float_6, p_float_7):
        """
        V.AdjustViewport(float, float, float, float, float, float, float,
            float)
        C++: void AdjustViewport(double oldXMin, double oldXMax,
            double oldYMin, double oldYMax, double newXMin,
            double newXMax, double newYMin, double newYMax)
        
        Perform an adjustment to the viewport coordinates.  By default
        Ortho, Frustum, and Perspective provide a window of
        ([-1,+1],[-1,+1]). In PreMultiply mode, you call this method
        before calling Ortho, Frustum, or Perspective.  In PostMultiply
        mode you can call it after.  Note that if you must apply both
        AdjustZBuffer and AdjustViewport, it makes no difference which
        order you apply them in.
        """
        ...
    
    def AdjustZBuffer(self, p_float, p_float_1, p_float_2, p_float_3):
        """
        V.AdjustZBuffer(float, float, float, float)
        C++: void AdjustZBuffer(double oldNearZ, double oldFarZ,
            double newNearZ, double newFarZ)
        
        Perform an adjustment to the Z-Buffer range that the near and far
        clipping planes map to.  By default Ortho, Frustum, and
        Perspective map the near clipping plane to -1 and the far
        clipping plane to +1. In PreMultiply mode, you call this method
        before calling Ortho, Frustum, or Perspective.  In PostMultiply
        mode you can call it after.
        """
        ...
    
    def CircuitCheck(self, vtkAbstractTransform):
        """
        V.CircuitCheck(vtkAbstractTransform) -> int
        C++: int CircuitCheck(vtkAbstractTransform *transform) override;
        
        Check for self-reference.  Will return true if concatenating with
        the specified transform, setting it to be our inverse, or setting
        it to be our input will create a circular reference. CircuitCheck
        is automatically called by SetInput(), SetInverse(), and
        Concatenate(vtkXTransform *).  Avoid using this function, it is
        experimental.
        """
        ...
    
    def Concatenate(self, vtkMatrix4x4):
        """
        V.Concatenate(vtkMatrix4x4)
        C++: void Concatenate(vtkMatrix4x4 *matrix)
        V.Concatenate((float, float, float, float, float, float, float,
            float, float, float, float, float, float, float, float, float)
            )
        C++: void Concatenate(const double elements[16])
        V.Concatenate(vtkHomogeneousTransform)
        C++: void Concatenate(vtkHomogeneousTransform *transform)
        
        Concatenates the matrix with the current transformation according
        to PreMultiply or PostMultiply semantics.
        """
        ...
    
    def Frustum(self, p_float, p_float_1, p_float_2, p_float_3, p_float_4, p_float_5):
        """
        V.Frustum(float, float, float, float, float, float)
        C++: void Frustum(double xmin, double xmax, double ymin,
            double ymax, double znear, double zfar)
        
        Create an perspective projection matrix and concatenate it by the
        current transformation.  The matrix maps a frustum with a back
        plane at -zfar and a front plane at -znear with extent
        [xmin,xmax],[ymin,ymax] to [-1,+1], [-1,+1], [+1,-1].
        """
        ...
    
    def GetConcatenatedTransform(self, p_int):
        """
        V.GetConcatenatedTransform(int) -> vtkHomogeneousTransform
        C++: vtkHomogeneousTransform *GetConcatenatedTransform(int i)
        
        Get one of the concatenated transformations as a
        vtkAbstractTransform. These transformations are applied, in
        series, every time the transformation of a coordinate occurs. 
        This method is provided to make it possible to decompose a
        transformation into its constituents, for example to save a
        transformation to a file.
        """
        ...
    
    def GetInput(self):
        """
        V.GetInput() -> vtkHomogeneousTransform
        C++: vtkHomogeneousTransform *GetInput()
        
        Set the input for this transformation.  This will be used as the
        base transformation if it is set.  This method allows you to
        build a transform pipeline: if the input is modified, then this
        transformation will automatically update accordingly.  Note that
        the InverseFlag, controlled via Inverse(), determines whether
        this transformation will use the Input or the inverse of the
        Input.
        """
        ...
    
    def GetInverseFlag(self):
        """
        V.GetInverseFlag() -> int
        C++: int GetInverseFlag()
        
        Get the inverse flag of the transformation.  This controls
        whether it is the Input or the inverse of the Input that is used
        as the base transformation.  The InverseFlag is flipped every
        time Inverse() is called.  The InverseFlag is off when a
        transform is first created.
        """
        ...
    
    def GetMTime(self):
        """
        V.GetMTime() -> int
        C++: vtkMTimeType GetMTime() override;
        
        Override GetMTime to account for input and concatenation.
        """
        ...
    
    def GetNumberOfConcatenatedTransforms(self):
        """
        V.GetNumberOfConcatenatedTransforms() -> int
        C++: int GetNumberOfConcatenatedTransforms()
        
        Get the total number of transformations that are linked into this
        one via Concatenate() operations or via SetInput().
        """
        ...
    
    def GetNumberOfGenerationsFromBase(self, string):
        """
        V.GetNumberOfGenerationsFromBase(string) -> int
        C++: vtkIdType GetNumberOfGenerationsFromBase(const char *type)
            override;
        
        Given a the name of a base class of this class type, return the
        distance of inheritance between this class type and the named
        class (how many generations of inheritance are there between this
        class and the named class). If the named class is not in this
        class's inheritance tree, return a negative value. Valid
        responses will always be nonnegative. This method works in
        combination with vtkTypeMacro found in vtkSetGet.h.
        """
        ...
    
    def GetNumberOfGenerationsFromBaseType(self, string):
        """
        V.GetNumberOfGenerationsFromBaseType(string) -> int
        C++: static vtkIdType GetNumberOfGenerationsFromBaseType(
            const char *type)
        
        Given a the name of a base class of this class type, return the
        distance of inheritance between this class type and the named
        class (how many generations of inheritance are there between this
        class and the named class). If the named class is not in this
        class's inheritance tree, return a negative value. Valid
        responses will always be nonnegative. This method works in
        combination with vtkTypeMacro found in vtkSetGet.h.
        """
        ...
    
    def Identity(self):
        """
        V.Identity()
        C++: void Identity()
        
        Set this transformation to the identity transformation.  If the
        transform has an Input, then the transformation will be reset so
        that it is the same as the Input.
        """
        ...
    
    def Inverse(self):
        """
        V.Inverse()
        C++: void Inverse() override;
        
        Invert the transformation.  This will also set a flag so that the
        transformation will use the inverse of its Input, if an Input has
        been set.
        """
        ...
    
    def IsA(self, string):
        """
        V.IsA(string) -> int
        C++: vtkTypeBool IsA(const char *type) override;
        
        Return 1 if this class is the same type of (or a subclass of) the
        named class. Returns 0 otherwise. This method works in
        combination with vtkTypeMacro found in vtkSetGet.h.
        """
        ...
    
    def IsTypeOf(self, string):
        """
        V.IsTypeOf(string) -> int
        C++: static vtkTypeBool IsTypeOf(const char *type)
        
        Return 1 if this class type is the same type of (or a subclass
        of) the named class. Returns 0 otherwise. This method works in
        combination with vtkTypeMacro found in vtkSetGet.h.
        """
        ...
    
    def MakeTransform(self):
        """
        V.MakeTransform() -> vtkAbstractTransform
        C++: vtkAbstractTransform *MakeTransform() override;
        
        Make a new transform of the same type -- you are responsible for
        deleting the transform when you are done with it.
        """
        ...
    
    def NewInstance(self):
        """
        V.NewInstance() -> vtkPerspectiveTransform
        C++: vtkPerspectiveTransform *NewInstance()
        """
        ...
    
    def Ortho(self, p_float, p_float_1, p_float_2, p_float_3, p_float_4, p_float_5):
        """
        V.Ortho(float, float, float, float, float, float)
        C++: void Ortho(double xmin, double xmax, double ymin,
            double ymax, double znear, double zfar)
        
        Create an orthogonal projection matrix and concatenate it by the
        current transformation.  The matrix maps [xmin,xmax],
        [ymin,ymax], [-znear,-zfar] to [-1,+1], [-1,+1], [+1,-1].
        """
        ...
    
    def Perspective(self, p_float, p_float_1, p_float_2, p_float_3):
        """
        V.Perspective(float, float, float, float)
        C++: void Perspective(double angle, double aspect, double znear,
            double zfar)
        
        Create a perspective projection matrix by specifying the view
        angle (this angle is in the y direction), the aspect ratio, and
        the near and far clipping range.  The projection matrix is
        concatenated with the current transformation.  This method works
        via Frustum.
        """
        ...
    
    def Pop(self):
        """
        V.Pop()
        C++: void Pop()
        
        Deletes the transformation on the top of the stack and sets the
        top to the next transformation on the stack.
        """
        ...
    
    def PostMultiply(self):
        """
        V.PostMultiply()
        C++: void PostMultiply()
        
        Sets the internal state of the transform to PostMultiply. All
        subsequent operations will occur after those already represented
        in the current transformation.  In homogeneous matrix notation, M
        = A*M where M is the current transformation matrix and A is the
        applied matrix. The default is PreMultiply.
        """
        ...
    
    def PreMultiply(self):
        """
        V.PreMultiply()
        C++: void PreMultiply()
        
        Sets the internal state of the transform to PreMultiply. All
        subsequent operations will occur before those already represented
        in the current transformation.  In homogeneous matrix notation, M
        = M*A where M is the current transformation matrix and A is the
        applied matrix. The default is PreMultiply.
        """
        ...
    
    def Push(self):
        """
        V.Push()
        C++: void Push()
        
        Pushes the current transformation onto the transformation stack.
        """
        ...
    
    def RotateWXYZ(self, p_float, p_float_1, p_float_2, p_float_3):
        """
        V.RotateWXYZ(float, float, float, float)
        C++: void RotateWXYZ(double angle, double x, double y, double z)
        V.RotateWXYZ(float, (float, float, float))
        C++: void RotateWXYZ(double angle, const double axis[3])
        
        Create a rotation matrix and concatenate it with the current
        transformation according to PreMultiply or PostMultiply
        semantics. The angle is in degrees, and (x,y,z) specifies the
        axis that the rotation will be performed around.
        """
        ...
    
    def RotateX(self, p_float):
        """
        V.RotateX(float)
        C++: void RotateX(double angle)
        
        Create a rotation matrix about the X, Y, or Z axis and
        concatenate it with the current transformation according to
        PreMultiply or PostMultiply semantics.  The angle is expressed in
        degrees.
        """
        ...
    
    def RotateY(self, p_float):
        """
        V.RotateY(float)
        C++: void RotateY(double angle)
        
        Create a rotation matrix about the X, Y, or Z axis and
        concatenate it with the current transformation according to
        PreMultiply or PostMultiply semantics.  The angle is expressed in
        degrees.
        """
        ...
    
    def RotateZ(self, p_float):
        """
        V.RotateZ(float)
        C++: void RotateZ(double angle)
        
        Create a rotation matrix about the X, Y, or Z axis and
        concatenate it with the current transformation according to
        PreMultiply or PostMultiply semantics.  The angle is expressed in
        degrees.
        """
        ...
    
    def SafeDownCast(self, vtkObjectBase):
        """
        V.SafeDownCast(vtkObjectBase) -> vtkPerspectiveTransform
        C++: static vtkPerspectiveTransform *SafeDownCast(
            vtkObjectBase *o)
        """
        ...
    
    def Scale(self, p_float, p_float_1, p_float_2):
        """
        V.Scale(float, float, float)
        C++: void Scale(double x, double y, double z)
        V.Scale((float, float, float))
        C++: void Scale(const double s[3])
        
        Create a scale matrix (i.e. set the diagonal elements to x, y, z)
        and concatenate it with the current transformation according to
        PreMultiply or PostMultiply semantics.
        """
        ...
    
    def SetInput(self, vtkHomogeneousTransform):
        """
        V.SetInput(vtkHomogeneousTransform)
        C++: void SetInput(vtkHomogeneousTransform *input)
        
        Set the input for this transformation.  This will be used as the
        base transformation if it is set.  This method allows you to
        build a transform pipeline: if the input is modified, then this
        transformation will automatically update accordingly.  Note that
        the InverseFlag, controlled via Inverse(), determines whether
        this transformation will use the Input or the inverse of the
        Input.
        """
        ...
    
    def SetMatrix(self, vtkMatrix4x4):
        """
        V.SetMatrix(vtkMatrix4x4)
        C++: void SetMatrix(vtkMatrix4x4 *matrix)
        V.SetMatrix((float, float, float, float, float, float, float,
            float, float, float, float, float, float, float, float, float)
            )
        C++: void SetMatrix(const double elements[16])
        
        Set the current matrix directly.  This actually calls Identity(),
        followed by Concatenate(matrix).
        """
        ...
    
    def SetupCamera(self, , , ):
        """
        V.SetupCamera((float, float, float), (float, float, float), (
            float, float, float))
        C++: void SetupCamera(const double position[3],
            const double focalpoint[3], const double viewup[3])
        V.SetupCamera(float, float, float, float, float, float, float,
            float, float)
        C++: void SetupCamera(double p0, double p1, double p2, double fp0,
             double fp1, double fp2, double vup0, double vup1,
            double vup2)
        
        Set a view transformation matrix for the camera (this matrix does
        not contain any perspective) and concatenate it with the current
        transformation.
        """
        ...
    
    def Shear(self, p_float, p_float_1, p_float_2):
        """
        V.Shear(float, float, float)
        C++: void Shear(double dxdz, double dydz, double zplane)
        
        Create a shear transformation about a plane at distance z from
        the camera.  The values dxdz (i.e. dx/dz) and dydz specify the
        amount of shear in the x and y directions.  The 'zplane'
        specifies the distance from the camera to the plane at which the
        shear causes zero displacement.  Generally you want this plane to
        be the focal plane. This transformation can be used in
        combination with Ortho to create an oblique projection.  It can
        also be used in combination with Perspective to provide correct
        stereo views when the eye is at arbitrary but known positions
        relative to the center of a flat viewing screen.
        """
        ...
    
    def Stereo(self, p_float, p_float_1):
        """
        V.Stereo(float, float)
        C++: void Stereo(double angle, double focaldistance)
        
        Create a stereo shear matrix and concatenate it with the current
        transformation.  This can be applied in conjunction with either a
        perspective transformation (via Frustum or Projection) or an
        orthographic projection.  You must specify the distance from the
        camera plane to the focal plane, and the angle between the
        distance vector and the eye.  The angle should be negative for
        the left eye, and positive for the right.  This method works via
        Oblique.
        """
        ...
    
    def Translate(self, p_float, p_float_1, p_float_2):
        """
        V.Translate(float, float, float)
        C++: void Translate(double x, double y, double z)
        V.Translate((float, float, float))
        C++: void Translate(const double x[3])
        
        Create a translation matrix and concatenate it with the current
        transformation according to PreMultiply or PostMultiply
        semantics.
        """
        ...
    
    def __delattr__(self, *args, **kwargs):
        """ Implement delattr(self, name). """
        ...
    
    def __getattribute__(self, *args, **kwargs):
        """ Return getattr(self, name). """
        ...
    
    def __init__(self, *args, **kwargs) -> None:
        ...
    
    @staticmethod
    def __new__(*args, **kwargs):
        """ Create and return a new object.  See help(type) for accurate signature. """
        ...
    
    def __repr__(self, *args, **kwargs):
        """ Return repr(self). """
        ...
    
    def __setattr__(self, *args, **kwargs):
        """ Implement setattr(self, name, value). """
        ...
    
    def __str__(self, *args, **kwargs) -> str:
        """ Return str(self). """
        ...
    
    __this__ = ...
    __dict__ = ...
    __vtkname__ = ...


class vtkSphericalTransform(vtkWarpTransform):
    """
    vtkSphericalTransform - spherical to rectangular coords and back
    
    Superclass: vtkWarpTransform
    
    vtkSphericalTransform will convert (r,phi,theta) coordinates to
    (x,y,z) coordinates and back again.  The angles are given in radians.
    By default, it converts spherical coordinates to rectangular, but
    GetInverse() returns a transform that will do the opposite.  The
    equation that is used is x = r*sin(phi)*cos(theta), y =
    r*sin(phi)*sin(theta), z = r*cos(phi).
    @warning
    This transform is not well behaved along the line x=y=0 (i.e. along
    the z-axis)
    @sa
    vtkCylindricalTransform vtkGeneralTransform
    """
    def GetNumberOfGenerationsFromBase(self, string):
        """
        V.GetNumberOfGenerationsFromBase(string) -> int
        C++: vtkIdType GetNumberOfGenerationsFromBase(const char *type)
            override;
        
        Given a the name of a base class of this class type, return the
        distance of inheritance between this class type and the named
        class (how many generations of inheritance are there between this
        class and the named class). If the named class is not in this
        class's inheritance tree, return a negative value. Valid
        responses will always be nonnegative. This method works in
        combination with vtkTypeMacro found in vtkSetGet.h.
        """
        ...
    
    def GetNumberOfGenerationsFromBaseType(self, string):
        """
        V.GetNumberOfGenerationsFromBaseType(string) -> int
        C++: static vtkIdType GetNumberOfGenerationsFromBaseType(
            const char *type)
        
        Given a the name of a base class of this class type, return the
        distance of inheritance between this class type and the named
        class (how many generations of inheritance are there between this
        class and the named class). If the named class is not in this
        class's inheritance tree, return a negative value. Valid
        responses will always be nonnegative. This method works in
        combination with vtkTypeMacro found in vtkSetGet.h.
        """
        ...
    
    def IsA(self, string):
        """
        V.IsA(string) -> int
        C++: vtkTypeBool IsA(const char *type) override;
        
        Return 1 if this class is the same type of (or a subclass of) the
        named class. Returns 0 otherwise. This method works in
        combination with vtkTypeMacro found in vtkSetGet.h.
        """
        ...
    
    def IsTypeOf(self, string):
        """
        V.IsTypeOf(string) -> int
        C++: static vtkTypeBool IsTypeOf(const char *type)
        
        Return 1 if this class type is the same type of (or a subclass
        of) the named class. Returns 0 otherwise. This method works in
        combination with vtkTypeMacro found in vtkSetGet.h.
        """
        ...
    
    def MakeTransform(self):
        """
        V.MakeTransform() -> vtkAbstractTransform
        C++: vtkAbstractTransform *MakeTransform() override;
        
        Make another transform of the same type.
        """
        ...
    
    def NewInstance(self):
        """
        V.NewInstance() -> vtkSphericalTransform
        C++: vtkSphericalTransform *NewInstance()
        """
        ...
    
    def SafeDownCast(self, vtkObjectBase):
        """
        V.SafeDownCast(vtkObjectBase) -> vtkSphericalTransform
        C++: static vtkSphericalTransform *SafeDownCast(vtkObjectBase *o)
        """
        ...
    
    def __delattr__(self, *args, **kwargs):
        """ Implement delattr(self, name). """
        ...
    
    def __getattribute__(self, *args, **kwargs):
        """ Return getattr(self, name). """
        ...
    
    def __init__(self, *args, **kwargs) -> None:
        ...
    
    @staticmethod
    def __new__(*args, **kwargs):
        """ Create and return a new object.  See help(type) for accurate signature. """
        ...
    
    def __repr__(self, *args, **kwargs):
        """ Return repr(self). """
        ...
    
    def __setattr__(self, *args, **kwargs):
        """ Implement setattr(self, name, value). """
        ...
    
    def __str__(self, *args, **kwargs) -> str:
        """ Return str(self). """
        ...
    
    __this__ = ...
    __dict__ = ...
    __vtkname__ = ...


class vtkThinPlateSplineTransform(vtkWarpTransform):
    """
    vtkThinPlateSplineTransform - a nonlinear warp transformation
    
    Superclass: vtkWarpTransform
    
    vtkThinPlateSplineTransform describes a nonlinear warp transform
    defined by a set of source and target landmarks. Any point on the
    mesh close to a source landmark will be moved to a place close to the
    corresponding target landmark. The points in between are interpolated
    smoothly using Bookstein's Thin Plate Spline algorithm.
    
    To obtain a correct TPS warp, use the R2LogR kernel if your data is
    2D, and the R kernel if your data is 3D. Or you can specify your own
    RBF. (Hence this class is more general than a pure TPS transform.)
    @warning
    1) The inverse transform is calculated using an iterative method,
    and is several times more expensive than the forward transform.
    2) Whenever you add, subtract, or set points you must call Modified()
       on the vtkPoints object, or the transformation might not update.
    3) Collinear point configurations (except those that lie in the XY
       plane) result in an unstable transformation. Forward transform can
    be computed for any configuration by disabling bulk transform
       regularization.
    @sa
    vtkGridTransform vtkGeneralTransform
    """
    def GetBasis(self):
        """
        V.GetBasis() -> int
        C++: virtual int GetBasis()
        
        Specify the radial basis function to use.  The default is R2LogR
        which is appropriate for 2D. Use |R| (SetBasisToR) if your data
        is 3D. Alternatively specify your own basis function, however
        this will mean that the transform will no longer be a true
        thin-plate spline.
        """
        ...
    
    def GetBasisAsString(self):
        """
        V.GetBasisAsString() -> string
        C++: const char *GetBasisAsString()
        
        Specify the radial basis function to use.  The default is R2LogR
        which is appropriate for 2D. Use |R| (SetBasisToR) if your data
        is 3D. Alternatively specify your own basis function, however
        this will mean that the transform will no longer be a true
        thin-plate spline.
        """
        ...
    
    def GetMTime(self):
        """
        V.GetMTime() -> int
        C++: vtkMTimeType GetMTime() override;
        
        Get the MTime.
        """
        ...
    
    def GetNumberOfGenerationsFromBase(self, string):
        """
        V.GetNumberOfGenerationsFromBase(string) -> int
        C++: vtkIdType GetNumberOfGenerationsFromBase(const char *type)
            override;
        
        Given a the name of a base class of this class type, return the
        distance of inheritance between this class type and the named
        class (how many generations of inheritance are there between this
        class and the named class). If the named class is not in this
        class's inheritance tree, return a negative value. Valid
        responses will always be nonnegative. This method works in
        combination with vtkTypeMacro found in vtkSetGet.h.
        """
        ...
    
    def GetNumberOfGenerationsFromBaseType(self, string):
        """
        V.GetNumberOfGenerationsFromBaseType(string) -> int
        C++: static vtkIdType GetNumberOfGenerationsFromBaseType(
            const char *type)
        
        Given a the name of a base class of this class type, return the
        distance of inheritance between this class type and the named
        class (how many generations of inheritance are there between this
        class and the named class). If the named class is not in this
        class's inheritance tree, return a negative value. Valid
        responses will always be nonnegative. This method works in
        combination with vtkTypeMacro found in vtkSetGet.h.
        """
        ...
    
    def GetRegularizeBulkTransform(self):
        """
        V.GetRegularizeBulkTransform() -> bool
        C++: virtual bool GetRegularizeBulkTransform()
        
        Get/set whether the bulk linear transformation matrix is
        regularized.
        
        If regularization is enabled: If all landmark points are on the
        XY plane then forward and inverse transforms are computed
        correctly. For other coplanar configurations, both forward an
        inverse transform computation is unstable.
        
        If regularization is disabled: Forward transform is computed
        correctly for all point configurations. Inverse transform
        computation is unstable if source and/or target points are
        coplanar.
        
        If landmarks points are not coplanar then this setting has no
        effect.
        
        The default is true.
        """
        ...
    
    def GetSigma(self):
        """
        V.GetSigma() -> float
        C++: virtual double GetSigma()
        
        Specify the 'stiffness' of the spline. The default is 1.0.
        """
        ...
    
    def GetSourceLandmarks(self):
        """
        V.GetSourceLandmarks() -> vtkPoints
        C++: virtual vtkPoints *GetSourceLandmarks()
        
        Set the source landmarks for the warp.  If you add or change the
        vtkPoints object, you must call Modified() on it or the
        transformation might not update.
        """
        ...
    
    def GetTargetLandmarks(self):
        """
        V.GetTargetLandmarks() -> vtkPoints
        C++: virtual vtkPoints *GetTargetLandmarks()
        
        Set the target landmarks for the warp.  If you add or change the
        vtkPoints object, you must call Modified() on it or the
        transformation might not update.
        """
        ...
    
    def IsA(self, string):
        """
        V.IsA(string) -> int
        C++: vtkTypeBool IsA(const char *type) override;
        
        Return 1 if this class is the same type of (or a subclass of) the
        named class. Returns 0 otherwise. This method works in
        combination with vtkTypeMacro found in vtkSetGet.h.
        """
        ...
    
    def IsTypeOf(self, string):
        """
        V.IsTypeOf(string) -> int
        C++: static vtkTypeBool IsTypeOf(const char *type)
        
        Return 1 if this class type is the same type of (or a subclass
        of) the named class. Returns 0 otherwise. This method works in
        combination with vtkTypeMacro found in vtkSetGet.h.
        """
        ...
    
    def MakeTransform(self):
        """
        V.MakeTransform() -> vtkAbstractTransform
        C++: vtkAbstractTransform *MakeTransform() override;
        
        Make another transform of the same type.
        """
        ...
    
    def NewInstance(self):
        """
        V.NewInstance() -> vtkThinPlateSplineTransform
        C++: vtkThinPlateSplineTransform *NewInstance()
        """
        ...
    
    def RegularizeBulkTransformOff(self):
        """
        V.RegularizeBulkTransformOff()
        C++: virtual void RegularizeBulkTransformOff()
        
        Get/set whether the bulk linear transformation matrix is
        regularized.
        
        If regularization is enabled: If all landmark points are on the
        XY plane then forward and inverse transforms are computed
        correctly. For other coplanar configurations, both forward an
        inverse transform computation is unstable.
        
        If regularization is disabled: Forward transform is computed
        correctly for all point configurations. Inverse transform
        computation is unstable if source and/or target points are
        coplanar.
        
        If landmarks points are not coplanar then this setting has no
        effect.
        
        The default is true.
        """
        ...
    
    def RegularizeBulkTransformOn(self):
        """
        V.RegularizeBulkTransformOn()
        C++: virtual void RegularizeBulkTransformOn()
        
        Get/set whether the bulk linear transformation matrix is
        regularized.
        
        If regularization is enabled: If all landmark points are on the
        XY plane then forward and inverse transforms are computed
        correctly. For other coplanar configurations, both forward an
        inverse transform computation is unstable.
        
        If regularization is disabled: Forward transform is computed
        correctly for all point configurations. Inverse transform
        computation is unstable if source and/or target points are
        coplanar.
        
        If landmarks points are not coplanar then this setting has no
        effect.
        
        The default is true.
        """
        ...
    
    def SafeDownCast(self, vtkObjectBase):
        """
        V.SafeDownCast(vtkObjectBase) -> vtkThinPlateSplineTransform
        C++: static vtkThinPlateSplineTransform *SafeDownCast(
            vtkObjectBase *o)
        """
        ...
    
    def SetBasis(self, p_int):
        """
        V.SetBasis(int)
        C++: void SetBasis(int basis)
        
        Specify the radial basis function to use.  The default is R2LogR
        which is appropriate for 2D. Use |R| (SetBasisToR) if your data
        is 3D. Alternatively specify your own basis function, however
        this will mean that the transform will no longer be a true
        thin-plate spline.
        """
        ...
    
    def SetBasisToR(self):
        """
        V.SetBasisToR()
        C++: void SetBasisToR()
        
        Specify the radial basis function to use.  The default is R2LogR
        which is appropriate for 2D. Use |R| (SetBasisToR) if your data
        is 3D. Alternatively specify your own basis function, however
        this will mean that the transform will no longer be a true
        thin-plate spline.
        """
        ...
    
    def SetBasisToR2LogR(self):
        """
        V.SetBasisToR2LogR()
        C++: void SetBasisToR2LogR()
        
        Specify the radial basis function to use.  The default is R2LogR
        which is appropriate for 2D. Use |R| (SetBasisToR) if your data
        is 3D. Alternatively specify your own basis function, however
        this will mean that the transform will no longer be a true
        thin-plate spline.
        """
        ...
    
    def SetRegularizeBulkTransform(self, bool):
        """
        V.SetRegularizeBulkTransform(bool)
        C++: virtual void SetRegularizeBulkTransform(bool _arg)
        
        Get/set whether the bulk linear transformation matrix is
        regularized.
        
        If regularization is enabled: If all landmark points are on the
        XY plane then forward and inverse transforms are computed
        correctly. For other coplanar configurations, both forward an
        inverse transform computation is unstable.
        
        If regularization is disabled: Forward transform is computed
        correctly for all point configurations. Inverse transform
        computation is unstable if source and/or target points are
        coplanar.
        
        If landmarks points are not coplanar then this setting has no
        effect.
        
        The default is true.
        """
        ...
    
    def SetSigma(self, p_float):
        """
        V.SetSigma(float)
        C++: virtual void SetSigma(double _arg)
        
        Specify the 'stiffness' of the spline. The default is 1.0.
        """
        ...
    
    def SetSourceLandmarks(self, vtkPoints):
        """
        V.SetSourceLandmarks(vtkPoints)
        C++: void SetSourceLandmarks(vtkPoints *source)
        
        Set the source landmarks for the warp.  If you add or change the
        vtkPoints object, you must call Modified() on it or the
        transformation might not update.
        """
        ...
    
    def SetTargetLandmarks(self, vtkPoints):
        """
        V.SetTargetLandmarks(vtkPoints)
        C++: void SetTargetLandmarks(vtkPoints *target)
        
        Set the target landmarks for the warp.  If you add or change the
        vtkPoints object, you must call Modified() on it or the
        transformation might not update.
        """
        ...
    
    def __delattr__(self, *args, **kwargs):
        """ Implement delattr(self, name). """
        ...
    
    def __getattribute__(self, *args, **kwargs):
        """ Return getattr(self, name). """
        ...
    
    def __init__(self, *args, **kwargs) -> None:
        ...
    
    @staticmethod
    def __new__(*args, **kwargs):
        """ Create and return a new object.  See help(type) for accurate signature. """
        ...
    
    def __repr__(self, *args, **kwargs):
        """ Return repr(self). """
        ...
    
    def __setattr__(self, *args, **kwargs):
        """ Implement setattr(self, name, value). """
        ...
    
    def __str__(self, *args, **kwargs) -> str:
        """ Return str(self). """
        ...
    
    __this__ = ...
    __dict__ = ...
    __vtkname__ = ...


class vtkTransform(vtkLinearTransform):
    """
    vtkTransform - describes linear transformations via a 4x4 matrix
    
    Superclass: vtkLinearTransform
    
    A vtkTransform can be used to describe the full range of linear (also
    known as affine) coordinate transformations in three dimensions,
    which are internally represented as a 4x4 homogeneous transformation
    matrix.  When you create a new vtkTransform, it is always initialized
    to the identity transformation.
    
    The SetInput() method allows you to set another transform, instead of
    the identity transform, to be the base transformation. There is a
    pipeline mechanism to ensure that when the input is modified, the
    current transformation will be updated accordingly. This pipeline
    mechanism is also supported by the Concatenate() method.
    
    Most of the methods for manipulating this transformation, e.g.
    Translate, Rotate, and Concatenate, can operate in either PreMultiply
    (the default) or PostMultiply mode.  In PreMultiply mode, the
    translation, concatenation, etc. will occur before any
    transformations which are represented by the current matrix.  In
    PostMultiply mode, the additional transformation will occur after any
    transformations represented by the current matrix.
    
    This class performs all of its operations in a right handed
    coordinate system with right handed rotations. Some other graphics
    libraries use left handed coordinate systems and rotations.
    @sa
    vtkPerspectiveTransform vtkGeneralTransform vtkMatrix4x4
    vtkTransformCollection vtkTransformFilter vtkTransformPolyDataFilter
    vtkImageReslice
    """
    def CircuitCheck(self, vtkAbstractTransform):
        """
        V.CircuitCheck(vtkAbstractTransform) -> int
        C++: int CircuitCheck(vtkAbstractTransform *transform) override;
        
        Check for self-reference.  Will return true if concatenating with
        the specified transform, setting it to be our inverse, or setting
        it to be our input will create a circular reference. CircuitCheck
        is automatically called by SetInput(), SetInverse(), and
        Concatenate(vtkXTransform *).  Avoid using this function, it is
        experimental.
        """
        ...
    
    def Concatenate(self, vtkMatrix4x4):
        """
        V.Concatenate(vtkMatrix4x4)
        C++: void Concatenate(vtkMatrix4x4 *matrix)
        V.Concatenate((float, float, float, float, float, float, float,
            float, float, float, float, float, float, float, float, float)
            )
        C++: void Concatenate(const double elements[16])
        V.Concatenate(vtkLinearTransform)
        C++: void Concatenate(vtkLinearTransform *transform)
        
        Concatenates the matrix with the current transformation according
        to PreMultiply or PostMultiply semantics.
        """
        ...
    
    def GetConcatenatedTransform(self, p_int):
        """
        V.GetConcatenatedTransform(int) -> vtkLinearTransform
        C++: vtkLinearTransform *GetConcatenatedTransform(int i)
        
        Get one of the concatenated transformations as a
        vtkAbstractTransform. These transformations are applied, in
        series, every time the transformation of a coordinate occurs. 
        This method is provided to make it possible to decompose a
        transformation into its constituents, for example to save a
        transformation to a file.
        """
        ...
    
    def GetInput(self):
        """
        V.GetInput() -> vtkLinearTransform
        C++: vtkLinearTransform *GetInput()
        
        Set the input for this transformation.  This will be used as the
        base transformation if it is set.  This method allows you to
        build a transform pipeline: if the input is modified, then this
        transformation will automatically update accordingly.  Note that
        the InverseFlag, controlled via Inverse(), determines whether
        this transformation will use the Input or the inverse of the
        Input.
        """
        ...
    
    def GetInverse(self, vtkMatrix4x4):
        """
        V.GetInverse(vtkMatrix4x4)
        C++: void GetInverse(vtkMatrix4x4 *inverse)
        V.GetInverse() -> vtkAbstractTransform
        C++: vtkAbstractTransform *GetInverse()
        
        Return a matrix which is the inverse of the current
        transformation matrix.
        """
        ...
    
    def GetInverseFlag(self):
        """
        V.GetInverseFlag() -> int
        C++: int GetInverseFlag()
        
        Get the inverse flag of the transformation.  This controls
        whether it is the Input or the inverse of the Input that is used
        as the base transformation.  The InverseFlag is flipped every
        time Inverse() is called.  The InverseFlag is off when a
        transform is first created.
        """
        ...
    
    def GetMTime(self):
        """
        V.GetMTime() -> int
        C++: vtkMTimeType GetMTime() override;
        
        Override GetMTime to account for input and concatenation.
        """
        ...
    
    def GetNumberOfConcatenatedTransforms(self):
        """
        V.GetNumberOfConcatenatedTransforms() -> int
        C++: int GetNumberOfConcatenatedTransforms()
        
        Get the total number of transformations that are linked into this
        one via Concatenate() operations or via SetInput().
        """
        ...
    
    def GetNumberOfGenerationsFromBase(self, string):
        """
        V.GetNumberOfGenerationsFromBase(string) -> int
        C++: vtkIdType GetNumberOfGenerationsFromBase(const char *type)
            override;
        
        Given a the name of a base class of this class type, return the
        distance of inheritance between this class type and the named
        class (how many generations of inheritance are there between this
        class and the named class). If the named class is not in this
        class's inheritance tree, return a negative value. Valid
        responses will always be nonnegative. This method works in
        combination with vtkTypeMacro found in vtkSetGet.h.
        """
        ...
    
    def GetNumberOfGenerationsFromBaseType(self, string):
        """
        V.GetNumberOfGenerationsFromBaseType(string) -> int
        C++: static vtkIdType GetNumberOfGenerationsFromBaseType(
            const char *type)
        
        Given a the name of a base class of this class type, return the
        distance of inheritance between this class type and the named
        class (how many generations of inheritance are there between this
        class and the named class). If the named class is not in this
        class's inheritance tree, return a negative value. Valid
        responses will always be nonnegative. This method works in
        combination with vtkTypeMacro found in vtkSetGet.h.
        """
        ...
    
    def GetOrientation(self, p_float=..., p_float=..., p_float=...):
        """
        V.GetOrientation([float, float, float])
        C++: void GetOrientation(double orient[3])
        V.GetOrientation() -> (float, float, float)
        C++: double *GetOrientation()
        V.GetOrientation([float, float, float], vtkMatrix4x4)
        C++: static void GetOrientation(double orient[3],
            vtkMatrix4x4 *matrix)
        
        Get the x, y, z orientation angles from the transformation matrix
        as an array of three floating point values.
        """
        ...
    
    def GetOrientationWXYZ(self, p_float=..., p_float=..., p_float=..., p_float=...):
        """
        V.GetOrientationWXYZ([float, float, float, float])
        C++: void GetOrientationWXYZ(double wxyz[4])
        V.GetOrientationWXYZ() -> (float, float, float, float)
        C++: double *GetOrientationWXYZ()
        
        Return the wxyz angle+axis representing the current orientation.
        The angle is in degrees and the axis is a unit vector.
        """
        ...
    
    def GetPosition(self, p_float=..., p_float=..., p_float=...):
        """
        V.GetPosition([float, float, float])
        C++: void GetPosition(double pos[3])
        V.GetPosition() -> (float, float, float)
        C++: double *GetPosition()
        
        Return the position from the current transformation matrix as an
        array of three floating point numbers. This is simply returning
        the translation component of the 4x4 matrix.
        """
        ...
    
    def GetScale(self, p_float=..., p_float=..., p_float=...):
        """
        V.GetScale([float, float, float])
        C++: void GetScale(double scale[3])
        V.GetScale() -> (float, float, float)
        C++: double *GetScale()
        
        Return the scale factors of the current transformation matrix as
        an array of three float numbers.  These scale factors are not
        necessarily about the x, y, and z axes unless unless the scale
        transformation was applied before any rotations.
        """
        ...
    
    def GetTranspose(self, vtkMatrix4x4):
        """
        V.GetTranspose(vtkMatrix4x4)
        C++: void GetTranspose(vtkMatrix4x4 *transpose)
        
        Return a matrix which is the transpose of the current
        transformation matrix.  This is equivalent to the inverse if and
        only if the transformation is a pure rotation with no translation
        or scale.
        """
        ...
    
    def Identity(self):
        """
        V.Identity()
        C++: void Identity()
        
        Set the transformation to the identity transformation.  If the
        transform has an Input, then the transformation will be reset so
        that it is the same as the Input.
        """
        ...
    
    def Inverse(self):
        """
        V.Inverse()
        C++: void Inverse() override;
        
        Invert the transformation.  This will also set a flag so that the
        transformation will use the inverse of its Input, if an Input has
        been set.
        """
        ...
    
    def IsA(self, string):
        """
        V.IsA(string) -> int
        C++: vtkTypeBool IsA(const char *type) override;
        
        Return 1 if this class is the same type of (or a subclass of) the
        named class. Returns 0 otherwise. This method works in
        combination with vtkTypeMacro found in vtkSetGet.h.
        """
        ...
    
    def IsTypeOf(self, string):
        """
        V.IsTypeOf(string) -> int
        C++: static vtkTypeBool IsTypeOf(const char *type)
        
        Return 1 if this class type is the same type of (or a subclass
        of) the named class. Returns 0 otherwise. This method works in
        combination with vtkTypeMacro found in vtkSetGet.h.
        """
        ...
    
    def MakeTransform(self):
        """
        V.MakeTransform() -> vtkAbstractTransform
        C++: vtkAbstractTransform *MakeTransform() override;
        
        Make a new transform of the same type.
        """
        ...
    
    def MultiplyPoint(self, , p_float=..., p_float=..., p_float=..., p_float=...):
        """
        V.MultiplyPoint((float, float, float, float), [float, float,
            float, float])
        C++: void MultiplyPoint(const double in[4], double out[4])
        
        Use this method only if you wish to compute the transformation in
        homogeneous (x,y,z,w) coordinates, otherwise use
        TransformPoint(). This method calls
        this->GetMatrix()->MultiplyPoint().
        """
        ...
    
    def NewInstance(self):
        """
        V.NewInstance() -> vtkTransform
        C++: vtkTransform *NewInstance()
        """
        ...
    
    def Pop(self):
        """
        V.Pop()
        C++: void Pop()
        
        Deletes the transformation on the top of the stack and sets the
        top to the next transformation on the stack.
        """
        ...
    
    def PostMultiply(self):
        """
        V.PostMultiply()
        C++: void PostMultiply()
        
        Sets the internal state of the transform to PostMultiply. All
        subsequent operations will occur after those already represented
        in the current transformation.  In homogeneous matrix notation, M
        = A*M where M is the current transformation matrix and A is the
        applied matrix. The default is PreMultiply.
        """
        ...
    
    def PreMultiply(self):
        """
        V.PreMultiply()
        C++: void PreMultiply()
        
        Sets the internal state of the transform to PreMultiply. All
        subsequent operations will occur before those already represented
        in the current transformation.  In homogeneous matrix notation, M
        = M*A where M is the current transformation matrix and A is the
        applied matrix. The default is PreMultiply.
        """
        ...
    
    def Push(self):
        """
        V.Push()
        C++: void Push()
        
        Pushes the current transformation onto the transformation stack.
        """
        ...
    
    def RotateWXYZ(self, p_float, p_float_1, p_float_2, p_float_3):
        """
        V.RotateWXYZ(float, float, float, float)
        C++: void RotateWXYZ(double angle, double x, double y, double z)
        V.RotateWXYZ(float, (float, float, float))
        C++: void RotateWXYZ(double angle, const double axis[3])
        
        Create a rotation matrix and concatenate it with the current
        transformation according to PreMultiply or PostMultiply
        semantics. The angle is in degrees, and (x,y,z) specifies the
        axis that the rotation will be performed around.
        """
        ...
    
    def RotateX(self, p_float):
        """
        V.RotateX(float)
        C++: void RotateX(double angle)
        
        Create a rotation matrix about the X, Y, or Z axis and
        concatenate it with the current transformation according to
        PreMultiply or PostMultiply semantics.  The angle is expressed in
        degrees.
        """
        ...
    
    def RotateY(self, p_float):
        """
        V.RotateY(float)
        C++: void RotateY(double angle)
        
        Create a rotation matrix about the X, Y, or Z axis and
        concatenate it with the current transformation according to
        PreMultiply or PostMultiply semantics.  The angle is expressed in
        degrees.
        """
        ...
    
    def RotateZ(self, p_float):
        """
        V.RotateZ(float)
        C++: void RotateZ(double angle)
        
        Create a rotation matrix about the X, Y, or Z axis and
        concatenate it with the current transformation according to
        PreMultiply or PostMultiply semantics.  The angle is expressed in
        degrees.
        """
        ...
    
    def SafeDownCast(self, vtkObjectBase):
        """
        V.SafeDownCast(vtkObjectBase) -> vtkTransform
        C++: static vtkTransform *SafeDownCast(vtkObjectBase *o)
        """
        ...
    
    def Scale(self, p_float, p_float_1, p_float_2):
        """
        V.Scale(float, float, float)
        C++: void Scale(double x, double y, double z)
        V.Scale((float, float, float))
        C++: void Scale(const double s[3])
        
        Create a scale matrix (i.e. set the diagonal elements to x, y, z)
        and concatenate it with the current transformation according to
        PreMultiply or PostMultiply semantics.
        """
        ...
    
    def SetInput(self, vtkLinearTransform):
        """
        V.SetInput(vtkLinearTransform)
        C++: void SetInput(vtkLinearTransform *input)
        
        Set the input for this transformation.  This will be used as the
        base transformation if it is set.  This method allows you to
        build a transform pipeline: if the input is modified, then this
        transformation will automatically update accordingly.  Note that
        the InverseFlag, controlled via Inverse(), determines whether
        this transformation will use the Input or the inverse of the
        Input.
        """
        ...
    
    def SetMatrix(self, vtkMatrix4x4):
        """
        V.SetMatrix(vtkMatrix4x4)
        C++: void SetMatrix(vtkMatrix4x4 *matrix)
        V.SetMatrix((float, float, float, float, float, float, float,
            float, float, float, float, float, float, float, float, float)
            )
        C++: void SetMatrix(const double elements[16])
        
        Set the current matrix directly. Note: First, the current matrix
        is set to the identity, then the input matrix is concatenated.
        """
        ...
    
    def Translate(self, p_float, p_float_1, p_float_2):
        """
        V.Translate(float, float, float)
        C++: void Translate(double x, double y, double z)
        V.Translate((float, float, float))
        C++: void Translate(const double x[3])
        
        Create a translation matrix and concatenate it with the current
        transformation according to PreMultiply or PostMultiply
        semantics.
        """
        ...
    
    def __delattr__(self, *args, **kwargs):
        """ Implement delattr(self, name). """
        ...
    
    def __getattribute__(self, *args, **kwargs):
        """ Return getattr(self, name). """
        ...
    
    def __init__(self, *args, **kwargs) -> None:
        ...
    
    @staticmethod
    def __new__(*args, **kwargs):
        """ Create and return a new object.  See help(type) for accurate signature. """
        ...
    
    def __repr__(self, *args, **kwargs):
        """ Return repr(self). """
        ...
    
    def __setattr__(self, *args, **kwargs):
        """ Implement setattr(self, name, value). """
        ...
    
    def __str__(self, *args, **kwargs) -> str:
        """ Return str(self). """
        ...
    
    __this__ = ...
    __dict__ = ...
    __vtkname__ = ...


class vtkTransform2D(__vtkmodules_vtkCommonCore.vtkObject):
    """
    vtkTransform2D - describes linear transformations via a 3x3 matrix
    
    Superclass: vtkObject
    
    A vtkTransform2D can be used to describe the full range of linear
    (also known as affine) coordinate transformations in two dimensions,
    which are internally represented as a 3x3 homogeneous transformation
    matrix.  When you create a new vtkTransform2D, it is always
    initialized to the identity transformation.
    
    All multiplicitive operations (Translate, Rotate, Scale, etc) are
    post-multiplied in this class (i.e. add them in the reverse of the
    order that they should be applied).
    
    This class performs all of its operations in a right handed
    coordinate system with right handed rotations. Some other graphics
    libraries use left handed coordinate systems and rotations.
    """
    def GetInverse(self, vtkMatrix3x3):
        """
        V.GetInverse(vtkMatrix3x3)
        C++: void GetInverse(vtkMatrix3x3 *inverse)
        
        Return a matrix which is the inverse of the current
        transformation matrix.
        """
        ...
    
    def GetMatrix(self):
        """
        V.GetMatrix() -> vtkMatrix3x3
        C++: virtual vtkMatrix3x3 *GetMatrix()
        V.GetMatrix(vtkMatrix3x3)
        C++: void GetMatrix(vtkMatrix3x3 *matrix)
        
        Get the underlying 3x3 matrix.
        """
        ...
    
    def GetMTime(self):
        """
        V.GetMTime() -> int
        C++: vtkMTimeType GetMTime() override;
        
        Override GetMTime to account for input and concatenation.
        """
        ...
    
    def GetNumberOfGenerationsFromBase(self, string):
        """
        V.GetNumberOfGenerationsFromBase(string) -> int
        C++: vtkIdType GetNumberOfGenerationsFromBase(const char *type)
            override;
        
        Given a the name of a base class of this class type, return the
        distance of inheritance between this class type and the named
        class (how many generations of inheritance are there between this
        class and the named class). If the named class is not in this
        class's inheritance tree, return a negative value. Valid
        responses will always be nonnegative. This method works in
        combination with vtkTypeMacro found in vtkSetGet.h.
        """
        ...
    
    def GetNumberOfGenerationsFromBaseType(self, string):
        """
        V.GetNumberOfGenerationsFromBaseType(string) -> int
        C++: static vtkIdType GetNumberOfGenerationsFromBaseType(
            const char *type)
        
        Given a the name of a base class of this class type, return the
        distance of inheritance between this class type and the named
        class (how many generations of inheritance are there between this
        class and the named class). If the named class is not in this
        class's inheritance tree, return a negative value. Valid
        responses will always be nonnegative. This method works in
        combination with vtkTypeMacro found in vtkSetGet.h.
        """
        ...
    
    def GetPosition(self, p_float=..., p_float=...):
        """
        V.GetPosition([float, float])
        C++: void GetPosition(double pos[2])
        
        Return the position from the current transformation matrix as an
        array of two floating point numbers. This is simply returning the
        translation component of the 3x3 matrix.
        """
        ...
    
    def GetScale(self, p_float=..., p_float=...):
        """
        V.GetScale([float, float])
        C++: void GetScale(double pos[2])
        
        Return the x and y scale from the current transformation matrix
        as an array of two floating point numbers. This is simply
        returning the scale component of the 3x3 matrix.
        """
        ...
    
    def GetTranspose(self, vtkMatrix3x3):
        """
        V.GetTranspose(vtkMatrix3x3)
        C++: void GetTranspose(vtkMatrix3x3 *transpose)
        
        Return a matrix which is the transpose of the current
        transformation matrix.  This is equivalent to the inverse if and
        only if the transformation is a pure rotation with no translation
        or scale.
        """
        ...
    
    def Identity(self):
        """
        V.Identity()
        C++: void Identity()
        
        Set the transformation to the identity transformation.
        """
        ...
    
    def Inverse(self):
        """
        V.Inverse()
        C++: void Inverse()
        
        Invert the transformation.
        """
        ...
    
    def InverseTransformPoints(self, float_tuple, *float, **kwargs):
        """
        V.InverseTransformPoints((float, ...), [float, ...], int)
        C++: void InverseTransformPoints(const double *inPts,
            double *outPts, int n)
        V.InverseTransformPoints(vtkPoints2D, vtkPoints2D)
        C++: void InverseTransformPoints(vtkPoints2D *inPts,
            vtkPoints2D *outPts)
        
        Apply the transformation to a series of points, and append the
        results to outPts. Where n is the number of points, and the float
        pointers are of length 2*n.
        """
        ...
    
    def IsA(self, string):
        """
        V.IsA(string) -> int
        C++: vtkTypeBool IsA(const char *type) override;
        
        Return 1 if this class is the same type of (or a subclass of) the
        named class. Returns 0 otherwise. This method works in
        combination with vtkTypeMacro found in vtkSetGet.h.
        """
        ...
    
    def IsTypeOf(self, string):
        """
        V.IsTypeOf(string) -> int
        C++: static vtkTypeBool IsTypeOf(const char *type)
        
        Return 1 if this class type is the same type of (or a subclass
        of) the named class. Returns 0 otherwise. This method works in
        combination with vtkTypeMacro found in vtkSetGet.h.
        """
        ...
    
    def MultiplyPoint(self, , p_float=..., p_float=..., p_float=...):
        """
        V.MultiplyPoint((float, float, float), [float, float, float])
        C++: void MultiplyPoint(const double in[3], double out[3])
        
        Use this method only if you wish to compute the transformation in
        homogeneous (x,y,w) coordinates, otherwise use TransformPoint().
        This method calls this->GetMatrix()->MultiplyPoint().
        """
        ...
    
    def NewInstance(self):
        """
        V.NewInstance() -> vtkTransform2D
        C++: vtkTransform2D *NewInstance()
        """
        ...
    
    def Rotate(self, p_float):
        """
        V.Rotate(float)
        C++: void Rotate(double angle)
        
        Create a rotation matrix and concatenate it with the current
        transformation. The angle is in degrees.
        """
        ...
    
    def SafeDownCast(self, vtkObjectBase):
        """
        V.SafeDownCast(vtkObjectBase) -> vtkTransform2D
        C++: static vtkTransform2D *SafeDownCast(vtkObjectBase *o)
        """
        ...
    
    def Scale(self, p_float, p_float_1):
        """
        V.Scale(float, float)
        C++: void Scale(double x, double y)
        V.Scale((float, float))
        C++: void Scale(const double s[2])
        
        Create a scale matrix (i.e. set the diagonal elements to x, y)
        and concatenate it with the current transformation.
        """
        ...
    
    def SetMatrix(self, vtkMatrix3x3):
        """
        V.SetMatrix(vtkMatrix3x3)
        C++: void SetMatrix(vtkMatrix3x3 *matrix)
        V.SetMatrix((float, float, float, float, float, float, float,
            float, float))
        C++: void SetMatrix(const double elements[9])
        
        Set the current matrix directly.
        """
        ...
    
    def TransformPoints(self, float_tuple, *float, **kwargs):
        """
        V.TransformPoints((float, ...), [float, ...], int)
        C++: void TransformPoints(const double *inPts, double *outPts,
            int n)
        V.TransformPoints(vtkPoints2D, vtkPoints2D)
        C++: void TransformPoints(vtkPoints2D *inPts, vtkPoints2D *outPts)
        
        Apply the transformation to a series of points, and append the
        results to outPts. Where n is the number of points, and the float
        pointers are of length 2*n.
        """
        ...
    
    def Translate(self, p_float, p_float_1):
        """
        V.Translate(float, float)
        C++: void Translate(double x, double y)
        V.Translate((float, float))
        C++: void Translate(const double x[2])
        
        Create a translation matrix and concatenate it with the current
        transformation.
        """
        ...
    
    def __delattr__(self, *args, **kwargs):
        """ Implement delattr(self, name). """
        ...
    
    def __getattribute__(self, *args, **kwargs):
        """ Return getattr(self, name). """
        ...
    
    def __init__(self, *args, **kwargs) -> None:
        ...
    
    @staticmethod
    def __new__(*args, **kwargs):
        """ Create and return a new object.  See help(type) for accurate signature. """
        ...
    
    def __repr__(self, *args, **kwargs):
        """ Return repr(self). """
        ...
    
    def __setattr__(self, *args, **kwargs):
        """ Implement setattr(self, name, value). """
        ...
    
    def __str__(self, *args, **kwargs) -> str:
        """ Return str(self). """
        ...
    
    __this__ = ...
    __dict__ = ...
    __vtkname__ = ...


class vtkTransformCollection(__vtkmodules_vtkCommonCore.vtkCollection):
    """
    vtkTransformCollection - maintain a list of transforms
    
    Superclass: vtkCollection
    
    vtkTransformCollection is an object that creates and manipulates
    lists of objects of type vtkTransform.
    
    @sa
    vtkCollection vtkTransform
    """
    def AddItem(self, vtkTransform):
        """
        V.AddItem(vtkTransform)
        C++: void AddItem(vtkTransform *)
        
        Add a Transform to the list.
        """
        ...
    
    def GetNextItem(self):
        """
        V.GetNextItem() -> vtkTransform
        C++: vtkTransform *GetNextItem()
        
        Get the next Transform in the list. Return nullptr when the end
        of the list is reached.
        """
        ...
    
    def GetNumberOfGenerationsFromBase(self, string):
        """
        V.GetNumberOfGenerationsFromBase(string) -> int
        C++: vtkIdType GetNumberOfGenerationsFromBase(const char *type)
            override;
        
        Given a the name of a base class of this class type, return the
        distance of inheritance between this class type and the named
        class (how many generations of inheritance are there between this
        class and the named class). If the named class is not in this
        class's inheritance tree, return a negative value. Valid
        responses will always be nonnegative. This method works in
        combination with vtkTypeMacro found in vtkSetGet.h.
        """
        ...
    
    def GetNumberOfGenerationsFromBaseType(self, string):
        """
        V.GetNumberOfGenerationsFromBaseType(string) -> int
        C++: static vtkIdType GetNumberOfGenerationsFromBaseType(
            const char *type)
        
        Given a the name of a base class of this class type, return the
        distance of inheritance between this class type and the named
        class (how many generations of inheritance are there between this
        class and the named class). If the named class is not in this
        class's inheritance tree, return a negative value. Valid
        responses will always be nonnegative. This method works in
        combination with vtkTypeMacro found in vtkSetGet.h.
        """
        ...
    
    def IsA(self, string):
        """
        V.IsA(string) -> int
        C++: vtkTypeBool IsA(const char *type) override;
        
        Return 1 if this class is the same type of (or a subclass of) the
        named class. Returns 0 otherwise. This method works in
        combination with vtkTypeMacro found in vtkSetGet.h.
        """
        ...
    
    def IsTypeOf(self, string):
        """
        V.IsTypeOf(string) -> int
        C++: static vtkTypeBool IsTypeOf(const char *type)
        
        Return 1 if this class type is the same type of (or a subclass
        of) the named class. Returns 0 otherwise. This method works in
        combination with vtkTypeMacro found in vtkSetGet.h.
        """
        ...
    
    def NewInstance(self):
        """
        V.NewInstance() -> vtkTransformCollection
        C++: vtkTransformCollection *NewInstance()
        """
        ...
    
    def SafeDownCast(self, vtkObjectBase):
        """
        V.SafeDownCast(vtkObjectBase) -> vtkTransformCollection
        C++: static vtkTransformCollection *SafeDownCast(vtkObjectBase *o)
        """
        ...
    
    def __delattr__(self, *args, **kwargs):
        """ Implement delattr(self, name). """
        ...
    
    def __getattribute__(self, *args, **kwargs):
        """ Return getattr(self, name). """
        ...
    
    def __init__(self, *args, **kwargs) -> None:
        ...
    
    @staticmethod
    def __new__(*args, **kwargs):
        """ Create and return a new object.  See help(type) for accurate signature. """
        ...
    
    def __repr__(self, *args, **kwargs):
        """ Return repr(self). """
        ...
    
    def __setattr__(self, *args, **kwargs):
        """ Implement setattr(self, name, value). """
        ...
    
    def __str__(self, *args, **kwargs) -> str:
        """ Return str(self). """
        ...
    
    __this__ = ...
    __dict__ = ...
    __vtkname__ = ...


class vtkTransformConcatenation(object):
    """ vtkTransformConcatenation - no description provided. """
    def Concatenate(self, vtkAbstractTransform):
        """
        V.Concatenate(vtkAbstractTransform)
        C++: void Concatenate(vtkAbstractTransform *transform)
        V.Concatenate((float, float, float, float, float, float, float,
            float, float, float, float, float, float, float, float, float)
            )
        C++: void Concatenate(const double elements[16])
        
        add a transform to the list according to Pre/PostMultiply
        semantics
        """
        ...
    
    def GetInverseFlag(self):
        """
        V.GetInverseFlag() -> int
        C++: int GetInverseFlag()
        
        get the inverse flag
        """
        ...
    
    def GetMaxMTime(self):
        """
        V.GetMaxMTime() -> int
        C++: vtkMTimeType GetMaxMTime()
        
        get maximum MTime of all transforms
        """
        ...
    
    def GetNumberOfPostTransforms(self):
        """
        V.GetNumberOfPostTransforms() -> int
        C++: int GetNumberOfPostTransforms()
        
        the number of transforms that were post-concatenated.
        """
        ...
    
    def GetNumberOfPreTransforms(self):
        """
        V.GetNumberOfPreTransforms() -> int
        C++: int GetNumberOfPreTransforms()
        
        the number of transforms that were pre-concatenated (note that
        whenever Inverse() is called, the pre-concatenated and
        post-concatenated transforms are switched)
        """
        ...
    
    def GetNumberOfTransforms(self):
        """
        V.GetNumberOfTransforms() -> int
        C++: int GetNumberOfTransforms()
        
        the number of stored transforms
        """
        ...
    
    def GetPreMultiplyFlag(self):
        """
        V.GetPreMultiplyFlag() -> int
        C++: int GetPreMultiplyFlag()
        
        set/get the PreMultiply flag
        """
        ...
    
    def GetTransform(self, p_int):
        """
        V.GetTransform(int) -> vtkAbstractTransform
        C++: vtkAbstractTransform *GetTransform(int i)
        
        get one of the transforms
        """
        ...
    
    def Identity(self):
        """
        V.Identity()
        C++: void Identity()
        
        identity simply clears the transform list
        """
        ...
    
    def Inverse(self):
        """
        V.Inverse()
        C++: void Inverse()
        
        invert the concatenation
        """
        ...
    
    def Rotate(self, p_float, p_float_1, p_float_2, p_float_3):
        """
        V.Rotate(float, float, float, float)
        C++: void Rotate(double angle, double x, double y, double z)
        
        the three basic linear transformations
        """
        ...
    
    def Scale(self, p_float, p_float_1, p_float_2):
        """
        V.Scale(float, float, float)
        C++: void Scale(double x, double y, double z)
        
        the three basic linear transformations
        """
        ...
    
    def SetPreMultiplyFlag(self, p_int):
        """
        V.SetPreMultiplyFlag(int)
        C++: void SetPreMultiplyFlag(int flag)
        
        set/get the PreMultiply flag
        """
        ...
    
    def Translate(self, p_float, p_float_1, p_float_2):
        """
        V.Translate(float, float, float)
        C++: void Translate(double x, double y, double z)
        
        the three basic linear transformations
        """
        ...
    
    def __getattribute__(self, *args, **kwargs):
        """ Return getattr(self, name). """
        ...
    
    def __hash__(self, *args, **kwargs) -> int:
        """ Return hash(self). """
        ...
    
    def __init__(self, *args, **kwargs) -> None:
        ...
    
    @staticmethod
    def __new__(*args, **kwargs):
        """ Create and return a new object.  See help(type) for accurate signature. """
        ...
    
    def __repr__(self, *args, **kwargs):
        """ Return repr(self). """
        ...
    


class vtkTransformConcatenationStack(object):
    """ vtkTransformConcatenationStack - no description provided. """
    def __getattribute__(self, *args, **kwargs):
        """ Return getattr(self, name). """
        ...
    
    def __hash__(self, *args, **kwargs) -> int:
        """ Return hash(self). """
        ...
    
    def __init__(self, *args, **kwargs) -> None:
        ...
    
    @staticmethod
    def __new__(*args, **kwargs):
        """ Create and return a new object.  See help(type) for accurate signature. """
        ...
    
    def __repr__(self, *args, **kwargs):
        """ Return repr(self). """
        ...
    


class vtkTransformPair(object):
    """
    vtkTransformPair - no description provided.
    
    vtkTransformPair()
    vtkTransformPair(const &vtkTransformPair)
    """
    def SwapForwardInverse(self):
        """
        V.SwapForwardInverse()
        C++: void SwapForwardInverse()
        """
        ...
    
    def __getattribute__(self, *args, **kwargs):
        """ Return getattr(self, name). """
        ...
    
    def __hash__(self, *args, **kwargs) -> int:
        """ Return hash(self). """
        ...
    
    def __init__(self) -> None:
        ...
    
    @staticmethod
    def __new__(*args, **kwargs):
        """ Create and return a new object.  See help(type) for accurate signature. """
        ...
    
    def __repr__(self, *args, **kwargs):
        """ Return repr(self). """
        ...
    


__loader__ = ...
__spec__ = ...
