"""
This type stub file was generated by pyright.
"""

import vtkmodules.vtkCommonExecutionModel as __vtkmodules_vtkCommonExecutionModel

class vtkVolumeRayCastSpaceLeapingImageFilter(__vtkmodules_vtkCommonExecutionModel.vtkThreadedImageAlgorithm):
    """
    vtkVolumeRayCastSpaceLeapingImageFilter - Builds the space leaping
    data structure.
    
    Superclass: vtkThreadedImageAlgorithm
    
    This is an optimized multi-threaded imaging filter that builds the
    space leaping datastructure, used by
    vtkFixedPointVolumeRayCastMapper. Empty space leaping is used to skip
    large empty regions in the scalar opacity and/or the gradient opacity
    transfer functions. Depending on the various options set by
    vtkFixedPointVolumeRayCastMapper, the class will internally invoke
    one of the many optimized routines to compute the
    min/max/gradient-max values within a fixed block size, trying to
    compute everything in a single multi-threaded pass through the data
    
    The block size may be changed at compile time. Its ifdef'ed to 4 in
    the CXX file.
    """
    def ComputeGradientOpacityOff(self):
        """
        V.ComputeGradientOpacityOff()
        C++: virtual void ComputeGradientOpacityOff()
        
        Compute gradient opacity ?
        """
        ...
    
    def ComputeGradientOpacityOn(self):
        """
        V.ComputeGradientOpacityOn()
        C++: virtual void ComputeGradientOpacityOn()
        
        Compute gradient opacity ?
        """
        ...
    
    def ComputeInputExtentsForOutput(self, p_int=..., p_int=..., p_int=..., p_int=..., p_int=..., p_int=..., *args, **kwargs):
        """
        V.ComputeInputExtentsForOutput([int, int, int, int, int, int],
            [int, int, int], [int, int, int, int, int, int], vtkImageData)
        C++: static void ComputeInputExtentsForOutput(int inExt[6],
            int inDim[3], int outExt[6], vtkImageData *inData)
        
        Compute the extents and dimensions of the input that's required
        to generate an output min-max structure given by outExt. INTERNAL
        - Do not use
        """
        ...
    
    def ComputeMinMaxOff(self):
        """
        V.ComputeMinMaxOff()
        C++: virtual void ComputeMinMaxOff()
        
        Compute the min max structure ?.
        """
        ...
    
    def ComputeMinMaxOn(self):
        """
        V.ComputeMinMaxOn()
        C++: virtual void ComputeMinMaxOn()
        
        Compute the min max structure ?.
        """
        ...
    
    def ComputeOffset(self, , , p_int_12):
        """
        V.ComputeOffset((int, int, int, int, int, int), (int, int, int,
            int, int, int), int) -> int
        C++: vtkIdType ComputeOffset(const int ext[6],
            const int wholeExt[6], int nComponents)
        
        INTERNAL - Do not use Compute the offset within an image of whole
        extents wholeExt, to access the data starting at extents ext.
        """
        ...
    
    def GetComputeGradientOpacity(self):
        """
        V.GetComputeGradientOpacity() -> int
        C++: virtual vtkTypeBool GetComputeGradientOpacity()
        
        Compute gradient opacity ?
        """
        ...
    
    def GetComputeMinMax(self):
        """
        V.GetComputeMinMax() -> int
        C++: virtual vtkTypeBool GetComputeMinMax()
        
        Compute the min max structure ?.
        """
        ...
    
    def GetCurrentScalars(self):
        """
        V.GetCurrentScalars() -> vtkDataArray
        C++: virtual vtkDataArray *GetCurrentScalars()
        
        Set the scalars.
        """
        ...
    
    def GetIndependentComponents(self):
        """
        V.GetIndependentComponents() -> int
        C++: virtual int GetIndependentComponents()
        
        Do we use independent components, or dependent components ?
        """
        ...
    
    def GetLastMinMaxBuildTime(self):
        """
        V.GetLastMinMaxBuildTime() -> int
        C++: vtkMTimeType GetLastMinMaxBuildTime()
        
        Get the last execution time. This is updated every time the
        scalars or the gradient opacity values are computed
        """
        ...
    
    def GetLastMinMaxFlagTime(self):
        """
        V.GetLastMinMaxFlagTime() -> int
        C++: vtkMTimeType GetLastMinMaxFlagTime()
        
        Get the last execution time. This is updated every time the flags
        bits are re-computed.
        """
        ...
    
    def GetMinMaxVolume(self, p_int=..., p_int=..., p_int=..., p_int=...):
        """
        V.GetMinMaxVolume([int, int, int, int]) -> (int, ...)
        C++: unsigned short *GetMinMaxVolume(int dims[4])
        
        Get the raw pointer to the final computed space leaping
        datastructure. The result is only valid after Update() has been
        called on the filter. Note that this filter holds onto its
        memory. The dimensions of the min- max volume are in dims. The
        4th value in the array indicates the number of independent
        components, (also queried via GetNumberOfIndependentComponents())
        """
        ...
    
    def GetMinNonZeroGradientMagnitudeIndex(self):
        """
        V.GetMinNonZeroGradientMagnitudeIndex() -> (int, ...)
        C++: unsigned char *GetMinNonZeroGradientMagnitudeIndex()
        
        Get the first non-zero scalar opacity and gradient opacity
        indices for each independent component INTERNAL - Do not use.
        """
        ...
    
    def GetMinNonZeroScalarIndex(self):
        """
        V.GetMinNonZeroScalarIndex() -> (int, ...)
        C++: unsigned short *GetMinNonZeroScalarIndex()
        
        Get the first non-zero scalar opacity and gradient opacity
        indices for each independent component INTERNAL - Do not use.
        """
        ...
    
    def GetNumberOfGenerationsFromBase(self, string):
        """
        V.GetNumberOfGenerationsFromBase(string) -> int
        C++: vtkIdType GetNumberOfGenerationsFromBase(const char *type)
            override;
        
        Given a the name of a base class of this class type, return the
        distance of inheritance between this class type and the named
        class (how many generations of inheritance are there between this
        class and the named class). If the named class is not in this
        class's inheritance tree, return a negative value. Valid
        responses will always be nonnegative. This method works in
        combination with vtkTypeMacro found in vtkSetGet.h.
        """
        ...
    
    def GetNumberOfGenerationsFromBaseType(self, string):
        """
        V.GetNumberOfGenerationsFromBaseType(string) -> int
        C++: static vtkIdType GetNumberOfGenerationsFromBaseType(
            const char *type)
        
        Given a the name of a base class of this class type, return the
        distance of inheritance between this class type and the named
        class (how many generations of inheritance are there between this
        class and the named class). If the named class is not in this
        class's inheritance tree, return a negative value. Valid
        responses will always be nonnegative. This method works in
        combination with vtkTypeMacro found in vtkSetGet.h.
        """
        ...
    
    def GetNumberOfIndependentComponents(self):
        """
        V.GetNumberOfIndependentComponents() -> int
        C++: int GetNumberOfIndependentComponents()
        
        Get the number of independent components for which we need to
        keep track of min/max
        """
        ...
    
    def GetTableScale(self):
        """
        V.GetTableScale() -> (float, float, float, float)
        C++: virtual float *GetTableScale()
        
        Is the difference between max and min of the data less than
        32768? If so, and if the data is not of float/double type, use a
        simple offset mapping. If the difference between max and min is
        32768 or greater, or the data is of type float or double, we must
        use an offset / scaling mapping. In this case, the array size
        will be 32768 - we need to figure out the offset and scale
        factor.
        """
        ...
    
    def GetTableShift(self):
        """
        V.GetTableShift() -> (float, float, float, float)
        C++: virtual float *GetTableShift()
        
        Is the difference between max and min of the data less than
        32768? If so, and if the data is not of float/double type, use a
        simple offset mapping. If the difference between max and min is
        32768 or greater, or the data is of type float or double, we must
        use an offset / scaling mapping. In this case, the array size
        will be 32768 - we need to figure out the offset and scale
        factor.
        """
        ...
    
    def GetTableSize(self):
        """
        V.GetTableSize() -> (int, int, int, int)
        C++: virtual int *GetTableSize()
        
        Is the difference between max and min of the data less than
        32768? If so, and if the data is not of float/double type, use a
        simple offset mapping. If the difference between max and min is
        32768 or greater, or the data is of type float or double, we must
        use an offset / scaling mapping. In this case, the array size
        will be 32768 - we need to figure out the offset and scale
        factor.
        """
        ...
    
    def GetUpdateGradientOpacityFlags(self):
        """
        V.GetUpdateGradientOpacityFlags() -> int
        C++: virtual vtkTypeBool GetUpdateGradientOpacityFlags()
        
        Update the gradient opacity flags. (The scalar opacity flags are
        always updated upon execution of this filter.)
        """
        ...
    
    def IsA(self, string):
        """
        V.IsA(string) -> int
        C++: vtkTypeBool IsA(const char *type) override;
        
        Return 1 if this class is the same type of (or a subclass of) the
        named class. Returns 0 otherwise. This method works in
        combination with vtkTypeMacro found in vtkSetGet.h.
        """
        ...
    
    def IsTypeOf(self, string):
        """
        V.IsTypeOf(string) -> int
        C++: static vtkTypeBool IsTypeOf(const char *type)
        
        Return 1 if this class type is the same type of (or a subclass
        of) the named class. Returns 0 otherwise. This method works in
        combination with vtkTypeMacro found in vtkSetGet.h.
        """
        ...
    
    def NewInstance(self):
        """
        V.NewInstance() -> vtkVolumeRayCastSpaceLeapingImageFilter
        C++: vtkVolumeRayCastSpaceLeapingImageFilter *NewInstance()
        """
        ...
    
    def SafeDownCast(self, vtkObjectBase):
        """
        V.SafeDownCast(vtkObjectBase)
            -> vtkVolumeRayCastSpaceLeapingImageFilter
        C++: static vtkVolumeRayCastSpaceLeapingImageFilter *SafeDownCast(
            vtkObjectBase *o)
        """
        ...
    
    def SetCache(self, vtkImageData):
        """
        V.SetCache(vtkImageData)
        C++: virtual void SetCache(vtkImageData *imageCache)
        
        INTERNAL - Do not use Set the last cached min-max volume, as used
        by vtkFixedPointVolumeRayCastMapper.
        """
        ...
    
    def SetComputeGradientOpacity(self, p_int):
        """
        V.SetComputeGradientOpacity(int)
        C++: virtual void SetComputeGradientOpacity(vtkTypeBool _arg)
        
        Compute gradient opacity ?
        """
        ...
    
    def SetComputeMinMax(self, p_int):
        """
        V.SetComputeMinMax(int)
        C++: virtual void SetComputeMinMax(vtkTypeBool _arg)
        
        Compute the min max structure ?.
        """
        ...
    
    def SetCurrentScalars(self, vtkDataArray):
        """
        V.SetCurrentScalars(vtkDataArray)
        C++: virtual void SetCurrentScalars(vtkDataArray *)
        
        Set the scalars.
        """
        ...
    
    def SetGradientOpacityTable(self, p_int, *int):
        """
        V.SetGradientOpacityTable(int, [int, ...])
        C++: void SetGradientOpacityTable(int c, unsigned short *t)
        
        Set the scalar opacity and gradient opacity tables computed for
        each component by the vtkFixedPointVolumeRayCastMapper
        """
        ...
    
    def SetIndependentComponents(self, p_int):
        """
        V.SetIndependentComponents(int)
        C++: virtual void SetIndependentComponents(int _arg)
        
        Do we use independent components, or dependent components ?
        """
        ...
    
    def SetScalarOpacityTable(self, p_int, *int):
        """
        V.SetScalarOpacityTable(int, [int, ...])
        C++: void SetScalarOpacityTable(int c, unsigned short *t)
        
        Set the scalar opacity and gradient opacity tables computed for
        each component by the vtkFixedPointVolumeRayCastMapper
        """
        ...
    
    def SetTableScale(self, p_float, p_float_1, p_float_2, p_float_3):
        """
        V.SetTableScale(float, float, float, float)
        C++: virtual void SetTableScale(float _arg1, float _arg2,
            float _arg3, float _arg4)
        V.SetTableScale((float, float, float, float))
        C++: virtual void SetTableScale(const float _arg[4])
        
        Is the difference between max and min of the data less than
        32768? If so, and if the data is not of float/double type, use a
        simple offset mapping. If the difference between max and min is
        32768 or greater, or the data is of type float or double, we must
        use an offset / scaling mapping. In this case, the array size
        will be 32768 - we need to figure out the offset and scale
        factor.
        """
        ...
    
    def SetTableShift(self, p_float, p_float_1, p_float_2, p_float_3):
        """
        V.SetTableShift(float, float, float, float)
        C++: virtual void SetTableShift(float _arg1, float _arg2,
            float _arg3, float _arg4)
        V.SetTableShift((float, float, float, float))
        C++: virtual void SetTableShift(const float _arg[4])
        
        Is the difference between max and min of the data less than
        32768? If so, and if the data is not of float/double type, use a
        simple offset mapping. If the difference between max and min is
        32768 or greater, or the data is of type float or double, we must
        use an offset / scaling mapping. In this case, the array size
        will be 32768 - we need to figure out the offset and scale
        factor.
        """
        ...
    
    def SetTableSize(self, p_int, p_int_1, p_int_2, p_int_3):
        """
        V.SetTableSize(int, int, int, int)
        C++: virtual void SetTableSize(int _arg1, int _arg2, int _arg3,
            int _arg4)
        V.SetTableSize((int, int, int, int))
        C++: virtual void SetTableSize(const int _arg[4])
        
        Is the difference between max and min of the data less than
        32768? If so, and if the data is not of float/double type, use a
        simple offset mapping. If the difference between max and min is
        32768 or greater, or the data is of type float or double, we must
        use an offset / scaling mapping. In this case, the array size
        will be 32768 - we need to figure out the offset and scale
        factor.
        """
        ...
    
    def SetUpdateGradientOpacityFlags(self, p_int):
        """
        V.SetUpdateGradientOpacityFlags(int)
        C++: virtual void SetUpdateGradientOpacityFlags(vtkTypeBool _arg)
        
        Update the gradient opacity flags. (The scalar opacity flags are
        always updated upon execution of this filter.)
        """
        ...
    
    def UpdateGradientOpacityFlagsOff(self):
        """
        V.UpdateGradientOpacityFlagsOff()
        C++: virtual void UpdateGradientOpacityFlagsOff()
        
        Update the gradient opacity flags. (The scalar opacity flags are
        always updated upon execution of this filter.)
        """
        ...
    
    def UpdateGradientOpacityFlagsOn(self):
        """
        V.UpdateGradientOpacityFlagsOn()
        C++: virtual void UpdateGradientOpacityFlagsOn()
        
        Update the gradient opacity flags. (The scalar opacity flags are
        always updated upon execution of this filter.)
        """
        ...
    
    def __delattr__(self, *args, **kwargs):
        """ Implement delattr(self, name). """
        ...
    
    def __getattribute__(self, *args, **kwargs):
        """ Return getattr(self, name). """
        ...
    
    def __init__(self, *args, **kwargs) -> None:
        ...
    
    @staticmethod
    def __new__(*args, **kwargs):
        """ Create and return a new object.  See help(type) for accurate signature. """
        ...
    
    def __repr__(self, *args, **kwargs):
        """ Return repr(self). """
        ...
    
    def __setattr__(self, *args, **kwargs):
        """ Implement setattr(self, name, value). """
        ...
    
    def __str__(self, *args, **kwargs) -> str:
        """ Return str(self). """
        ...
    
    __this__ = ...
    __dict__ = ...
    __vtkname__ = ...


